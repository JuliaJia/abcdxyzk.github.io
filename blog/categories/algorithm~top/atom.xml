<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithm~top | kk Blog]]></title>
  <link href="http://abcdxyzk.github.io/blog/categories/algorithm~top/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2014-11-19T10:52:15+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[树状数组]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/11/16/alg-bit/"/>
    <updated>2014-11-16T21:19:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/11/16/alg-bit</id>
    <content type="html"><![CDATA[<p>大体上可以分为两种:</p>

<h4>一</h4>

<p>每次修改的是一个点，所求的是关于某段区间；<br/>
这种情况最好办；比如说poj2352 stars；求每个点前面比他小的点的个数；<br/>
只用设置数组a[],先全是0，然后有某个点就依次修改，并以此统计；<br/>
这一种是最基本的向上修改，向下统计；<br/>
<code>
    int lowbit(int x) {
        return x&amp;(-x);
    }
    void update(int x,int num) {
        while(x&lt;=N) {
             d[x]+=num;
             x+=lowbit(x);
         }
    }
    int getSum(int x) {
        int s=0;
        while(x&gt;0) {
             s+=d[x];
             x-=lowbit(x);
         }
        return s;
    }
</code></p>

<!--more-->


<h4>二</h4>

<p>每次修改的是一个区间，所求的值是关于某个点的；<br/>
代表的典型题目是HOJ1556 color the ball；<br/>
这个题是每次修改了一整个区间，最后求的是每个点修改的次数；<br/>
这个需要将上面的函数，稍加修改；<br/>
对于[s,t]，要向下修改，将它的区间[0, t]都加一遍update(t)；再向下修改，把不必要的区间[0, s)再减去update(s-1)；
<code>
    void update(int x,int num) {
        while(x&gt;0) {
             d[x]+=num;
             x-=lowbit(x);
         }
    }
    int getSum(int x) {
        int s=0;
        while(x&lt;=N) {
             s+=d[x];
             x+=lowbit(x);
         }
        return s;
    }
</code></p>

<h5>注意</h5>

<div style="color:red">
对于一，可以用于计算统计子树；</br>
对于二，可以用于计算统计树上某个节点的所有祖先节点
</div>


<h4>poj3321</h4>

<p>这题难的不是树状数组，主要是映射到树状数组。<br/>
建树，然后dfs一次就可以算出对某个节点它的第一个下标(在树状数组中)和最后一个下标。那个更改的时候就用这两个下标就行了。<br/>
<img src="/images/alg/20141116.png" alt="" /><br/>
类似于将树向右倾斜，dfs建好树后c子树的第一个下标是4，最后一个下标是7。统计子树时只要sum(7)-sum(4-1)</p>

<h4>foj2176</h4>

<p>是poj3321加强版，一样的建树，但是节点要存k个值，然后update和sum的时候注意取和dep的差值，注意update减去val时的dep不要取错，update(le[i], dep[ri[i]], -val);</p>

<pre><code>    #include &lt;stdio.h&gt;
    #include &lt;vector&gt;
    using namespace std;

    int n,m,mod;
    vector&lt;int&gt; tr[50009];
    int pre[50009];
    int s[50009][5];
    int dep[50009];
    int now, le[50009], ri[50009];

    int lowbit(int x)
    {
        return x&amp;(-x);
    }

    void update(int x, int de, int v)
    {
        int i;
        while (x &gt; 0) {
            i = (dep[x]-de+mod*1000000)%mod;
            s[x][i%mod] += v;
            x -= lowbit(x);
        }
    }

    int sum(int x, int de)
    {
        int i, j, val[5], ret;
        for (i=0;i&lt;mod;i++) val[i] = 0;
        while (x &lt;= now) {
            j = i = (de-dep[x]+mod*1000000)%mod;
            for (;i&lt;j+mod;i++)
                val[i%mod] += s[x][i-j];
            x += lowbit(x);
        }
        ret = 0;
        for (i=0;i&lt;mod;i++) ret += (i+1)*val[i];
        return ret;
    }

    void dfs(int k, int d)
    {
        int i;
        le[k] = now;
        for (i=0;i&lt;tr[k].size();i++)
            dfs(tr[k][i], d+1);
        now++;
        ri[k] = now;
        dep[now] = d;
    }

    int main()
    {
        int i,j,k,l,T,cas=0;
        scanf("%d", &amp;T);
        while (T--)
        {
            cas++;
            printf("Case#%d:\n", cas);
            scanf("%d %d %d", &amp;n, &amp;m, &amp;mod);
            for (i=1;i&lt;=n;i++) tr[i].clear();
            for (i=1;i&lt;n;i++) {
                scanf("%d %d", &amp;j, &amp;k);
                pre[k] = j;
                tr[j].push_back(k);
            }
            for (i=1;i&lt;=n;i++) if (pre[i] == 0) break;
            now = 0;
            dfs(i, 0);
            for (i=0;i&lt;=now;i++)
                for (j=0;j&lt;mod;j++) s[i][j] = 0;
            while (m--) {
                scanf("%d", &amp;l);
                if (l == 1) {
                    scanf("%d %d", &amp;j, &amp;k);
                    update(ri[j], dep[ri[j]], k);
                    update(le[j], dep[ri[j]], -k);
                } else {
                    scanf("%d", &amp;j);
                    k = sum(ri[j], dep[ri[j]]);
                    printf("%d\n", k);
                }
            }
        }
        return 0;
    }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[两个数只出现一次]]></title>
    <link href="http://abcdxyzk.github.io/blog/2012/11/12/alg-2num-appear-once/"/>
    <updated>2012-11-12T16:51:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2012/11/12/alg-2num-appear-once</id>
    <content type="html"><![CDATA[<h4>problem</h4>

<p>一个数组，其中只有两个数只出现一次，其余数皆出现偶数次。<br/>
设计Time: O(n) 的算法得出那个只出现一次的数。</p>

<h4>answer</h4>

<p>再因为a和b不等，那么a<sup>b</sup>必然不为0。<br/>
那么a<sup>b</sup>这个数上面必然能够找到一个二进制位是1<br/>
在这个二进制位上，a和b不等。<br/>
根据这个二进制位，将各元素中在这位上为1的分派到左边，为0的分派到右边，形成两个子数组。</p>

<p>可以证明，<br/>
1）这两个数组分别包含a和b。<br/>
2）每个数组中除了a或b之外的所有元素都是成对出现的。</p>
]]></content>
  </entry>
  
</feed>
