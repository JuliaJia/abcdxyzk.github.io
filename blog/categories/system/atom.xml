<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: System | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/categories/system/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2014-11-19T18:40:53+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ar Ranlib Nm 命令--制作.a文件]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/11/06/command-ar/"/>
    <updated>2014-11-06T23:08:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/11/06/command-ar</id>
    <content type="html"><![CDATA[<h4>1.ar基本用法</h4>

<h5>功能说明：建立或修改备存文件，或是从备存文件中抽取文件。</h5>

<p>ar命令可以用来创建、修改库，也可以从库中提出单个模块。库是一单独的文件，里面包含了按照特定的结构组织起来的其它的一些文件（称做此库文件的member）。原始文件的内容、模式、时间戳、属主、组等属性都保留在库文件中。</p>

<!--more-->


<h5>下面是ar命令的格式：</h5>

<p>　　ar [-]{dmpqrtx}[abcfilNoPsSuvV] [membername] [count] archive files&hellip;<br/>
　　例如我们可以用ar rv libtest.a hello.o hello1.o来 生成一个库，库名字是test，链接时可以用-ltest链接。该库中存放了两个模块hello.o和hello1.o。选项前可以有‘-&lsquo;字符，也可以 没有。下面我们来看看命令的操作选项和任选项。现在我们把{dmpqrtx}部分称为操作选项，而[abcfilNoPsSuvV]部分称为任选项。<br/>
　　{dmpqrtx}中的操作选项在命令中只能并且必须使用其中一个，它们的含义如下：<br/>
    d：从库中删除模块。按模块原来的文件名指定要删除的模块。如果使用了任选项v则列出被删除的每个模块。<br/>
    m：该操作是在一个库中移动成员。当库中如果有若干模块有相同的符号定义(如函数定义)，则成员的位置顺序很重要。如果没有指定任选项，任何指定的成员将移到库的最后。也可以使用&#8217;a&#8217;，&#8217;b&#8217;，或&#8217;I&#8217;任选项移动到指定的位置。<br/>
    p：显示库中指定的成员到标准输出。如果指定任选项v，则在输出成员的内容前，将显示成员的名字。如果没有指定成员的名字，所有库中的文件将显示出来。<br/>
    q：快速追加。增加新模块到库的结尾处。并不检查是否需要替换。&#8217;a&#8217;，&#8217;b&#8217;，或&#8217;I&#8217;任选项对此操作没有影响，模块总是追加的库的结尾处。如果使用了任选项v则列出每个模块。 这时，库的符号表没有更新，可以用&#8217;ar s&#8217;或ranlib来更新库的符号表索引。<br/>
    r：在库中插入模块(替换)。当插入的模块名已经在库中存在，则替换同名的模块。如果若干模块中有一个模块在库中不存在，ar显示一个错误消息，并不替换其他同名模块。默认的情况下，新的成员增加在库的结尾处，可以使用其他任选项来改变增加的位置。<br/>
    t：显示库的模块表清单。一般只显示模块名。<br/>
    x：从库中提取一个成员。如果不指定要提取的模块，则提取库中所有的模块。<br/>
　　下面在看看可与操作选项结合使用的任选项：<br/>
    a：在库的一个已经存在的成员后面增加一个新的文件。如果使用任选项a，则应该为命令行中membername参数指定一个已经存在的成员名。<br/>
    b：在库的一个已经存在的成员前面增加一个新的文件。如果使用任选项b，则应该为命令行中membername参数指定一个已经存在的成员名。<br/>
    c：创建一个库。不管库是否存在，都将创建。<br/>
    f：在库中截短指定的名字。缺省情况下，文件名的长度是不受限制的，可以使用此参数将文件名截短，以保证与其它系统的兼容。<br/>
    i：在库的一个已经存在的成员前面增加一个新的文件。如果使用任选项i，则应该为命令行中membername参数指定一个已经存在的成员名(类似任选项b)。<br/>
    l：暂未使用<br/>
    N：与count参数一起使用，在库中有多个相同的文件名时指定提取或输出的个数。<br/>
    o：当提取成员时，保留成员的原始数据。如果不指定该任选项，则提取出的模块的时间将标为提取出的时间。<br/>
    P：进行文件名匹配时使用全路径名。ar在创建库时不能使用全路径名（这样的库文件不符合POSIX标准），但是有些工具可以。<br/>
    s：写入一个目标文件索引到库中，或者更新一个存在的目标文件索引。甚至对于没有任何变化的库也作该动作。对一个库做ar s等同于对该库做ranlib。<br/>
    S：不创建目标文件索引，这在创建较大的库时能加快时间。<br/>
    u：一般说来，命令ar r&hellip;插入所有列出的文件到库中，如果你只想插入列出文件中那些比库中同名文件新的文件，就可以使用该任选项。该任选项只用于r操作选项。<br/>
    v：该选项用来显示执行操作选项的附加信息。<br/>
    V：显示ar的版本。</p>

<h4>2.ranlib命令</h4>

<p>静态库文件需要使用“ar”来创建和维护。当给静态库增建一个成员时（加入一个.o文件到静态库中），“ar”可直接 将需要增加的.o文件简单的追加到静态库的末尾。之后当我们使用这个库进行连接生成可执行文件时，链接程序“ld”却提示错误，这可能是：主程序使用了之 前加入到库中的.o文件中定义的一个函数或者全局变量，但连接程序无法找到这个函数或者变量。</p>

<p>这个问题的原因是：之前我们将编译完成的.o文件直接加入到了库的末尾，却并没有更新库的有效符号表。连接程序进行连接时，在静态库的符号索引表中无法定 位刚才加入的.o文件中定义的函数或者变量。这就需要在完成库成员追加以后让加入的所有.o文件中定义的函数（变量）有效，完成这个工作需要使用另外一个 工具“ranlib”来对静态库的符号索引表进行更新。</p>

<p>我们所使用到的静态库（文档文件）中，存在这样一个特殊的成员，它的名字是“<strong>.SYMDEF”。它包含了静态库中所有成员所定义的有效符号（函数名、 变量名）。因此，当为库增加了一个成员时，相应的就需要更新成员“</strong>.SYMDEF”，否则所增加的成员中定义的所有的符号将无法被连接程序定位。完成 更新的命令是：
<code>
    ranlib ARCHIVEFILE
</code>
通常在Makefile中我们可以这样来实现：
<code>
    libfoo.a: libfoo.a(x.o) libfoo.a(y.o) ...
    ranlib libfoo.a
</code>
它所实现的是在更新静态库成员“x.o”和“y.o”之后，对静态库的成员“__.SYMDEF”进行更新（更新库的符号索引表）。
如果我们使用GNU ar工具来维护、管理静态库，我们就不需要考虑这一步。GNU ar本身已经提供了在更新库的同时更新符号索引表的功能（这是默认行为，也可以通过命令行选项控制ar的具体行为。可参考 GNU ar工具的man手册）。</p>

<p>GNU工具中ar是用来制作库文件.a的，但同时还提供了一个ranlib，从手册上看ranlib相当于ar -s，为什么这样呢？<br/>
这是由于最早在Unix系统上ar程序是单纯用来打包多个.o到.a（类似于tar做的事情），而不处理.o里的符号表。Linker程序则需 要.a文件提供一个完整的符号表，所以当时就写了单独的ranlib程序用来产生linker所需要的符号信息。也就是说，产生一个对linker合 格的的.a文件需要做ar和ranlib两步 。<br/>
很快，Unix厂商就发现ranlib做得事情完全可以合并到ar里面去，于是ar程序的升级版本就包括了ranlib的功能，但早期的很多项目的Makefile都已经是按照两步式的方法生成.a，所以为了保证这些早期文件的兼容性，ranlib被保留下来了。<br/>
如今，GNU/Linux系统上，ranlib依然存在，当然大部分项目已经不使用它了，因为ar -s就做了ranlib的工作。<br/>
历史通常是进步和妥协的混合！</p>

<h4>3.nm基本用法命令</h4>

<p>　　nm用来列出目标文件的符号清单。下面是nm命令的格式：
<code>
    nm [-a|--debug-syms] [-g|--extern-only] [-B][-C|--demangle] [-D|--dynamic] [-s|--print-armap][-o|--print-file-name] [-n|--numeric-sort][-p|--no-sort] [-r|--reverse-sort] [--size-sort][-u|--undefined-only] [-l|--line-numbers] [--help][--version] [-t radix|--radix=radix][-P|--portability] [-f format|--format=format][--target=bfdname] [objfile...]
</code>
如果没有为nm命令指出目标文件，则nm假定目标文件是a.out。下面列出该命令的任选项，大部分支持&#8221;-&ldquo;开头的短格式和&#8221;—&#8221;开头的长格式。<br/>
-A、-o或&ndash;print-file-name：在找到的各个符号的名字前加上文件名，而不是在此文件的所有符号前只出现文件名一次。<br/>
    例如nm libtest.a的输出如下：
<code>
    CPThread.o:
    00000068 T Main__8CPThreadPv
    00000038 T Start__8CPThread
    00000014 T _._8CPThread
    00000000 T __8CPThread
    00000000 ? __FRAME_BEGIN__
    .......................................
    则nm -A 的输出如下：
    libtest.a:CPThread.o:00000068 T Main__8CPThreadPv
    libtest.a:CPThread.o:00000038 T Start__8CPThread
    libtest.a:CPThread.o:00000014 T _._8CPThread
    libtest.a:CPThread.o:00000000 T __8CPThread
    libtest.a:CPThread.o:00000000 ? __FRAME_BEGIN__
    ..................................................................
</code>
nm命令<br/>
    -a或&ndash;debug-syms：显示调试符号。<br/>
    -B：等同于&ndash;format=bsd，用来兼容MIPS的nm。<br/>
    -C或&ndash;demangle：将低级符号名解码(demangle)成用户级名字。这样可以使得C++函数名具有可读性。<br/>
    -D或&ndash;dynamic：显示动态符号。该任选项仅对于动态目标(例如特定类型的共享库)有意义。<br/>
    -f format：使用format格式输出。format可以选取bsd、sysv或posix，该选项在GNU的nm中有用。默认为bsd。<br/>
    -g或&ndash;extern-only：仅显示外部符号。<br/>
    -n、-v或&ndash;numeric-sort：按符号对应地址的顺序排序，而非按符号名的字符顺序。<br/>
    -p或&ndash;no-sort：按目标文件中遇到的符号顺序显示，不排序。<br/>
    -P或&ndash;portability：使用POSIX.2标准输出格式代替默认的输出格式。等同于使用任选项-f posix。<br/>
    -s或&ndash;print-armap：当列出库中成员的符号时，包含索引。索引的内容包含：哪些模块包含哪些名字的映射。<br/>
    -r或&ndash;reverse-sort：反转排序的顺序(例如，升序变为降序)。<br/>
    &ndash;size-sort：按大小排列符号顺序。该大小是按照一个符号的值与它下一个符号的值进行计算的。<br/>
    -t radix或&ndash;radix=radix：使用radix进制显示符号值。radix只能为&#8221;d&#8221;表示十进制、&#8221;o&#8221;表示八进制或&#8221;x&#8221;表示十六进制。<br/>
    &ndash;target=bfdname：指定一个目标代码的格式，而非使用系统的默认格式。<br/>
    -u或&ndash;undefined-only：仅显示没有定义的符号(那些外部符号)。<br/>
    -l或&ndash;line-numbers：对每个符号，使用调试信息来试图找到文件名和行号。对于已定义的符号，查找符号地址的行号。对于未定义符号，查找指向符号重定位入口的行号。如果可以找到行号信息，显示在符号信息之后。<br/>
    -V或&ndash;version：显示nm的版本号。<br/>
    &ndash;help：显示nm的任选项。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[修改elf文件标记的源码路径debugedit，find-debuginfo]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/11/03/tools-edit-source-dir/"/>
    <updated>2014-11-03T18:19:17+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/11/03/tools-edit-source-dir</id>
    <content type="html"><![CDATA[<pre><code>    yum install rpm-build
    sudo apt-get install rpm
</code></pre>

<p>/usr/lib/rpm/debugedit 用来改变源码查找路径。
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ /usr/lib/rpm/debugedit
</span><span class='line'>Usage: debugedit [OPTION&hellip;]
</span><span class='line'>  -b, &ndash;base-dir=STRING      base build directory of objects
</span><span class='line'>  -d, &ndash;dest-dir=STRING      directory to rewrite base-dir into
</span><span class='line'>  -l, &ndash;list-file=STRING     file where to put list of source and header file
</span><span class='line'>                         names
</span><span class='line'>  -i, &ndash;build-id             recompute build ID note and print ID on stdout&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;Help options:
</span><span class='line'>  -?, --help                 Show this help message
</span><span class='line'>  --usage                    Display brief usage message
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;base-dir 长度要大等于 dest-dir  
</span><span class='line'>-i 输出build-id  
</span><span class='line'>-l 输出源编译文件位置，便于有需要的人打包
</span><span class='line'>
</span><span class='line'>--------
</span><span class='line'>
</span><span class='line'>.debug_str段保存着所有全局变量的名字，以0x00作为每一个全局变量名的结束。  
</span><span class='line'>在其它段来调用名字时，是以其在.debug_str段的偏移量来实现的  
</span><span class='line'>gcc -g /root/Desktop/a.c -o /root/Desktop/a.out  
</span><span class='line'>用绝对路径编译，在.debug_str段中就会存下源文件路径，.debug_info的DW_TAG_compile_unit中的DW_AT_name对应.debug_str中的偏移。  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;$ objdump &ndash;dwarf=str a.out
</span><span class='line'>&hellip;.
</span><span class='line'>  0x00000000 474e5520 4320342e 342e3720 32303132 GNU C 4.4.7 2012
</span><span class='line'>  0x00000010 30333133 20285265 64204861 7420342e 0313 (Red Hat 4.
</span><span class='line'>  0x00000020 342e372d 3429006c 6f6e6720 756e7369 4.7-4).long unsi
</span><span class='line'>  0x00000030 676e6564 20696e74 002f726f 6f742f44 gned int.&lt;span style="color:red"&gt;/root/D&lt;/span&gt;
</span><span class='line'>  0x00000040 65736b74 6f702f61 2e630075 6e736967 esktop/a.c.unsig
</span><span class='line'>  0x00000050 6e656420 63686172 006d6169 6e006c6f ned char.main.lo
</span><span class='line'>  0x00000060 6e672069 6e74002f 726f6f74 2f446573 ng int./root/Des
</span><span class='line'>  0x00000070 6b746f70 0073686f 72742075 6e736967 ktop.short unsig
</span><span class='line'>  0x00000080 6e656420 696e7400 73686f72 7420696e ned int.short in
</span><span class='line'>  0x00000090 7400                                t.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;$ objdump &ndash;dwarf=info a.out
</span><span class='line'>&hellip;..
</span><span class='line'> &lt;0&gt;&lt;b&gt;: Abbrev Number: 1 (DW_TAG_compile_unit)
</span><span class='line'>&lt; c&gt;   DW_AT_producer    : (indirect string, offset: 0x0): GNU C 4.4.7 20120313 (Red Hat 4.4.7-4)
</span><span class='line'>&lt;10&gt;   DW_AT_language    : 1        (ANSI C)
</span><span class='line'>&lt;11&gt;   DW_AT_name        : (indirect string, offset: 0x39): /root/Desktop/a.c
</span><span class='line'>&lt;15&gt;   DW_AT_comp_dir    : (indirect string, offset: 0x67): /root/Desktop
</span><span class='line'>&lt;19&gt;   DW_AT_low_pc      : 0x4004c4
</span><span class='line'>&lt;21&gt;   DW_AT_high_pc     : 0x40051c
</span><span class='line'>&lt;29&gt;   DW_AT_stmt_list   : 0x0&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;-----------------------------------------
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;$ /usr/lib/rpm/debugedit -b /root/Desktop -d /usr/src /root/Desktop/a.out</span></code></pre></td></tr></table></div></figure></p>

<hr />

<pre><code>$ objdump --dwarf=str a.out
...
  0x00000000 474e5520 4320342e 342e3720 32303132 GNU C 4.4.7 2012
  0x00000010 30333133 20285265 64204861 7420342e 0313 (Red Hat 4.
  0x00000020 342e372d 3429006c 6f6e6720 756e7369 4.7-4).long unsi
  0x00000030 676e6564 20696e74 002f7573 722f7372 gned int./usr/sr
  0x00000040 632f612e 63002f61 2e630075 6e736967 c/a.c./a.c.unsig
  0x00000050 6e656420 63686172 006d6169 6e006c6f ned char.main.lo
  0x00000060 6e672069 6e74002f 726f6f74 2f446573 ng int./root/Des
  0x00000070 6b746f70 0073686f 72742075 6e736967 ktop.short unsig
  0x00000080 6e656420 696e7400 73686f72 7420696e ned int.short in
  0x00000090 7400                                t.


$ objdump --dwarf=info a.out

...
 &lt;0&gt;&lt;b&gt;: Abbrev Number: 1 (DW_TAG_compile_unit)
    &lt; c&gt;   DW_AT_producer    : (indirect string, offset: 0x0): GNU C 4.4.7 20120313 (Red Hat 4.4.7-4)
    &lt;10&gt;   DW_AT_language    : 1        (ANSI C)
    &lt;11&gt;   DW_AT_name        : (indirect string, offset: 0x39): /usr/src/a.c
    &lt;15&gt;   DW_AT_comp_dir    : (indirect string, offset: 0x67): /root/Desktop
    &lt;19&gt;   DW_AT_low_pc      : 0x4004c4
    &lt;21&gt;   DW_AT_high_pc     : 0x40051c
    &lt;29&gt;   DW_AT_stmt_list   : 0x0
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Screen]]></title>
    <link href="http://abcdxyzk.github.io/blog/2012/02/18/tools-screen/"/>
    <updated>2012-02-18T12:53:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2012/02/18/tools-screen</id>
    <content type="html"><![CDATA[<h4>断开控制台而不结束会话-Screen</h4>

<p>设想一下，你通过 ssh 连接到了一台服务器，接着你开始编译一个软件。这或许要占用你一个小时甚至更多的时间，突然！你需要离开，或者是断开网络了~<br/>
怎么办？下次再重新编译一次么？还有例外一种办法~（当然，我指的不是一开始放在后台运行。）<br/>
Screen！</p>

<h4>一、启动 Screen</h4>

<p>启动 Screen 再简单不过了，在 Shell 中运行 screen ，按回车，就进入 Screen 输入环境了。</p>

<h4>二、给 Screen 的指令</h4>

<p>和VIM类似，当你想给 Screen 发送指令，而不是给 shell 输入指令的时候需要用到特定的组合键：Ctrl-A 。（这类似于 VIM 中的 ESC。）当你执行Ctrl-A 后就可以引起 Screen 的注意了。</p>

<h4>三、我在 Screen 中么？</h4>

<p>通过 screen -list 调用 screen 可以看到类似如下界面：<br/>
这标明你正处于 Screen 中。并且进程号是8941。</p>

<h4>四、还有哪些命令？</h4>

<p>通过 Ctrl-A and ? 的方式你可以看到如下列表：<br/>
ok！一切都明了了！</p>

<h4>五、离开</h4>

<p>这时我需要离开那台正在编译软件的主机了，通过 Ctrl+A and D。我们脱离了 screen。但是 screen 依然在后台运行着。</p>

<h4>六、归来</h4>

<p>当你回到这台主机，并想重新进入之前的 screen 时，以前看到的 进程号（PID）就要发挥作用了。<br/>
通过命令：<br/>
screen -r pid<br/>
就可以回到之前的Screen了。<br/>
如果你觉得记住 PID 是一件很麻烦的事情，也可以使用 -S 参数：<br/>
scree  -S latteye<br/>
这样就可以打开一个名为 latteye 的会话，下次连接时使用：<br/>
screen -r latteye <br/>
即可。</p>

<h4>七、特殊情况</h4>

<p>有些时候我们离开 screen 并不是那么正常，不一定会按 Ctrl-a + D 来离开 Screen，比如网络突然断开的时候。<br/>
这个时候，若我们重新回到主机，则通过 -r 参数是无法连接 screen 的，我们还需要 -d 的帮助：<br/>
screen -d -r pid</p>

<hr />

<p>命令其实超简单的：<br/>
直接在终端上输入 screen , 这个时候，服务器端会启一个新的终端，但这个终端，与之前的普通终端不一样，它不隶属于 sshd 进程组，这样，当本地终端关闭后，服务器终端不会被 kill。<br/>
当然，优点还不止这么些，在服务器终端里执行任务时，你甚至可以随时地切换到本地终端做些其他事情，然后，要回去时，再恢复到刚才已经打开的服务器终端里，如果刚才的任务没有结束，还可以继续执行任务。<br/>
操作步骤：<br/>
首先，进入 screen -S sessionname终端。(sessionname是为了区分你的session)<br/>
然后按 ctrl + a，再按 d键暂时退出终端。<br/>
当要返回时， 先查看刚才的终端进程ID， screen -list<br/>
或直接<br/>
 screen -r xx(刚才的sessionname)就可以了 <br/>
当然，当你开了很多个session后，打算关闭几个session，可以进入到session后，exit一下就可以了.<br/>
<code>
    Ctrl + a + ?    显示所有键绑定信息
    Ctrl + a + w    显示所有窗口列表
    Ctrl + a + a    切换到之前显示的窗口
    Ctrl + a + c    创建一个新的运行shell的窗口并切换到该窗口
    Ctrl + a + n    切换到下一个窗口
    Ctrl + a + p    切换到前一个窗口(与C-a n相对)
    Ctrl + a + 0..9 切换到窗口0..9
    Ctrl + a + a    发送 C-a到当前窗口
    Ctrl + a + d    暂时断开screen会话
    Ctrl + a + k    杀掉当前窗口
    Ctrl + a + [    进入拷贝/回滚模式
</code></p>
]]></content>
  </entry>
  
</feed>
