<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Kernel | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/categories/kernel/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2014-11-19T18:45:45+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Crash vs Gdb Work]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/11/06/kernel-crash-work/"/>
    <updated>2014-11-06T10:51:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/11/06/kernel-crash-work</id>
    <content type="html"><![CDATA[<p><a href="https://www.redhat.com/archives/crash-utility/2014-October/msg00002.html">贴自https://www.redhat.com/archives/crash-utility/2014-October/msg00002.html</a><br/>
Yes, sure. GDB works very differently from crash. There main conceptual<br/>
difference is that GDB only handles with VIRTUAL addresses, while the<br/>
crash utility first translates everything to PHYSICAL addresses.<br/>
Consequently, GDB ignores the PhysAddr field in ELF program headers,<br/>
and crash ignores the VirtAddr field.</p>

<p>I have looked at some of my ELF dump files, and it seems to me that<br/>
VirtAddr is not filled correctly, except for kernel text and static<br/>
data (address range 0xffffffff80000000-0xffffffff9fffffff). Your linked<br/>
list is most likely allocated in the direct mapping<br/>
(0xffff880000000000-0xffffc7ffffffffff). However, I found out that the<br/>
virtual addresses for the direct mapping segments are wrong, e.g. my<br/>
dump file specifies it at 0xffff810000000000 (hypervisor area). This is<br/>
most likely a bug in the kernel code that implements /proc/vmcore.</p>

<p>But that&rsquo;s beside the point. Why?  The Linux kernel maps many physical<br/>
pages more than once into the virtual address space. It would be waste<br/>
of space if you saved it multiple times (for each virtual address that<br/>
maps to it). The crash utility can translate each virtual address to<br/>
the physical address and map it onto ELF segments using PhysAddr.<br/>
Incidentally, the PhysAddr fields are correct in my dump files&hellip;</p>

<p>I&rsquo;m glad you&rsquo;re interested in using GDB to read kernel dump files,<br/>
especially if you&rsquo;re willing to make it work for real. I have proposed<br/>
more than once that the crash utility be re-implemented in pure gdb.<br/>
Last time I looked (approx. 1.5 years ago) the main missing pieces were:</p>

<ol>
<li> Use of physical addresses (described above)</li>
<li> Support for multiple virtual address spaces (for different process<br/>
 contexts)</li>
<li> Ability to read compressed kdump files</li>
<li> Ability to use 64-bit files on 32-bit platforms (to handle PAE)</li>
</ol>


<p>HTH,<br/>
Petr Tesarik</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[静态编译crash + Xbt + Bt -H]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/11/04/kernel-crash-static-compiler/"/>
    <updated>2014-11-04T18:23:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/11/04/kernel-crash-static-compiler</id>
    <content type="html"><![CDATA[<h5>要在centos6上编译，为了能在centos5用，用静态编译</h5>

<h5>有两个显示函数参数的patch，但是不一定能起作用</h5>

<h5>patch1:</h5>

<p><a href="https://github.com/jhammond/xbt">https://github.com/jhammond/xbt</a>
<a href="https://www.redhat.com/archives/crash-utility/2013-September/msg00010.html">https://www.redhat.com/archives/crash-utility/2013-September/msg00010.html</a></p>

<h5>patch2:</h5>

<p><a href="https://github.com/hziSot/crash-stack-parser">https://github.com/hziSot/crash-stack-parser</a>
<a href="https://github.com/hziSot/crash-stack-parser/blob/master/crash-parse-stack-7.0.1.patch">https://github.com/hziSot/crash-stack-parser/blob/master/crash-parse-stack-7.0.1.patch</a></p>

<h4>一、依赖包：</h4>

<p>yum install bison zlib zlib-static glibc-static elfutils-devel elfutils-devel-static elfutils-libelf-devel-static ncurses ncurses-static crash-devel</p>

<h4>二、patch1: xbt 显示参数</h4>

<p>patch: <a href="https://github.com/hziSot/crash-stack-parser  ">https://github.com/hziSot/crash-stack-parser  </a>
make CFLAGS+=&ndash;static LDFLAGS+=&ndash;static</p>

<h4>三、patch2: bt -H 显示参数</h4>

<pre><code>    依赖：有些没有静态包，要自己编译安装：
    liblzma.a: http://tukaani.org/xz/xz-5.0.7.tar.bz2
    libbz2.a:  http://www.bzip.org/1.0.6/bzip2-1.0.6.tar.gz
    下载代码：git clone https://github.com/jhammond/xbt.git xbt.git
    把xbt.git/xbt_crash.c中函数xbt_func前的static删了
    把xbt.git/xbt_crash.c中函数xmod_init的register_extension删了
    把 xbt 命令加到global_data.c        函数x86_64_exception_frame已经在其他库中定义了，所以要换个名字
    编译xbt代码：make   ==  rm -rf *.so
    把 xbt.git/xbt_crash.o  xbt.git/xbt_dwarf.o  xbt.git/xbt_dwfl.o  xbt.git/xbt_eval.o  xbt.git/xbt_frame_print.o 加到 Makefile 的 OBJECT_FILES= 中
    make CFLAGS+=--static LDFLAGS+="--static -lc  -lm -ldl -ldw -lebl -lelf -lbz2 -llzma"


    注意:-lelf -lebl要放在-ldw后面。
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[内核编译模块]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/06/06/kernel-mod-compiler/"/>
    <updated>2013-06-06T14:28:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/06/06/kernel-mod-compiler</id>
    <content type="html"><![CDATA[<pre><code>    /*filename: test.c*/
    #include &lt;linux/init.h&gt;
    #include &lt;linux/kernel.h&gt;
    #include &lt;linux/module.h&gt;

    staticintdummy_init(void)
    {
        printk("hello,world.\n");
        return0;
    }
    staticvoiddummy_exit(void)
    {
        return;
    }

    module_init(dummy_init);
    module_exit(dummy_exit);

    MODULE_LICENSE("GPL")
</code></pre>

<p>执行如下命令：
<code>
    $ gcc -c -O2 -DMODULE -D__KERNEL__ -I/usr/src/linux test.c
    $ insmod test.o
</code>
No module found in object<br/>
insmod: error inserting &lsquo;test.o&rsquo;: -1 Invalid module format</p>

<p>正确的做法是写一个Makefile,由内核的Kbuild来帮你编译。<br/>
<code>
    $ cat Makefile
    obj-m :=test.o
    KDIR :=/lib/modules/$(shell uname -r)/build
    PWD :=$(shell pwd)
    default:
        $(MAKE)-C $(KDIR)SUBDIRS=$(PWD)modules
</code>
执行如下命令：
<code>
    $make
    make -C /lib/modules/2.6.5-1.358/build SUBDIRS=/test modules
    make[1]:Entering directory `/lib/modules/2.6.5-1.358/build'
      CC [M]  /test/modinject/test.o
      Building modules, stage 2.
      MODPOST
      CC      /test/modinject/test.mod.o
      LD [M]  /test/modinject/test.ko
    make[1]: Leaving directory `/lib/modules/2.6.5-1.358/build'
    $ls -l
    -rw-r--r--1 root root   268 Jan  7 08:31 test.c
    -rw-r--r--1 root root  2483 Jan  8 09:19 test.ko
    -rw-r--r--1 root root   691 Jan  8 09:19 test.mod.c
    -rw-r--r--1 root root  1964 Jan  8 09:19 test.mod.o
    -rw-r--r--1 root root  1064 Jan  8 09:19 test.o
</code>
其实上边的test.o就是用gcc生成的test.o,而test.ko是使用下列命令来生成的。
<code>
    $ld -m elf_i386  -r -o test.ko test.o  test.mod.o
</code></p>

<p>再来看看test.mod.c，它是由/usr/src/linux/scripts/modpost.c来生成的。
&#8220;`
    $ cat test.mod.c
    #include &lt;linux/module.h>
    #include &lt;linux/vermagic.h>
    #include &lt;linux/compiler.h></p>

<pre><code>MODULE_INFO(vermagic,VERMAGIC_STRING);
#undef unix

struct module __this_module
__attribute__((section(".gnu.linkonce.this_module")))={
.name =__stringify(KBUILD_MODNAME),
.init =init_module,
#ifdef CONFIG_MODULE_UNLOAD

.exit=cleanup_module,
#endif

};
static const struct modversion_info ____versions[]
__attribute_used__
__attribute__((section("__versions")))={
    {0,"cleanup_module"},
    {0,"init_module"},
    {0,"struct_module"},
    {0,"printk"},
};
static const char __module_depends[]
__attribute_used__
__attribute__((section(".modinfo")))=
"depends=";
</code></pre>

<p>&#8220;`
可见，test.mod.o只是产生了几个ELF的节，分别是modinfo,  .gun.linkonce.this_module(用于重定位，引进了rel.gnu.linkonce.this_module),  __versions。而test.ko是test.o和test.mod.o合并的结果。</p>
]]></content>
  </entry>
  
</feed>
