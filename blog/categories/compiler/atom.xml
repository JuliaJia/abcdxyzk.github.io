<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: compiler | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/categories/compiler/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2014-11-21T02:35:03+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[gcc同时使用动态和静态链接]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/11/06/complier-static-dynamic-ld/"/>
    <updated>2014-11-06T14:51:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/11/06/complier-static-dynamic-ld</id>
    <content type="html"><![CDATA[<p>gcc &ndash;static a.c -Wl,-Bstatic -lm -Wl,-Bdynamic -lc</p>

<p>其中用到的两个选项：-Wl,-Bstatic和-Wl,-Bdynamic。这两个选项是gcc的特殊选项，它会将选项的参数传递给链接器，作为 链接器的选项。比如-Wl,-Bstatic告诉链接器使用-Bstatic选项，该选项是告诉链接器，对接下来的-l选项使用静态链 接；-Wl,-Bdynamic就是告诉链接器对接下来的-l选项使用动态链接。下面是man gcc对-Wl,option的描述，<br/>
<code>
    -Wl,option  
           Pass option as an option to the linker.  If option contains commas, it is   
           split into multiple options at the commas.  You can use this syntax to pass  
           an argument to the option.  For example, -Wl,-Map,output.map passes -Map output.map  
           to the linker.  When using the GNU linker, you can also get the same effect with   
           -Wl,-Map=output.map.  
</code>
下面是man ld分别对-Bstatic和-Bdynamic的描述，<br/>
&#8220;`
    -Bdynamic<br/>
    -dy<br/>
    -call_shared<br/>
           Link against dynamic libraries. You may use this option multiple times on the<br/>
           command line: it affects library searching for -l options which follow it.</p>

<pre><code>-Bstatic  
-dn  
-non_shared  
-static  
       Do not link against shared libraries. You may use this option multiple times on   
       the command line: it affects library searching for -l options which follow it.   
       This option also implies --unresolved-symbols=report-all.  This option can be   
       used with -shared.  Doing so means that a shared library is being created but   
       that all of the library's external references must be resolved by pulling in   
       entries from static libraries.  
</code></pre>

<p>&#8220;`
　　值得注意的是对-static的描述：-static和-shared可以同时存在，这样会创建共享库，但该共享库引用的其他库会静态地链接到该共享库中。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GCC制作Library--shared部分相当不错]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/11/06/compiler-gcc-lib/"/>
    <updated>2014-11-06T14:49:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/11/06/compiler-gcc-lib</id>
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/alex_ww/article/details/4544207">贴自http://blog.csdn.net/alex_ww/article/details/4544207</a></p>

<h3>Library可分成三种，static、shared与dynamically loaded。</h3>

<h4>1. Static libraries</h4>

<p>Static 链接库用于静态链接，简单讲是把一堆object檔用ar(archiver)包装集合起来，文件名以 `.a&#8217; 结尾。优点是执行效能通常会比后两者快，而且因为是静态链接，所以不易发生执行时找不到library或版本错置而无法执行的问题。缺点则是档案较大，维护度较低；例如library如果发现bug需要更新，那么就必须重新连结执行档。</p>

<h5>1.1 编译</h5>

<p>编译方式很简单，先例用 `-c&#8217; 编出 object 檔，再用 ar 包起来即可。
<code>
    ____ hello.c ____
    #include
    void hello(){ printf("Hello "); }
    ____ world.c ____
    #include
    void world(){ printf("world."); }
    ____ mylib.h ____
    void hello();
    void world();
</code>
$ gcc -c hello.c world.c /* 编出 hello.o 与 world.o */ <br/>
$ ar rcs libmylib.a hello.o world.o /* 包成 limylib.a */ <br/>
这样就可以建出一个档名为 libmylib.a 的檔。输出的档名其实没有硬性规定，但如果想要配合 gcc 的 &lsquo;-l&rsquo; 参数来连结，一定要以 &lsquo;lib&rsquo; 开头，中间是你要的library名称，然后紧接着 &lsquo;.a&rsquo; 结尾。</p>

<h5>1.2 使用</h5>

<pre><code>    ____ main.c ____
    #include "mylib.h"
    int main() {
    hello();
    world();
    }
</code></pre>

<p>使用上就像与一般的 object 档连结没有差别。<br/>
$ gcc main.c libmylib.a<br/>
也可以配合 gcc 的 `-l&#8217; 参数使用<br/>
$ gcc main.c -L. -lmylib<br/>
&lsquo;-Ldir&rsquo; 参数用来指定要搜寻链接库的目录，&#8217;.&lsquo; 表示搜寻现在所在的目录。通常默认会搜 /usr/lib 或 /lib 等目录。<br/>
&rsquo;-llibrary&#8217; 参数用来指定要连结的链接库，&#8217;mylib&#8217; 表示要与mylib进行连结，他会搜寻library名称前加&#8217;lib&#8217;后接&#8217;.a&#8217;的档案来连结。<br/>
$ ./a.out<br/>
Hello world.</p>

<h3>2. Shared libraries</h3>

<p>Shared library 会在程序执行起始时才被自动加载。因为链接库与执行档是分离的，所以维护弹性较好。有两点要注意，shared library是在程序起始时就要被加载，而不是执行中用到才加载，而且在连结阶段需要有该链接库才能进行连结。<br/>
首先有一些名词要弄懂，soname、real name与linker name。<br/>
soname 用来表示是一个特定 library 的名称，像是 libmylib.so.1 。前面以 &lsquo;lib&rsquo; 开头，接着是该 library 的名称，然后是 &lsquo;.so&rsquo; ，接着是版号，用来表名他的界面；如果接口改变时，就会增加版号来维护兼容度。<br/>
real name 是实际放有library程序的文件名，后面会再加上 minor 版号与release 版号，像是 libmylib.so.1.0.0 。<br/>
一般来说，版号的改变规则是(印象中在 APress-Difinitive Guide to GCC中有提到，但目前手边没这本书)，最后缀的release版号用于程序内容的修正，接口完全没有改变。中间的minor用于有新增加接口，但相旧接口没改变，所以与旧版本兼容。最前面的version版号用于原接口有移除或改变，与旧版不兼容时。<br/>
linker name是用于连结时的名称，是不含版号的 soname ，如: libmylib.so。<br/>
通常 linker name与 real name是用 ln 指到对应的 real name ，用来提供弹性与维护性。</p>

<h5>2.1 编译</h5>

<p>shared library的制作过程较复杂。<br/>
$ gcc -c -fPIC hello.c world.c<br/>
编译时要加上 -fPIC 用来产生 position-independent code。也可以用 -fpic参数。 (不太清楚差异，只知道 -fPIC 较通用于不同平台，但产生的code较大，而且编译速度较慢)。<br/>
$ gcc -shared -Wl,-soname,libmylib.so.1 -o libmylib.so.1.0.0 /<br/>
hello.o world.o<br/>
-shared 表示要编译成 shared library<br/>
-Wl 用于参递参数给linker，因此-soname与libmylib.so.1会被传给linker处理。<br/>
-soname用来指名 soname 为 limylib.so.1<br/>
library会被输出成libmylib.so.1.0.0 (也就是real name)<br/>
若不指定 soname 的话，在编译结连后的执行档会以连时的library档名为soname，并载入他。否则是载入soname指定的library档案。<br/>
可以利用 objdump 来看 library 的 soname。<br/>
$ objdump -p libmylib.so | grep SONAME<br/>
SONAME libmylib.so.1<br/>
若不指名-soname参数的话，则library不会有这个字段数据。<br/>
在编译后再用 ln 来建立 soname 与 linker name 两个档案。<br/>
$ ln -s libmylib.so.1.0.0 libmylib.so<br/>
$ ln -s libmylib.so.1.0.0 libmylib.so.1</p>

<h5>2.2 使用</h5>

<p>与使用 static library 同。<br/>
$ gcc main.c libmylib.so<br/>
以上直接指定与 libmylib.so 连结。<br/>
或用<br/>
$ gcc main.c -L. -lmylib<br/>
linker会搜寻 libmylib.so 来进行连结。<br/>
如果目录下同时有static与shared library的话，会以shared为主。<br/>
使用 -static 参数可以避免使用shared连结。<br/>
$ gcc main.c -static -L. -lmylib<br/>
此时可以用 ldd 看编译出的执行档与shared链接库的相依性<br/>
$ldd a.out<br/>
linux-gate.so.1 => (0xffffe000)<br/>
libmylib.so.1 => not found<br/>
libc.so.6 => /lib/libc.so.6 (0xb7dd6000)<br/>
/lib/ld-linux.so.2 (0xb7f07000)<br/>
输出结果显示出该执行文件需要 libmylib.so.1 这个shared library。<br/>
会显示 not found 因为没指定该library所在的目录，所找不到该library。<br/>
因为编译时有指定-soname参数为 libmylib.so.1 的关系，所以该执行档会加载libmylib.so.1。否则以libmylib.so连结，执行档则会变成要求加载libmylib.so
$ ./a.out<br/>
./a.out: error while loading shared libraries: libmylib.so.1:<br/>
cannot open shared object file: No such file or directory<br/>
因为找不到 libmylib.so.1 所以无法执行程序。<br/>
有几个方式可以处理。<br/>
a. 把 libmylib.so.1 安装到系统的library目录，如/usr/lib下<br/>
b. 设定 /etc/ld.so.conf ，加入一个新的library搜寻目录，并执行ldconfig<br/>
更新快取<br/>
c. 设定 LD_LIBRARY_PATH 环境变量来搜寻library<br/>
这个例子是加入当前目录来搜寻要载作的library<br/>
$ LD_LIBRARY_PATH=. ./a.out<br/>
Hello world.</p>

<h4>3. Dynamically loaded libraries</h4>

<p>Dynamicaaly loaded libraries 才是像 windows 所用的 DLL ，在使用到<br/>
时才加载，编译连结时不需要相关的library。动态载入库常被用于像plug-ins的应用。</p>

<h5>3.1 使用方式</h5>

<p>动态加载是透过一套 dl function来处理。<br/>
    #include &lt;dlfcn.h><br/>
    void *dlopen(const char *filename, int flag);<br/>
开启加载 filename 指定的 library。<br/>
    void *dlsym(void *handle, const char *symbol);<br/>
取得 symbol 指定的symbol name在library被加载的内存地址。<br/>
    int dlclose(void *handle);<br/>
关闭dlopen开启的handle。<br/>
    char *dlerror(void);<br/>
传回最近所发生的错误讯息。
<code>
    ____ dltest.c ____
    #include &lt;stdio.h&gt;
    #include &lt;stdlib.h&gt;
    #include &lt;stddef.h&gt;
    #include &lt;dlfcn.h&gt;
    int main() {
    void *handle;
    void (*f)();
    char *error;
    /* 开启之前所撰写的 libmylib.so 链接库 */
    handle = dlopen("./libmylib.so", RTLD_LAZY);
    if( !handle ) {
    fputs( dlerror(), stderr);
    exit(1);
    }
    /* 取得 hello function 的 address */
    f = dlsym(handle, "hello");
    if(( error=dlerror())!=NULL) {
    fputs(error, stderr);
    exit(1);
    }
    /* 呼叫该 function */
    f();
    dlclose(handle);
    }
</code>
编译时要加上 -ldl 参数来与 dl library 连结<br/>
$ gcc dltest.c -ldl<br/>
结果会印出 Hello 字符串<br/>
$ ./a.out<br/>
Hello<br/>
关于dl的详细内容请参阅 man dlopen</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C 语言文法 ( C Language Grammar )]]></title>
    <link href="http://abcdxyzk.github.io/blog/2011/07/23/compiler-c-grammar/"/>
    <updated>2011-07-23T13:43:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2011/07/23/compiler-c-grammar</id>
    <content type="html"><![CDATA[<pre><code>    %token IDENTIFIER CONSTANT STRING_LITERAL SIZEOF
    %token TYPE_NAME

    %token TYPEDEF EXTERN STATIC AUTO REGISTER
    %token CHAR SHORT INT LONG SIGNED UNSIGNED FLOAT DOUBLE CONST VOLATILE VOID
    %token STRUCT UNION ENUM

    %token CASE DEFAULT IF ELSE SWITCH WHILE DO FOR GOTO CONTINUE BREAK RETURN

    %start translation_unit
    %%
    translation_unit
        : external_declaration
        | translation_unit external_declaration
        ;

    external_declaration
        : function_definition
        | declaration
        ;

    function_definition
        : declaration_specifiers declarator declaration_list compound_statement
        | declaration_specifiers declarator compound_statement
        | declarator declaration_list compound_statement
        | declarator compound_statement
        ;

    declaration_list
        : declaration
        | declaration_list declaration
        ;

    declaration
        : declaration_specifiers ';'
        | declaration_specifiers init_declarator_list ';'
        ;

    declaration_specifiers
        : storage_class_specifier
        | storage_class_specifier declaration_specifiers
        | type_specifier
        | type_specifier declaration_specifiers
        | type_qualifier
        | type_qualifier declaration_specifiers
        ;

    specifier_qualifier_list
        : type_specifier specifier_qualifier_list
        | type_specifier
        | type_qualifier specifier_qualifier_list
        | type_qualifier

    type_qualifier_list
        : type_qualifier
        | type_qualifier_list type_qualifier
        ;

    type_qualifier
        : CONST
        | VOLATILE
        ;

    storage_class_specifier
        : TYPEDEF
        | EXTERN
        | STATIC
        | AUTO
        | REGISTER
        ;

    type_specifier
        : VOID
        | CHAR
        | SHORT
        | INT
        | LONG
        | FLOAT
        | DOUBLE
        | SIGNED
        | UNSIGNED
        | struct_or_union_specifier
        | enum_specifier
        | TYPE_NAME
        ;

    struct_or_union_specifier
        : struct_or_union IDENTIFIER '{' struct_declaration_list '}'
        | struct_or_union '{' struct_declaration_list '}'
        | struct_or_union IDENTIFIER
        ;

    struct_or_union
        : STRUCT
        | UNION
        ;

    struct_declaration_list
        : struct_declaration
        | struct_declaration_list struct_declaration
        ;

    struct_declaration
        : specifier_qualifier_list struct_declarator_list ';'
        ;

    struct_declarator_list
        : struct_declarator
        | struct_declarator_list ',' struct_declarator
        ;

    struct_declarator
        : declarator
        | ':' constant_expression
        | declarator ':' constant_expression
        ;

    enum_specifier
        : ENUM '{' enumerator_list '}'
        | ENUM IDENTIFIER '{' enumerator_list '}'
        | ENUM IDENTIFIER
        ;

    enumerator_list
        : enumerator
        | enumerator_list ',' enumerator
        ;

    enumerator
        : IDENTIFIER
        | IDENTIFIER '=' constant_expression
        ;       

    init_declarator_list
        : init_declarator
        | init_declarator_list ',' init_declarator
        ;       

    init_declarator
        : declarator
        | declarator '=' initializer
        ;

    initializer_list
        : initializer
        | initializer_list ',' initializer
        ;        

    initializer
        : assignment_expression
        | '{' initializer_list '}'
        | '{' initializer_list ',' '}'
        ;

    parameter_type_list
        : parameter_list
        | parameter_list ',' '...'
        ;

    parameter_list
        : parameter_declaration
        | parameter_list ',' parameter_declaration

    parameter_declaration
        : declaration_specifiers declarator
        | declaration_specifiers abstract_declarator
        | declaration_specifiers
        ;

    identifier_list
        : IDENTIFIER
        | identifier_list ',' IDENTIFIER
        ;

    type_name
        : specifier_qualifier_list
        | specifier_qualifier_list abstract_declarator
        ;

    abstract_declarator
        : pointer
        | direct_abstract_declarator
        | pointer direct_abstract_declarator
        ;

    direct_abstract_declarator
        : '(' abstract_declarator ')'
        | '[' ']'
        | '[' constant_expression ']'
        | direct_abstract_declarator '[' ']'
        | direct_abstract_declarator '[' constant_expression ']'
        | '(' ')'
        | '(' parameter_type_list ')'
        | direct_abstract_declarator '(' ')'
        | direct_abstract_declarator '(' parameter_type_list ')'
        ;

    declarator
        : pointer direct_declarator
        | direct_declarator
        ;

    direct_declarator
        : IDENTIFIER
        | '(' declarator ')'
        | direct_declarator '[' constant_expression ']'
        | direct_declarator '[' ']'
        | direct_declarator '(' parameter_type_list ')'
        | direct_declarator '(' identifier_list ')'
        | direct_declarator '(' ')'
        ;

    pointer
        : '*'
        | '*' type_qualifier_list
        | '*' pointer
        | '*' type_qualifier_list pointer
        ;        

    statement
        : labeled_statement
        | compound_statement
        | expression_statement
        | selection_statement
        | iteration_statement
        | jump_statement
        ;

    labeled_statement
        : IDENTIFIER ':' statement
        | CASE constant_expression ':' statement
        | DEFAULT ':' statement
        ;

    compound_statement
        : '{' '}'
        | '{' statement_list '}'
        | '{' declaration_list '}'
        | '{' declaration_list statement_list '}'
        ;        

    statement_list
        : statement
        | statement_list statement
        ;

    expression_statement
        : ';'
        | expression ';'
        ;

    selection_statement
        : IF '(' expression ')' statement
        | IF '(' expression ')' statement ELSE statement
        | SWITCH '(' expression ')' statement
        ;

    iteration_statement
        : WHILE '(' expression ')' statement
        | DO statement WHILE '(' expression ')' ';'
        | FOR '(' expression_statement expression_statement ')' statement
        | FOR '(' expression_statement expression_statement expression ')' statement
        ;

    jump_statement
        : GOTO IDENTIFIER ';'
        | CONTINUE ';'
        | BREAK ';'
        | RETURN ';'
        | RETURN expression ';'
        ;        

    expression
        : assignment_expression
        | expression ',' assignment_expression
        ;

    assignment_expression
        : conditional_expression
        | unary_expression assignment_operator assignment_expression
        ;

    assignment_operator
        : '='
        | '*='
        | '/='
        | '%='
        | '+='
        | '-='
        | '&lt;&lt;='
        | '&gt;&gt;='
        | '&amp;='
        | '^='
        | '|='
        ;

    constant_expression
        : conditional_expression
        ;

    conditional_expression
        : logical_or_expression
        | logical_or_expression '?' expression ':' conditional_expression
        ;

    logical_or_expression
        : logical_and_expression
        | logical_or_expression '||' logical_and_expression
        ;

    logical_and_expression
        : inclusive_or_expression
        | logical_and_expression '&amp;&amp;' inclusive_or_expression
        ;

    inclusive_or_expression
        : exclusive_or_expression
        | inclusive_or_expression '|' exclusive_or_expression
        ;

    exclusive_or_expression
        : and_expression
        | exclusive_or_expression '^' and_expression
        ;

    and_expression
        : equality_expression
        | and_expression '&amp;' equality_expression
        ;

    equality_expression
        : relational_expression
        | equality_expression '==' relational_expression
        | equality_expression '!=' relational_expression
        ;

    relational_expression
        : shift_expression
        | relational_expression '&lt;' shift_expression
        | relational_expression '&gt;' shift_expression
        | relational_expression '&lt;=' shift_expression
        | relational_expression '&gt;=' shift_expression
        ;

    shift_expression
        : additive_expression
        | shift_expression '&lt;&lt;' additive_expression
        | shift_expression '&gt;&gt;' additive_expression
        ;

    additive_expression
        : multiplicative_expression
        | additive_expression '+' multiplicative_expression
        | additive_expression '-' multiplicative_expression
        ;

    multiplicative_expression
        : cast_expression
        | multiplicative_expression '*' cast_expression
        | multiplicative_expression '/' cast_expression
        | multiplicative_expression '%' cast_expression
        ;

    cast_expression
        : unary_expression
        | '(' type_name ')' cast_expression
        ;

    unary_expression
        : postfix_expression
        | '++' unary_expression
        | '--' unary_expression
        | unary_operator cast_expression
        | SIZEOF unary_expression
        | SIZEOF '(' type_name ')'
        ;

    unary_operator
        : '&amp;'
        | '*'
        | '+'
        | '-'
        | '~'
        | '!'
        ;

    argument_expression_list
        : assignment_expression
        | argument_expression_list ',' assignment_expression
        ;

    postfix_expression
        : primary_expression
        | postfix_expression '[' expression ']'
        | postfix_expression '(' ')'
        | postfix_expression '(' argument_expression_list ')'
        | postfix_expression '.' IDENTIFIER
        | postfix_expression '-&gt;' IDENTIFIER
        | postfix_expression '++'
        | postfix_expression '--'
        ;

    primary_expression
        : IDENTIFIER
        | CONSTANT
        | STRING_LITERAL
        | '(' expression ')'
        ;
    %%
</code></pre>
]]></content>
  </entry>
  
</feed>
