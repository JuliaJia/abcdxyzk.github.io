<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 2012 | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/2012/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2014-11-27T00:49:31+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[两个数只出现一次]]></title>
    <link href="http://abcdxyzk.github.io/blog/2012/11/12/alg-2num-appear-once/"/>
    <updated>2012-11-12T16:51:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2012/11/12/alg-2num-appear-once</id>
    <content type="html"><![CDATA[<h4>problem</h4>

<p>一个数组，其中只有两个数只出现一次，其余数皆出现偶数次。<br/>
设计Time: O(n) 的算法得出那个只出现一次的数。</p>

<h4>answer</h4>

<p>再因为a和b不等，那么a<sup>b</sup>必然不为0。<br/>
那么a<sup>b</sup>这个数上面必然能够找到一个二进制位是1<br/>
在这个二进制位上，a和b不等。<br/>
根据这个二进制位，将各元素中在这位上为1的分派到左边，为0的分派到右边，形成两个子数组。</p>

<p>可以证明，<br/>
1）这两个数组分别包含a和b。<br/>
2）每个数组中除了a或b之外的所有元素都是成对出现的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[eclipse生成jar包]]></title>
    <link href="http://abcdxyzk.github.io/blog/2012/10/29/lang-java-eclipse-jar/"/>
    <updated>2012-10-29T11:46:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2012/10/29/lang-java-eclipse-jar</id>
    <content type="html"><![CDATA[<h4>第一：普通类导出jar包</h4>

<p>普通类就是指此类包含main方法，并且没有用到别的jar包。<br/>
1.在eclipse中选择你要导出的类或者package，右击，选择Export子选项；<br/>
2.在弹出的对话框中，选择java文件&mdash;选择JAR file，单击next；<br/>
3.在JAR file后面的文本框中选择你要生成的jar包的位置以及名字，注意在Export generated class files and resources和Export java source files and resources前面打上勾，单击next; <br/>
4.单击两次next按钮，到达JAR Manifest Specification。注意在最底下的Main class后面的文本框中选择你的jar包的入口类。单击Finish，完成。</p>

<p>运行 java -jar 名字.jar，检测运行是否正确。</p>

<h4>第二、你所要导出的类里边用到了别的jar包。</h4>

<p>比如说你写的类连接了数据库，用到数据库驱动包oracl.jar.。<br/>
1.先把你要导出的类按照上面的步骤导出形成jar包，比如叫test.jar<br/>
2.新建一个文件夹main，比如在D盘根目录下；<br/>
3.把test.jar和oracl.jar拷贝到main文件下，右击test.jar，解压到当前文件夹。把META-INF\MANIFEST.MF剪切到另外一个地方 （比如是桌面！） ；<br/>
4.右击oracl.jar，解压到当前文件夹。<br/>
5.在dos环境下，进入到D盘的main文件夹下，执行 jar cvfm new.jar meta-inf/manifest.mf .，不要忘了最后面的点。<br/>
6.用压缩工具打开你新生成的new.jar，用你放在桌面的META-INF\MANIFEST.MF覆盖new.jar原有。</p>

<p>运行 java -jar 名字.jar，检测运行是否正确。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[统计git提交行数的脚本]]></title>
    <link href="http://abcdxyzk.github.io/blog/2012/10/16/tools-git-count-lines/"/>
    <updated>2012-10-16T14:15:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2012/10/16/tools-git-count-lines</id>
    <content type="html"><![CDATA[<p>可以保存为count.sh运行 ./count.sh your_name
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#!/bin/sh
</span><span class='line'>insert=0
</span><span class='line'>delete=0
</span><span class='line'>git log&ndash;author=$1&ndash;shortstat&ndash;pretty=format:&ldquo;&rdquo;|sed/^$/d &gt;.tmp.count&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;whilereadline ;do
</span><span class='line'>current=`echo$line|awk-F',''{printf $2}'|awk'{printf $1}'`
</span><span class='line'>insert=`expr$insert+ $current`
</span><span class='line'>current=`echo$line|awk-F',''{printf $3}'|awk'{printf $1}'`
</span><span class='line'>delete=`expr$delete+ $current`
</span><span class='line'>done&lt;.tmp.count
</span><span class='line'>
</span><span class='line'>rm .tmp.count
</span><span class='line'>echo$1$insertinsertions, $deletedeletions
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[git建库，配置颜色分支名]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2012/05/01/tools-git-base2/"/&gt;
</span><span class='line'>&lt;updated&gt;2012-05-01T17:00:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2012/05/01/tools-git-base2&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;h4&gt;建一个库&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;服务器&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;mkdir allgit
</span><span class='line'>cd allgit
</span><span class='line'>git --bare init
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;客户端&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;git clone username@192.168.1.2:/home/abc/allgit allgit
</span><span class='line'>cd allgit
</span><span class='line'>...
</span><span class='line'>git push origin master // 第一次的时候用， 以后直接用 git push
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;配置颜色分支名&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;git 配色&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;/home/username/.gitconfig
</span><span class='line'>&lt;code&gt;
</span><span class='line'>[color]
</span><span class='line'>branch = auto
</span><span class='line'>status = auto
</span><span class='line'>diff = auto
</span><span class='line'>log = auto
</span><span class='line'>grep = auto
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;bash 显示分支名&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;/home/username/.bash_profile  或 /home/username/.bashrc ？</span></code></pre></td></tr></table></div></figure>
    function parse_git_branch {
      git branch &ndash;no-color 2> /dev/null | sed -e &lsquo;/^[^<em>]/d&rsquo; -e &rsquo;s/</em> (.*)/(\1)/&lsquo;
    }</p>

<pre><code>function proml {
  local YELLOW="\[\033[01;32m\]"
  local WHITE="\[\033[01;00m\]"
#  local YELLOW="\[\033[0;33m\]"
#  local WHITE="\[\033[1;37m\]"
#  local cyan="\[\033[1;36m\]"
  case $TERM in
    xterm*)
    TITLEBAR='\[\033]0;\u@\h:\w\007\]'
    ;;
    *)
    TITLEBAR=""
    ;;
  esac
PS1="${TITLEBAR}\
$WHITE\u@\h:\w$YELLOW\$(parse_git_branch)\
$WHITE\$ "
PS2='&gt; '
PS4='+ '
}
proml
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[避免僵死进程]]></title>
    <link href="http://abcdxyzk.github.io/blog/2012/04/21/lang-c-fork/"/>
    <updated>2012-04-21T19:45:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2012/04/21/lang-c-fork</id>
    <content type="html"><![CDATA[<h4>一 两次fork避免僵死进程</h4>

<p>如果在一个进程A中启动了一个子进程B，但是B的执行时间可能很长，也可能很短。因此，既不希望A调用wait或者waitpid来等待B的完成（如果B执行时间太长，A的时间就耗费在等待B的完成了，虽然waitpid有WNOHANG选项，但免不了多次调用waitpid来看B是否完成）；也不希望如果B执行时间太短了，然后A又不用wait或waitpid去获取B的退出状态，那么B就一直处于僵死状态直到A终止（这样造成了资源的浪费）。</p>

<p>此时，可以使用一个小trick。就是调用两次fork，让B的父进程变成init进程（pid=1的那个进程，所有孤儿进程的父进程）。这样，A进程可以想干嘛干嘛去，B进程也可以想执行多久就执行多久了。
<code>
    #include &lt;unistd.h&gt;
    #include &lt;sys/wait.h&gt;
    int main()
    {
        pid_t pid;
        if((pid=fork())&lt;0)
        {
            printf("fork 1 error\n");
            exit(-1);
        }
        else if(pid==0）//第一个子进程
        {
            if((pid=fork())&lt;0)
            {
                printf("fork 2 error\n");
                exit(-1);
            }
            else if(pid&gt;0)//第二次fork产生的子进程（第二个子进程）的父进程，其实就是第一次fork产生的子进程（第一个子进程）
            {
                exit(0);//第一个子进程结束，那么它的子进程（第二个子进程）将由init进程领养，init进程成为第二个子进程的父进程
            }
            //第二个子进程（就是我们前面说的B进程）可以做他想做的事情了
            ................
        }
        if(waitpid(pid,NULL,0)!=pid)//获取第一个子进程的终止状态，不让它变成僵死进程
        printf("waitpid error\n");
        //父进程（就是我们前面说的A进程）也可以做他想做的事情了
        .........
        return 0;
    }
</code></p>

<h4>二</h4>

<p>父进程可以忽略 SIGCLD 软中断而不必要 wait()。可以这样做到(在支持它的系统上,比如Linux):　
<code>
    main()　　
    {　　
        signal(SIGCLD, SIG_IGN); /* now I don't have to wait()! */　　
        .......　　
        fork();　　
        fork();　　
        fork(); /* Rabbits, rabbits, rabbits! */　　
    ｝
</code></p>
]]></content>
  </entry>
  
</feed>
