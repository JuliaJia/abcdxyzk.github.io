<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: debug~base | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/debug~base/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2014-11-30T22:48:57+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Oops打印Tainted信息]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/07/16/debug-oops/"/>
    <updated>2014-07-16T15:58:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/07/16/debug-oops</id>
    <content type="html"><![CDATA[<p>检查一下上面的Oops，看看Linux内核还有没有给我们留下其他的有用信息。
<code>
Oops: 0002 [#1]
</code>
* 这里面，0002表示Oops的错误代码（写错误，发生在内核空间），#1表示这个错误发生一次。</p>

<p>Oops的错误代码根据错误的原因会有不同的定义，本文中的例子可以参考下面的定义（如果发现自己遇到的Oops和下面无法对应的话，最好去内核代码里查找）：
<code>
 * error_code:
 *      bit 0 == 0 means no page found, 1 means protection fault
 *      bit 1 == 0 means read, 1 means write
 *      bit 2 == 0 means kernel, 1 means user-mode
 *      bit 3 == 0 means data, 1 means instruction
</code>
有时候，Oops还会打印出Tainted信息。这个信息用来指出内核是因何种原因被tainted（直译为“玷污”）。具体的定义如下：
<code>
  1: 'G' if all modules loaded have a GPL or compatible license, 'P' if any proprietary module has been loaded.  Modules without a MODULE_LICENSE or with a MODULE_LICENSE that is not recognised by insmod as GPL compatible are assumed to be proprietary.
  2: 'F' if any module was force loaded by "insmod -f", ' ' if all modules were loaded normally.
  3: 'S' if the oops occurred on an SMP kernel running on hardware that hasn't been certified as safe to run multiprocessor. Currently this occurs only on various Athlons that are not SMP capable.
  4: 'R' if a module was force unloaded by "rmmod -f", ' ' if all modules were unloaded normally.
  5: 'M' if any processor has reported a Machine Check Exception, ' ' if no Machine Check Exceptions have occurred.
  6: 'B' if a page-release function has found a bad page reference or some unexpected page flags.
  7: 'U' if a user or user application specifically requested that the Tainted flag be set, ' ' otherwise.
  8: 'D' if the kernel has died recently, i.e. there was an OOPS or BUG.
  9: 'A' if the ACPI table has been overridden.
 10: 'W' if a warning has previously been issued by the kernel. (Though some warnings may set more specific taint flags.)
 11: 'C' if a staging driver has been loaded.
 12: 'I' if the kernel is working around a severe bug in the platform firmware (BIOS or similar).
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[the meaning of '?' in Linux kernel panic call trace]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/06/12/debug-dumpstack-mean/"/>
    <updated>2014-06-12T09:42:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/06/12/debug-dumpstack-mean</id>
    <content type="html"><![CDATA[<ul>
<li>&lsquo;?&rsquo; means that the information about this stack entry is probably not reliable.</li>
</ul>


<p>The stack output mechanism (see the implementation of dump_trace() function) was unable to prove that the address it has found is a valid return address in the call stack.</p>

<p>&lsquo;?&rsquo; itself is output by printk_stack_address().</p>

<p>The stack entry may be valid or not. Sometimes one may simply skip it. It may be helpful to investigate the disassembly of the involved module to see which function is called at ClearFunctionName+0x88 (or, on x86, immediately before that position).</p>

<p>Concerning reliability</p>

<p>On x86, when dump_stack() is called, the function that actually examines the stack is print_context_stack() defined in arch/x86/kernel/dumpstack.c. Take a look at its code, I&rsquo;ll try to explain it below.</p>

<p>I assume DWARF2 stack unwind facilities are not available in your Linux system (most likely, they are not, if it is not OpenSUSE or SLES). In this case, print_context_stack() seems to do the following.</p>

<p>It starts from an address (&lsquo;stack&rsquo; variable in the code) that is guaranteed to be an address of a stack location. It is actually the address of a local variable in dump_stack().</p>

<p>The function repeatedly increments that address (while (valid_stack_ptr &hellip;) { &hellip; stack++}) and checks if what it points to could also be an address in the kernel code (if (__kernel_text_address(addr)) &hellip;). This way it attempts to find the functions' return addresses pushed on stack when these functions were called.</p>

<p>Of course, not every unsigned long value that looks like a return address is actually a return address. So the function tries to check it. If frame pointers are used in the code of the kernel (%ebp/%rbp registers are employed for that if CONFIG_FRAME_POINTER is set), they can be used to traverse the stack frames of the functions. The return address for a function lies just above the frame pointer (i.e. at %ebp/%rbp + sizeof(unsigned long)). print_context_stack checks exactly that.</p>

<p>If there is a stack frame for which the value &lsquo;stack&rsquo; points to is the return address, the value is considered a reliable stack entry. ops->address will be called for it with reliable == 1, it will eventually call printk_stack_address() and the value will be output as a reliable call stack entry. Otherwise the address will be considered unreliable. It will be output anyway but with &lsquo;?&rsquo; prepended.</p>

<p>[NB] If frame pointer information is not available (e.g. like it was in Debian 6 by default), all call stack entries will be marked as unreliable for this reason.</p>

<p>The systems with DWARF2 unwinding support (and with CONFIG_STACK_UNWIND set) is a whole another story.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Connecting Two Virtual Machines]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/02/28/debug-2vm-connect/"/>
    <updated>2014-02-28T17:50:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/02/28/debug-2vm-connect</id>
    <content type="html"><![CDATA[<p>  You can set up the virtual serial ports in two virtual machines to connect to each other. This is useful, for example, if you want to use an application in one virtual machine to capture debugging information sent from the other virtual machine&rsquo;s serial port.</p>

<p>  To install a direct serial connection between two virtual machines (a server and a client), take the following steps:</p>

<h4>Windows Host In the server virtual machine</h4>

<ol>
<li>Open the virtual machine settings editor (VM > Settings).</li>
<li>Click Add to start the Add Hardware Wizard.</li>
<li>Select Serial Port, then click Next.</li>
<li>Select Output to named pipe, then click Next.</li>
<li>Use the default pipe name, or enter another pipe name of your choice. The pipe name must follow the form \.\pipe\<namedpipe> — that is, it must begin with \.\pipe.</li>
<li>Select This end is the server.</li>
<li>Select The other end is a virtual machine.</li>
<li>By default, the device status setting is Connect at power on. You may deselect this setting if you wish.
Click Advanced if you want to configure this serial port to use polled mode. This option is of interest primarily to developers who are using debugging tools that communicate over a serial connection. For more information, see <a href="https://www.vmware.com/support/ws55/doc/ws_devices_serial_advanced.html">Special Configuration Options for Advanced Users.</a></li>
<li>Click Finish, then click OK to close the virtual machine settings editor.</li>
</ol>


<h4>In the client virtual machine</h4>

<ol>
<li>Open the virtual machine settings editor (VM > Settings).</li>
<li>Click Add to start the Add Hardware Wizard.</li>
<li>Select Serial Port, then click Next.</li>
<li>Select Use named pipe.</li>
<li>Use the default name, or enter another pipe name of your choice. The pipe name must follow the form \.\pipe\<namedpipe> — that is, it must begin with \.\pipe. The pipe name must be the same on both server and client.</li>
<li>Select This end is the client.</li>
<li>Select The other end is a virtual machine.</li>
<li>By default, the device status setting is Connect at power on. You may deselect this setting if you wish.
Click Advanced if you want to configure this serial port to use polled mode. This option is of interest primarily to developers who are using debugging tools that communicate over a serial connection. For more information, see <a href="https://www.vmware.com/support/ws55/doc/ws_devices_serial_advanced.html">Special Configuration Options for Advanced Users.</a></li>
<li>Click Finish, then click OK to close the virtual machine settings editor.</li>
</ol>


<h4>Linux Host In the server virtual machine</h4>

<ol>
<li>Open the virtual machine settings editor (VM > Settings).</li>
<li>Click Add to start the Add Hardware Wizard.</li>
<li>Select Serial Port, then click Next.</li>
<li>Select Output to named pipe, then click Next.</li>
<li>In the Path field, enter /tmp/<socket> or another Unix socket name of your choice.</li>
<li>Select This end is the server.</li>
<li>Select The other end is a virtual machine.</li>
<li>By default, the device status setting is Connect at power on. You may deselect this setting if you wish.
Click Advanced if you want to configure this serial port to use polled mode. This option is of interest primarily to developers who are using debugging tools that communicate over a serial connection. For more information, see <a href="https://www.vmware.com/support/ws55/doc/ws_devices_serial_advanced.html">Special Configuration Options for Advanced Users.</a></li>
<li>Click Finish, then click OK to save your configuration and close the virtual machine settings editor.</li>
</ol>


<h4>In the client virtual machine</h4>

<ol>
<li>Open the virtual machine settings editor (VM > Settings).</li>
<li>Click Add to start the Add Hardware Wizard.</li>
<li>Select Serial Port, then click Next.</li>
<li>Select Output to named pipe, then click Next.</li>
<li>In the Path field, enter /tmp/<socket> or another Unix socket name of your choice. The pipe name must be the same on both server and client.</li>
<li>Select This end is the client.</li>
<li>Select The other end is a virtual machine.</li>
<li>By default, the device status setting is Connect at power on. You may deselect this setting if you wish.
Click Advanced if you want to configure this serial port to use polled mode. This option is of interest primarily to developers who are using debugging tools that communicate over a serial connection. For more information, see <a href="https://www.vmware.com/support/ws55/doc/ws_devices_serial_advanced.html">Special Configuration Options for Advanced Users.</a></li>
<li>Click Finish, then click OK to save your configuration and close the virtual machine settings editor.</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[vmware 串口调试]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/02/28/debug-vm-ttys/"/>
    <updated>2014-02-28T17:48:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/02/28/debug-vm-ttys</id>
    <content type="html"><![CDATA[<p>  在系统内核开发中，经常会用到串口调试，利用VMware的Virtual Machine更是为调试系统内核如虎添翼。那么怎么搭建串口调试环境呢？</p>

<p>Virtual Machine 主要有三种串口调试技术，可以在serial port的配置界面找到：</p>

<ol>
<li>Use physical serial port      即使用物理机串口，当用串口线盒另一台电脑连接时，就用这种方式</li>
<li>Use output file                   即把串口数据输出到宿主机某文件中，当只需要看输出结果的时候可以用这种方式，简单方便</li>
<li>Use named pipe                把串口输出到命名管道，命名管道可读可写，也就可以交互，进行一些debug工作，而不是简单的看结果</li>
</ol>


<p>  因为前两种相对简单易用就不具体介绍了，这里主要说第三种用命名管道调试方法。命名管道，在Linux中是进程间通信(IPC)的一种方式，两个进 程可以通过读写管道来交换数据。这里就是运用了这种技术，通过把串口绑定一个有名管道，对有名管道的读写交换串口数据。也有两种方式：1. 宿主机与虚拟机之间， 2. 在同一宿主机上，两虚拟机间通过绑定同一个宿主机上的有名管道。问题的关键在于如何把虚拟机串口绑定到宿主机的某一有名管道，而第一种方式则需要找到一种 方式使得主机如何读写有名管道来交互，经过一阵Google终于找到分别在Linux和Windows分别试验成功的工具。</p>

<p>  在Windows中有名管道式通过路径//./pipe/namedpipe来创建的，当然你可以指定到其他机子如//192.168.1.10 /pipe/namedpipe，而在Linux中，/tmp/mypipe就可以了。创建好有名管道后，就是如何和管道交互了。目前，无论是 Windows还是Linux，似乎都没有一款工具可以直接读写有名管道的，而我找到的两个工具都是通过把有名管道和Socket绑定，通过读写 Socket来间接读写管道。</p>

<h4>下面我就简要介绍一下在Windows和Linux下如何配置：</h4>

<h5>Linux Host:</h5>

<h6>Host  ~  Virtual Machine</h6>

<pre><code>1. configure VM
a. add hardware -&gt; Serial port
b. using named pipe
c. /tmp/isocket
d. this end is server &amp; far end is application
e. check Yield CPU on poll
f. start Virtual Machine

2. socat /tmp/isocket tcp4-listen:9001 &amp;
/tmp/socket: VMware call it 'named piped', actually it is Unix Daemon Socket, so you shouldn't use pipe:/tmp/socket
3. telnet 127.0.0.1 9001
</code></pre>

<p>Trouble Shoot: 有时候会遇到错误Connection closed by foreign host，或者telnet一开，socat就能退出，很可能是你没power on虚拟机，有名管道还没创建，你就socat，这样也会创建一个名为isocket的文件但只是普通文件。具体的细节请看socat help<br/>
start Virtual Machine first, than run the socat, and telnet<br/>
(Note you must have permission to all resource, /tmp/socket, VM and so on)</p>

<h6>Vritual Machine ~ Virtual Machine</h6>

<pre><code>1. configure VM
a. add hardware --&gt;　serial port
b. Using named pipe, configure /tmp/isocket 
c.  this end is server &amp; far end is Virtual Machine
d. check Yield CPU on poll
e. start VM

2. Another VM
a. add hardware  --&gt;  Serial Port
b. Using named pipe, configure /tmp/isocket 
c.  this end is client &amp; far end is Virtual Machine 
d. check Yield CPU on poll
e. start VMs
</code></pre>

<h5>Windows Host:</h5>

<h6>Host ~ Virtual Machine</h6>

<pre><code>1. configure VM
a. add hardware --&gt; serial port
b. using named pipe
c. //./pipe/vmwaredebug
d. this end is client &amp; far end is application
e. check Yield CPU on poll

2. using 3rd-party tool to communicate with named pipe
a. down the tool 
b. install service
cmd&gt;vmwaregateway.exe /r
c. start service
c:/&gt; net start vmwaregateway
d. telnet 127.0.0.1 567
3. start Virtual Machine
</code></pre>

<p>如果你使用的是vmwaregateway.exe这个小工具，这里的管道名就必须是vmwaredebug，除非你把它的源代码download下来自己改改。</p>

<h6>Vritual Machine ~ Virtual Machine</h6>

<pre><code>1. configure VM
a. add hardware --&gt;　serial port
b. Using named pipe, //./pipe/vmwaredebug
c.  this end is server &amp; far end is Virtual Machine
d. check Yield CPU on poll
e. start VM

2. Another VM
a. add hardware  --&gt;  Serial Port
b. Using named pipe, //./pipe/vmwaredebug
c.  this end is client &amp; far end is Virtual Machine 
d. check Yield CPU on poll
e. start VMs
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How source debuggers work?]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/12/04/debug-source-debug/"/>
    <updated>2013-12-04T09:51:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/12/04/debug-source-debug</id>
    <content type="html"><![CDATA[<p><a href="http://blog.techveda.org/howsourcedebuggerswork/">http://blog.techveda.org/howsourcedebuggerswork/</a></p>

<p>Application binaries are a result of compile and build operations performed on a single or a set of source files. Program Source files contain functions, data variables of various types (local, global, register, static), and abstract data objects, all written and neatly indented with nested control structures as per high level programming language syntax (C/C++).  Compilers translate code in each source file into machine instructions (1’s and 0’s) as per target processors Instruction set Architecture and bury that code into object files. Further, Linkers integrate compiled object files with other pre-compiled objects files (libraries, runtime binaries) to create end application binary image called executable.</p>

<p>Source debuggers are tools used to trace execution of an application executable binary. Most amazing feature of a source debugger is its ability to list source code of the program being debugged; it can show the line or expression in the source code that resulted in a particular machine code instruction of a running program loaded in memory. This helps the programmer to analyze a program’s behavior in the high-level terms like source-level flow control constructs, procedure calls, named variables, etc,  instead of machine instructions and memory locations. Source-level debugging also makes it possible to step through execution a line at a time and set source-level breakpoints. (If you do not have any prior hands on experience with source debuggers I suggest you to look at this before continuing with following.)</p>

<p>lets explore how source debuggers like gnu gdb work ? So how does a debugger know where to stop when you ask it to break at the entry to some function? How does it manage to find what to show you when you ask it for the value of a variable? The answer is – debug information.  All modern compilers are designed to generate Debug information together with the machine code of the source file. It is a representation of the relationship between the executable program and the original source code. This information is encoded as per  a pre-defined format and stored alongside the machine code. Many such formats were invented over the years for different platforms and executable files (aim of this article isn’t to survey the history of these formats, but rather to show how they work). Gnu compiler and ELF executable on Linux/ UNIX platforms use DWARF, which is widely used today as default debugging information format.</p>

<p>Word of Advice : Does an Application/ Kernel programmer need to know Dwarf?</p>

<p>Obvious answer to this question is a big NO.  It is purely subject matter for developers involved in implementation of a Debugger tool. A normal Application developer using debugger tools would never need to learn or dig into binary files for debug information. This in no way adds any edge to your debugging skills nor adds any new skills into your armory. However, if you are a developer using debuggers for years and curious about how debuggers work read this document for an outline into debug information.  If you are a beginner to systems programming or fresher’s learning programming I would  suggest  not to waste your time as you can safely ignore this.</p>

<p>ELF -DWARF sections</p>

<p>Gnu compiler generates debug information which is organized into various sections of the ELF object file. Let’s use the following source file for compiling and observing DWARF sections</p>

<p>root@techveda:~# vim sample.c
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>#include &lt;stdlib.h&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;int add(int x, int y)
</span><span class='line'>{
</span><span class='line'>return x + y;
</span><span class='line'>}
</span><span class='line'>int main()
</span><span class='line'>{
</span><span class='line'>int a = 10, b = 20;
</span><span class='line'>int result;
</span><span class='line'>int (*fp) (int, int);
</span><span class='line'>
</span><span class='line'>fp = add;
</span><span class='line'>result = (*fp) (a, b);
</span><span class='line'>printf(" %dn", result);
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;root@techveda:~# gcc -c -g sample.c -o sample.o
</span><span class='line'>root@techveda:~# objdump -h sample.o | more&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;sample.o:     file format elf32-i386&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Sections:
</span><span class='line'>Idx Name          Size      VMA       LMA       File off  Algn
</span><span class='line'>  0 .text         0000005f  00000000  00000000  00000034  2&lt;strong&gt;2
</span><span class='line'>              CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
</span><span class='line'>  1 .data         00000000  00000000  00000000  00000094  2&lt;/strong&gt;2
</span><span class='line'>              CONTENTS, ALLOC, LOAD, DATA
</span><span class='line'>  2 .bss          00000000  00000000  00000000  00000094  2&lt;strong&gt;2
</span><span class='line'>              ALLOC
</span><span class='line'>  3 .debug_abbrev 000000a2  00000000  00000000  00000094  2&lt;/strong&gt;0
</span><span class='line'>              CONTENTS, READONLY, DEBUGGING
</span><span class='line'>  4 .debug_info   00000114  00000000  00000000  00000136  2&lt;strong&gt;0
</span><span class='line'>              CONTENTS, RELOC, READONLY, DEBUGGING
</span><span class='line'>  5 .debug_line   00000040  00000000  00000000  0000024a  2&lt;/strong&gt;0
</span><span class='line'>              CONTENTS, RELOC, READONLY, DEBUGGING
</span><span class='line'>  6 .rodata       00000005  00000000  00000000  0000028a  2&lt;strong&gt;0
</span><span class='line'>              CONTENTS, ALLOC, LOAD, READONLY, DATA
</span><span class='line'>  7 .debug_loc    00000070  00000000  00000000  0000028f  2&lt;/strong&gt;0
</span><span class='line'>              CONTENTS, READONLY, DEBUGGING
</span><span class='line'>  8 .debug_pubnames 00000023  00000000  00000000  000002ff  2&lt;strong&gt;0
</span><span class='line'>              CONTENTS, RELOC, READONLY, DEBUGGING
</span><span class='line'>  9 .debug_pubtypes 00000012  00000000  00000000  00000322  2&lt;/strong&gt;0
</span><span class='line'>              CONTENTS, RELOC, READONLY, DEBUGGING
</span><span class='line'> 10 .debug_aranges 00000020  00000000  00000000  00000334  2&lt;strong&gt;0
</span><span class='line'>              CONTENTS, RELOC, READONLY, DEBUGGING
</span><span class='line'> 11 .debug_str    000000b0  00000000  00000000  00000354  2&lt;/strong&gt;0
</span><span class='line'>              CONTENTS, READONLY, DEBUGGING
</span><span class='line'> 12 .comment      0000002b  00000000  00000000  00000404  2&lt;strong&gt;0
</span><span class='line'>              CONTENTS, READONLY
</span><span class='line'> 13 .note.GNU-stack 00000000  00000000  00000000  0000042f  2&lt;/strong&gt;0
</span><span class='line'>              CONTENTS, READONLY
</span><span class='line'> 14 .debug_frame  00000054  00000000  00000000  00000430  2**2
</span><span class='line'>              CONTENTS, RELOC, READONLY, DEBUGGING
</span><span class='line'>&lt;code&gt;
</span><span class='line'>All of the sections with naming debug_xxx are debugging information sections.  Information in these sections is interpreted by source debugger like gdb.  Each debug_ section holds specific information like
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>.debug_info               core DWARF data containing DIEs
</span><span class='line'>.debug_line               Line Number Program
</span><span class='line'>.debug_frame              Call Frame Information
</span><span class='line'>.debug_macinfo            lookup table for global objects and functions
</span><span class='line'>.debug_pubnames           lookup table for global objects and functions
</span><span class='line'>.debug_pubtypes           lookup table for global types
</span><span class='line'>.debug_loc                Macro descriptions
</span><span class='line'>.debug_abbrev             Abbreviations used in the .debug_info section
</span><span class='line'>.debug_aranges            mapping between memory address and compilation
</span><span class='line'>.debug_ranges             Address ranges referenced by DIEs
</span><span class='line'>.debug_str                String table used by .debug_info</span></code></pre></td></tr></table></div></figure>
Debugging Information Entry (DIE)</p>

<p>Dwarf format organizes debug data in all of the above sections using special objects (program descriptive entities) called Debugging Information Entry (DIE).  Each DIE has a tag filed whose value specifies its type, and a set of attributes. DIEs are interlinked via sibling and child links, and values of attributes can point at other DIEs. Now let’s dig into ELF file to view how a DIE looks like. We will begin our exploration with .debug_info section of the ELF file since core DIE’s are listed in it.
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>root@techveda:~# objdump &ndash;dwarf=info . /sample&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Above operation shows long list of DIE’s. Let’s limit ourselves to relevant information&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;./sample:     file format elf32-i386&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Contents of the .debug_info section:&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  Compilation Unit @ offset 0x0:
</span><span class='line'>   Length:        0x110 (32-bit)
</span><span class='line'>   Version:       2
</span><span class='line'>   Abbrev Offset: 0
</span><span class='line'>   Pointer Size:  4
</span><span class='line'> &lt;0&gt;&lt;b&gt;: Abbrev Number: 1 (DW_TAG_compile_unit)
</span><span class='line'>    &lt; c&gt;   DW_AT_producer    : (indirect string, offset: 0xe): GNU C 4.5.2 &lt;br/&gt;
</span><span class='line'>    &lt;10&gt;   DW_AT_language    : 1  (ANSI C)
</span><span class='line'>    &lt;11&gt;   DW_AT_name        : (indirect string, offset: 0x44): sample.c
</span><span class='line'>    &lt;15&gt;   DW_AT_comp_dir    : (indirect string, offset: 0x71): /root
</span><span class='line'>    &lt;19&gt;   DW_AT_low_pc      : 0x80483c4
</span><span class='line'>    &lt;1d&gt;   DW_AT_high_pc     : 0x8048423
</span><span class='line'>    &lt;21&gt;   DW_AT_stmt_list   : 0x0</span></code></pre></td></tr></table></div></figure>
Each source file in the application is referred in dwarf terminology as a “compilation unit”.   Dwarf data for each compilation unit (source file) starts with a compilation unit DIE. Above dump shows the first DIE’s and tag value “DW_TAG_compile_unit “.  This DIE provides general information about compilation unit like source file name (DW_AT_name   : (indirect string, offset: 0×44): sample.c),  high level programming language used to write source file(DW_AT_language    : 1    (ANSI C))  ,   directory of the source file(DW_AT_comp_dir    : (indirect string, offset: 0×71): /root) ,  compiler and producer of dwarf data(  DW_AT_producer    : (indirect string, offset: 0xe): GNU C 4.5.2) , start virtual address of the compilation unit  (DW_AT_low_pc      : 0x80483c4), end virtual address of the unit (DW_AT_high_pc     : 0×8048423).</p>

<p>Compilation Unit DIE is the parent for all the other DIE’s that describe elements of source file. Generally, the list of DIE’s that follow will describe data types, followed by global data, then the functions that make up the source file. The DIEs for variables and functions are in the same order in which they appear in the source file.</p>

<p>How does debugger locate Function Information ?</p>

<p> While using source debuggers we often instruct debugger to insert or place break point at some function, expecting the debugger to pause program execution at functions. To be able to perform this task, debugger must have some mapping between a function name in the high-level code and the address in the machine code where the instructions for this function begin. For this mapping information debuggers rely on DIE’s that describes specified function. DIE’s describing functions in a compilation unit are assigned tag value “DW_TAG_subprogram” subprogram as per dwarf terminology is a function.</p>

<p>In our sample application source we have two functions (main, add), dwarf should generate a “DW_TAG_subprogram” DIE’s for each function, these DIE attributes would define function mapping information that debugger needs for resolving machine code addresses with function name.
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Each “DW_TAG_subprogam” DIE contains&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;function scope
</span><span class='line'>function name
</span><span class='line'>source file or compilation unit in which function is located
</span><span class='line'> line no in the source file where the function starts
</span><span class='line'>Functions return type
</span><span class='line'>Start address of the fucntion
</span><span class='line'>End address of the function
</span><span class='line'>Frame information of the function.
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;root@techveda:~# objdump &ndash;dwarf=info ./sample | grep &ldquo;DW_TAG_subprogram&rdquo;
</span><span class='line'> &lt;1&gt;&lt;72&gt;: Abbrev Number: 4 (DW_TAG_subprogram)
</span><span class='line'> &lt;1&gt;&lt;a8&gt;: Abbrev Number: 6 (DW_TAG_subprogram)&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;1&gt;&lt;72&gt;: Abbrev Number: 4 (DW_TAG_subprogram)
</span><span class='line'>    &lt;73&gt;   DW_AT_external    : 1
</span><span class='line'>    &lt;74&gt;   DW_AT_name        : add &lt;br/&gt;
</span><span class='line'>    &lt;78&gt;   DW_AT_decl_file   : 1
</span><span class='line'>    &lt;79&gt;   DW_AT_decl_line   : 4
</span><span class='line'>    &lt;7a&gt;   DW_AT_prototyped  : 1
</span><span class='line'>    &lt;7b&gt;   DW_AT_type        : &lt;0x4f&gt;&lt;br/&gt;
</span><span class='line'>    &lt;7f&gt;   DW_AT_low_pc      : 0x80483c4
</span><span class='line'>    &lt;83&gt;   DW_AT_high_pc     : 0x80483d1
</span><span class='line'>    &lt;87&gt;   DW_AT_frame_base  : 0x0    (location list)
</span><span class='line'>    &lt;8b&gt;   DW_AT_sibling     : &lt;0xa8&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;1&gt;&lt;a8&gt;: Abbrev Number: 6 (DW_TAG_subprogram)
</span><span class='line'>    &lt;a9&gt;   DW_AT_external    : 1
</span><span class='line'>    &lt;aa&gt;   DW_AT_name        : (indirect string, offset: 0x1a): main
</span><span class='line'>    &lt;ae&gt;   DW_AT_decl_file   : 1
</span><span class='line'>    &lt;af&gt;   DW_AT_decl_line   : 8
</span><span class='line'>    &lt;b0&gt;   DW_AT_type        : &lt;0x4f&gt;&lt;br/&gt;
</span><span class='line'>    &lt;b4&gt;   DW_AT_low_pc      : 0x80483d2
</span><span class='line'>    &lt;b8&gt;   DW_AT_high_pc     : 0x8048423
</span><span class='line'>    &lt;bc&gt;   DW_AT_frame_base  : 0x38   (location list)
</span><span class='line'>    &lt;c0&gt;   DW_AT_sibling     : &lt;0xf8&gt;</span></code></pre></td></tr></table></div></figure></p>

<p>We now have accessed DIE description of function’s main and add.  Let’s analyze attribute information of add fucntions DIE.</p>

<p>Function scope:    DW_AT_external    : 1 (scope external)</p>

<p>Function name:     DW_AT_name        : add</p>

<p>Source file or compilation unit in which function is located:  DW_AT_decl_file   : 1 (indicates 1st compilation unit which is sample.c)</p>

<p>line no in the source file where the function starts:  DW_AT_decl_line   : 4 ( indicates line no 4 in source file)
<code>
1#include &lt;stdio.h&gt;
2#include &lt;stdlib.h&gt;
3
4int add(int x, int y)
5{
6        return x + y;
7}
8int main()
9{
10        int a = 10, b = 20;
11        int result;
12        int (*fp) (int, int);
13
14        fp = add;
15        result = (*fp) (a, b);
16        printf(" %dn", result);
17}
</code>
Function’s source line no matched with DIE description of line no. let’s continue with rest of the attribute values</p>

<p>Functions return type:  DW_AT_type        : <0x4f></p>

<p>As we have already understood that values of attributes can point to other DIE , here is an example of it.  Value   DW_AT_type     : <0x4f> indicates that return type description is stored in other DIE at offset 0x4f.
<code>
&lt;4f&gt;: Abbrev Number: 3 (DW_TAG_base_type)
    &lt;50&gt;   DW_AT_byte_size   : 4
    &lt;51&gt;   DW_AT_encoding    : 5  (signed)
    &lt;52&gt;   DW_AT_name        : int
</code>
This DIE describes data type and composition of return type of the function add, as per DIE attribute values return type is signed int  of size 4 bytes.</p>

<p>Start address of the function : DW_AT_low_pc   : 0x80483c4</p>

<p>End address of the function: DW_AT_high_pc     : 0x80483d1</p>

<p>Above values indicate start and end virtual address of the machine instructions of add function, we can verify that with binary dump of the function
<code>
080483c4 &lt;add&gt;:
 80483c4:   55                      push   %ebp
 80483c5:   89 e5                   mov    %esp,%ebp
 80483c7:   8b 45 0c                mov    0xc(%ebp),%eax
 80483ca:   8b 55 08                mov    0x8(%ebp),%edx
 80483cd:   8d 04 02                lea    (%edx,%eax,1),%eax
 80483d0:   5d                      pop    %ebp
 80483d1:   c3                      ret
</code>
How does debugger find program data (variables…) Information?</p>

<p>When the program hits assigned break point in a function, debugger pauses the program execution, at this time we can instruct debugger to show or print values of variables, by using debugger commands like print or display followed by variable name (ex: print a) How does debugger know where to find memory location of the variable ? Variables can be located in global storage, on the stack, and even in registers.The debugging information has to be able to reflect all these variations, and indeed DWARF does. As an example let’s take a look at complete DIE information set for main function.
<code>
&lt;1&gt;&lt;a8&gt;: Abbrev Number: 6 (DW_TAG_subprogram)
    &lt;a9&gt;   DW_AT_external    : 1
    &lt;aa&gt;   DW_AT_name        : (indirect string, offset: 0x1a): main
    &lt;ae&gt;   DW_AT_decl_file   : 1
    &lt;af&gt;   DW_AT_decl_line   : 8
    &lt;b0&gt;   DW_AT_type        : &lt;0x4f&gt;  
    &lt;b4&gt;   DW_AT_low_pc      : 0x80483d2
    &lt;b8&gt;   DW_AT_high_pc     : 0x8048423
    &lt;bc&gt;   DW_AT_frame_base  : 0x38   (location list)
    &lt;c0&gt;   DW_AT_sibling     : &lt;0xf8&gt;  
 &lt;2&gt;&lt;c4&gt;: Abbrev Number: 7 (DW_TAG_variable)
    &lt;c5&gt;   DW_AT_name        : a
    &lt;c7&gt;   DW_AT_decl_file   : 1
    &lt;c8&gt;   DW_AT_decl_line   : 10
    &lt;c9&gt;   DW_AT_type        : &lt;0x4f&gt;  
    &lt;cd&gt;   DW_AT_location    : 2 byte block: 74 1c    (DW_OP_breg4 (esp): 28)
 &lt;2&gt;&lt;d0&gt;: Abbrev Number: 7 (DW_TAG_variable)
    &lt;d1&gt;   DW_AT_name        : b
    &lt;d3&gt;   DW_AT_decl_file   : 1
    &lt;d4&gt;   DW_AT_decl_line   : 10
    &lt;d5&gt;   DW_AT_type        : &lt;0x4f&gt;  
    &lt;d9&gt;   DW_AT_location    : 2 byte block: 74 18    (DW_OP_breg4 (esp): 24)
 &lt;2&gt;&lt;dc&gt;: Abbrev Number: 8 (DW_TAG_variable)
    &lt;dd&gt;           : (indirect string, offset: 0x6a): result
    &lt;e1&gt;   DW_AT_decl_file   : 1
    &lt;e2&gt;   DW_AT_decl_line   : 11
    &lt;e3&gt;   DW_AT_type        : &lt;0x4f&gt;  
    &lt;e7&gt;   DW_AT_location    : 2 byte block: 74 10    (DW_OP_breg4 (esp): 16)
 &lt;2&gt;&lt;ea&gt;: Abbrev Number: 7 (DW_TAG_variable)
    &lt;eb&gt;   DW_AT_name        : fp
    &lt;ee&gt;   DW_AT_decl_file   : 1
    &lt;ef&gt;   DW_AT_decl_line   : 12
    &lt;f0&gt;   DW_AT_type        : &lt;0x10d&gt;
    &lt;f4&gt;   DW_AT_location    : 2 byte block: 74 14    (DW_OP_breg4 (esp): 20)
</code>
Note the first number inside the angle brackets in each entry. This is the nesting level – in this example entries with <2> are children of the entry with <1>. main function has three integer variables a,b and result each of these variables are described with DW_TAG_variable nested DIE’s (0xc4, 0xd0, 0xdc). main function also has a function pointer  fp described  in DIE 0xea . Variable DIE attributes specify variable name (DW_AT_name), declaration line no in source function (DW_AT_decl_line ), pointer to address of DIE describing variables data type (DW_AT_type) and relative location of the variable within function’s frame (DW_AT_location).</p>

<p>To locate the variable in the memory image of the executing process, the debugger will look at the DW_AT_location attribute of DIE. For a its value is    DW_OP_fbreg4 (esp):28. This means that the variable is stored at offset 28  from the top in the frame of  containing function. The DW_AT_frame_base attribute of main has the value 0×38(location list), which means that this value actually has to be looked up in the location list section. Let’s look at it:
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>root@techveda:~# objdump &ndash;dwarf=loc sample&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;sample:     file format elf32-i386&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Contents of the .debug_loc section:&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;Offset   Begin    End      Expression
</span><span class='line'>00000000 080483c4 080483c5 (DW_OP_breg4 (esp): 4)
</span><span class='line'>00000000 080483c5 080483c7 (DW_OP_breg4 (esp): 8)
</span><span class='line'>00000000 080483c7 080483d1 (DW_OP_breg5 (ebp): 8)
</span><span class='line'>00000000 080483d1 080483d2 (DW_OP_breg4 (esp): 4)
</span><span class='line'>00000000 &lt;End of list&gt;
</span><span class='line'>00000038 080483d2 080483d3 (DW_OP_breg4 (esp): 4)
</span><span class='line'>00000038 080483d3 080483d5 (DW_OP_breg4 (esp): 8)
</span><span class='line'>00000038 080483d5 08048422 (DW_OP_breg5 (ebp): 8)
</span><span class='line'>00000038 08048422 08048423 (DW_OP_breg4 (esp): 4)
</span><span class='line'>00000038 &lt;End of list&gt;
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;Offset column 0×38 values are the entries for main function variables. Each entry here describes possible frame base address with respect to where debugger may be paused by break point within function instructions; it specifies the current frame base from which offsets to variables are to be computed as an offset from a register. For x86, bpreg4 refers to esp and bpreg5 refers to ebp.  Before analyzing further lets look at disassemble dump for main function
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;080483d2 &lt;main&gt;:
</span><span class='line'> 80483d2:   55                      push   %ebp
</span><span class='line'> 80483d3:   89 e5                   mov    %esp,%ebp
</span><span class='line'> 80483d5:   83 e4 f0                and    $0xfffffff0,%esp
</span><span class='line'> 80483d8:   83 ec 20                sub    $0x20,%esp
</span><span class='line'> 80483db:   c7 44 24 1c 0a 00 00    movl   $0xa,0x1c(%esp)
</span><span class='line'> 80483e2:   00
</span><span class='line'> 80483e3:   c7 44 24 18 14 00 00    movl   $0x14,0x18(%esp)
</span><span class='line'> 80483ea:   00
</span><span class='line'> 80483eb:   c7 44 24 14 c4 83 04    movl   $0x80483c4,0x14(%esp)
</span><span class='line'> 80483f2:   08
</span><span class='line'> 80483f3:   8b 44 24 18             mov    0x18(%esp),%eax
</span><span class='line'> 80483f7:   89 44 24 04             mov    %eax,0x4(%esp)
</span><span class='line'> 80483fb:   8b 44 24 1c             mov    0x1c(%esp),%eax
</span><span class='line'> 80483ff:   89 04 24                mov    %eax,(%esp)
</span><span class='line'> 8048402:   8b 44 24 14             mov    0x14(%esp),%eax
</span><span class='line'> 8048406:   ff d0                               call   *%eax
</span><span class='line'> 8048408:   89 44 24 10             mov    %eax,0x10(%esp)
</span><span class='line'> 804840c:   b8 f0 84 04 08          mov    $0x80484f0,%eax
</span><span class='line'> 8048411:   8b 54 24 10             mov    0x10(%esp),%edx
</span><span class='line'> 8048415:   89 54 24 04             mov    %edx,0x4(%esp)
</span><span class='line'> 8048419:   89 04 24                mov    %eax,(%esp)
</span><span class='line'> 804841c:   e8 d3 fe ff ff          call   80482f4 &lt;printf@plt&gt;
</span><span class='line'> 8048421:   c9                      leave
</span><span class='line'> 8048422:   c3                      ret</span></code></pre></td></tr></table></div></figure></p>

<p>First two instructions deal with function’s preamble, function’s stack frame base pointer is determined after pre-amble instructions are executed.  Ebp remains constant throughout function’s execution and esp keeps changing with data being pushed and popped from the stack frame. From the above dump instructions at offset 80483db and 80483e3 are assigning values 10 and 20 to variables a, and b. These variables are being accessed their offset in stack frame relative to location of current esp( variable a: 0x1c(%esp), variable b: 0×18(%esp)). Now let’s assume that break point was set after initializing a and b variables and program paused, and we have run print command to view conents of a or b variables. Debugger would access 3rd record of the main function’s dwarf debug.loc table since our break point falls between 080483d5 – 08048422 region of the function code.
<code>
00000038 080483d2 080483d3 (DW_OP_breg4 (esp): 4)
00000038 080483d3 080483d5 (DW_OP_breg4 (esp): 8)
00000038 080483d5 08048422 (DW_OP_breg5 (ebp): 8)--- 3rd record
00000038 08048422 08048423 (DW_OP_breg4 (esp): 4)
</code>
Now as per records debugger will locate a with esp + 28 , b with esp +24 and so on…</p>

<p>Looking up line number information</p>

<p>We can set breakpoints mentioning line no’s Lets now look at how debuggers resolve line no’s to machine instruction’s? DWARF encodes a full mapping between lines in the C source code and machine code addresses in the executable. This information is contained in the .debug_line section and can be extracted using objdump
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>root@techveda:~# objdump &ndash;dwarf=decodedline ./sample&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;./sample:     file format elf32-i386&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Decoded dump of debug contents of section .debug_line:&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;CU: sample.c:
</span><span class='line'>File name                            Line number    Starting address                 &lt;br/&gt;
</span><span class='line'>sample.c                                       5          0x80483c4
</span><span class='line'>sample.c                                       6          0x80483c7
</span><span class='line'>sample.c                                       7          0x80483d0
</span><span class='line'>sample.c                                       9          0x80483d2
</span><span class='line'>sample.c                                      10          0x80483db
</span><span class='line'>sample.c                                      14          0x80483eb
</span><span class='line'>sample.c                                      15          0x80483f3
</span><span class='line'>sample.c                                      16          0x804840c
</span><span class='line'>sample.c                                      17          0x8048421
</span><span class='line'>&lt;code&gt;
</span><span class='line'>This dump shows machine instruction line no’s for our program. It is quite obvious that line no’s for non-executable statements of the source file need not be tracked by dwarf .we can map the above dump to our source code for analysis.
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>1 #include &lt;stdio.h&gt;
</span><span class='line'> 2 #include &lt;stdlib.h&gt;
</span><span class='line'> 3
</span><span class='line'> 4 int add(int x, int y)
</span><span class='line'> 5 {
</span><span class='line'> 6         return x + y;
</span><span class='line'> 7 }
</span><span class='line'> 8 int main()
</span><span class='line'> 9 {
</span><span class='line'>10         int a = 10, b = 20;
</span><span class='line'>11         int result;
</span><span class='line'>12         int (&lt;em&gt;fp) (int, int);
</span><span class='line'>13
</span><span class='line'>14         fp = add;
</span><span class='line'>15         result = (&lt;/em&gt;fp) (a, b);
</span><span class='line'>16         printf(&ldquo; %dn&rdquo;, result);
</span><span class='line'>17 }</span></code></pre></td></tr></table></div></figure>
From the above it should be clear of what debugger does it is instructed to set breakpoint at entry into function add, it would insert break point at line no 6 and pause after pre-amble of function add is executed.</p>

<p>What’s next?</p>

<p>if you are into implementation of debugging tools or involved in writing programs/tools  that simulate debugger facilities/ read binary files , you may be interested in specific programming libraries libbfd or libdwarf.</p>

<p>Binary File Descriptor library (BFD) or libbfd as it is called provides ready to use functions to read into ELF and other popular binary files. BFD works by presenting a common abstract view of object files. An object file has a “header” with descriptive info; a variable number of “sections” that each has a name, some attributes, and a block of data; a symbol table; relocation entries; and so forth. Gnu binutils package tools like objdump, readelf and others have been written using these libraries.</p>

<p>Libdwarf is a C library intended to simplify reading (and writing) applications built with DWARF2, DWARF3 debug information.</p>

<p>Dwarfdump is an application written using libdwarf to print dwarf information in a human readable format. It is also open sourced and is copyrighted GPL. It provides an example of using libdwarf to read DWARF2/3 information as well as providing readable text output.</p>

<p>References</p>

<p><a href="http://www.dwarfstd.org/">Dwarf Standard</a><br/>
<a href="http://wiki.dwarfstd.org/index.php?title=Libdwarf_And_Dwarfdump">Libdwarf Wiki</a><br/>
<a href="http://www.skyfree.org/linux/references/bfd.pdf">Libbfd draft</a></p>
]]></content>
  </entry>
  
</feed>
