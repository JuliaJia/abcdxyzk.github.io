<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: debug~base | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/debug~base/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2014-12-07T17:07:47+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Universal Build-ID]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/09/12/compiler-build-id/"/>
    <updated>2014-09-12T18:08:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/09/12/compiler-build-id</id>
    <content type="html"><![CDATA[<p><a href="http://fedoraproject.org/wiki/Summer_Coding_2010_ideas_-_Universal_Build-ID">http://fedoraproject.org/wiki/Summer_Coding_2010_ideas_-_Universal_Build-ID</a></p>

<h4>Summary</h4>

<p>  Build-IDs are currently being put into binaries, shared libraries, core files and related debuginfo files to uniquely identify the build a user or developer is working with. There are a couple of conventions in place to use this information to identify &ldquo;currently running&rdquo; or &ldquo;distro installed&rdquo; builds. This helps with identifying what was being run and match it to the corresponding package, sources and debuginfo for tools that want to help the user show what is going on (at the moment mostly when things break). We would like to extend this to a more universial approach, that helps people identify historical, local, non- or cross-distro or organisational builds. So that Build-IDs become useful outside the current &ldquo;static&rdquo; setup and retain information over time and across upgrades.</p>

<h3>Build-ID background</h3>

<p>  Build-IDs are unique identifiers of &ldquo;builds&rdquo;. A build is an executable, a shared library, the kernel, a module, etc. You can also find the build-id in a running process, a core file or a separate debuginfo file.</p>

<p>  The main idea behind Build-IDs is to make elf files &ldquo;self-identifying&rdquo;. This means that when you have a Build-ID it should uniquely identify a final executable or shared library. The default Build-ID calculation (done through ld &ndash;build-id, see the ld manual) calculates a sha1 hash (160 bits/20 bytes) based on all the ELF header bits and section contents in the file. Which means that it is unique among the set of meaningful contents for ELF files and identical when the output file would otherwise have been identical. GCC now passes &ndash;build-id to the linker by default.</p>

<p>  When an executable or shared library is loaded into memory the Build-ID will also be loaded into memory, a core dump of a process will also have the Build-IDs of the executable and the shared libraries embedded. And when separating debuginfo from the main executable or shared library into .debug files the original Build-ID will also be copied over. This means it is easy to match a core file or a running process to the original executable and shared library builds. And that matching those against the debuginfo files that provide more information for introspection and debugging should be trivial.</p>

<p>  Fedora has had full support for build-ids since Fedora Core 8: <a href="https://fedoraproject.org/wiki/Releases/FeatureBuildId">https://fedoraproject.org/wiki/Releases/FeatureBuildId</a></p>

<h4>Getting Build-IDs</h4>

<p>  A simple way to get the build-id(s) is through eu-unstrip (part of elfutils).</p>

<p>build-id from an executable, shared library or separate debuginfo file:<br/>
$ eu-unstrip -n -e &lt;exec|.sharedlib|.debug></p>

<p>build-ids of an executable and all shared libraries from a core file:<br/>
$ eu-unstrip -n &ndash;core <corefile></p>

<p>build-ids of an executable and all shared libraries of a running process:<br/>
$ eu-unstrip -n &ndash;pid <pid></p>

<p>build-id of the running kernel and all loaded modules:<br/>
$ eu-unstrip -n -k</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Oops打印Tainted信息]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/07/16/debug-oops/"/>
    <updated>2014-07-16T15:58:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/07/16/debug-oops</id>
    <content type="html"><![CDATA[<p>检查一下上面的Oops，看看Linux内核还有没有给我们留下其他的有用信息。
<code>
Oops: 0002 [#1]
</code>
* 这里面，0002表示Oops的错误代码（写错误，发生在内核空间），#1表示这个错误发生一次。</p>

<p>Oops的错误代码根据错误的原因会有不同的定义，本文中的例子可以参考下面的定义（如果发现自己遇到的Oops和下面无法对应的话，最好去内核代码里查找）：
<code>
 * error_code:
 *      bit 0 == 0 means no page found, 1 means protection fault
 *      bit 1 == 0 means read, 1 means write
 *      bit 2 == 0 means kernel, 1 means user-mode
 *      bit 3 == 0 means data, 1 means instruction
</code>
有时候，Oops还会打印出Tainted信息。这个信息用来指出内核是因何种原因被tainted（直译为“玷污”）。具体的定义如下：
<code>
  1: 'G' if all modules loaded have a GPL or compatible license, 'P' if any proprietary module has been loaded.  Modules without a MODULE_LICENSE or with a MODULE_LICENSE that is not recognised by insmod as GPL compatible are assumed to be proprietary.
  2: 'F' if any module was force loaded by "insmod -f", ' ' if all modules were loaded normally.
  3: 'S' if the oops occurred on an SMP kernel running on hardware that hasn't been certified as safe to run multiprocessor. Currently this occurs only on various Athlons that are not SMP capable.
  4: 'R' if a module was force unloaded by "rmmod -f", ' ' if all modules were unloaded normally.
  5: 'M' if any processor has reported a Machine Check Exception, ' ' if no Machine Check Exceptions have occurred.
  6: 'B' if a page-release function has found a bad page reference or some unexpected page flags.
  7: 'U' if a user or user application specifically requested that the Tainted flag be set, ' ' otherwise.
  8: 'D' if the kernel has died recently, i.e. there was an OOPS or BUG.
  9: 'A' if the ACPI table has been overridden.
 10: 'W' if a warning has previously been issued by the kernel. (Though some warnings may set more specific taint flags.)
 11: 'C' if a staging driver has been loaded.
 12: 'I' if the kernel is working around a severe bug in the platform firmware (BIOS or similar).
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[the meaning of '?' in Linux kernel panic call trace]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/06/12/debug-dumpstack-mean/"/>
    <updated>2014-06-12T09:42:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/06/12/debug-dumpstack-mean</id>
    <content type="html"><![CDATA[<ul>
<li>&lsquo;?&rsquo; means that the information about this stack entry is probably not reliable.</li>
</ul>


<p>The stack output mechanism (see the implementation of dump_trace() function) was unable to prove that the address it has found is a valid return address in the call stack.</p>

<p>&lsquo;?&rsquo; itself is output by printk_stack_address().</p>

<p>The stack entry may be valid or not. Sometimes one may simply skip it. It may be helpful to investigate the disassembly of the involved module to see which function is called at ClearFunctionName+0x88 (or, on x86, immediately before that position).</p>

<p>Concerning reliability</p>

<p>On x86, when dump_stack() is called, the function that actually examines the stack is print_context_stack() defined in arch/x86/kernel/dumpstack.c. Take a look at its code, I&rsquo;ll try to explain it below.</p>

<p>I assume DWARF2 stack unwind facilities are not available in your Linux system (most likely, they are not, if it is not OpenSUSE or SLES). In this case, print_context_stack() seems to do the following.</p>

<p>It starts from an address (&lsquo;stack&rsquo; variable in the code) that is guaranteed to be an address of a stack location. It is actually the address of a local variable in dump_stack().</p>

<p>The function repeatedly increments that address (while (valid_stack_ptr &hellip;) { &hellip; stack++}) and checks if what it points to could also be an address in the kernel code (if (__kernel_text_address(addr)) &hellip;). This way it attempts to find the functions' return addresses pushed on stack when these functions were called.</p>

<p>Of course, not every unsigned long value that looks like a return address is actually a return address. So the function tries to check it. If frame pointers are used in the code of the kernel (%ebp/%rbp registers are employed for that if CONFIG_FRAME_POINTER is set), they can be used to traverse the stack frames of the functions. The return address for a function lies just above the frame pointer (i.e. at %ebp/%rbp + sizeof(unsigned long)). print_context_stack checks exactly that.</p>

<p>If there is a stack frame for which the value &lsquo;stack&rsquo; points to is the return address, the value is considered a reliable stack entry. ops->address will be called for it with reliable == 1, it will eventually call printk_stack_address() and the value will be output as a reliable call stack entry. Otherwise the address will be considered unreliable. It will be output anyway but with &lsquo;?&rsquo; prepended.</p>

<p>[NB] If frame pointer information is not available (e.g. like it was in Debian 6 by default), all call stack entries will be marked as unreliable for this reason.</p>

<p>The systems with DWARF2 unwinding support (and with CONFIG_STACK_UNWIND set) is a whole another story.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Connecting Two Virtual Machines]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/02/28/debug-2vm-connect/"/>
    <updated>2014-02-28T17:50:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/02/28/debug-2vm-connect</id>
    <content type="html"><![CDATA[<p>  You can set up the virtual serial ports in two virtual machines to connect to each other. This is useful, for example, if you want to use an application in one virtual machine to capture debugging information sent from the other virtual machine&rsquo;s serial port.</p>

<p>  To install a direct serial connection between two virtual machines (a server and a client), take the following steps:</p>

<h4>Windows Host In the server virtual machine</h4>

<ol>
<li>Open the virtual machine settings editor (VM > Settings).</li>
<li>Click Add to start the Add Hardware Wizard.</li>
<li>Select Serial Port, then click Next.</li>
<li>Select Output to named pipe, then click Next.</li>
<li>Use the default pipe name, or enter another pipe name of your choice. The pipe name must follow the form \.\pipe\<namedpipe> — that is, it must begin with \.\pipe.</li>
<li>Select This end is the server.</li>
<li>Select The other end is a virtual machine.</li>
<li>By default, the device status setting is Connect at power on. You may deselect this setting if you wish.
Click Advanced if you want to configure this serial port to use polled mode. This option is of interest primarily to developers who are using debugging tools that communicate over a serial connection. For more information, see <a href="https://www.vmware.com/support/ws55/doc/ws_devices_serial_advanced.html">Special Configuration Options for Advanced Users.</a></li>
<li>Click Finish, then click OK to close the virtual machine settings editor.</li>
</ol>


<h4>In the client virtual machine</h4>

<ol>
<li>Open the virtual machine settings editor (VM > Settings).</li>
<li>Click Add to start the Add Hardware Wizard.</li>
<li>Select Serial Port, then click Next.</li>
<li>Select Use named pipe.</li>
<li>Use the default name, or enter another pipe name of your choice. The pipe name must follow the form \.\pipe\<namedpipe> — that is, it must begin with \.\pipe. The pipe name must be the same on both server and client.</li>
<li>Select This end is the client.</li>
<li>Select The other end is a virtual machine.</li>
<li>By default, the device status setting is Connect at power on. You may deselect this setting if you wish.
Click Advanced if you want to configure this serial port to use polled mode. This option is of interest primarily to developers who are using debugging tools that communicate over a serial connection. For more information, see <a href="https://www.vmware.com/support/ws55/doc/ws_devices_serial_advanced.html">Special Configuration Options for Advanced Users.</a></li>
<li>Click Finish, then click OK to close the virtual machine settings editor.</li>
</ol>


<h4>Linux Host In the server virtual machine</h4>

<ol>
<li>Open the virtual machine settings editor (VM > Settings).</li>
<li>Click Add to start the Add Hardware Wizard.</li>
<li>Select Serial Port, then click Next.</li>
<li>Select Output to named pipe, then click Next.</li>
<li>In the Path field, enter /tmp/<socket> or another Unix socket name of your choice.</li>
<li>Select This end is the server.</li>
<li>Select The other end is a virtual machine.</li>
<li>By default, the device status setting is Connect at power on. You may deselect this setting if you wish.
Click Advanced if you want to configure this serial port to use polled mode. This option is of interest primarily to developers who are using debugging tools that communicate over a serial connection. For more information, see <a href="https://www.vmware.com/support/ws55/doc/ws_devices_serial_advanced.html">Special Configuration Options for Advanced Users.</a></li>
<li>Click Finish, then click OK to save your configuration and close the virtual machine settings editor.</li>
</ol>


<h4>In the client virtual machine</h4>

<ol>
<li>Open the virtual machine settings editor (VM > Settings).</li>
<li>Click Add to start the Add Hardware Wizard.</li>
<li>Select Serial Port, then click Next.</li>
<li>Select Output to named pipe, then click Next.</li>
<li>In the Path field, enter /tmp/<socket> or another Unix socket name of your choice. The pipe name must be the same on both server and client.</li>
<li>Select This end is the client.</li>
<li>Select The other end is a virtual machine.</li>
<li>By default, the device status setting is Connect at power on. You may deselect this setting if you wish.
Click Advanced if you want to configure this serial port to use polled mode. This option is of interest primarily to developers who are using debugging tools that communicate over a serial connection. For more information, see <a href="https://www.vmware.com/support/ws55/doc/ws_devices_serial_advanced.html">Special Configuration Options for Advanced Users.</a></li>
<li>Click Finish, then click OK to save your configuration and close the virtual machine settings editor.</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[vmware 串口调试]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/02/28/debug-vm-ttys/"/>
    <updated>2014-02-28T17:48:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/02/28/debug-vm-ttys</id>
    <content type="html"><![CDATA[<p>  在系统内核开发中，经常会用到串口调试，利用VMware的Virtual Machine更是为调试系统内核如虎添翼。那么怎么搭建串口调试环境呢？</p>

<p>Virtual Machine 主要有三种串口调试技术，可以在serial port的配置界面找到：</p>

<ol>
<li>Use physical serial port      即使用物理机串口，当用串口线盒另一台电脑连接时，就用这种方式</li>
<li>Use output file                   即把串口数据输出到宿主机某文件中，当只需要看输出结果的时候可以用这种方式，简单方便</li>
<li>Use named pipe                把串口输出到命名管道，命名管道可读可写，也就可以交互，进行一些debug工作，而不是简单的看结果</li>
</ol>


<p>  因为前两种相对简单易用就不具体介绍了，这里主要说第三种用命名管道调试方法。命名管道，在Linux中是进程间通信(IPC)的一种方式，两个进 程可以通过读写管道来交换数据。这里就是运用了这种技术，通过把串口绑定一个有名管道，对有名管道的读写交换串口数据。也有两种方式：1. 宿主机与虚拟机之间， 2. 在同一宿主机上，两虚拟机间通过绑定同一个宿主机上的有名管道。问题的关键在于如何把虚拟机串口绑定到宿主机的某一有名管道，而第一种方式则需要找到一种 方式使得主机如何读写有名管道来交互，经过一阵Google终于找到分别在Linux和Windows分别试验成功的工具。</p>

<p>  在Windows中有名管道式通过路径//./pipe/namedpipe来创建的，当然你可以指定到其他机子如//192.168.1.10 /pipe/namedpipe，而在Linux中，/tmp/mypipe就可以了。创建好有名管道后，就是如何和管道交互了。目前，无论是 Windows还是Linux，似乎都没有一款工具可以直接读写有名管道的，而我找到的两个工具都是通过把有名管道和Socket绑定，通过读写 Socket来间接读写管道。</p>

<h4>下面我就简要介绍一下在Windows和Linux下如何配置：</h4>

<h5>Linux Host:</h5>

<h6>Host  ~  Virtual Machine</h6>

<pre><code>1. configure VM
a. add hardware -&gt; Serial port
b. using named pipe
c. /tmp/isocket
d. this end is server &amp; far end is application
e. check Yield CPU on poll
f. start Virtual Machine

2. socat /tmp/isocket tcp4-listen:9001 &amp;
/tmp/socket: VMware call it 'named piped', actually it is Unix Daemon Socket, so you shouldn't use pipe:/tmp/socket
3. telnet 127.0.0.1 9001
</code></pre>

<p>Trouble Shoot: 有时候会遇到错误Connection closed by foreign host，或者telnet一开，socat就能退出，很可能是你没power on虚拟机，有名管道还没创建，你就socat，这样也会创建一个名为isocket的文件但只是普通文件。具体的细节请看socat help<br/>
start Virtual Machine first, than run the socat, and telnet<br/>
(Note you must have permission to all resource, /tmp/socket, VM and so on)</p>

<h6>Vritual Machine ~ Virtual Machine</h6>

<pre><code>1. configure VM
a. add hardware --&gt;　serial port
b. Using named pipe, configure /tmp/isocket 
c.  this end is server &amp; far end is Virtual Machine
d. check Yield CPU on poll
e. start VM

2. Another VM
a. add hardware  --&gt;  Serial Port
b. Using named pipe, configure /tmp/isocket 
c.  this end is client &amp; far end is Virtual Machine 
d. check Yield CPU on poll
e. start VMs
</code></pre>

<h5>Windows Host:</h5>

<h6>Host ~ Virtual Machine</h6>

<pre><code>1. configure VM
a. add hardware --&gt; serial port
b. using named pipe
c. //./pipe/vmwaredebug
d. this end is client &amp; far end is application
e. check Yield CPU on poll

2. using 3rd-party tool to communicate with named pipe
a. down the tool 
b. install service
cmd&gt;vmwaregateway.exe /r
c. start service
c:/&gt; net start vmwaregateway
d. telnet 127.0.0.1 567
3. start Virtual Machine
</code></pre>

<p>如果你使用的是vmwaregateway.exe这个小工具，这里的管道名就必须是vmwaredebug，除非你把它的源代码download下来自己改改。</p>

<h6>Vritual Machine ~ Virtual Machine</h6>

<pre><code>1. configure VM
a. add hardware --&gt;　serial port
b. Using named pipe, //./pipe/vmwaredebug
c.  this end is server &amp; far end is Virtual Machine
d. check Yield CPU on poll
e. start VM

2. Another VM
a. add hardware  --&gt;  Serial Port
b. Using named pipe, //./pipe/vmwaredebug
c.  this end is client &amp; far end is Virtual Machine 
d. check Yield CPU on poll
e. start VMs
</code></pre>
]]></content>
  </entry>
  
</feed>
