<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: kernel~irq | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/kernel~irq/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2015-04-01T18:29:16+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[linux软中断机制分析]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/01/23/kernel-irq-mark3/"/>
    <updated>2015-01-23T14:29:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/01/23/kernel-irq-mark3</id>
    <content type="html"><![CDATA[<h3>软中断分析</h3>

<h4>1. 为什么要软中断</h4>

<p>编写驱动的时候，一个中断产生之后，内核在中断处理函数中可能需要完成很多工作。但是中断处理函数的处理是关闭了中断的。也就是说在响应中断时，系统不能再次响应外部的其它中断。这样的后果会造成有可能丢失外部中断。于是，linux内核设计出了一种架构，中断函数需要处理的任务分为两部分，一部分在中断处理函数中执行，这时系统关闭中断。另外一部分在软件中断中执行，这个时候开启中断，系统可以响应外部中断。</p>

<p>关于软件中断的理论各种书籍都有介绍，不多叙述。而要真正体会软件中断的作用就必须从代码的角度来分析。我们做工作时候讲求的是professional，当一个人在某个领域一无所知的时候，我们称他为小白，偶，非苹果电脑。小白的脑子里充满了各种问题。慢慢的当这些疑惑解释完之后，小白就脱白了。此时，我们对这个领域的基本框架有了解，但这和professional还有一定的差距。再加以时日，逐渐融会贯通该领域才能达到专业的境界。</p>

<h4>2. 什么时候触发处理软件中断</h4>

<p>说了这么多废话，赶快步入正题。初识软中断，脑子里肯定有不少的疑问，首先就是软件中断在什么地方被触发处理？这个问题的答案就是：一个硬件中断处理完成之后。下面的函数在处理完硬件中断之后推出中断处理函数，在irq_exit中会触发软件中断的处理。
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
<span class='line-number'>206</span>
<span class='line-number'>207</span>
<span class='line-number'>208</span>
<span class='line-number'>209</span>
<span class='line-number'>210</span>
<span class='line-number'>211</span>
<span class='line-number'>212</span>
<span class='line-number'>213</span>
<span class='line-number'>214</span>
<span class='line-number'>215</span>
<span class='line-number'>216</span>
<span class='line-number'>217</span>
<span class='line-number'>218</span>
<span class='line-number'>219</span>
<span class='line-number'>220</span>
<span class='line-number'>221</span>
<span class='line-number'>222</span>
<span class='line-number'>223</span>
<span class='line-number'>224</span>
<span class='line-number'>225</span>
<span class='line-number'>226</span>
<span class='line-number'>227</span>
<span class='line-number'>228</span>
<span class='line-number'>229</span>
<span class='line-number'>230</span>
<span class='line-number'>231</span>
<span class='line-number'>232</span>
<span class='line-number'>233</span>
<span class='line-number'>234</span>
<span class='line-number'>235</span>
<span class='line-number'>236</span>
<span class='line-number'>237</span>
<span class='line-number'>238</span>
<span class='line-number'>239</span>
<span class='line-number'>240</span>
<span class='line-number'>241</span>
<span class='line-number'>242</span>
<span class='line-number'>243</span>
<span class='line-number'>244</span>
<span class='line-number'>245</span>
<span class='line-number'>246</span>
<span class='line-number'>247</span>
<span class='line-number'>248</span>
<span class='line-number'>249</span>
<span class='line-number'>250</span>
<span class='line-number'>251</span>
<span class='line-number'>252</span>
<span class='line-number'>253</span>
<span class='line-number'>254</span>
<span class='line-number'>255</span>
<span class='line-number'>256</span>
<span class='line-number'>257</span>
<span class='line-number'>258</span>
<span class='line-number'>259</span>
<span class='line-number'>260</span>
<span class='line-number'>261</span>
<span class='line-number'>262</span>
<span class='line-number'>263</span>
<span class='line-number'>264</span>
<span class='line-number'>265</span>
<span class='line-number'>266</span>
<span class='line-number'>267</span>
<span class='line-number'>268</span>
<span class='line-number'>269</span>
<span class='line-number'>270</span>
<span class='line-number'>271</span>
<span class='line-number'>272</span>
<span class='line-number'>273</span>
<span class='line-number'>274</span>
<span class='line-number'>275</span>
<span class='line-number'>276</span>
<span class='line-number'>277</span>
<span class='line-number'>278</span>
<span class='line-number'>279</span>
<span class='line-number'>280</span>
<span class='line-number'>281</span>
<span class='line-number'>282</span>
<span class='line-number'>283</span>
<span class='line-number'>284</span>
<span class='line-number'>285</span>
<span class='line-number'>286</span>
<span class='line-number'>287</span>
<span class='line-number'>288</span>
<span class='line-number'>289</span>
<span class='line-number'>290</span>
<span class='line-number'>291</span>
<span class='line-number'>292</span>
<span class='line-number'>293</span>
<span class='line-number'>294</span>
<span class='line-number'>295</span>
<span class='line-number'>296</span>
<span class='line-number'>297</span>
<span class='line-number'>298</span>
<span class='line-number'>299</span>
<span class='line-number'>300</span>
<span class='line-number'>301</span>
<span class='line-number'>302</span>
<span class='line-number'>303</span>
<span class='line-number'>304</span>
<span class='line-number'>305</span>
<span class='line-number'>306</span>
<span class='line-number'>307</span>
<span class='line-number'>308</span>
<span class='line-number'>309</span>
<span class='line-number'>310</span>
<span class='line-number'>311</span>
<span class='line-number'>312</span>
<span class='line-number'>313</span>
<span class='line-number'>314</span>
<span class='line-number'>315</span>
<span class='line-number'>316</span>
<span class='line-number'>317</span>
<span class='line-number'>318</span>
<span class='line-number'>319</span>
<span class='line-number'>320</span>
<span class='line-number'>321</span>
<span class='line-number'>322</span>
<span class='line-number'>323</span>
<span class='line-number'>324</span>
<span class='line-number'>325</span>
<span class='line-number'>326</span>
<span class='line-number'>327</span>
<span class='line-number'>328</span>
<span class='line-number'>329</span>
<span class='line-number'>330</span>
<span class='line-number'>331</span>
<span class='line-number'>332</span>
<span class='line-number'>333</span>
<span class='line-number'>334</span>
<span class='line-number'>335</span>
<span class='line-number'>336</span>
<span class='line-number'>337</span>
<span class='line-number'>338</span>
<span class='line-number'>339</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>asmlinkage void __exception asm_do_IRQ(unsigned int irq, struct pt_regs &lt;em&gt;regs)
</span><span class='line'>{
</span><span class='line'>    struct pt_regs &lt;/em&gt;old_regs = set_irq_regs(regs);&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    irq_enter();
</span><span class='line'>
</span><span class='line'>/*
</span><span class='line'> * Some hardware gives randomly wrong interrupts.  Rather
</span><span class='line'> * than crashing, do something sensible.
</span><span class='line'> */ 
</span><span class='line'>if (irq &gt;= NR_IRQS)
</span><span class='line'>    handle_bad_irq(irq, &amp;bad_irq_desc);
</span><span class='line'>else 
</span><span class='line'>    generic_handle_irq(irq);
</span><span class='line'>
</span><span class='line'>/* AT91 specific workaround */ 
</span><span class='line'>irq_finish(irq);
</span><span class='line'>
</span><span class='line'>irq_exit();
</span><span class='line'>set_irq_regs(old_regs);
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;这里要注意，invoke_softirq必须满足两个条件才能被调用到，一个就是不是在硬件中断处理过程中或者在软件中断处理中，第二个就是必须有软件中断处于pending状态。第二个好理解，有软件中断产生才去处理，没有就不处理。第一个就不好理解了。
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;/*
</span><span class='line'>* Exit an interrupt context. Process softirqs if needed and possible:
</span><span class='line'>*/ 
</span><span class='line'>void irq_exit(void)
</span><span class='line'>{
</span><span class='line'>account_system_vtime(current);
</span><span class='line'>trace_hardirq_exit();
</span><span class='line'>sub_preempt_count(IRQ_EXIT_OFFSET);
</span><span class='line'>if (!in_interrupt() &amp;&amp; local_softirq_pending())
</span><span class='line'>    invoke_softirq();
</span><span class='line'>
</span><span class='line'>#ifdef CONFIG_NO_HZ
</span><span class='line'>/* Make sure that timer wheel updates are propagated */ 
</span><span class='line'>rcu_irq_exit();
</span><span class='line'>if (idle_cpu(smp_processor_id()) &amp;&amp; !in_interrupt() &amp;&amp; !need_resched())
</span><span class='line'>    tick_nohz_stop_sched_tick(0);
</span><span class='line'>#endif 
</span><span class='line'>preempt_enable_no_resched();
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;在linux系统的进程数据结构里，有这么一个数据结构
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;#define preempt_count() (current_thread_info()-&gt;preempt_count)，
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;利用preempt_count可以表示是否处于中断处理或者软件中断处理过程中。
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;#define PREEMPT_MASK    (__IRQ_MASK(PREEMPT_BITS) &lt;&lt; PREEMPT_SHIFT)
</span><span class='line'>#define SOFTIRQ_MASK    (__IRQ_MASK(SOFTIRQ_BITS) &lt;&lt; SOFTIRQ_SHIFT)
</span><span class='line'>#define HARDIRQ_MASK    (__IRQ_MASK(HARDIRQ_BITS) &lt;&lt; HARDIRQ_SHIFT)
</span><span class='line'>
</span><span class='line'>#define PREEMPT_OFFSET    (1UL &lt;&lt; PREEMPT_SHIFT)
</span><span class='line'>#define SOFTIRQ_OFFSET    (1UL &lt;&lt; SOFTIRQ_SHIFT)
</span><span class='line'>#define HARDIRQ_OFFSET    (1UL &lt;&lt; HARDIRQ_SHIFT)
</span><span class='line'>
</span><span class='line'>sub_preempt_count(IRQ_EXIT_OFFSET);
</span><span class='line'>
</span><span class='line'>#define in_interrupt() (irq_count())
</span><span class='line'>
</span><span class='line'>#define irq_count() (preempt_count() &amp; (HARDIRQ_MASK | SOFTIRQ_MASK))
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>![](/images/kernel/2015-01-23-1.png)
</span><span class='line'>
</span><span class='line'>preempt_count的8～23位记录中断处理和软件中断处理过程的计数。如果有计数，表示系统在硬件中断或者软件中断处理过程中。系统这么设计是为了避免软件中断在中断嵌套中被调用，并且达到在单个CPU上软件中断不能被重入的目的。对于ARM架构的CPU不存在中断嵌套中调用软件中断的问题，因为ARM架构的CPU在处理硬件中断的过程中是关闭掉中断的。只有在进入了软中断处理过程中之后才会开启硬件中断，如果在软件中断处理过程中有硬件中断嵌套，也不会再次调用软中断，because硬件中断是软件中断处理过程中再次进入的，此时preempt_count已经记录了软件中断！对于其它架构的CPU，有可能在触发调用软件中断前，也就是还在处理硬件中断的时候，就已经开启了硬件中断，可能会发生中断嵌套，在中断嵌套中是不允许调用软件中断处理的。Why？我的理解是，在发生中断嵌套的时候，表明这个时候是系统突发繁忙的时候，内核第一要务就是赶紧把中断中的事情处理完成，退出中断嵌套。避免多次嵌套，哪里有时间处理软件中断，所以把软件中断推迟到了所有中断处理完成的时候才能触发软件中断。
</span><span class='line'>
</span><span class='line'>#### 3. 软件中断的处理过程
</span><span class='line'>
</span><span class='line'>之前我已经说到，软中断的一个很大的目的就是避免中断处理中，处理的操作过多而丢失中断。同时中断还需要考虑到一件事情就是中断处理过程过长就会影响系统响应时间。如果一个中断处理一秒钟，那你一定能感受到串口卡住的现象。从另外一方面说呢，我们又必须考虑中断处理的操作一定的优先度，毕竟是硬件触发的事务，关系到网络、块设备的效率问题。Linux内核就中断方面就必须考虑平衡这三个方面的问题。而下面我要分析的__do_softirq函数就恰似在这三者之间打太极，游刃有余，面面俱到！
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;/*
</span><span class='line'>* We restart softirq processing MAX_SOFTIRQ_RESTART times,
</span><span class='line'>* and we fall back to softirqd after that.
</span><span class='line'>*
</span><span class='line'>* This number has been established via experimentation.
</span><span class='line'>* The two things to balance is latency against fairness -
</span><span class='line'>* we want to handle softirqs as soon as possible, but they
</span><span class='line'>* should not be able to lock up the box.
</span><span class='line'>*/ 
</span><span class='line'>#define MAX_SOFTIRQ_RESTART 10 
</span><span class='line'>
</span><span class='line'>asmlinkage void __do_softirq(void)
</span><span class='line'>{
</span><span class='line'>struct softirq_action *h;
</span><span class='line'>__u32 pending;
</span><span class='line'>int max_restart = MAX_SOFTIRQ_RESTART;
</span><span class='line'>int cpu;
</span><span class='line'>
</span><span class='line'>pending = local_softirq_pending();
</span><span class='line'>account_system_vtime(current);
</span><span class='line'>
</span><span class='line'>__local_bh_disable((unsigned long)__builtin_return_address(0));
</span><span class='line'>trace_softirq_enter();
</span><span class='line'>
</span><span class='line'>cpu = smp_processor_id();
</span><span class='line'>restart:
</span><span class='line'>/* Reset the pending bitmask before enabling irqs */ 
</span><span class='line'>set_softirq_pending(0);
</span><span class='line'>
</span><span class='line'>local_irq_enable();
</span><span class='line'>
</span><span class='line'>h = softirq_vec;
</span><span class='line'>
</span><span class='line'>do 
</span><span class='line'>{
</span><span class='line'>    if (pending &amp; 1)
</span><span class='line'>    {
</span><span class='line'>        int prev_count = preempt_count();
</span><span class='line'>
</span><span class='line'>        h-&gt;action(h);
</span><span class='line'>
</span><span class='line'>        if (unlikely(prev_count != preempt_count()))
</span><span class='line'>        {
</span><span class='line'>            printk(KERN_ERR "huh, entered softirq %td %p" 
</span><span class='line'>                   "with preempt_count %08x," 
</span><span class='line'>                   " exited with %08x?\n", h - softirq_vec,
</span><span class='line'>                   h-&gt;action, prev_count, preempt_count());
</span><span class='line'>            preempt_count() = prev_count;
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        rcu_bh_qsctr_inc(cpu);
</span><span class='line'>    }
</span><span class='line'>    h++;
</span><span class='line'>    pending &gt;&gt;= 1;
</span><span class='line'>}
</span><span class='line'>while (pending);
</span><span class='line'>
</span><span class='line'>local_irq_disable();
</span><span class='line'>
</span><span class='line'>pending = local_softirq_pending();
</span><span class='line'>if (pending &amp;&amp; --max_restart)
</span><span class='line'>    goto restart;
</span><span class='line'>
</span><span class='line'>if (pending)
</span><span class='line'>    wakeup_softirqd();
</span><span class='line'>
</span><span class='line'>trace_softirq_exit();
</span><span class='line'>
</span><span class='line'>account_system_vtime(current);
</span><span class='line'>_local_bh_enable();
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>__do_softirq函数处理软件中断过程如下图流程分析
</span><span class='line'>
</span><span class='line'>4. 首先调用local_softirq_pending函数取得目前有哪些位存在软件中断
</span><span class='line'>
</span><span class='line'>5. 调用__local_bh_disable关闭软中断，其实就是设置正在处理软件中断标记，在同一个CPU上使得不能重入__do_softirq函数
</span><span class='line'>
</span><span class='line'>6. 重新设置软中断标记为0，set_softirq_pending重新设置软中断标记为0，这样在之后重新开启中断之后硬件中断中又可以设置软件中断位。
</span><span class='line'>
</span><span class='line'>7. 开启硬件中断
</span><span class='line'>
</span><span class='line'>8. 之后在一个循环中，遍历pending标志的每一位，如果这一位设置就会调用软件中断的处理函数。在这个过程中硬件中断是开启的，随时可以打断软件中断。这样保证硬件中断不会丢失。
</span><span class='line'>
</span><span class='line'>9. 之后关闭硬件中断，查看是否又有软件中断处于pending状态，如果是，并且在本次调用__do_softirq函数过程中没有累计重复进入软件中断处理的次数超过10次，就可以重新调用软件中断处理。如果超过了10次，就调用wakeup_softirqd();唤醒内核的一个进程来处理软件中断。设立10次的限制，也是为了避免影响系统响应时间。
</span><span class='line'>
</span><span class='line'>![](/images/kernel/2015-01-23-2.png)
</span><span class='line'>
</span><span class='line'>#### 4. 处理软中断内核线程
</span><span class='line'>
</span><span class='line'>之前我说到不能让CPU长时间来处理中断事务，这样会影响系统的响应时间，严重影响用户和系统之间的交互式体验。所以在之前的__do_softirq中最多将循环执行10次，那么当执行了10次仍然有软中断在pending状态，这个时候应该怎么处理呢？系统将唤醒一个软件中断处理的内核进程，在内核进程中处理pending中的软件中断。这里要注意，之前我们分析的触发软件中断的位置其实是中断上下文中，而在软中断的内核线程中实际已经是进程的上下文。
</span><span class='line'>
</span><span class='line'>这里说的软中断上下文指的就是系统为每个CPU建立的ksoftirqd进程。
</span><span class='line'>
</span><span class='line'>看完这个函数，我不得不佩服这个函数设计的精巧！而我更多的从中体会到其中蕴藏的一种做人的道理。那就是做人要霸道一点，太谦和太恭维不行，但是又不能横行霸道，原则的问题要公平讲理，一定的时候顾及别人的利益，好处不能一个人独吞。这就跟下面ksoftirqd处理过程一样，该狠的时候禁止抢占，其它进程别想调度到哦，但是自己占用CPU时间过长的话，也自觉的问一问是不是该释放CPU给其它进程了。
</span><span class='line'>
</span><span class='line'>下面我们就来分析一下这个处理过程怎么就体现了上面的这种说法呢？软中断的内核进程中主要有两个大循环，外层的循环处理有软件中断就处理，没有软件中断就休眠。内层的循环处理软件中断，并每循环一次都试探一次是否过长时间占据了CPU，需要调度释放CPU给其它进程。具体的操作在注释中做了解释。
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static int ksoftirqd(void *__bind_cpu)
</span><span class='line'>{
</span><span class='line'>set_current_state(TASK_INTERRUPTIBLE);
</span><span class='line'>
</span><span class='line'>while (!kthread_should_stop())
</span><span class='line'>{
</span><span class='line'>    /*不管三七二十一首先禁止抢占，我掌握CPU，并全凭我自己掌握调度*/ 
</span><span class='line'>    preempt_disable();
</span><span class='line'>    if (!local_softirq_pending())
</span><span class='line'>    {
</span><span class='line'>        preempt_enable_no_resched();
</span><span class='line'>        /*如果没有软中断在pending，那就让出CPU来吧*/ 
</span><span class='line'>        schedule();
</span><span class='line'>       /*我被唤醒了，首先掌握CPU，不让自己被抢占，自己决定自己的是否要调度*/ 
</span><span class='line'>        preempt_disable();
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    __set_current_state(TASK_RUNNING);
</span><span class='line'>
</span><span class='line'>    while (local_softirq_pending())
</span><span class='line'>    {
</span><span class='line'>        /* Preempt disable stops cpu going offline.
</span><span class='line'>           If already offline, we'll be on wrong CPU:
</span><span class='line'>           don't process */ 
</span><span class='line'>        if (cpu_is_offline((long)__bind_cpu))
</span><span class='line'>            goto wait_to_die;
</span><span class='line'>        /*处理软中断*/ 
</span><span class='line'>        do_softirq();
</span><span class='line'>        /*虽然我自己掌握是否要调度，虽然我可以一直不调度，但是我是
</span><span class='line'>        个正直的人，运行一段时间后我会看看是否需要调度，还其它进程运行*/ 
</span><span class='line'>        preempt_enable_no_resched();
</span><span class='line'>        cond_resched();
</span><span class='line'>        preempt_disable();
</span><span class='line'>        rcu_qsctr_inc((long)__bind_cpu);
</span><span class='line'>    }
</span><span class='line'>    preempt_enable();
</span><span class='line'>    set_current_state(TASK_INTERRUPTIBLE);
</span><span class='line'>}
</span><span class='line'>__set_current_state(TASK_RUNNING);
</span><span class='line'>return 0;
</span><span class='line'>
</span><span class='line'>wait_to_die:
</span><span class='line'>preempt_enable();
</span><span class='line'>/* Wait for kthread_stop */ 
</span><span class='line'>set_current_state(TASK_INTERRUPTIBLE);
</span><span class='line'>while (!kthread_should_stop())
</span><span class='line'>{
</span><span class='line'>    schedule();
</span><span class='line'>    set_current_state(TASK_INTERRUPTIBLE);
</span><span class='line'>}
</span><span class='line'>__set_current_state(TASK_RUNNING);
</span><span class='line'>return 0;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[中断机制]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2015/01/23/kernel-irq-mark2/"/&gt;
</span><span class='line'>&lt;updated&gt;2015-01-23T14:03:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2015/01/23/kernel-irq-mark2&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;h4&gt;1、&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;cpu的中断管理和指令执行（运算器）是两套硬件，他们互相独立又有关联。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;2、&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;无论中断是否允许，运算器都按自己的节奏工作，无须花时间去查询是否由中断到达。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;3、&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;中断管理器则不断地探测是否有中断信号到达，若有且中断允许，则保存当前执行状态信息，然后打断当前取指序列，强行转到特定地址（中断向量）取指令，整个过程运算器并不知道，它只是忠实地执行取指电路取得的指令。&lt;br/&gt;
</span><span class='line'>  因此，只要没有中断信号到达，就不存在cpu边走边看的问题。
</span><span class='line'>  为保证正确访问临界数据区和正确执行临界代码段，操作系统一般有：关中断、关调度、信号量，还有些操作系统提供原子变量的方法，linux中广为人知的锁其实是用信号量实现的。那么，这么多的方法中，什么情况适用哪一种方法呢？是有规律的。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;1、原子变量&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  原子变量可以保证一个变量单次操作的正确性，其保护甚至比信号量还完善，信号量只能保护全局数据不被其他线程破坏，而原子变量能保证全局数据不被中断破坏。
</span><span class='line'>&lt;code&gt;
</span><span class='line'>example1：
</span><span class='line'>    atomic int a;
</span><span class='line'>int b,c;
</span><span class='line'>a = a + b + c;
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>上述代码中，cpu对a有一个读、修改、写的过程，这个过程如果被打断，并在其他线程中修改了a值，执行结果将出现错误，而原子变量将保证不会发生这样的错误。
</span><span class='line'>原子变量不能保护一系列操作的原子性，若把上述代码改为
</span><span class='line'>&lt;code&gt;
</span><span class='line'>example2：
</span><span class='line'>atomic int a;
</span><span class='line'>int b,c;
</span><span class='line'>a = a + b; //L1
</span><span class='line'>a = a + c; //L2
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>原子变量不能保证L1和L2两行程序间a不被其他线程修改，因此example2不一定能得到正确的结果。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;2、信号量&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  稍微完善一点的操作系统都提供信号量机制，用于保护临界代码。上述example2就应该用下列代码替代L1和L2：
</span><span class='line'>&lt;code&gt;
</span><span class='line'>获取信号量；
</span><span class='line'>a = a + b; //L1
</span><span class='line'>a = a + c; //L2
</span><span class='line'>释放信号量；
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>当一个全局变量可能被多个线程操作时，就应该用信号量保护，注意，不能在中断中访问用信号量保护的变量。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;3、关调度&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  关调度是一种比较粗暴的方式，关调度后，操作系统不会再进行线程上下文切换，而是专心执行一个线程，但是中断仍然开着。关调度可以起到替代信号量保护全局变量的作用，但一般不这样用，太粗暴了。但是如果某一段代码的执行时间有要求，希望cpu全速执行不被打断，但又不希望关中断时，可用关调度的方法。注意，从逻辑上，关调度能替换信号量，但不能替换原子变量。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;4、关中断&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  关中断是最粗暴的一种方式，用于保证最严格的时序执行，比如某段代码要在IO上输出两个高精度脉冲，脉冲宽度2uS，间隔2uS，这种需求只能通过用精确的指令延时来实现，延时过程中，如果被中断，或者发生线程切换，将不能正确输出脉冲。从逻辑上，前面所讲的三种保护，都可以用关中断实现，只是，太粗暴了。&lt;/p&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[NMI 看门狗]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2015/01/14/kernel-nmi-irq/"/&gt;
</span><span class='line'>&lt;updated&gt;2015-01-14T23:34:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2015/01/14/kernel-nmi-irq&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;p&gt;&lt;a href="http://blog.csdn.net/arethe/article/details/6153143"&gt;http://blog.csdn.net/arethe/article/details/6153143&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;[X86和X86-64体系结构均支持NMI看门狗]&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  你的系统是不是会经常被锁住（Lock up）？直至解锁，系统不再响应键盘？你希望帮助我们解决类似的问题吗？如果你对所有的问题都回答“yes”，那么此文档正是为你而写。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  在很多X86/X86-64结构的硬件上，我们都可以使用一种被称为“看门狗NMI中断”的机制。（NMI：Non Maskable Interrupt. 这种中断即使在系统被锁住时，也能被响应）。这种机制可以被用来调试内核锁住现象。通过周期性地执行NMI中断，内核能够监测到是否有CPU被锁住。当有处理器被锁住时，打印调试信息。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  为了使用NMI看门狗，首先需要在内核中支持APIC。对于SMP内核，APIC的相关支持已自动地被编译进内核。对于UP内核，需要在内核配置中使能CONFIG_X86_UP_APIC (Processor type and features -&gt; Local APIC support on uniprocessors) 或 CONFIG_X86_UP_IOAPIC (Processor type and features -&gt; IO-APIC support on uniprocessors)。在没有IO-APIC的单处理器系统中，配置CONFIG_X86_UP_APIC。在有IO-APIC的单处理器系统中，则需配置CONFIG_X86_UP_IOAPIC。[注意：某些与内核调试相关选项可能会禁用NMI看门狗。如：Kernel Stack Meter或Kernel Tracer]。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  对于X86-64系统，APIC已被编进内核。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  使用本地APIC（nmi_watchdog=2）时，需要占用第一个性能寄存器，因而此寄存器不能再被另作它用（如高精度的性能分析）。Oprofile与perfctr的驱动已自动地禁用了本地APIC的NMI看门狗。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  可以通过启动参数“nmi_watchdog=N”使能NMI看门狗。即在lilo.conf的相关项中添加如下语句：
</span><span class='line'>&lt;code&gt;
</span><span class='line'>  append=”nmi_watchdog=1”
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>  对于具有IO-APIC的SMP与UP机器，设置nmi_watchdog=1。对于没有IO-APIC的UP机器，设置nmi_watchdog=2，但仅在某些处理器上可以起作用。如果有疑问，在用nmi_watchdog=1启动后，再查看/proc/interrupts文件中的NMI项，如果该项为0，那么便用nmi_watchdog=2重新启动，并再次检查NMI项。如果还是0，问题就比较严重了，你的处理器很可能不支持NMI。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  “锁住（Lockup）”是指如下的情况：如果系统中的任何一个CPU不能处理周期性的本地时钟中断，并持续5秒钟以上，那么NMI的处理函数将产生一个oops并杀死当前进程。这是一种“可控崩溃”（Controlled Crash，所谓可控，是指发生崩溃时，能够输出内核信息），可以用此机制来调试“锁住”现象。那么，无论什么时候发生“锁住”，5秒钟之后都会自动地输出oops。如果内核没有输出信息，说明此时发生的崩溃过于严重（如：hardware-wise），以至于NMI中断都无法被响应，或者此次崩溃使得内核无法打印信息。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  在使用本地APIC时要注意，NMI中断被触发的频率依赖于系统的当前负载。由于缺乏更好的时钟源，本地APIC中的NMI看门狗使用的是“有效周期（Cycle unhalted，这个词的翻译似乎不太确切，如果某位朋友有更佳的建议，请告知在下。）”事件。也许你已经猜到了，当CPU处于halted（空等）状态时，该时钟是不计数的。处理器处于空闲状态的时候，常出现这样的情况。如果你的系统在被锁住时，执行的不是hlt指令，看门狗中断很快就会被触发，因为每个时钟周期都会发生“有效周期”事件。如果不幸，处理器在被锁住时，执行的恰是“hlt”指令，那么“有效周期”事件永远都不会发生，看门狗自然也不会被触发。这是本地APIC看门狗的缺陷，在倒霉的时候，永远不会进行时钟计数。而I/O APIC中的看门狗由于采用外部时钟进行驱动，便不存在这个缺陷。但是，它的NMI频率非常高，会显著地影响系统的性能。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  X86的nmi_watchdog在默认情况下是禁用的，因此你需要在系统启动的时候使能它。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  在系统运行期间，可以禁用NMI看门狗，只要向文件“/proc/sys/kernel/nmi_watchdog”中写“0”即可。向该文件写“1”，将重新使能看门狗。即使如此，你仍然需要在启动时使用参数“nmi_watchdog=”。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  注意：在2.4.2-ac18之前的内核中，X86 SMP平台会无条件地使能NMI-oopser。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;hr /&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;www.2cto.com/kf/201311/260704.html</span></code></pre></td></tr></table></div></figure>
    //  使能hard lockup探测
    //  调用路径：watchdog_enable->watchdog_nmi_enable
    //  函数任务：
    //      1.初始化hard lockup检测事件
    //          2.hard lockup阈值为10s
    //      2.向performance monitoring子系统注册hard lockup检测事件
    //      3.使能hard lockup检测事件
    //  注：
    //      performance monitoring，x86中的硬件设备，当cpu clock经过了指定个周期后发出一个NMI中断。
    1.1 static int watchdog_nmi_enable(unsigned int cpu)
    {
        //hard lockup事件
        struct perf_event_attr <em>wd_attr;
        struct perf_event </em>event = per_cpu(watchdog_ev, cpu);
        &hellip;.
        wd_attr = &amp;wd_hw_attr;
        //hard lockup检测周期，10s
        wd_attr->sample_period = hw_nmi_get_sample_period(watchdog_thresh);
        //向performance monitoring注册hard lockup检测事件
        event = perf_event_create_kernel_counter(wd_attr, cpu, NULL, watchdog_overflow_callback, NULL);
        &hellip;.
        //使能hard lockup的检测
        per_cpu(watchdog_ev, cpu) = event;
        perf_event_enable(per_cpu(watchdog_ev, cpu));
        return 0;
    }</p>

<pre><code>//  换算hard lockup检测周期到cpu频率
1.2 u64 hw_nmi_get_sample_period(int watchdog_thresh)
{
    return (u64)(cpu_khz) * 1000 * watchdog_thresh;
}

//  hard lockup检测事件发生时的nmi回调函数
//  函数任务：
//      1.判断是否发生了hard lockup
//          1.1 dump hard lockup信息
1.3 static void watchdog_overflow_callback(struct perf_event *event,
     struct perf_sample_data *data,
     struct pt_regs *regs)
{
    //判断是否发生hard lockup
    if (is_hardlockup()) {
        int this_cpu = smp_processor_id();

        //打印hard lockup信息
        if (hardlockup_panic)
            panic("Watchdog detected hard LOCKUP on cpu %d", this_cpu);
        else
            WARN(1, "Watchdog detected hard LOCKUP on cpu %d", this_cpu);

        return;
    }
    return;
}

//  判断是否发生hard lockup
//  注：
//      如果时钟中断在指定阈值范围内为运行，核心认为可屏蔽中断被屏蔽时间过长
1.4 static int is_hardlockup(void)
{
    //获取watchdog timer的运行次数
    unsigned long hrint = __this_cpu_read(hrtimer_interrupts);
    //在一个hard lockup检测时间阈值内，如果watchdog timer未运行，说明cpu中断被屏蔽时间超过阈值
    if (__this_cpu_read(hrtimer_interrupts_saved) == hrint)
        return 1;
    //记录watchdog timer运行的次数
    __this_cpu_write(hrtimer_interrupts_saved, hrint);
    return 0;
}

//  关闭hard lockup检测机制
//  函数任务：
//      1.向performance monitoring子系统注销hard lockup检测控制块
//      2.清空per-cpu hard lockup检测控制块
//      3.释放hard lock检测控制块
2.1 static void watchdog_nmi_disable(unsigned int cpu)
{
    struct perf_event *event = per_cpu(watchdog_ev, cpu);
    if (event) {
        //向performance monitoring子系统注销hard lockup检测控制块
        perf_event_disable(event);
        //清空per-cpu hard lockup检测控制块
        per_cpu(watchdog_ev, cpu) = NULL;
        //释放hard lock检测控制块
        perf_event_release_kernel(event);
    }
    return;
}
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[中断，进程]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/01/03/kernel-irq-mark/"/>
    <updated>2015-01-03T15:45:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/01/03/kernel-irq-mark</id>
    <content type="html"><![CDATA[<p>blog.chinaunix.net/uid-20806345-id-3203602.html</p>

<p>  中断不是进程，不受内核调度器的管辖。在系统处理进程的过程中，对于某个cpu来说，如果有内部中断或外部中断到来，则切换到中断处理程序，切换首先要将进程由用户态要切到进程的内核态，然后再将cpu切换到中断态，待处理完中断返回进程的内核态，再返回进程的用户态，如果中断时进程刚好处于内核态中不用由用户态切到内核态了。<br/>
  中断处理时是不分优先级的，处理中断的过程中如果有任意中断到来，都会抢占当前的中断处理过程。所以对于要及时响应的中断，需要通过关中断来屏蔽其他中断。通常所说的中断优先级是指中断控制器端的优先级，当有多个中断触发时，首先选择优先级高的中断发出请求给处理器。中断优先级只是对中断控制器而言的，所有的中断对cpu来说都是一样的，没有优先级高低之分。<br/>
  关中断是关闭所有的外部可屏蔽中断，和优先级没有关系，如果在某中断处理程序中关中断，则不会被任何可屏蔽中断抢占，但是会被任意的不可屏蔽中断抢占。关中断是中断处理程序可选的。</p>

<p>bbs.chinaunix.net/thread-2306027-1-8.html</p>

<p>软中断做的是一些可延迟的费时间的事，当然不能在中断里执行了。<br/>
  <code>__do_softirq</code>代码，可以看到在执行可延迟函数第一件事就是开中断。但在开始之前，禁用了下半部中断（<code>__local_bh_disable</code>）。这样就算被中断了，返回内核时也不会被抢占，还是执行这里的代码。也不会被调度。<br/>
  那么这样的后果就是软中断上下文里的会一直执行下去，直到到达了限定次数，然后唤醒守护进程。<br/>
  因为软中断切换了栈，不再使用进程上下文，那么如果在软中断上下文直接或简洁调用了shedule，那么只有死翘翘了！！因为schedule调度回来的时候是依赖进程内核栈的thread_info。</p>

<p>  内核抢占点之一就是中断返回的时候检查是否可以抢占，检查的内容之一就是preempt_count是否等于0，因为禁用了下半部中断，那么肯定就不会等于0的，所以不会被抢占。也就是说返回的时候不会发生调度。</p>

<p>  个人理解 中断上下文 最大的特征 禁掉了某种中断（硬中断和软中断），所以导致 不能阻塞。<br/>
  softirq 有可能在两种方式下被调用，一是中断处理程序退出时，开放硬件中断之后，会去调用do_softirq()。
  do_softirq()会禁掉后半部抢占，并且现在执行流使用的是被中断的进程的栈，所以无法阻塞。<br/>
  softirq的另一种调用方式是ksoftirq内核线程，同样do_softirq()被调用，后半部中断被禁掉，同样禁止阻塞。<br/>
  工作队列，可以被任何中断或者软中断中断，运行在进程上下文，有自己的栈，可以阻塞。</p>

<p>看一下__do_softirq()的代码,新的硬中断确实可能触发更高优先级的软中断，但是这个软中断并不会在被中断的软中断之前得到执行，软中断始终是顺序执行的。从代码看来，新一批的软中断，无论优先级多高，也得等到前一批的软中断被处理完成之后才能得到处理。而优先级只能帮助软中断在对应的批次中优先得到处理。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[硬中断和软中断]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/01/03/kernel-irq/"/>
    <updated>2015-01-03T15:15:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/01/03/kernel-irq</id>
    <content type="html"><![CDATA[<p>关闭硬中断： spin_lock_irq和spin_unlock_irq以及spin_lock_irqsave和spin_unlock_irqrestore<br/>
关闭软中断： spin_lock_bh和spin_unlock_bh</p>

<hr />

<p>netfilter：<br/>
有些netfilter hooks可以从系统调用的context到达， 比如socket的send_msg()是可以到达LOCAL_OUT/POST_ROUTING的， <br/>
这样，也就是说，在这些情况下操作conntrack链表的时候，是进程上下文，而不是软中断上下文， 因此，是需要关闭bh的。</p>

<p>PRE_ROUTING上的按道理说，它只能从软中断到达，因此只需要spin_lock()就可以了。</p>

<hr />

<p><a href="http://blog.csdn.net/zhangskd/article/details/21992933">http://blog.csdn.net/zhangskd/article/details/21992933</a></p>

<h4>概述</h4>

<p>从本质上来讲，中断是一种电信号，当设备有某种事件发生时，它就会产生中断，通过总线把电信号发送给中断控制器。
如果中断的线是激活的，中断控制器就把电信号发送给处理器的某个特定引脚。处理器于是立即停止自己正在做的事，
跳到中断处理程序的入口点，进行中断处理。</p>

<h5>(1) 硬中断</h5>

<p>由与系统相连的外设(比如网卡、硬盘)自动产生的。主要是用来通知操作系统系统外设状态的变化。比如当网卡收到数据包的时候，就会发出一个中断。我们通常所说的中断指的是硬中断(hardirq)。</p>

<h5>(2) 软中断</h5>

<p>为了满足实时系统的要求，中断处理应该是越快越好。linux为了实现这个特点，当中断发生的时候，硬中断处理那些短时间就可以完成的工作，而将那些处理事件比较长的工作，放到中断之后来完成，也就是软中断(softirq)来完成。</p>

<h5>(3) 中断嵌套</h5>

<p>Linux下硬中断是可以嵌套的，但是没有优先级的概念，也就是说任何一个新的中断都可以打断正在执行的中断，但同种中断除外。软中断不能嵌套，但相同类型的软中断可以在不同CPU上并行执行。</p>

<h5>(4) 软中断指令</h5>

<p>int是软中断指令。<br/>
中断向量表是中断号和中断处理函数地址的对应表。<br/>
int n - 触发软中断n。相应的中断处理函数的地址为：中断向量表地址 + 4 * n。</p>

<h5>(5)硬中断和软中断的区别</h5>

<p>软中断是执行中断指令产生的，而硬中断是由外设引发的。<br/>
硬中断的中断号是由中断控制器提供的，软中断的中断号由指令直接指出，无需使用中断控制器。<br/>
硬中断是可屏蔽的，软中断不可屏蔽。<br/>
硬中断处理程序要确保它能快速地完成任务，这样程序执行时才不会等待较长时间，称为上半部。<br/>
软中断处理硬中断未完成的工作，是一种推后执行的机制，属于下半部。</p>

<h4>开关</h4>

<h5>(1) 硬中断的开关</h5>

<p>简单禁止和激活当前处理器上的本地中断：
<code>
    local_irq_disable();
    local_irq_enable();
</code>
保存本地中断系统状态下的禁止和激活：
<code>
    unsigned long flags;
    local_irq_save(flags);
    local_irq_restore(flags);
</code></p>

<h5>(2) 软中断的开关</h5>

<p>禁止下半部，如softirq、tasklet和workqueue等：
<code>
    local_bh_disable();
    local_bh_enable();
</code>
需要注意的是，禁止下半部时仍然可以被硬中断抢占。</p>

<h5>(3) 判断中断状态</h5>

<pre><code>    #define in_interrupt() (irq_count()) // 是否处于中断状态(硬中断或软中断)
    #define in_irq() (hardirq_count()) // 是否处于硬中断
    #define in_softirq() (softirq_count()) // 是否处于软中断
</code></pre>

<h4>硬中断</h4>

<h5>(1) 注册中断处理函数</h5>

<p>注册中断处理函数：
```
    /<em><em>
     * irq: 要分配的中断号
     * handler: 要注册的中断处理函数
     * flags: 标志(一般为0)
     * name: 设备名(dev->name)
     * dev: 设备(struct net_device </em>dev)，作为中断处理函数的参数
     * 成功返回0
     </em>/</p>

<pre><code>int request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags,   
    const char *name, void *dev);  
</code></pre>

<pre><code>
中断处理函数本身：
</code></pre>

<pre><code>typedef irqreturn_t (*irq_handler_t) (int, void *);  

/** 
 * enum irqreturn 
 * @IRQ_NONE: interrupt was not from this device 
 * @IRQ_HANDLED: interrupt was handled by this device 
 * @IRQ_WAKE_THREAD: handler requests to wake the handler thread 
 */  
enum irqreturn {  
    IRQ_NONE,  
    IRQ_HANDLED,  
    IRQ_WAKE_THREAD,  
};  
typedef enum irqreturn irqreturn_t;  
#define IRQ_RETVAL(x) ((x) != IRQ_NONE)  
</code></pre>

<pre><code>
##### (2) 注销中断处理函数
</code></pre>

<pre><code>/** 
 * free_irq - free an interrupt allocated with request_irq 
 * @irq: Interrupt line to free 
 * @dev_id: Device identity to free 
 * 
 * Remove an interrupt handler. The handler is removed and if the 
 * interrupt line is no longer in use by any driver it is disabled. 
 * On a shared IRQ the caller must ensure the interrupt is disabled 
 * on the card it drives before calling this function. The function does 
 * not return until any executing interrupts for this IRQ have completed. 
 * This function must not be called from interrupt context. 
 */  

void free_irq(unsigned int irq, void *dev_id);  
</code></pre>

<pre><code>
#### 软中断
##### (1) 定义
软中断是一组静态定义的下半部接口，可以在所有处理器上同时执行，即使两个类型相同也可以。  
但一个软中断不会抢占另一个软中断，唯一可以抢占软中断的是硬中断。

软中断由softirq_action结构体表示：
</code></pre>

<pre><code>struct softirq_action {  
    void (*action) (struct softirq_action *); /* 软中断的处理函数 */  
};  
</code></pre>

<pre><code>
目前已注册的软中断有10种，定义为一个全局数组：
</code></pre>

<pre><code>static struct softirq_action softirq_vec[NR_SOFTIRQS];  

enum {  
    HI_SOFTIRQ = 0, /* 优先级高的tasklets */  
    TIMER_SOFTIRQ, /* 定时器的下半部 */  
    NET_TX_SOFTIRQ, /* 发送网络数据包 */  
    NET_RX_SOFTIRQ, /* 接收网络数据包 */  
    BLOCK_SOFTIRQ, /* BLOCK装置 */  
    BLOCK_IOPOLL_SOFTIRQ,  
    TASKLET_SOFTIRQ, /* 正常优先级的tasklets */  
    SCHED_SOFTIRQ, /* 调度程序 */  
    HRTIMER_SOFTIRQ, /* 高分辨率定时器 */  
    RCU_SOFTIRQ, /* RCU锁定 */  
    NR_SOFTIRQS /* 10 */  
};  
</code></pre>

<pre><code>
##### (2) 注册软中断处理函数
</code></pre>

<pre><code>/** 
 * @nr: 软中断的索引号 
 * @action: 软中断的处理函数 
 */  

void open_softirq(int nr, void (*action) (struct softirq_action *))  
{  
    softirq_vec[nr].action = action;  
}  
</code></pre>

<pre><code>例如：
</code></pre>

<pre><code>open_softirq(NET_TX_SOFTIRQ, net_tx_action);
open_softirq(NET_RX_SOFTIRQ, net_rx_action);
</code></pre>

<pre><code>
##### (3) 触发软中断 
调用raise_softirq()来触发软中断。
</code></pre>

<pre><code>void raise_softirq(unsigned int nr)  
{  
    unsigned long flags;  
    local_irq_save(flags);  
    raise_softirq_irqoff(nr);  
    local_irq_restore(flags);  
}  

/* This function must run with irqs disabled */  
inline void rasie_softirq_irqsoff(unsigned int nr)  
{  
    __raise_softirq_irqoff(nr);  

    /* If we're in an interrupt or softirq, we're done 
     * (this also catches softirq-disabled code). We will 
     * actually run the softirq once we return from the irq 
     * or softirq. 
     * Otherwise we wake up ksoftirqd to make sure we 
     * schedule the softirq soon. 
     */  
    if (! in_interrupt()) /* 如果不处于硬中断或软中断 */  
        wakeup_softirqd(void); /* 唤醒ksoftirqd/n进程 */  
}  
</code></pre>

<pre><code>
Percpu变量irq_cpustat_t中的__softirq_pending是等待处理的软中断的位图，通过设置此变量

即可告诉内核该执行哪些软中断。
</code></pre>

<pre><code>static inline void __rasie_softirq_irqoff(unsigned int nr)  
{  
    trace_softirq_raise(nr);  
    or_softirq_pending(1UL &lt;&lt; nr);  
}  

typedef struct {  
    unsigned int __softirq_pending;  
    unsigned int __nmi_count; /* arch dependent */  
} irq_cpustat_t;  

irq_cpustat_t irq_stat[];  
#define __IRQ_STAT(cpu, member) (irq_stat[cpu].member)  
#define or_softirq_pending(x) percpu_or(irq_stat.__softirq_pending, (x))  
#define local_softirq_pending() percpu_read(irq_stat.__softirq_pending)  
</code></pre>

<pre><code>
唤醒ksoftirqd内核线程处理软中断。
</code></pre>

<pre><code>static void wakeup_softirqd(void)  
{  
    /* Interrupts are disabled: no need to stop preemption */  
    struct task_struct *tsk = __get_cpu_var(ksoftirqd);  

    if (tsk &amp;&amp; tsk-&gt;state != TASK_RUNNING)  
        wake_up_process(tsk);  
}  
</code></pre>

<pre><code>
在下列地方，待处理的软中断会被检查和执行：  
1. 从一个硬件中断代码处返回时  
2. 在ksoftirqd内核线程中  
3. 在那些显示检查和执行待处理的软中断的代码中，如网络子系统中

而不管是用什么方法唤起，软中断都要在do_softirq()中执行。如果有待处理的软中断，do_softirq()会循环遍历每一个，调用它们的相应的处理程序。在中断处理程序中触发软中断是最常见的形式。中断处理程序执行硬件设备的相关操作，然后触发相应的软中断，最后退出。内核在执行完中断处理程序以后，马上就会调用do_softirq()，于是软中断开始执行中断处理程序完成剩余的任务。

下面来看下do_softirq()的具体实现。
</code></pre>

<pre><code>asmlinkage void do_softirq(void)  
{  
    __u32 pending;  
    unsigned long flags;  

    /* 如果当前已处于硬中断或软中断中，直接返回 */  
    if (in_interrupt())   
        return;  

    local_irq_save(flags);  
    pending = local_softirq_pending();  
    if (pending) /* 如果有激活的软中断 */  
        __do_softirq(); /* 处理函数 */  
    local_irq_restore(flags);  
}  
</code></pre>

<p><code>
</code>
    /<em> We restart softirq processing MAX_SOFTIRQ_RESTART times,
     * and we fall back to softirqd after that.
     * This number has been established via experimentation.
     * The two things to balance is latency against fairness - we want
     * to handle softirqs as soon as possible, but they should not be
     * able to lock up the box.
     </em>/<br/>
    asmlinkage void <strong>do_softirq(void)<br/>
    {<br/>
        struct softirq_action *h;<br/>
        </strong>u32 pending;<br/>
        /<em> 本函数能重复触发执行的次数，防止占用过多的cpu时间 </em>/<br/>
        int max_restart = MAX_SOFTIRQ_RESTART;<br/>
        int cpu;</p>

<pre><code>    pending = local_softirq_pending(); /* 激活的软中断位图 */  
    account_system_vtime(current);  
    /* 本地禁止当前的软中断 */  
    __local_bh_disable((unsigned long)__builtin_return_address(0), SOFTIRQ_OFFSET);  
    lockdep_softirq_enter(); /* current-&gt;softirq_context++ */  
    cpu = smp_processor_id(); /* 当前cpu编号 */  

restart:  
    /* Reset the pending bitmask before enabling irqs */  
    set_softirq_pending(0); /* 重置位图 */  
    local_irq_enable();  
    h = softirq_vec;  
    do {  
        if (pending &amp; 1) {  
            unsigned int vec_nr = h - softirq_vec; /* 软中断索引 */  
            int prev_count = preempt_count();  
            kstat_incr_softirqs_this_cpu(vec_nr);  

            trace_softirq_entry(vec_nr);  
            h-&gt;action(h); /* 调用软中断的处理函数 */  
            trace_softirq_exit(vec_nr);  

            if (unlikely(prev_count != preempt_count())) {  
                printk(KERN_ERR "huh, entered softirq %u %s %p" "with preempt_count %08x,"  
                    "exited with %08x?\n", vec_nr, softirq_to_name[vec_nr], h-&gt;action, prev_count,  
                    preempt_count());  
            }  
            rcu_bh_qs(cpu);  
        }  
        h++;  
        pending &gt;&gt;= 1;  
    } while(pending);  

    local_irq_disable();  
    pending = local_softirq_pending();  
    if (pending &amp; --max_restart) /* 重复触发 */  
        goto restart;  

    /* 如果重复触发了10次了，接下来唤醒ksoftirqd/n内核线程来处理 */  
    if (pending)  
        wakeup_softirqd();   

    lockdep_softirq_exit();  
    account_system_vtime(current);  
    __local_bh_enable(SOFTIRQ_OFFSET);  
}  
</code></pre>

<pre><code>
##### (4) ksoftirqd内核线程
内核不会立即处理重新触发的软中断。  
当大量软中断出现的时候，内核会唤醒一组内核线程来处理。  
这些线程的优先级最低(nice值为19)，这能避免它们跟其它重要的任务抢夺资源。  
但它们最终肯定会被执行，所以这个折中的方案能够保证在软中断很多时用户程序不会因为得不到处理时间而处于饥饿状态，同时也保证过量的软中断最终会得到处理。

每个处理器都有一个这样的线程，名字为ksoftirqd/n，n为处理器的编号。
</code></pre>

<pre><code>static int run_ksoftirqd(void *__bind_cpu)  
{  
    set_current_state(TASK_INTERRUPTIBLE);  
    current-&gt;flags |= PF_KSOFTIRQD; /* I am ksoftirqd */  

    while(! kthread_should_stop()) {  
        preempt_disable();  

        if (! local_softirq_pending()) { /* 如果没有要处理的软中断 */  
            preempt_enable_no_resched();  
            schedule();  
            preempt_disable():  
        }  

        __set_current_state(TASK_RUNNING);  

        while(local_softirq_pending()) {  
            /* Preempt disable stops cpu going offline. 
             * If already offline, we'll be on wrong CPU: don't process. 
             */  
             if (cpu_is_offline(long)__bind_cpu))/* 被要求释放cpu */  
                 goto wait_to_die;  

            do_softirq(); /* 软中断的统一处理函数 */  

            preempt_enable_no_resched();  
            cond_resched();  
            preempt_disable();  
            rcu_note_context_switch((long)__bind_cpu);  
        }  

        preempt_enable();  
        set_current_state(TASK_INTERRUPTIBLE);  
    }  

    __set_current_state(TASK_RUNNING);  
    return 0;  

wait_to_die:  
    preempt_enable();  
    /* Wait for kthread_stop */  
    set_current_state(TASK_INTERRUPTIBLE);  
    while(! kthread_should_stop()) {  
        schedule();  
        set_current_state(TASK_INTERRUPTIBLE);  
    }  

    __set_current_state(TASK_RUNNING);  
    return 0;  
}
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
</feed>
