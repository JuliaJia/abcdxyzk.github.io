<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 2015~05 | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/2015~05/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2015-05-11T11:08:27+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[tcp_read_sock BUG]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/05/11/debug-mark-tcp_read_sock_bug/"/>
    <updated>2015-05-11T10:17:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/05/11/debug-mark-tcp_read_sock_bug</id>
    <content type="html"><![CDATA[<pre><code>commit baff42ab1494528907bf4d5870359e31711746ae
Author: Steven J. Magnani &lt;steve@digidescorp.com&gt;
Date:   Tue Mar 30 13:56:01 2010 -0700

    net: Fix oops from tcp_collapse() when using splice()

    tcp_read_sock() can have a eat skbs without immediately advancing copied_seq.
    This can cause a panic in tcp_collapse() if it is called as a result
    of the recv_actor dropping the socket lock.

    A userspace program that splices data from a socket to either another
    socket or to a file can trigger this bug.

    Signed-off-by: Steven J. Magnani &lt;steve@digidescorp.com&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;
</code></pre>

<pre><code>    diff --git a/net/ipv4/tcp.c b/net/ipv4/tcp.c
    index 6afb6d8..2c75f89 100644
    --- a/net/ipv4/tcp.c
    +++ b/net/ipv4/tcp.c
    @@ -1368,6 +1368,7 @@ int tcp_read_sock(struct sock *sk, read_descriptor_t *desc,
            sk_eat_skb(sk, skb, 0);
            if (!desc-&gt;count)
                break;
    +       tp-&gt;copied_seq = seq;
        }
        tp-&gt;copied_seq = seq;
</code></pre>

<p>如果在tcp_read_sock中sk_eat_skb时copied_seq没有及时一起修改的话，就会出现copied_seq小于sk_write_queue队列第一个包的seq。<br/>
tcp_read_sock的recv_actor指向的函数(比如tcp_splice_data_recv)是有可能释放sk锁的，如果这时进入收包软中断且内存紧张调用tcp_collapse，<br/>
tcp_collapse中：<br/>
```
    start = copied_seq
    &hellip;
    int offset = start - TCP_SKB_CB(skb)->seq;</p>

<pre><code>BUG_ON(offset &lt; 0);
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[tcp_match_skb_to_sack BUG]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/05/11/debug-mark-tcp_match_skb_to_sack_bug/"/>
    <updated>2015-05-11T10:09:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/05/11/debug-mark-tcp_match_skb_to_sack_bug</id>
    <content type="html"><![CDATA[<pre><code>commit 2cd0d743b05e87445c54ca124a9916f22f16742e
Author: Neal Cardwell &lt;ncardwell@google.com&gt;
Date:   Wed Jun 18 21:15:03 2014 -0400

    tcp: fix tcp_match_skb_to_sack() for unaligned SACK at end of an skb

    If there is an MSS change (or misbehaving receiver) that causes a SACK
    to arrive that covers the end of an skb but is less than one MSS, then
    tcp_match_skb_to_sack() was rounding up pkt_len to the full length of
    the skb ("Round if necessary..."), then chopping all bytes off the skb
    and creating a zero-byte skb in the write queue.

    This was visible now because the recently simplified TLP logic in
    bef1909ee3ed1c ("tcp: fixing TLP's FIN recovery") could find that 0-byte
    skb at the end of the write queue, and now that we do not check that
    skb's length we could send it as a TLP probe.

    Consider the following example scenario:

     mss: 1000
     skb: seq: 0 end_seq: 4000  len: 4000
     SACK: start_seq: 3999 end_seq: 4000

    The tcp_match_skb_to_sack() code will compute:

     in_sack = false
     pkt_len = start_seq - TCP_SKB_CB(skb)-&gt;seq = 3999 - 0 = 3999
     new_len = (pkt_len / mss) * mss = (3999/1000)*1000 = 3000
     new_len += mss = 4000

    Previously we would find the new_len &gt; skb-&gt;len check failing, so we
    would fall through and set pkt_len = new_len = 4000 and chop off
    pkt_len of 4000 from the 4000-byte skb, leaving a 0-byte segment
    afterward in the write queue.

    With this new commit, we notice that the new new_len &gt;= skb-&gt;len check
    succeeds, so that we return without trying to fragment.

    Fixes: adb92db857ee ("tcp: Make SACK code to split only at mss boundaries")
    Reported-by: Eric Dumazet &lt;edumazet@google.com&gt;
    Signed-off-by: Neal Cardwell &lt;ncardwell@google.com&gt;
    Cc: Eric Dumazet &lt;edumazet@google.com&gt;
    Cc: Yuchung Cheng &lt;ycheng@google.com&gt;
    Cc: Ilpo Jarvinen &lt;ilpo.jarvinen@helsinki.fi&gt;
    Acked-by: Eric Dumazet &lt;edumazet@google.com&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;
</code></pre>

<pre><code>    diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c
    index 40661fc..b5c2375 100644
    --- a/net/ipv4/tcp_input.c
    +++ b/net/ipv4/tcp_input.c
    @@ -1162,7 +1162,7 @@ static int tcp_match_skb_to_sack(struct sock *sk, struct sk_buff *skb,
                unsigned int new_len = (pkt_len / mss) * mss;
                if (!in_sack &amp;&amp; new_len &lt; pkt_len) {
                    new_len += mss;
    -               if (new_len &gt; skb-&gt;len)
    +               if (new_len &gt;= skb-&gt;len)
                        return 0;
                }
                pkt_len = new_len;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[gro收包]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/05/08/debug-mark-gro-attention/"/>
    <updated>2015-05-08T16:32:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/05/08/debug-mark-gro-attention</id>
    <content type="html"><![CDATA[<p><a href="/blog/2015/04/18/kernel-net-gro/">linux kernel 网络协议栈之GRO(Generic receive offload)</a></p>

<p>gro会合并多个gso_size不同的包, 会将gso_size设置成第一个包的gso_size.</p>

<p>如果此时把这个包发出去，那么就会导致不满足： skb->gso_size * (skb->segs-1) &lt; skb->len &lt;= skb->gso_size * skb->segs</p>

<p>那么后面的三个函数就有可能出错</p>

<h4>一、tcp_shift_skb_data</h4>

<pre><code>    mss = skb-&gt;gso_size
    len = len/mss * mss

    |---|-------|-------|
     mss    |
            V
    |---|---|
</code></pre>

<h4>二、tcp_mark_head_lost</h4>

<pre><code>    len = (packets - cnt) * mss

    |--------|--|--|
       mss   |
             V
    |--------|--------|
</code></pre>

<h4>三、tcp_match_skb_to_sack</h4>

<pre><code>    new_len = (pkt_len/mm)*mss
    in_sack = 1
    pkt_len = new_len

    |---|-------|-------|
     mss    |
            V
    |---|---|
</code></pre>

<h4>修改</h4>

<p>加入发包队列前
<code>
    skb_shinfo(skb)-&gt;gso_size = 0;
    skb_shinfo(skb)-&gt;gso_segs = 0;
    skb_shinfo(skb)-&gt;gso_type = 0;
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[tcp_trim_head BUG]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/05/08/debug-mark-tcp_trim_head_bug/"/>
    <updated>2015-05-08T16:24:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/05/08/debug-mark-tcp_trim_head_bug</id>
    <content type="html"><![CDATA[<p><a href="http://kernel.opensuse.org/cgit/kernel/commit/?id=5b35e1e6e9ca651e6b291c96d1106043c9af314a">http://kernel.opensuse.org/cgit/kernel/commit/?id=5b35e1e6e9ca651e6b291c96d1106043c9af314a</a></p>

<p>author  Neal Cardwell <a href="&#109;&#97;&#105;&#108;&#116;&#x6f;&#58;&#110;&#99;&#97;&#x72;&#x64;&#119;&#101;&#108;&#108;&#x40;&#x67;&#111;&#x6f;&#103;&#x6c;&#101;&#46;&#x63;&#111;&#109;">&#x6e;&#x63;&#x61;&#x72;&#x64;&#x77;&#x65;&#108;&#x6c;&#64;&#103;&#x6f;&#111;&#103;&#108;&#x65;&#46;&#x63;&#111;&#x6d;</a>    2012-01-28 17:29:46 (GMT)<br/>
committer   David S. Miller <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#x64;&#x61;&#118;&#101;&#x6d;&#x40;&#x64;&#97;&#118;&#101;&#109;&#108;&#111;&#102;&#x74;&#x2e;&#x6e;&#x65;&#116;">&#100;&#97;&#x76;&#101;&#x6d;&#x40;&#x64;&#97;&#x76;&#x65;&#x6d;&#108;&#111;&#102;&#116;&#46;&#x6e;&#x65;&#x74;</a>   2012-01-30 17:42:58 (GMT)<br/>
commit  5b35e1e6e9ca651e6b291c96d1106043c9af314a (patch)<br/>
tree    d18caadee5e93dc45d0c5fa2c530537cfa14586c<br/>
parent  4acb41903b2f99f3dffd4c3df9acc84ca5942cb2 (diff)</p>

<h4>tcp: fix tcp_trim_head() to adjust segment count with skb MSS</h4>

<p>This commit fixes tcp_trim_head() to recalculate the number of segments in the skb with the skb&rsquo;s existing MSS, so trimming the head causes the skb segment count to be monotonically non-increasing - it should stay the same or go down, but not increase.</p>

<p>Previously tcp_trim_head() used the current MSS of the connection. But if there was a decrease in MSS between original transmission and ACK (e.g. due to PMTUD), this could cause tcp_trim_head() to counter-intuitively increase the segment count when trimming bytes off the head of an skb. This violated assumptions in tcp_tso_acked() that tcp_trim_head() only decreases the packet count, so that packets_acked in tcp_tso_acked() could underflow, leading tcp_clean_rtx_queue() to pass u32 pkts_acked values as large as 0xffffffff to ca_ops->pkts_acked().</p>

<p>As an aside, if tcp_trim_head() had really wanted the skb to reflect the current MSS, it should have called tcp_set_skb_tso_segs() unconditionally, since a decrease in MSS would mean that a single-packet skb should now be sliced into multiple segments.</p>

<p>Signed-off-by: Neal Cardwell <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#x6e;&#x63;&#x61;&#x72;&#x64;&#119;&#x65;&#108;&#108;&#64;&#103;&#111;&#111;&#x67;&#x6c;&#x65;&#x2e;&#x63;&#111;&#109;">&#110;&#x63;&#x61;&#x72;&#x64;&#x77;&#x65;&#x6c;&#108;&#x40;&#103;&#x6f;&#x6f;&#x67;&#108;&#101;&#x2e;&#x63;&#x6f;&#109;</a> <br/>
Acked-by: Nandita Dukkipati <a href="&#x6d;&#x61;&#105;&#108;&#116;&#x6f;&#x3a;&#x6e;&#97;&#x6e;&#x64;&#105;&#x74;&#x61;&#100;&#64;&#103;&#x6f;&#111;&#103;&#x6c;&#101;&#46;&#99;&#x6f;&#109;">&#110;&#x61;&#110;&#x64;&#x69;&#x74;&#97;&#x64;&#x40;&#103;&#111;&#x6f;&#103;&#108;&#101;&#x2e;&#x63;&#x6f;&#109;</a> <br/>
Acked-by: Ilpo Järvinen <a href="&#x6d;&#97;&#x69;&#108;&#116;&#x6f;&#x3a;&#105;&#x6c;&#x70;&#x6f;&#46;&#106;&#97;&#114;&#x76;&#x69;&#x6e;&#101;&#110;&#x40;&#104;&#101;&#108;&#115;&#x69;&#110;&#107;&#105;&#46;&#102;&#x69;">&#105;&#x6c;&#x70;&#111;&#x2e;&#x6a;&#97;&#114;&#118;&#x69;&#110;&#101;&#110;&#64;&#104;&#x65;&#108;&#115;&#105;&#x6e;&#107;&#105;&#x2e;&#x66;&#x69;</a> <br/>
Signed-off-by: David S. Miller <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#x64;&#97;&#x76;&#101;&#x6d;&#x40;&#100;&#x61;&#x76;&#x65;&#109;&#x6c;&#x6f;&#102;&#116;&#x2e;&#110;&#101;&#116;">&#100;&#x61;&#x76;&#x65;&#109;&#x40;&#100;&#97;&#118;&#101;&#109;&#108;&#x6f;&#102;&#x74;&#x2e;&#x6e;&#x65;&#x74;</a></p>

<p>1 files changed, 2 insertions, 4 deletions
<code>
    diff --git a/net/ipv4/tcp_output.c b/net/ipv4/tcp_output.c
    index 8c8de27..4ff3b6d 100644
    --- a/net/ipv4/tcp_output.c
    +++ b/net/ipv4/tcp_output.c
    @@ -1141,11 +1141,9 @@ int tcp_trim_head(struct sock *sk, struct sk_buff *skb, u32 len)
        sk_mem_uncharge(sk, len);
        sock_set_flag(sk, SOCK_QUEUE_SHRUNK);
    -   /* Any change of skb-&gt;len requires recalculation of tso
    -    * factor and mss.
    -    */
    +   /* Any change of skb-&gt;len requires recalculation of tso factor. */
        if (tcp_skb_pcount(skb) &gt; 1)
    -       tcp_set_skb_tso_segs(sk, skb, tcp_current_mss(sk));
    +       tcp_set_skb_tso_segs(sk, skb, tcp_skb_mss(skb));
        return 0;
     }
</code></p>

<hr />

<p>会出现tp->packets_out不正确, 导致sk_write_queue为空时却掉tcp_rearm_rto()，判断tp->packets_out不为0，启动重传定时器，然后重传时取出的是list_head的地址，不是skb的地址，导致后面异常。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如果sk_write_queue异常]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/05/08/debug-mark-write_queue/"/>
    <updated>2015-05-08T14:14:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/05/08/debug-mark-write_queue</id>
    <content type="html"><![CDATA[<ul>
<li>注意，以下情况内核都不可能产生，纯属假设</li>
</ul>


<h4>一、连续的SYN/FIN</h4>

<pre><code>    |---FIN---|---SYN/FIN---|
        skb       next_skb
</code></pre>

<ul>
<li>内核不可能出现是因为：发送FIN包后就不再发包。所以FIN包只可能在sk_write_queue的最后一个包</li>
</ul>


<p>假设skb和next_skb发出去后都丢了，那tcp_retransmit_skb会重传skb，
重传的时候会调用tcp_retrans_try_collapse尝试去和下一个包合并。</p>

<p>skb和next_skb合并过程：<br/>
先检查一些条件，然后
<code>
    ...
    skb_copy_from_linear_data(next_skb, skb_put(skb, next_skb_size), next_skb_size);
    ...
    TCP_SKB_CB(skb)-&gt;end_seq = TCP_SKB_CB(next_skb)-&gt;end_seq;
</code>
也就是skb->len += next_skb->len; skb->end_seq = next_skb->end_seq;</p>

<p>假设:
<code>
    skb-&gt;len = 0;      skb-&gt;seq = 10;      skb-&gt;end_seq = 10 + FIN = 11;
    next_skb-&gt;len = 0; next_skb-&gt;seq = 11; next_skb-&gt;end_seq = 11 + SYN/FIN = 12;
</code>
那么合并后：
<code>
    skb-&gt;len = 0;      skb-&gt;seq = 10;      skb-&gt;end_seq = 12;
</code>
很明显不正常了，正常情况下：skb->len &lt;= skb->end_seq - skb->seq &lt;= skb->len+1</p>

<p>这时如果来了ack 11，那么会再重传合并后的skb，然后会调用tcp_trim_head(struct ws_st_sock <em>sk, struct sk_buff </em>skb, u32 len)，参数len = tp->snd_una - TCP_SKB_CB(skb)->seq = 1，但skb->len = 0;</p>

<p>tcp_trim_head函数中会：
<code>
    skb-&gt;len -= len;
</code>
这时skb->len = (U32)-1 = 0xFFFFFFFF，skb->len错误后，再调用skb_copy之类的就会访问越界，报BUG。
<code>
     821 struct sk_buff *skb_copy(const struct sk_buff *skb, gfp_t gfp_mask)
     822 {
            ......
     835         if (skb_copy_bits(skb, -headerlen, n-&gt;head, headerlen + skb-&gt;len))
     836                 BUG();
</code></p>

<h4>二、write_queue的skb->end_seq > next_skb->seq可能的问题</h4>

<ul>
<li>内核用tp->write_seq控制，保证了write_queue的skb->end_seq == next_skb->seq</li>
</ul>


<pre><code>    skb:       |------------------|
    next_skb:  |---------------------|

    假设skb已经发送出去，并被ack了，这时tp-&gt;snd_una = skb-&gt;end_seq
    此时再发送next_skb，并且mss变小了，需要对next_skb分包，分包后如下：

    skb:       |------------------|
    next_skb:  |-------|-------:-----|
                  skb1       skb2

    next_skb 被分成了两个包，skb1-&gt;len = mss, skb1-&gt;gso_segs = 1; skb2-&gt;len &gt; mss, skb2-&gt;gso_segs = 2;
    skb1, skb2发送出去，丢了，然后重传skb1，
    此时 skb1-&gt;end_seq &lt; tp-&gt;snd_una

    2092 int tcp_retransmit_skb(struct sock *sk, struct sk_buff *skb)
    2093 {
            ......
    2111         if (before(TCP_SKB_CB(skb)-&gt;seq, tp-&gt;snd_una)) {
    2112                 if (before(TCP_SKB_CB(skb)-&gt;end_seq, tp-&gt;snd_una))
    2113                         BUG();
</code></pre>

<h4>三、write_queue的skb->end_seq > next_skb->seq可能的问题</h4>

<pre><code>    skb:       |------------------|
    next_skb:  |---------------------|

    skb, next_skb 发送出去丢了，重传，调用tcp_retrans_try_collapse合并。
    合并后：skb-&gt;len += next_skb-&gt;len; skb-&gt;end_seq = next_skb-&gt;end_seq;

    假设   skb-&gt;len = 100;      skb-&gt;seq = 0;      skb-&gt;end_seq = 100;
          next_skb-&gt;len = 120  next_skb-&gt;seq = 0; next_skb-&gt;end_seq = 120;
    合并后 skb-&gt;len = 200;      skb-&gt;seq = 0;      skb-&gt;end_seq = 120;

    发送合并后的skb，再丢包，再重传，mss = 150，skb-&gt;len &gt; mss, 会分包
          skb-&gt;len = 150;      skb-&gt;seq = 0;      skb-&gt;end_seq = 150;
          next_skb-&gt;len = 50;  next_skb-&gt;seq = 150; next_skb-&gt;end_seq = 120;
    也就是出现了next_skb-&gt;seq &gt; next_skb-&gt;end_seq
    (此时如果ack skb也会把next_skb一起清了，因为next_skb-&gt;end_seq &lt; skb-&gt;end_seq)

    这时如果skb再重传分包，分成skb3，skb4
        skb3-&gt;len = 130;   skb3-&gt;seq = 0;   skb3-&gt;end_seq = 130;
        skb4-&gt;len = 20;    skb4-&gt;seq = 130; skb4-&gt;end_seq = 150;

    这时ack了skb3，tp-&gt;snd_una = 130 (虽然next_skb-&gt;end_seq &lt; skb3-&gt;end_seq, 但skb4-&gt;end_seq &gt; skb3-&gt;end_seq, 所以不会把next_skb清掉)
    重传skb4，skb5，此时skb5-&gt;end_seq &lt; tp-&gt;snd_una

    2092 int tcp_retransmit_skb(struct sock *sk, struct sk_buff *skb)
    2093 {
            ......
    2111         if (before(TCP_SKB_CB(skb)-&gt;seq, tp-&gt;snd_una)) {
    2112                 if (before(TCP_SKB_CB(skb)-&gt;end_seq, tp-&gt;snd_una))
    2113                         BUG();
</code></pre>

<h4>四、write_queue的skb->end_seq > next_skb->seq可能的问题</h4>

<pre><code>    skb:       |------------------|
    next_skb:  |---------------------|

    发送 skb，next_skb
    接收到 sack:|---------------------|

    调用tcp_sacktag_walk() ---&gt; tcp_shift_skb_data() 将多个被sack的包合并成一个。
    合并过程：
        skb-&gt;len += next_skb-&gt;len; skb-&gt;end_seq += next_skb-&gt;len;
    那么就会合并出一超出原来end_seq的包：
               |----------------------------------------|
    然后再ack:  |----------------------|
    这时把合并出的包trim掉一部分，剩skb7:  |-----------------|

    再发包skb_new:                     |-------|
    这时tp-&gt;snd_nxt = skb_new-&gt;end_seq
    再重传skb7, 并分包:                 |----------|------|
    分包时skb7-&gt;end_seq &gt; tp-&gt;snd_nxt, 所以不会调整tp-&gt;packets_out，
    但ack到来时(tcp_clean_rtx_queue)tp-&gt;packets_out却会减去分包后的gso_segs。
    导致tp-&gt;packets_out &lt; 0, 但sk_write_queue却是空的。
    tcp_rearm_rto()判断tp-&gt;packets_out不为0，启动重传定时器，然后重传时取出的是list_head的地址，不是skb的地址，导致后面异常。
    代码：
     974 int tcp_fragment(struct sock *sk, struct sk_buff *skb, u32 len,
     975                  unsigned int mss_now)
     976 {
        ......
    1047         if (!before(tp-&gt;snd_nxt, TCP_SKB_CB(buff)-&gt;end_seq)) {
    1048                 int diff = old_factor - tcp_skb_pcount(skb) -
    1049                         tcp_skb_pcount(buff);
    1050 
    1051                 if (diff)
    1052                         tcp_adjust_pcount(sk, skb, diff);
    1053         }
</code></pre>

<h4>五（发现好像没错）、write_queue的skb->end_seq > next_skb->seq可能的问题</h4>

<ul>
<li>内核用tp->write_seq控制，保证了write_queue的skb->end_seq == next_skb->seq</li>
</ul>


<pre><code>    skb:       |------------------|
    next_skb:  |---------------------|

    假设skb已经发送出去，这时tp-&gt;snd_nxt = skb-&gt;end_seq
    发送next_skb时mss变小了，需要对next_skb分包，分包后如下：

    skb:       |------------------|
    next_skb:  |-------|-------:-----|
                  skb1       skb2
    next_skb 被分成了两个包，skb1-&gt;len = mss, skb1-&gt;gso_segs = 1; skb2-&gt;len &gt; mss, skb2-&gt;gso_segs = 2;

    然后将skb1, skb2发送出去, tp-&gt;packets_out += 3; 这时假设ack了skb，清掉skb1和skb2的一个mss，。。。没错。。。
</code></pre>
]]></content>
  </entry>
  
</feed>
