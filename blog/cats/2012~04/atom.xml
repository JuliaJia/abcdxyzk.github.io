<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 2012~04 | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/2012~04/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2014-11-27T00:49:31+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[避免僵死进程]]></title>
    <link href="http://abcdxyzk.github.io/blog/2012/04/21/lang-c-fork/"/>
    <updated>2012-04-21T19:45:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2012/04/21/lang-c-fork</id>
    <content type="html"><![CDATA[<h4>一 两次fork避免僵死进程</h4>

<p>如果在一个进程A中启动了一个子进程B，但是B的执行时间可能很长，也可能很短。因此，既不希望A调用wait或者waitpid来等待B的完成（如果B执行时间太长，A的时间就耗费在等待B的完成了，虽然waitpid有WNOHANG选项，但免不了多次调用waitpid来看B是否完成）；也不希望如果B执行时间太短了，然后A又不用wait或waitpid去获取B的退出状态，那么B就一直处于僵死状态直到A终止（这样造成了资源的浪费）。</p>

<p>此时，可以使用一个小trick。就是调用两次fork，让B的父进程变成init进程（pid=1的那个进程，所有孤儿进程的父进程）。这样，A进程可以想干嘛干嘛去，B进程也可以想执行多久就执行多久了。
<code>
    #include &lt;unistd.h&gt;
    #include &lt;sys/wait.h&gt;
    int main()
    {
        pid_t pid;
        if((pid=fork())&lt;0)
        {
            printf("fork 1 error\n");
            exit(-1);
        }
        else if(pid==0）//第一个子进程
        {
            if((pid=fork())&lt;0)
            {
                printf("fork 2 error\n");
                exit(-1);
            }
            else if(pid&gt;0)//第二次fork产生的子进程（第二个子进程）的父进程，其实就是第一次fork产生的子进程（第一个子进程）
            {
                exit(0);//第一个子进程结束，那么它的子进程（第二个子进程）将由init进程领养，init进程成为第二个子进程的父进程
            }
            //第二个子进程（就是我们前面说的B进程）可以做他想做的事情了
            ................
        }
        if(waitpid(pid,NULL,0)!=pid)//获取第一个子进程的终止状态，不让它变成僵死进程
        printf("waitpid error\n");
        //父进程（就是我们前面说的A进程）也可以做他想做的事情了
        .........
        return 0;
    }
</code></p>

<h4>二</h4>

<p>父进程可以忽略 SIGCLD 软中断而不必要 wait()。可以这样做到(在支持它的系统上,比如Linux):　
<code>
    main()　　
    {　　
        signal(SIGCLD, SIG_IGN); /* now I don't have to wait()! */　　
        .......　　
        fork();　　
        fork();　　
        fork(); /* Rabbits, rabbits, rabbits! */　　
    ｝
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设置线程的栈空间]]></title>
    <link href="http://abcdxyzk.github.io/blog/2012/04/21/lang-c-set-thread-stack/"/>
    <updated>2012-04-21T19:32:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2012/04/21/lang-c-set-thread-stack</id>
    <content type="html"><![CDATA[<h1>include &lt;pthread.h></h1>

<pre><code>    pthread_attr_t thread_attr;
    size_t stack_size;
    int status;

    status = pthread_attr_init (&amp;thread_attr);
    if (status != 0)
        err_abort (status, "Create attr");

    status = pthread_attr_setdetachstate (&amp;thread_attr, PTHREAD_CREATE_DETACHED);

    if (status != 0)
        err_abort (status, "Set detach");
    //通常出现的问题之一，下面的宏没有定义
    #ifdef _POSIX_THREAD_ATTR_STACKSIZE
        //得到当前的线程栈大小
        status = pthread_attr_getstacksize (&amp;thread_attr, &amp;stack_size);
        if (status != 0)
            err_abort (status, "Get stack size");
        printf ("Default stack size is %u; minimum is %u\n", stack_size, PTHREAD_STACK_MIN);

        //设置当前的线程的大小
        status = pthread_attr_setstacksize (&amp;thread_attr, PTHREAD_STACK_MIN*1024);
        if (status != 0)
            err_abort (status, "Set stack size");

        //得到当前的线程栈的大小
        status = pthread_attr_getstacksize (&amp;thread_attr, &amp;stack_size);
        if (status != 0)
            err_abort (status, "Get stack size");
        printf ("Default stack size is %u; minimum is %u\n", stack_size, PTHREAD_STACK_MIN);
    #endif
</code></pre>
]]></content>
  </entry>
  
</feed>
