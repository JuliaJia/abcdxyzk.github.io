<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 2013~10 | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/2013~10/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2014-11-29T16:26:34+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[binutils(含as、ld等)静态编译]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/10/31/compiler-binutil-static/"/>
    <updated>2013-10-31T14:47:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/10/31/compiler-binutil-static</id>
    <content type="html"><![CDATA[<h4>静态编译</h4>

<pre><code>./configure 后加   CFLAGS=-static --enable-static LDFLAGS=-static --disable-shared
./configure 后加   CFLAGS=-static LDFLAGS=-static
</code></pre>

<h4>binutils-2.23.2 中gas、ld静态编译：</h4>

<pre><code>./configure
make
cd gas
make clean
make LDFLAGS=-all-static
</code></pre>

<p>或者
<code>
./configure
vim gas/Makefile
     搜 --mode=link，找到 LINK = $(LIBTOOL) --tag=CC ...
     在CC后面加个参数 -all-static
make
</code></p>

<h5>原因：</h5>

<p>他们链接的时候是通过 ./libtool 完成的，在libtool里有一行提示（./libtool &ndash;help没有显示这个提示)：
<code>
-all-static       do not do any dynamic linking at all
</code>
所以就是要libtool增加-all-static参数</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[--prefix]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/10/23/compiler-makefile-prefix/"/>
    <updated>2013-10-23T10:49:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/10/23/compiler-makefile-prefix</id>
    <content type="html"><![CDATA[<p>以安装supersparrow-0.0.0为例，我们打算把他安装到目录 /usr/local/supersparrow,于是在supersparrow-0.0.0目录执行带选项的脚本
<code>
./configure –prefix=/usr/local/supersparrow
</code>
执行成功后再编译、安装（make，make install）；安装完成将自动生成目录supersparrow,而且该软件任何的文档都被复制到这个目录。为什么要指定这个安装目录？是为了以后的维护方便，假如没有用这个选项，安装过程结束后，该软件所需的软件被复制到不同的系统目录下，很难弄清楚到底复制了那些文档、都复制到哪里去了—基本上是一塌糊涂。</p>

<p>用了—prefix选项的另一个好处是卸载软件或移植软件。当某个安装的软件不再需要时，只须简单的删除该安装目录，就能够把软件卸载得干干净净；移植软件只需拷贝整个目录到另外一个机器即可（相同的操作系统，不同系统用&ndash;target XXX）。</p>

<p>一个小选项有这么方便的作用，建议在实际工作中多多使用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LD_PRELOAD环境变量]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/10/22/tools-LD_PRELOAD/"/>
    <updated>2013-10-22T16:08:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/10/22/tools-LD_PRELOAD</id>
    <content type="html"><![CDATA[<p>在Linux的动态链接库的世界中，LD_PRELOAD就是这样一个环境变量，它可以影响程序的运行时的链接（Runtime linker），它允许你定义在程序运行前优先加载的动态链接库。这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。一方面，我们可以以此功能来使用自己的或是更好的函数（无需别人的源码），而另一方面，我们也可以以向别人的程序注入恶意程序，从而达到那不可告人的罪恶的目的。</p>

<p>我们知道，Linux的用的都是glibc，有一个叫libc.so.6的文件，这是几乎所有Linux下命令的动态链接中，其中有标准C的各种函数。对于GCC而言，默认情况下，所编译的程序中对标准C函数的链接，都是通过动态链接方式来链接libc.so.6这个函数库的。</p>

<p>OK。还是让我用一个例子来看一下用LD_PRELOAD来hack别人的程序。</p>

<h5>示例一</h5>

<p>我们写下面一段例程：
<code>
    /* 文件名：verifypasswd.c */
    /* 这是一段判断用户口令的程序，其中使用到了标准C函数strcmp*/
    #include &lt;stdio.h&gt;
    #include &lt;string.h&gt;
    int main(int argc, char **argv)
    {
        char passwd[] = "password";
        if (argc &lt; 2) {
            printf("usage: %s &lt;password&gt;/n", argv[0]);
            return 1;
        }
        if (!strcmp(passwd, argv[1])) {
            printf("Correct Password!/n");
            return 1;
        }
        printf("Invalid Password!/n");
        return 0;
    }
</code>
在上面这段程序中，我们使用了strcmp函数来判断两个字符串是否相等。下面，我们使用一个动态函数库来重载strcmp函数：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/&lt;em&gt; 文件名：hack.c &lt;/em&gt;/
</span><span class='line'>#include &lt;stdio.h&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;#include &lt;string.h&gt;
</span><span class='line'>int strcmp(const char *s1, const char *s2)
</span><span class='line'>{
</span><span class='line'>printf("hack function invoked. s1=&lt;%s&gt; s2=&lt;%s&gt;/n", s1, s2);
</span><span class='line'>/* 永远返回0，表示两个字符串相等 */
</span><span class='line'>return 0;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;编译程序：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;$ gcc -o verifypasswd verifypasswd.c
</span><span class='line'>$ gcc -shared -o hack.so hack.c
</span><span class='line'>&lt;code&gt;
</span><span class='line'>测试一下程序：（得到正确结果）
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>$ ./verifypasswd asdf
</span><span class='line'>Invalid Password!</span></code></pre></td></tr></table></div></figure></p>

<h5>设置LD_PRELOAD变量：</h5>

<p>（使我们重写过的strcmp函数的hack.so成为优先载入链接库）
<code>
$ export LD_PRELOAD="./hack.so"
</code>
再次运行程序：
<code>
$ ./verifypasswd  asdf
hack function invoked. s1=&lt;password&gt; s2=&lt;asdf&gt;
Correct Password!
</code>
我们可以看到，<br/>
1）我们的hack.so中的strcmp被调用了。<br/>
2）主程序中运行结果被影响了。<br/>
如果这是一个系统登录程序，那么这也就意味着我们用任意口令都可以进入系统了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Thunderbird]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/10/15/tools-thunderbird/"/>
    <updated>2013-10-15T10:10:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/10/15/tools-thunderbird</id>
    <content type="html"><![CDATA[<h4>Mozilla Thunderbird 最小化附加组建</h4>

<p>在工具->附加组建中<br/>
1、搜索minimize，安装firetray<br/>
2、firetray 首选项->邮件->邮件通知类型   选第二个：显示新邮件图示<br/>
不想最小化到托盘： firetray 首选项->视窗   去掉第二个勾选</p>

<h4>Mozilla Thunderbird 导入导出邮件</h4>

<p>一种Mozilla Thunderbird的扩展ImportExportTools。<br/>
<a href="https://addons.mozilla.org/zh-CN/thunderbird/addon/importexporttools/">https://addons.mozilla.org/zh-CN/thunderbird/addon/importexporttools/</a></p>

<h5>安装流程 （本地安装）</h5>

<pre><code>1 进入Mozilla Thunderbird
2 点击菜单栏的“工具”-&gt;“附加软件”
3 从附加组件搜索框旁边的选项按钮中，选择“从文件安装附加组件...”选项
4 选择本地文件（ImportExportTools-X.X.xpi）位置 安装
5 安装完成 重启Mozilla Thunderbird
</code></pre>

<h5>如何用呢</h5>

<pre><code>1 进入Mozilla Thunderbird
2 右键“收件箱”
3 “导入/导出”
4 “汇出此资料夹所以的邮件” 进行选择格式
5 汇出完成 查看本地文件夹
</code></pre>
]]></content>
  </entry>
  
</feed>
