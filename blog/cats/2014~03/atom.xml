<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 2014~03 | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/2014~03/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2014-11-25T18:07:20+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[const的使用]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/03/17/lang-c-const/"/>
    <updated>2014-03-17T17:31:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/03/17/lang-c-const</id>
    <content type="html"><![CDATA[<h4>1、定义常量</h4>

<h5>(1)const修饰变量</h5>

<p>以下两种定义形式在本质上是一样的。<br/>
它的含义是：const修饰的类型为TYPE的变量value是不可变的。
<code>
    TYPE const ValueName = value;
    const TYPE ValueName = value;
</code></p>

<h5>(2)将const改为外部连接</h5>

<p>作用于扩大至全局,编译时会分配内存,并且可以不进行初始化,仅仅作为声明,编译器认为在程序其他地方进行了定义.
<code>
    extend const int ValueName = value;
</code></p>

<h4><span style="color:red">2、指针使用CONST</span></h4>

<h5>(1)指针本身是常量不可变</h5>

<pre><code>    (char*) const pContent;
    const (char*) pContent;
</code></pre>

<h5>(2)指针所指向的内容是常量不可变</h5>

<pre><code>    const (char) *pContent;
    (char) const *pContent;
</code></pre>

<h5>(3)两者都不可变</h5>

<pre><code>    const char* const pContent;
</code></pre>

<h5>(4)还有其中区别方法，沿着*号划一条线：</h5>

<p>如果const位于<em>的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；<br/>
如果const位于</em>的右侧，const就是修饰指针本身，即指针本身是常量。</p>

<h4>3、函数中使用CONST</h4>

<h5>(1)const修饰函数参数</h5>

<h6>a.传递过来的参数在函数内不可以改变(无意义，因为Var本身就是形参)</h6>

<pre><code>    void function(const int Var);
</code></pre>

<h6>b.参数指针所指内容为常量不可变</h6>

<pre><code>    void function(const char* Var);
</code></pre>

<h6>c.参数指针本身为常量不可变(也无意义，因为char* Var也是形参)</h6>

<pre><code>    void function(char* const Var);
</code></pre>

<h6>d.参数为引用，为了增加效率同时防止修改。修饰引用参数时：</h6>

<pre><code>    void function(const Class&amp; Var);//引用参数在函数内不可以改变
    void function(const TYPE&amp; Var); //引用参数在函数内为常量不可变
</code></pre>

<p>这样的一个const引用传递和最普通的函数按值传递的效果是一模一样的,他禁止对引用的对象的一切修改,唯一不同的是按值传递会先建立一个类对象的副本, 然后传递过去,而它直接传递地址,所以这种传递比按值传递更有效.另外只有引用的const传递可以传递一个临时对象,因为临时对象都是const属性, 且是不可见的,他短时间存在一个局部域中,所以不能使用指针,只有引用的const传递能够捕捉到这个家伙.</p>

<h5>(2)const 修饰函数返回值</h5>

<p>const修饰函数返回值其实用的并不是很多，它的含义和const修饰普通变量以及指针的含义基本相同。</p>

<h6>a.</h6>

<p>const int fun1() // 这个其实无意义，因为参数返回本身就是赋值。</p>

<h6>b.</h6>

<p>const int * fun2() //调用时 const int *pValue = fun2();<br/>
                   //我们可以把fun2()看作成一个变量，即指针内容不可变。</p>

<h6>c.</h6>

<p>int* const fun3()   //调用时 int * const pValue = fun2();<br/>
                    //我们可以把fun2()看作成一个变量，即指针本身不可变。</p>

<p>一般情况下，函数的返回值为某个对象时，如果将其声明为const时，多用于操作符的重载。<br/>
通常，不建议用const修饰函数的返回值类型为某个对象或对某个对象引用的情况。<br/>
原因如下：<br/>
如果返回值为某个对象为const（const A test = A 实例）或某个对象的引用为const（const A&amp; test = A实例） ，<br/>
则返回值具有const属性，则返回实例只能访问类A中的公有（保护）数据成员和const成员函数，<br/>
并且不允许对其进行赋值操作，这在一般情况下很少用到。</p>
]]></content>
  </entry>
  
</feed>
