<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: kernel~mm | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/kernel~mm/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2015-04-18T23:57:14+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Linux slab 分配器]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/03/03/kernel-mm-slab2/"/>
    <updated>2015-03-03T17:32:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/03/03/kernel-mm-slab2</id>
    <content type="html"><![CDATA[<p><a href="http://www.linuxidc.com/Linux/2012-06/62965.htm">Linux Slab分配器(一)-概述</a><br/>
<a href="http://www.linuxidc.com/Linux/2012-06/62966.htm">Linux Slab分配器(二)-初始化</a><br/>
<a href="http://www.linuxidc.com/Linux/2012-06/63109.htm">Linux Slab分配器(三)-创建缓存</a><br/>
<a href="http://www.linuxidc.com/Linux/2012-06/63138.htm">Linux Slab分配器(四)-分配对象</a></p>

<h2>一、概述</h2>

<p>  slab分配器是Linux内存管理中非常重要和复杂的一部分，其工作是针对一些经常分配并释放的对象，如进程描述符等，这些对象的大小一般比较小，如果直接采用伙伴系统来进行分配和释放，不仅会造成大量的内碎片，而且处理速度也太慢。而slab分配器是基于对象进行管理的，相同类型的对象归为一类(如进程描述符就是一类)，每当要申请这样一个对象，slab分配器就从一个slab列表中分配一个这样大小的单元出去，而当要释放时，将其重新保存在该列表中，而不是直接返回给伙伴系统。slab分配对象时，会使用最近释放的对象内存块，因此其驻留在CPU高速缓存的概率较高。</p>

<h5>用于描述和管理cache的数据结构是struct kmem_cache</h5>

<pre><code>    struct kmem_cache {  
    /* 1) per-cpu data, touched during every alloc/free */  
        /*per-CPU数据，记录了本地高速缓存的信息，也用于跟踪最近释放的对象，每次分配和释放都要直接访问它*/  
        struct array_cache *array[NR_CPUS];   
    /* 2) Cache tunables. Protected by cache_chain_mutex */  
        unsigned int batchcount;  /*本地高速缓存转入或转出的大批对象数量*/  
        unsigned int limit;       /*本地高速缓存中空闲对象的最大数目*/  
        unsigned int shared;  

        unsigned int buffer_size;/*管理对象的大小*/  
        u32 reciprocal_buffer_size;/*buffer_size的倒数值*/  
    /* 3) touched by every alloc &amp; free from the backend */  

        unsigned int flags;          /* 高速缓存的永久标识*/  
        unsigned int num;         /* 一个slab所包含的对象数目 */  

    /* 4) cache_grow/shrink */  
        /* order of pgs per slab (2^n) */  
        unsigned int gfporder;   /*一个slab包含的连续页框数的对数*/  

        /* force GFP flags, e.g. GFP_DMA */  
        gfp_t gfpflags;          /*与伙伴系统交互时所提供的分配标识*/  

        size_t colour;         /* 颜色的个数*/  
        unsigned int colour_off; /* 着色的偏移量 */  

        /*如果将slab描述符存储在外部，该指针指向存储slab描述符的cache, 
          否则为NULL*/  
        struct kmem_cache *slabp_cache;  
        unsigned int slab_size;  /*slab管理区的大小*/  
        unsigned int dflags;     /*动态标识*/  

        /* constructor func */  
        void (*ctor)(void *obj); /*创建高速缓存时的构造函数指针*/  

    /* 5) cache creation/removal */  
        const char *name;         /*高速缓存名*/  
        struct list_head next;    /*用于将高速缓存链入cache chain*/  

    /* 6) statistics */  
    #ifdef CONFIG_DEBUG_SLAB /*一些用于调试用的变量*/   
        unsigned long num_active;  
        unsigned long num_allocations;  
        unsigned long high_mark;  
        unsigned long grown;  
        unsigned long reaped;  
        unsigned long errors;  
        unsigned long max_freeable;  
        unsigned long node_allocs;  
        unsigned long node_frees;  
        unsigned long node_overflow;  
        atomic_t allochit;  
        atomic_t allocmiss;  
        atomic_t freehit;  
        atomic_t freemiss;  

        /* 
         * If debugging is enabled, then the allocator can add additional 
         * fields and/or padding to every object. buffer_size contains the total 
         * object size including these internal fields, the following two 
         * variables contain the offset to the user object and its size. 
         */  
        int obj_offset;  
        int obj_size;  
    #endif /* CONFIG_DEBUG_SLAB */   

        /* 
         * We put nodelists[] at the end of kmem_cache, because we want to size 
         * this array to nr_node_ids slots instead of MAX_NUMNODES 
         * (see kmem_cache_init()) 
         * We still use [MAX_NUMNODES] and not [1] or [0] because cache_cache 
         * is statically defined, so we reserve the max number of nodes. 
         */  
         /*struct kmem_list3用于组织该高速缓存中的slab*/  
        struct kmem_list3 *nodelists[MAX_NUMNODES];  
        /* 
         * Do not add fields after nodelists[] 
         */  
    }; 
</code></pre>

<pre><code>    struct kmem_list3 {  
        struct list_head slabs_partial;/*slab链表，包含空闲对象和已分配对象的slab描述符*/  
        struct list_head slabs_full;   /*slab链表，只包含非空闲的slab描述符*/  
        struct list_head slabs_free;   /*slab链表，只包含空闲的slab描述符*/  
        unsigned long free_objects;    /*高速缓存中空闲对象的个数*/  
        unsigned int free_limit;       /*空闲对象的上限*/  
        unsigned int colour_next;       /*下一个slab使用的颜色*/  
        spinlock_t list_lock;  
        struct array_cache *shared; /* shared per node */  
        struct array_cache **alien; /* on other nodes */  
        unsigned long next_reap;    /* updated without locking */  
        int free_touched;       /* updated without locking */  
    };  
</code></pre>

<h5>描述和管理单个slab的结构是struct slab</h5>

<pre><code>    struct slab {  
        struct list_head list;  /*用于将slab链入kmem_list3的链表*/  
        unsigned long colouroff;/*该slab的着色偏移*/  
        void *s_mem;            /*指向slab中的第一个对象*/  
        unsigned int inuse;     /*已分配出去的对象*/  
        kmem_bufctl_t free;     /*下一个空闲对象的下标*/  
        unsigned short nodeid;  /*节点标识号*/  
    };
</code></pre>

<!-- more -->


<p>  还要介绍的一个数据结构就是struct array_cache。struct kmem_cache中定义了一个struct array_cache指针数组，数组的元素个数对应了系统的CPU数，和伙伴系统中的每CPU页框高速缓存类似，该结构用来描述每个CPU的本地高速缓存，它可以减少SMP系统中对于自旋锁的竞争。在每个array_cache的末端都用一个指针数组记录了slab中的空闲对象，分配对象时，采用LIFO方式，也就是将该数组中的最后一个索引对应的对象分配出去，以保证该对象还驻留在高速缓存中的可能性。实际上，每次分配内存都是直接与本地CPU高速缓存进行交互，只有当其空闲内存不足时，才会从kmem_list中的slab中引入一部分对象到本地高速缓存中，而kmem_list中的空闲对象也不足了，那么就要从伙伴系统中引入新的页来建立新的slab了，这一点也和伙伴系统的每CPU页框高速缓存很类似。
<code>
    struct array_cache {  
        unsigned int avail;/*本地高速缓存中可用的空闲对象数*/  
        unsigned int limit;/*空闲对象的上限*/  
        unsigned int batchcount;/*一次转入和转出的对象数量*/  
        unsigned int touched;   /*标识本地CPU最近是否被使用*/  
        spinlock_t lock;  
        void *entry[];  /*这是一个伪数组，便于对后面用于跟踪空闲对象的指针数组的访问
                 * Must have this definition in here for the proper
                 * alignment of array_cache. Also simplifies accessing
                 * the entries.
                 */  
    };
</code></p>

<p>slab分配器涉及到了一些繁杂的概念，这些在后面再逐一结合代码进行讲解，在理解slab分配器的工作之前，必须先理解上述这些数据结构之间的联系，下图给出了一个清晰的描述</p>

<p><img src="/images/kernel/2015-03-03-11.png" alt="" /></p>

<h2>二、初始化</h2>

<p>在前文中介绍了slab所涉及到的数据结构， slab分配器的初始化工作都是围绕这些数据结构来展开的，主要是针对以下两个问题:<br/>
1. 创建kmem_cache高速缓存用来存储所有的cache描述符<br/>
2. 创建array_cache和kmem_list3高速缓存用来存储slab数据结构中的这两个关键结构</p>

<p>这里明显有点自相矛盾，那就是slab管理器尚未建立起来，又如何靠slab分配高速缓存来给这些结构分配空间呢？</p>

<p>  解决第一个问题的方法是直接静态定义一个名为cache_cache的kmem_cache结构，来管理所有的kmem_cache描述符，对于array_cache和kmem_list3，内核也是先静态定义，然后建立起普通高速缓存(general cache)，再使用kmalloc分配普通高速缓存空间来替代之前静态定义的部分。</p>

<h5>普通高速缓存是一组大小按几何倍数增长的高速缓存的合集，一个普通高速缓存用如下结构描述</h5>

<pre><code>    /* Size description struct for general caches. */  
    struct cache_sizes {  
        size_t          cs_size;   /*general cache的大小*/  
        struct kmem_cache   *cs_cachep;         /*general cache的cache描述符指针*/  
    #ifdef CONFIG_ZONE_DMA   
        struct kmem_cache   *cs_dmacachep;  
    #endif   
    };
</code></pre>

<p>普通高速缓存的大小由malloc_sizes表来确定
<code>
    /*
     * These are the default caches for kmalloc. Custom caches can have other sizes.
     */  
    struct cache_sizes malloc_sizes[] = {  
    #define CACHE(x) { .cs_size = (x) },   
    #include &lt;linux/kmalloc_sizes.h&gt;   
        CACHE(ULONG_MAX)  
    #undef CACHE   
    };
</code>
其中&lt;linux/kmalloc_sizes.h>中的内容为
<code>
    #if (PAGE_SIZE == 4096)   
        CACHE(32)  
    #endif   
        CACHE(64)  
    #if L1_CACHE_BYTES &lt; 64   
        CACHE(96)  
    #endif   
        CACHE(128)  
    #if L1_CACHE_BYTES &lt; 128   
        CACHE(192)  
    #endif   
        CACHE(256)  
        CACHE(512)  
        CACHE(1024)  
        CACHE(2048)  
        CACHE(4096)  
        CACHE(8192)  
        CACHE(16384)  
        CACHE(32768)  
        CACHE(65536)  
        CACHE(131072)  
    #if KMALLOC_MAX_SIZE &gt;= 262144   
        CACHE(262144)  
    #endif   
    #if KMALLOC_MAX_SIZE &gt;= 524288   
        CACHE(524288)  
    #endif   
    #if KMALLOC_MAX_SIZE &gt;= 1048576   
        CACHE(1048576)  
    #endif   
    #if KMALLOC_MAX_SIZE &gt;= 2097152   
        CACHE(2097152)  
    #endif   
    #if KMALLOC_MAX_SIZE &gt;= 4194304   
        CACHE(4194304)  
    #endif   
    #if KMALLOC_MAX_SIZE &gt;= 8388608   
        CACHE(8388608)  
    #endif   
    #if KMALLOC_MAX_SIZE &gt;= 16777216   
        CACHE(16777216)  
    #endif   
    #if KMALLOC_MAX_SIZE &gt;= 33554432   
        CACHE(33554432)  
    #endif
</code></p>

<h5>cache_cache的初始化和普通高速缓存的建立</h5>

<p>由<code>start_kernel()--&gt;mm_init()--&gt;kmem_cache_init()</code>函数来完成，下面就来看具体的初始化代码
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
<span class='line-number'>206</span>
<span class='line-number'>207</span>
<span class='line-number'>208</span>
<span class='line-number'>209</span>
<span class='line-number'>210</span>
<span class='line-number'>211</span>
<span class='line-number'>212</span>
<span class='line-number'>213</span>
<span class='line-number'>214</span>
<span class='line-number'>215</span>
<span class='line-number'>216</span>
<span class='line-number'>217</span>
<span class='line-number'>218</span>
<span class='line-number'>219</span>
<span class='line-number'>220</span>
<span class='line-number'>221</span>
<span class='line-number'>222</span>
<span class='line-number'>223</span>
<span class='line-number'>224</span>
<span class='line-number'>225</span>
<span class='line-number'>226</span>
<span class='line-number'>227</span>
<span class='line-number'>228</span>
<span class='line-number'>229</span>
<span class='line-number'>230</span>
<span class='line-number'>231</span>
<span class='line-number'>232</span>
<span class='line-number'>233</span>
<span class='line-number'>234</span>
<span class='line-number'>235</span>
<span class='line-number'>236</span>
<span class='line-number'>237</span>
<span class='line-number'>238</span>
<span class='line-number'>239</span>
<span class='line-number'>240</span>
<span class='line-number'>241</span>
<span class='line-number'>242</span>
<span class='line-number'>243</span>
<span class='line-number'>244</span>
<span class='line-number'>245</span>
<span class='line-number'>246</span>
<span class='line-number'>247</span>
<span class='line-number'>248</span>
<span class='line-number'>249</span>
<span class='line-number'>250</span>
<span class='line-number'>251</span>
<span class='line-number'>252</span>
<span class='line-number'>253</span>
<span class='line-number'>254</span>
<span class='line-number'>255</span>
<span class='line-number'>256</span>
<span class='line-number'>257</span>
<span class='line-number'>258</span>
<span class='line-number'>259</span>
<span class='line-number'>260</span>
<span class='line-number'>261</span>
<span class='line-number'>262</span>
<span class='line-number'>263</span>
<span class='line-number'>264</span>
<span class='line-number'>265</span>
<span class='line-number'>266</span>
<span class='line-number'>267</span>
<span class='line-number'>268</span>
<span class='line-number'>269</span>
<span class='line-number'>270</span>
<span class='line-number'>271</span>
<span class='line-number'>272</span>
<span class='line-number'>273</span>
<span class='line-number'>274</span>
<span class='line-number'>275</span>
<span class='line-number'>276</span>
<span class='line-number'>277</span>
<span class='line-number'>278</span>
<span class='line-number'>279</span>
<span class='line-number'>280</span>
<span class='line-number'>281</span>
<span class='line-number'>282</span>
<span class='line-number'>283</span>
<span class='line-number'>284</span>
<span class='line-number'>285</span>
<span class='line-number'>286</span>
<span class='line-number'>287</span>
<span class='line-number'>288</span>
<span class='line-number'>289</span>
<span class='line-number'>290</span>
<span class='line-number'>291</span>
<span class='line-number'>292</span>
<span class='line-number'>293</span>
<span class='line-number'>294</span>
<span class='line-number'>295</span>
<span class='line-number'>296</span>
<span class='line-number'>297</span>
<span class='line-number'>298</span>
<span class='line-number'>299</span>
<span class='line-number'>300</span>
<span class='line-number'>301</span>
<span class='line-number'>302</span>
<span class='line-number'>303</span>
<span class='line-number'>304</span>
<span class='line-number'>305</span>
<span class='line-number'>306</span>
<span class='line-number'>307</span>
<span class='line-number'>308</span>
<span class='line-number'>309</span>
<span class='line-number'>310</span>
<span class='line-number'>311</span>
<span class='line-number'>312</span>
<span class='line-number'>313</span>
<span class='line-number'>314</span>
<span class='line-number'>315</span>
<span class='line-number'>316</span>
<span class='line-number'>317</span>
<span class='line-number'>318</span>
<span class='line-number'>319</span>
<span class='line-number'>320</span>
<span class='line-number'>321</span>
<span class='line-number'>322</span>
<span class='line-number'>323</span>
<span class='line-number'>324</span>
<span class='line-number'>325</span>
<span class='line-number'>326</span>
<span class='line-number'>327</span>
<span class='line-number'>328</span>
<span class='line-number'>329</span>
<span class='line-number'>330</span>
<span class='line-number'>331</span>
<span class='line-number'>332</span>
<span class='line-number'>333</span>
<span class='line-number'>334</span>
<span class='line-number'>335</span>
<span class='line-number'>336</span>
<span class='line-number'>337</span>
<span class='line-number'>338</span>
<span class='line-number'>339</span>
<span class='line-number'>340</span>
<span class='line-number'>341</span>
<span class='line-number'>342</span>
<span class='line-number'>343</span>
<span class='line-number'>344</span>
<span class='line-number'>345</span>
<span class='line-number'>346</span>
<span class='line-number'>347</span>
<span class='line-number'>348</span>
<span class='line-number'>349</span>
<span class='line-number'>350</span>
<span class='line-number'>351</span>
<span class='line-number'>352</span>
<span class='line-number'>353</span>
<span class='line-number'>354</span>
<span class='line-number'>355</span>
<span class='line-number'>356</span>
<span class='line-number'>357</span>
<span class='line-number'>358</span>
<span class='line-number'>359</span>
<span class='line-number'>360</span>
<span class='line-number'>361</span>
<span class='line-number'>362</span>
<span class='line-number'>363</span>
<span class='line-number'>364</span>
<span class='line-number'>365</span>
<span class='line-number'>366</span>
<span class='line-number'>367</span>
<span class='line-number'>368</span>
<span class='line-number'>369</span>
<span class='line-number'>370</span>
<span class='line-number'>371</span>
<span class='line-number'>372</span>
<span class='line-number'>373</span>
<span class='line-number'>374</span>
<span class='line-number'>375</span>
<span class='line-number'>376</span>
<span class='line-number'>377</span>
<span class='line-number'>378</span>
<span class='line-number'>379</span>
<span class='line-number'>380</span>
<span class='line-number'>381</span>
<span class='line-number'>382</span>
<span class='line-number'>383</span>
<span class='line-number'>384</span>
<span class='line-number'>385</span>
<span class='line-number'>386</span>
<span class='line-number'>387</span>
<span class='line-number'>388</span>
<span class='line-number'>389</span>
<span class='line-number'>390</span>
<span class='line-number'>391</span>
<span class='line-number'>392</span>
<span class='line-number'>393</span>
<span class='line-number'>394</span>
<span class='line-number'>395</span>
<span class='line-number'>396</span>
<span class='line-number'>397</span>
<span class='line-number'>398</span>
<span class='line-number'>399</span>
<span class='line-number'>400</span>
<span class='line-number'>401</span>
<span class='line-number'>402</span>
<span class='line-number'>403</span>
<span class='line-number'>404</span>
<span class='line-number'>405</span>
<span class='line-number'>406</span>
<span class='line-number'>407</span>
<span class='line-number'>408</span>
<span class='line-number'>409</span>
<span class='line-number'>410</span>
<span class='line-number'>411</span>
<span class='line-number'>412</span>
<span class='line-number'>413</span>
<span class='line-number'>414</span>
<span class='line-number'>415</span>
<span class='line-number'>416</span>
<span class='line-number'>417</span>
<span class='line-number'>418</span>
<span class='line-number'>419</span>
<span class='line-number'>420</span>
<span class='line-number'>421</span>
<span class='line-number'>422</span>
<span class='line-number'>423</span>
<span class='line-number'>424</span>
<span class='line-number'>425</span>
<span class='line-number'>426</span>
<span class='line-number'>427</span>
<span class='line-number'>428</span>
<span class='line-number'>429</span>
<span class='line-number'>430</span>
<span class='line-number'>431</span>
<span class='line-number'>432</span>
<span class='line-number'>433</span>
<span class='line-number'>434</span>
<span class='line-number'>435</span>
<span class='line-number'>436</span>
<span class='line-number'>437</span>
<span class='line-number'>438</span>
<span class='line-number'>439</span>
<span class='line-number'>440</span>
<span class='line-number'>441</span>
<span class='line-number'>442</span>
<span class='line-number'>443</span>
<span class='line-number'>444</span>
<span class='line-number'>445</span>
<span class='line-number'>446</span>
<span class='line-number'>447</span>
<span class='line-number'>448</span>
<span class='line-number'>449</span>
<span class='line-number'>450</span>
<span class='line-number'>451</span>
<span class='line-number'>452</span>
<span class='line-number'>453</span>
<span class='line-number'>454</span>
<span class='line-number'>455</span>
<span class='line-number'>456</span>
<span class='line-number'>457</span>
<span class='line-number'>458</span>
<span class='line-number'>459</span>
<span class='line-number'>460</span>
<span class='line-number'>461</span>
<span class='line-number'>462</span>
<span class='line-number'>463</span>
<span class='line-number'>464</span>
<span class='line-number'>465</span>
<span class='line-number'>466</span>
<span class='line-number'>467</span>
<span class='line-number'>468</span>
<span class='line-number'>469</span>
<span class='line-number'>470</span>
<span class='line-number'>471</span>
<span class='line-number'>472</span>
<span class='line-number'>473</span>
<span class='line-number'>474</span>
<span class='line-number'>475</span>
<span class='line-number'>476</span>
<span class='line-number'>477</span>
<span class='line-number'>478</span>
<span class='line-number'>479</span>
<span class='line-number'>480</span>
<span class='line-number'>481</span>
<span class='line-number'>482</span>
<span class='line-number'>483</span>
<span class='line-number'>484</span>
<span class='line-number'>485</span>
<span class='line-number'>486</span>
<span class='line-number'>487</span>
<span class='line-number'>488</span>
<span class='line-number'>489</span>
<span class='line-number'>490</span>
<span class='line-number'>491</span>
<span class='line-number'>492</span>
<span class='line-number'>493</span>
<span class='line-number'>494</span>
<span class='line-number'>495</span>
<span class='line-number'>496</span>
<span class='line-number'>497</span>
<span class='line-number'>498</span>
<span class='line-number'>499</span>
<span class='line-number'>500</span>
<span class='line-number'>501</span>
<span class='line-number'>502</span>
<span class='line-number'>503</span>
<span class='line-number'>504</span>
<span class='line-number'>505</span>
<span class='line-number'>506</span>
<span class='line-number'>507</span>
<span class='line-number'>508</span>
<span class='line-number'>509</span>
<span class='line-number'>510</span>
<span class='line-number'>511</span>
<span class='line-number'>512</span>
<span class='line-number'>513</span>
<span class='line-number'>514</span>
<span class='line-number'>515</span>
<span class='line-number'>516</span>
<span class='line-number'>517</span>
<span class='line-number'>518</span>
<span class='line-number'>519</span>
<span class='line-number'>520</span>
<span class='line-number'>521</span>
<span class='line-number'>522</span>
<span class='line-number'>523</span>
<span class='line-number'>524</span>
<span class='line-number'>525</span>
<span class='line-number'>526</span>
<span class='line-number'>527</span>
<span class='line-number'>528</span>
<span class='line-number'>529</span>
<span class='line-number'>530</span>
<span class='line-number'>531</span>
<span class='line-number'>532</span>
<span class='line-number'>533</span>
<span class='line-number'>534</span>
<span class='line-number'>535</span>
<span class='line-number'>536</span>
<span class='line-number'>537</span>
<span class='line-number'>538</span>
<span class='line-number'>539</span>
<span class='line-number'>540</span>
<span class='line-number'>541</span>
<span class='line-number'>542</span>
<span class='line-number'>543</span>
<span class='line-number'>544</span>
<span class='line-number'>545</span>
<span class='line-number'>546</span>
<span class='line-number'>547</span>
<span class='line-number'>548</span>
<span class='line-number'>549</span>
<span class='line-number'>550</span>
<span class='line-number'>551</span>
<span class='line-number'>552</span>
<span class='line-number'>553</span>
<span class='line-number'>554</span>
<span class='line-number'>555</span>
<span class='line-number'>556</span>
<span class='line-number'>557</span>
<span class='line-number'>558</span>
<span class='line-number'>559</span>
<span class='line-number'>560</span>
<span class='line-number'>561</span>
<span class='line-number'>562</span>
<span class='line-number'>563</span>
<span class='line-number'>564</span>
<span class='line-number'>565</span>
<span class='line-number'>566</span>
<span class='line-number'>567</span>
<span class='line-number'>568</span>
<span class='line-number'>569</span>
<span class='line-number'>570</span>
<span class='line-number'>571</span>
<span class='line-number'>572</span>
<span class='line-number'>573</span>
<span class='line-number'>574</span>
<span class='line-number'>575</span>
<span class='line-number'>576</span>
<span class='line-number'>577</span>
<span class='line-number'>578</span>
<span class='line-number'>579</span>
<span class='line-number'>580</span>
<span class='line-number'>581</span>
<span class='line-number'>582</span>
<span class='line-number'>583</span>
<span class='line-number'>584</span>
<span class='line-number'>585</span>
<span class='line-number'>586</span>
<span class='line-number'>587</span>
<span class='line-number'>588</span>
<span class='line-number'>589</span>
<span class='line-number'>590</span>
<span class='line-number'>591</span>
<span class='line-number'>592</span>
<span class='line-number'>593</span>
<span class='line-number'>594</span>
<span class='line-number'>595</span>
<span class='line-number'>596</span>
<span class='line-number'>597</span>
<span class='line-number'>598</span>
<span class='line-number'>599</span>
<span class='line-number'>600</span>
<span class='line-number'>601</span>
<span class='line-number'>602</span>
<span class='line-number'>603</span>
<span class='line-number'>604</span>
<span class='line-number'>605</span>
<span class='line-number'>606</span>
<span class='line-number'>607</span>
<span class='line-number'>608</span>
<span class='line-number'>609</span>
<span class='line-number'>610</span>
<span class='line-number'>611</span>
<span class='line-number'>612</span>
<span class='line-number'>613</span>
<span class='line-number'>614</span>
<span class='line-number'>615</span>
<span class='line-number'>616</span>
<span class='line-number'>617</span>
<span class='line-number'>618</span>
<span class='line-number'>619</span>
<span class='line-number'>620</span>
<span class='line-number'>621</span>
<span class='line-number'>622</span>
<span class='line-number'>623</span>
<span class='line-number'>624</span>
<span class='line-number'>625</span>
<span class='line-number'>626</span>
<span class='line-number'>627</span>
<span class='line-number'>628</span>
<span class='line-number'>629</span>
<span class='line-number'>630</span>
<span class='line-number'>631</span>
<span class='line-number'>632</span>
<span class='line-number'>633</span>
<span class='line-number'>634</span>
<span class='line-number'>635</span>
<span class='line-number'>636</span>
<span class='line-number'>637</span>
<span class='line-number'>638</span>
<span class='line-number'>639</span>
<span class='line-number'>640</span>
<span class='line-number'>641</span>
<span class='line-number'>642</span>
<span class='line-number'>643</span>
<span class='line-number'>644</span>
<span class='line-number'>645</span>
<span class='line-number'>646</span>
<span class='line-number'>647</span>
<span class='line-number'>648</span>
<span class='line-number'>649</span>
<span class='line-number'>650</span>
<span class='line-number'>651</span>
<span class='line-number'>652</span>
<span class='line-number'>653</span>
<span class='line-number'>654</span>
<span class='line-number'>655</span>
<span class='line-number'>656</span>
<span class='line-number'>657</span>
<span class='line-number'>658</span>
<span class='line-number'>659</span>
<span class='line-number'>660</span>
<span class='line-number'>661</span>
<span class='line-number'>662</span>
<span class='line-number'>663</span>
<span class='line-number'>664</span>
<span class='line-number'>665</span>
<span class='line-number'>666</span>
<span class='line-number'>667</span>
<span class='line-number'>668</span>
<span class='line-number'>669</span>
<span class='line-number'>670</span>
<span class='line-number'>671</span>
<span class='line-number'>672</span>
<span class='line-number'>673</span>
<span class='line-number'>674</span>
<span class='line-number'>675</span>
<span class='line-number'>676</span>
<span class='line-number'>677</span>
<span class='line-number'>678</span>
<span class='line-number'>679</span>
<span class='line-number'>680</span>
<span class='line-number'>681</span>
<span class='line-number'>682</span>
<span class='line-number'>683</span>
<span class='line-number'>684</span>
<span class='line-number'>685</span>
<span class='line-number'>686</span>
<span class='line-number'>687</span>
<span class='line-number'>688</span>
<span class='line-number'>689</span>
<span class='line-number'>690</span>
<span class='line-number'>691</span>
<span class='line-number'>692</span>
<span class='line-number'>693</span>
<span class='line-number'>694</span>
<span class='line-number'>695</span>
<span class='line-number'>696</span>
<span class='line-number'>697</span>
<span class='line-number'>698</span>
<span class='line-number'>699</span>
<span class='line-number'>700</span>
<span class='line-number'>701</span>
<span class='line-number'>702</span>
<span class='line-number'>703</span>
<span class='line-number'>704</span>
<span class='line-number'>705</span>
<span class='line-number'>706</span>
<span class='line-number'>707</span>
<span class='line-number'>708</span>
<span class='line-number'>709</span>
<span class='line-number'>710</span>
<span class='line-number'>711</span>
<span class='line-number'>712</span>
<span class='line-number'>713</span>
<span class='line-number'>714</span>
<span class='line-number'>715</span>
<span class='line-number'>716</span>
<span class='line-number'>717</span>
<span class='line-number'>718</span>
<span class='line-number'>719</span>
<span class='line-number'>720</span>
<span class='line-number'>721</span>
<span class='line-number'>722</span>
<span class='line-number'>723</span>
<span class='line-number'>724</span>
<span class='line-number'>725</span>
<span class='line-number'>726</span>
<span class='line-number'>727</span>
<span class='line-number'>728</span>
<span class='line-number'>729</span>
<span class='line-number'>730</span>
<span class='line-number'>731</span>
<span class='line-number'>732</span>
<span class='line-number'>733</span>
<span class='line-number'>734</span>
<span class='line-number'>735</span>
<span class='line-number'>736</span>
<span class='line-number'>737</span>
<span class='line-number'>738</span>
<span class='line-number'>739</span>
<span class='line-number'>740</span>
<span class='line-number'>741</span>
<span class='line-number'>742</span>
<span class='line-number'>743</span>
<span class='line-number'>744</span>
<span class='line-number'>745</span>
<span class='line-number'>746</span>
<span class='line-number'>747</span>
<span class='line-number'>748</span>
<span class='line-number'>749</span>
<span class='line-number'>750</span>
<span class='line-number'>751</span>
<span class='line-number'>752</span>
<span class='line-number'>753</span>
<span class='line-number'>754</span>
<span class='line-number'>755</span>
<span class='line-number'>756</span>
<span class='line-number'>757</span>
<span class='line-number'>758</span>
<span class='line-number'>759</span>
<span class='line-number'>760</span>
<span class='line-number'>761</span>
<span class='line-number'>762</span>
<span class='line-number'>763</span>
<span class='line-number'>764</span>
<span class='line-number'>765</span>
<span class='line-number'>766</span>
<span class='line-number'>767</span>
<span class='line-number'>768</span>
<span class='line-number'>769</span>
<span class='line-number'>770</span>
<span class='line-number'>771</span>
<span class='line-number'>772</span>
<span class='line-number'>773</span>
<span class='line-number'>774</span>
<span class='line-number'>775</span>
<span class='line-number'>776</span>
<span class='line-number'>777</span>
<span class='line-number'>778</span>
<span class='line-number'>779</span>
<span class='line-number'>780</span>
<span class='line-number'>781</span>
<span class='line-number'>782</span>
<span class='line-number'>783</span>
<span class='line-number'>784</span>
<span class='line-number'>785</span>
<span class='line-number'>786</span>
<span class='line-number'>787</span>
<span class='line-number'>788</span>
<span class='line-number'>789</span>
<span class='line-number'>790</span>
<span class='line-number'>791</span>
<span class='line-number'>792</span>
<span class='line-number'>793</span>
<span class='line-number'>794</span>
<span class='line-number'>795</span>
<span class='line-number'>796</span>
<span class='line-number'>797</span>
<span class='line-number'>798</span>
<span class='line-number'>799</span>
<span class='line-number'>800</span>
<span class='line-number'>801</span>
<span class='line-number'>802</span>
<span class='line-number'>803</span>
<span class='line-number'>804</span>
<span class='line-number'>805</span>
<span class='line-number'>806</span>
<span class='line-number'>807</span>
<span class='line-number'>808</span>
<span class='line-number'>809</span>
<span class='line-number'>810</span>
<span class='line-number'>811</span>
<span class='line-number'>812</span>
<span class='line-number'>813</span>
<span class='line-number'>814</span>
<span class='line-number'>815</span>
<span class='line-number'>816</span>
<span class='line-number'>817</span>
<span class='line-number'>818</span>
<span class='line-number'>819</span>
<span class='line-number'>820</span>
<span class='line-number'>821</span>
<span class='line-number'>822</span>
<span class='line-number'>823</span>
<span class='line-number'>824</span>
<span class='line-number'>825</span>
<span class='line-number'>826</span>
<span class='line-number'>827</span>
<span class='line-number'>828</span>
<span class='line-number'>829</span>
<span class='line-number'>830</span>
<span class='line-number'>831</span>
<span class='line-number'>832</span>
<span class='line-number'>833</span>
<span class='line-number'>834</span>
<span class='line-number'>835</span>
<span class='line-number'>836</span>
<span class='line-number'>837</span>
<span class='line-number'>838</span>
<span class='line-number'>839</span>
<span class='line-number'>840</span>
<span class='line-number'>841</span>
<span class='line-number'>842</span>
<span class='line-number'>843</span>
<span class='line-number'>844</span>
<span class='line-number'>845</span>
<span class='line-number'>846</span>
<span class='line-number'>847</span>
<span class='line-number'>848</span>
<span class='line-number'>849</span>
<span class='line-number'>850</span>
<span class='line-number'>851</span>
<span class='line-number'>852</span>
<span class='line-number'>853</span>
<span class='line-number'>854</span>
<span class='line-number'>855</span>
<span class='line-number'>856</span>
<span class='line-number'>857</span>
<span class='line-number'>858</span>
<span class='line-number'>859</span>
<span class='line-number'>860</span>
<span class='line-number'>861</span>
<span class='line-number'>862</span>
<span class='line-number'>863</span>
<span class='line-number'>864</span>
<span class='line-number'>865</span>
<span class='line-number'>866</span>
<span class='line-number'>867</span>
<span class='line-number'>868</span>
<span class='line-number'>869</span>
<span class='line-number'>870</span>
<span class='line-number'>871</span>
<span class='line-number'>872</span>
<span class='line-number'>873</span>
<span class='line-number'>874</span>
<span class='line-number'>875</span>
<span class='line-number'>876</span>
<span class='line-number'>877</span>
<span class='line-number'>878</span>
<span class='line-number'>879</span>
<span class='line-number'>880</span>
<span class='line-number'>881</span>
<span class='line-number'>882</span>
<span class='line-number'>883</span>
<span class='line-number'>884</span>
<span class='line-number'>885</span>
<span class='line-number'>886</span>
<span class='line-number'>887</span>
<span class='line-number'>888</span>
<span class='line-number'>889</span>
<span class='line-number'>890</span>
<span class='line-number'>891</span>
<span class='line-number'>892</span>
<span class='line-number'>893</span>
<span class='line-number'>894</span>
<span class='line-number'>895</span>
<span class='line-number'>896</span>
<span class='line-number'>897</span>
<span class='line-number'>898</span>
<span class='line-number'>899</span>
<span class='line-number'>900</span>
<span class='line-number'>901</span>
<span class='line-number'>902</span>
<span class='line-number'>903</span>
<span class='line-number'>904</span>
<span class='line-number'>905</span>
<span class='line-number'>906</span>
<span class='line-number'>907</span>
<span class='line-number'>908</span>
<span class='line-number'>909</span>
<span class='line-number'>910</span>
<span class='line-number'>911</span>
<span class='line-number'>912</span>
<span class='line-number'>913</span>
<span class='line-number'>914</span>
<span class='line-number'>915</span>
<span class='line-number'>916</span>
<span class='line-number'>917</span>
<span class='line-number'>918</span>
<span class='line-number'>919</span>
<span class='line-number'>920</span>
<span class='line-number'>921</span>
<span class='line-number'>922</span>
<span class='line-number'>923</span>
<span class='line-number'>924</span>
<span class='line-number'>925</span>
<span class='line-number'>926</span>
<span class='line-number'>927</span>
<span class='line-number'>928</span>
<span class='line-number'>929</span>
<span class='line-number'>930</span>
<span class='line-number'>931</span>
<span class='line-number'>932</span>
<span class='line-number'>933</span>
<span class='line-number'>934</span>
<span class='line-number'>935</span>
<span class='line-number'>936</span>
<span class='line-number'>937</span>
<span class='line-number'>938</span>
<span class='line-number'>939</span>
<span class='line-number'>940</span>
<span class='line-number'>941</span>
<span class='line-number'>942</span>
<span class='line-number'>943</span>
<span class='line-number'>944</span>
<span class='line-number'>945</span>
<span class='line-number'>946</span>
<span class='line-number'>947</span>
<span class='line-number'>948</span>
<span class='line-number'>949</span>
<span class='line-number'>950</span>
<span class='line-number'>951</span>
<span class='line-number'>952</span>
<span class='line-number'>953</span>
<span class='line-number'>954</span>
<span class='line-number'>955</span>
<span class='line-number'>956</span>
<span class='line-number'>957</span>
<span class='line-number'>958</span>
<span class='line-number'>959</span>
<span class='line-number'>960</span>
<span class='line-number'>961</span>
<span class='line-number'>962</span>
<span class='line-number'>963</span>
<span class='line-number'>964</span>
<span class='line-number'>965</span>
<span class='line-number'>966</span>
<span class='line-number'>967</span>
<span class='line-number'>968</span>
<span class='line-number'>969</span>
<span class='line-number'>970</span>
<span class='line-number'>971</span>
<span class='line-number'>972</span>
<span class='line-number'>973</span>
<span class='line-number'>974</span>
<span class='line-number'>975</span>
<span class='line-number'>976</span>
<span class='line-number'>977</span>
<span class='line-number'>978</span>
<span class='line-number'>979</span>
<span class='line-number'>980</span>
<span class='line-number'>981</span>
<span class='line-number'>982</span>
<span class='line-number'>983</span>
<span class='line-number'>984</span>
<span class='line-number'>985</span>
<span class='line-number'>986</span>
<span class='line-number'>987</span>
<span class='line-number'>988</span>
<span class='line-number'>989</span>
<span class='line-number'>990</span>
<span class='line-number'>991</span>
<span class='line-number'>992</span>
<span class='line-number'>993</span>
<span class='line-number'>994</span>
<span class='line-number'>995</span>
<span class='line-number'>996</span>
<span class='line-number'>997</span>
<span class='line-number'>998</span>
<span class='line-number'>999</span>
<span class='line-number'>1000</span>
<span class='line-number'>1001</span>
<span class='line-number'>1002</span>
<span class='line-number'>1003</span>
<span class='line-number'>1004</span>
<span class='line-number'>1005</span>
<span class='line-number'>1006</span>
<span class='line-number'>1007</span>
<span class='line-number'>1008</span>
<span class='line-number'>1009</span>
<span class='line-number'>1010</span>
<span class='line-number'>1011</span>
<span class='line-number'>1012</span>
<span class='line-number'>1013</span>
<span class='line-number'>1014</span>
<span class='line-number'>1015</span>
<span class='line-number'>1016</span>
<span class='line-number'>1017</span>
<span class='line-number'>1018</span>
<span class='line-number'>1019</span>
<span class='line-number'>1020</span>
<span class='line-number'>1021</span>
<span class='line-number'>1022</span>
<span class='line-number'>1023</span>
<span class='line-number'>1024</span>
<span class='line-number'>1025</span>
<span class='line-number'>1026</span>
<span class='line-number'>1027</span>
<span class='line-number'>1028</span>
<span class='line-number'>1029</span>
<span class='line-number'>1030</span>
<span class='line-number'>1031</span>
<span class='line-number'>1032</span>
<span class='line-number'>1033</span>
<span class='line-number'>1034</span>
<span class='line-number'>1035</span>
<span class='line-number'>1036</span>
<span class='line-number'>1037</span>
<span class='line-number'>1038</span>
<span class='line-number'>1039</span>
<span class='line-number'>1040</span>
<span class='line-number'>1041</span>
<span class='line-number'>1042</span>
<span class='line-number'>1043</span>
<span class='line-number'>1044</span>
<span class='line-number'>1045</span>
<span class='line-number'>1046</span>
<span class='line-number'>1047</span>
<span class='line-number'>1048</span>
<span class='line-number'>1049</span>
<span class='line-number'>1050</span>
<span class='line-number'>1051</span>
<span class='line-number'>1052</span>
<span class='line-number'>1053</span>
<span class='line-number'>1054</span>
<span class='line-number'>1055</span>
<span class='line-number'>1056</span>
<span class='line-number'>1057</span>
<span class='line-number'>1058</span>
<span class='line-number'>1059</span>
<span class='line-number'>1060</span>
<span class='line-number'>1061</span>
<span class='line-number'>1062</span>
<span class='line-number'>1063</span>
<span class='line-number'>1064</span>
<span class='line-number'>1065</span>
<span class='line-number'>1066</span>
<span class='line-number'>1067</span>
<span class='line-number'>1068</span>
<span class='line-number'>1069</span>
<span class='line-number'>1070</span>
<span class='line-number'>1071</span>
<span class='line-number'>1072</span>
<span class='line-number'>1073</span>
<span class='line-number'>1074</span>
<span class='line-number'>1075</span>
<span class='line-number'>1076</span>
<span class='line-number'>1077</span>
<span class='line-number'>1078</span>
<span class='line-number'>1079</span>
<span class='line-number'>1080</span>
<span class='line-number'>1081</span>
<span class='line-number'>1082</span>
<span class='line-number'>1083</span>
<span class='line-number'>1084</span>
<span class='line-number'>1085</span>
<span class='line-number'>1086</span>
<span class='line-number'>1087</span>
<span class='line-number'>1088</span>
<span class='line-number'>1089</span>
<span class='line-number'>1090</span>
<span class='line-number'>1091</span>
<span class='line-number'>1092</span>
<span class='line-number'>1093</span>
<span class='line-number'>1094</span>
<span class='line-number'>1095</span>
<span class='line-number'>1096</span>
<span class='line-number'>1097</span>
<span class='line-number'>1098</span>
<span class='line-number'>1099</span>
<span class='line-number'>1100</span>
<span class='line-number'>1101</span>
<span class='line-number'>1102</span>
<span class='line-number'>1103</span>
<span class='line-number'>1104</span>
<span class='line-number'>1105</span>
<span class='line-number'>1106</span>
<span class='line-number'>1107</span>
<span class='line-number'>1108</span>
<span class='line-number'>1109</span>
<span class='line-number'>1110</span>
<span class='line-number'>1111</span>
<span class='line-number'>1112</span>
<span class='line-number'>1113</span>
<span class='line-number'>1114</span>
<span class='line-number'>1115</span>
<span class='line-number'>1116</span>
<span class='line-number'>1117</span>
<span class='line-number'>1118</span>
<span class='line-number'>1119</span>
<span class='line-number'>1120</span>
<span class='line-number'>1121</span>
<span class='line-number'>1122</span>
<span class='line-number'>1123</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void __init kmem_cache_init(void)&lt;br/&gt;
</span><span class='line'>{&lt;br/&gt;
</span><span class='line'>    size_t left_over;&lt;br/&gt;
</span><span class='line'>    struct cache_sizes &lt;em&gt;sizes;&lt;br/&gt;
</span><span class='line'>    struct cache_names &lt;/em&gt;names;&lt;br/&gt;
</span><span class='line'>    int i;&lt;br/&gt;
</span><span class='line'>    int order;&lt;br/&gt;
</span><span class='line'>    int node;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    if (num_possible_nodes() == 1)  
</span><span class='line'>    use_alien_caches = 0;  
</span><span class='line'>
</span><span class='line'>/*初始化静态L3变量initkmem_list3*/  
</span><span class='line'>for (i = 0; i &lt; NUM_INIT_LISTS; i++) {  
</span><span class='line'>    kmem_list3_init(&amp;initkmem_list3[i]);  
</span><span class='line'>    if (i &lt; MAX_NUMNODES)  
</span><span class='line'>        cache_cache.nodelists[i] = NULL;  
</span><span class='line'>}  
</span><span class='line'>/*将cache_cache和initkmem_list3相关联*/  
</span><span class='line'>set_up_list3s(&amp;cache_cache, CACHE_CACHE);  
</span><span class='line'>
</span><span class='line'>/* 
</span><span class='line'> * Fragmentation resistance on low memory - only use bigger 
</span><span class='line'> * page orders on machines with more than 32MB of memory. 
</span><span class='line'> */  
</span><span class='line'>if (totalram_pages &gt; (32 &lt;&lt; 20) &gt;&gt; PAGE_SHIFT)  
</span><span class='line'>    slab_break_gfp_order = BREAK_GFP_ORDER_HI;  
</span><span class='line'>
</span><span class='line'>/* Bootstrap is tricky, because several objects are allocated 
</span><span class='line'> * from caches that do not exist yet: 
</span><span class='line'> * 1) initialize the cache_cache cache: it contains the struct 
</span><span class='line'> *    kmem_cache structures of all caches, except cache_cache itself: 
</span><span class='line'> *    cache_cache is statically allocated. 
</span><span class='line'> *    Initially an __init data area is used for the head array and the 
</span><span class='line'> *    kmem_list3 structures, it's replaced with a kmalloc allocated 
</span><span class='line'> *    array at the end of the bootstrap. 
</span><span class='line'> * 2) Create the first kmalloc cache. 
</span><span class='line'> *    The struct kmem_cache for the new cache is allocated normally. 
</span><span class='line'> *    An __init data area is used for the head array. 
</span><span class='line'> * 3) Create the remaining kmalloc caches, with minimally sized 
</span><span class='line'> *    head arrays. 
</span><span class='line'> * 4) Replace the __init data head arrays for cache_cache and the first 
</span><span class='line'> *    kmalloc cache with kmalloc allocated arrays. 
</span><span class='line'> * 5) Replace the __init data for kmem_list3 for cache_cache and 
</span><span class='line'> *    the other cache's with kmalloc allocated memory. 
</span><span class='line'> * 6) Resize the head arrays of the kmalloc caches to their final sizes. 
</span><span class='line'> */  
</span><span class='line'>
</span><span class='line'>node = numa_node_id();  
</span><span class='line'>
</span><span class='line'>/*初始化cache_cache的其余部分*/  
</span><span class='line'>
</span><span class='line'>/* 1) create the cache_cache */  
</span><span class='line'>INIT_LIST_HEAD(&amp;cache_chain);  
</span><span class='line'>list_add(&amp;cache_cache.next, &amp;cache_chain);  
</span><span class='line'>cache_cache.colour_off = cache_line_size();  
</span><span class='line'>cache_cache.array[smp_processor_id()] = &amp;initarray_cache.cache;  
</span><span class='line'>cache_cache.nodelists[node] = &amp;initkmem_list3[CACHE_CACHE + node];  
</span><span class='line'>
</span><span class='line'>/* 
</span><span class='line'> * struct kmem_cache size depends on nr_node_ids, which 
</span><span class='line'> * can be less than MAX_NUMNODES. 
</span><span class='line'> */  
</span><span class='line'>cache_cache.buffer_size = offsetof(struct kmem_cache, nodelists) +  
</span><span class='line'>             nr_node_ids * sizeof(struct kmem_list3 *);  
</span><span class='line'>#if DEBUG   
</span><span class='line'>cache_cache.obj_size = cache_cache.buffer_size;  
</span><span class='line'>#endif   
</span><span class='line'>cache_cache.buffer_size = ALIGN(cache_cache.buffer_size,  
</span><span class='line'>                cache_line_size());  
</span><span class='line'>cache_cache.reciprocal_buffer_size =  
</span><span class='line'>    reciprocal_value(cache_cache.buffer_size);  
</span><span class='line'>
</span><span class='line'>/*计算cache_cache的剩余空间以及slab中对象的数目，order决定了slab的大小(PAGE_SIZE&lt;&lt;order)*/  
</span><span class='line'>for (order = 0; order &lt; MAX_ORDER; order++) {  
</span><span class='line'>    cache_estimate(order, cache_cache.buffer_size,  
</span><span class='line'>        cache_line_size(), 0, &amp;left_over, &amp;cache_cache.num);  
</span><span class='line'>    /*当该order计算出来的num,即slab中对象的数目不为0时，则跳出循环*/  
</span><span class='line'>    if (cache_cache.num)  
</span><span class='line'>        break;  
</span><span class='line'>}  
</span><span class='line'>BUG_ON(!cache_cache.num);  
</span><span class='line'>cache_cache.gfporder = order;/*确定分配给每个slab的页数的对数*/  
</span><span class='line'>cache_cache.colour = left_over / cache_cache.colour_off;/*确定可用颜色的数目*/  
</span><span class='line'>/*确定slab管理区的大小，即slab描述符以及kmem_bufctl_t数组*/  
</span><span class='line'>cache_cache.slab_size = ALIGN(cache_cache.num * sizeof(kmem_bufctl_t) +  
</span><span class='line'>                  sizeof(struct slab), cache_line_size());  
</span><span class='line'>
</span><span class='line'>/* 2+3) create the kmalloc caches */  
</span><span class='line'>sizes = malloc_sizes;  
</span><span class='line'>names = cache_names;  
</span><span class='line'>
</span><span class='line'>/* 
</span><span class='line'> * Initialize the caches that provide memory for the array cache and the 
</span><span class='line'> * kmem_list3 structures first.  Without this, further allocations will 
</span><span class='line'> * bug. 
</span><span class='line'> */  
</span><span class='line'>/*为了后面能够调用kmalloc()创建per-CPU高速缓存和kmem_list3高速缓存， 
</span><span class='line'>   这里必须先创建大小相应的general cache*/  
</span><span class='line'>sizes[INDEX_AC].cs_cachep = kmem_cache_create(names[INDEX_AC].name,  
</span><span class='line'>                sizes[INDEX_AC].cs_size,  
</span><span class='line'>                ARCH_KMALLOC_MINALIGN,  
</span><span class='line'>                ARCH_KMALLOC_FLAGS|SLAB_PANIC,  
</span><span class='line'>                NULL);  
</span><span class='line'>
</span><span class='line'>/*如果AC和L3在malloc_sizes中的偏移不一样，也就是说它们的大小不属于同一级别， 
</span><span class='line'> 则创建AC的gerneral cache，否则两者共用一个gerneral cache*/  
</span><span class='line'>if (INDEX_AC != INDEX_L3) {  
</span><span class='line'>    sizes[INDEX_L3].cs_cachep =  
</span><span class='line'>        kmem_cache_create(names[INDEX_L3].name,  
</span><span class='line'>            sizes[INDEX_L3].cs_size,  
</span><span class='line'>            ARCH_KMALLOC_MINALIGN,  
</span><span class='line'>            ARCH_KMALLOC_FLAGS|SLAB_PANIC,  
</span><span class='line'>            NULL);  
</span><span class='line'>}  
</span><span class='line'>
</span><span class='line'>slab_early_init = 0;  
</span><span class='line'>
</span><span class='line'>/*创建各级的gerneral cache*/  
</span><span class='line'>while (sizes-&gt;cs_size != ULONG_MAX) {  
</span><span class='line'>    /* 
</span><span class='line'>     * For performance, all the general caches are L1 aligned. 
</span><span class='line'>     * This should be particularly beneficial on SMP boxes, as it 
</span><span class='line'>     * eliminates "false sharing". 
</span><span class='line'>     * Note for systems short on memory removing the alignment will 
</span><span class='line'>     * allow tighter packing of the smaller caches. 
</span><span class='line'>     */  
</span><span class='line'>    if (!sizes-&gt;cs_cachep) {  
</span><span class='line'>        sizes-&gt;cs_cachep = kmem_cache_create(names-&gt;name,  
</span><span class='line'>                sizes-&gt;cs_size,  
</span><span class='line'>                ARCH_KMALLOC_MINALIGN,  
</span><span class='line'>                ARCH_KMALLOC_FLAGS|SLAB_PANIC,  
</span><span class='line'>                NULL);  
</span><span class='line'>    }  
</span><span class='line'>#ifdef CONFIG_ZONE_DMA   
</span><span class='line'>    sizes-&gt;cs_dmacachep = kmem_cache_create(  
</span><span class='line'>                names-&gt;name_dma,  
</span><span class='line'>                sizes-&gt;cs_size,  
</span><span class='line'>                ARCH_KMALLOC_MINALIGN,  
</span><span class='line'>                ARCH_KMALLOC_FLAGS|SLAB_CACHE_DMA|  
</span><span class='line'>                    SLAB_PANIC,  
</span><span class='line'>                NULL);  
</span><span class='line'>#endif   
</span><span class='line'>    sizes++;  
</span><span class='line'>    names++;  
</span><span class='line'>}  
</span><span class='line'>/* 4) Replace the bootstrap head arrays */  
</span><span class='line'>{  
</span><span class='line'>    struct array_cache *ptr;  
</span><span class='line'>
</span><span class='line'>    /*这里调用kmalloc()为cache_cache创建per-CPU高速缓存*/  
</span><span class='line'>    ptr = kmalloc(sizeof(struct arraycache_init), GFP_NOWAIT);  
</span><span class='line'>
</span><span class='line'>    BUG_ON(cpu_cache_get(&amp;cache_cache) != &amp;initarray_cache.cache);  
</span><span class='line'>    /*将静态定义的initarray_cache中的array_cache拷贝到malloc申请到的空间中*/  
</span><span class='line'>    memcpy(ptr, cpu_cache_get(&amp;cache_cache),  
</span><span class='line'>           sizeof(struct arraycache_init));  
</span><span class='line'>    /* 
</span><span class='line'>     * Do not assume that spinlocks can be initialized via memcpy: 
</span><span class='line'>     */  
</span><span class='line'>    spin_lock_init(&amp;ptr-&gt;lock);  
</span><span class='line'>
</span><span class='line'>    /*将cache_cache与保存per-CPU高速缓存的空间关联*/  
</span><span class='line'>    cache_cache.array[smp_processor_id()] = ptr;  
</span><span class='line'>
</span><span class='line'>    /*为之前创建的AC gerneral cache创建per-CPU高速缓存，替换静态定义的initarray_generic.cache*/  
</span><span class='line'>    ptr = kmalloc(sizeof(struct arraycache_init), GFP_NOWAIT);  
</span><span class='line'>
</span><span class='line'>    BUG_ON(cpu_cache_get(malloc_sizes[INDEX_AC].cs_cachep)  
</span><span class='line'>           != &amp;initarray_generic.cache);  
</span><span class='line'>    memcpy(ptr, cpu_cache_get(malloc_sizes[INDEX_AC].cs_cachep),  
</span><span class='line'>           sizeof(struct arraycache_init));  
</span><span class='line'>    /* 
</span><span class='line'>     * Do not assume that spinlocks can be initialized via memcpy: 
</span><span class='line'>     */  
</span><span class='line'>    spin_lock_init(&amp;ptr-&gt;lock);  
</span><span class='line'>
</span><span class='line'>    malloc_sizes[INDEX_AC].cs_cachep-&gt;array[smp_processor_id()] =  
</span><span class='line'>        ptr;  
</span><span class='line'>}  
</span><span class='line'>/* 5) Replace the bootstrap kmem_list3's */  
</span><span class='line'>{  
</span><span class='line'>    int nid;  
</span><span class='line'>
</span><span class='line'>    for_each_online_node(nid) {  
</span><span class='line'>
</span><span class='line'>        /*为cache_cache的kmem_list3申请高速缓存空间，并替换静态定义的initkmem_list3*/  
</span><span class='line'>        init_list(&amp;cache_cache, &amp;initkmem_list3[CACHE_CACHE + nid], nid);  
</span><span class='line'>
</span><span class='line'>        /*为AC的kmem_list3申请高速缓存空间，并替换静态定义的initkmem_list3*/  
</span><span class='line'>        init_list(malloc_sizes[INDEX_AC].cs_cachep,  
</span><span class='line'>              &amp;initkmem_list3[SIZE_AC + nid], nid);  
</span><span class='line'>
</span><span class='line'>        if (INDEX_AC != INDEX_L3) {  
</span><span class='line'>        /*为L3的kmem_list3申请高速缓存空间，并替换静态定义的initkmem_list3*/  
</span><span class='line'>            init_list(malloc_sizes[INDEX_L3].cs_cachep,  
</span><span class='line'>                  &amp;initkmem_list3[SIZE_L3 + nid], nid);  
</span><span class='line'>        }  
</span><span class='line'>    }  
</span><span class='line'>}  
</span><span class='line'>
</span><span class='line'>g_cpucache_up = EARLY;  
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>* 前面大部分的代码都是围绕cache_cache展开的，主要是将cache_cache同静态kmem_list3进行关联，将cache_cache添加到cache_chain链表中，并且计算初始化内部的一些数据项  
</span><span class='line'>* 现在还没有高速缓存来存储cache_cache中的kmem_list3描述符和array_cache描述符，因此下面就要调用kmem_cache_create()建立高速缓存来存储这两种描述符  
</span><span class='line'>* 内核使用g_cpucache_up这个枚举量来表示slab分配器的初始化进度  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static enum {  
</span><span class='line'>NONE,  
</span><span class='line'>PARTIAL_AC,  
</span><span class='line'>PARTIAL_L3,  
</span><span class='line'>EARLY,  
</span><span class='line'>FULL  
</span><span class='line'>} g_cpucache_up;
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;  这个值的更新是在`kmem_cache_create()--&gt;setup_cpu_cache()`函数中进行更新的，每调用一次kmem_cache_create(),g_cpucache_up的值就加1，直到它等于EARLY，比如说第一次调用kmem_cache_create()创建了AC(array_cache)的高速缓存，那么g_cpucache_up由NONE变为PARTIAL_AC，那么下次调用kmem_cache_create()创建L3高速缓存时，内核就知道AC高速缓存已经准备好了，也就是说可以在array_cache高速缓存中为L3高速缓存描述符的array_cache描述符分配高速缓存空间了。
</span><span class='line'>
</span><span class='line'>* 创建了AC和L3高速缓存后就循环创建各级普通高速缓存，此时创建的高速缓存都是完整的了！也就是说里面的结构变量都已经是存储在相应的高速缓存中  
</span><span class='line'>* 由于AC高速缓存已经创建，因此kmalloc()动态创建一个array_cache对象替换cache_cache的静态array_cache  
</span><span class='line'>* 由于AC高速缓存描述符本身的array_cache描述符还未动态创建，因此同样kmalloc()动态创建一个array_cache替换AC高速缓存的静态array_cache  
</span><span class='line'>* 为cache_cache,AC,L3高速缓存分别动态创建kmem_list描述符对象，替换静态的initkmem_list3   
</span><span class='line'>* 将g_cpucache_up置为EARLY,表示slab分配器的初始化已初步完成   
</span><span class='line'>
</span><span class='line'>##### slab分配器初始化工作的最后一步由kmem_cache_init_late()函数完成
</span><span class='line'>这个函数就不做详细分析了，它的工作就是设置cache_cache和各级普通高速缓存中的array_cache本地高速缓存的相关属性
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;void __init kmem_cache_init_late(void)  
</span><span class='line'>{  
</span><span class='line'>struct kmem_cache *cachep;  
</span><span class='line'>
</span><span class='line'>/* 6) resize the head arrays to their final sizes */  
</span><span class='line'>mutex_lock(&amp;cache_chain_mutex);  
</span><span class='line'>list_for_each_entry(cachep, &amp;cache_chain, next)  
</span><span class='line'>    if (enable_cpucache(cachep, GFP_NOWAIT))  
</span><span class='line'>        BUG();  
</span><span class='line'>mutex_unlock(&amp;cache_chain_mutex);  
</span><span class='line'>
</span><span class='line'>/* Done! */  
</span><span class='line'>g_cpucache_up = FULL;   /*slab初始化完成*/  
</span><span class='line'>
</span><span class='line'>/* Annotate slab for lockdep -- annotate the malloc caches */  
</span><span class='line'>init_lock_keys();  
</span><span class='line'>
</span><span class='line'>/* 
</span><span class='line'> * Register a cpu startup notifier callback that initializes 
</span><span class='line'> * cpu_cache_get for all new cpus 
</span><span class='line'> */  
</span><span class='line'>register_cpu_notifier(&amp;cpucache_notifier);  
</span><span class='line'>
</span><span class='line'>/* 
</span><span class='line'> * The reap timers are started later, with a module init call: That part 
</span><span class='line'> * of the kernel is not yet operational. 
</span><span class='line'> */  
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>
</span><span class='line'>## 三、创建缓存
</span><span class='line'>##### 创建新的缓存必须通过kmem_cache_create()函数来完成，原型如下
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;struct kmem_cache *  
</span><span class='line'>kmem_cache_create (const char *name, size_t size, size_t align,  
</span><span class='line'>unsigned long flags, void (*ctor)(void *))
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>* name:所创建的新缓存的名字
</span><span class='line'>* size :缓存所分配对象的大小
</span><span class='line'>* align:对象的对齐值
</span><span class='line'>* flags:创建用的标识
</span><span class='line'>* ctor:创建对象时的构造函数
</span><span class='line'>
</span><span class='line'>kmem_cache_create()的实际工作就是为新的缓存申请缓存描述符，array_cache描述符和kmem_list3描述符，并根据接收的参数对这三个结构中的变量进行相应的初始化。新创建的缓存是空的，不包含slab。
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;struct kmem_cache *  
</span><span class='line'>kmem_cache_create (const char *name, size_t size, size_t align,  
</span><span class='line'>unsigned long flags, void (*ctor)(void *))  
</span><span class='line'>{  
</span><span class='line'>size_t left_over, slab_size, ralign;  
</span><span class='line'>struct kmem_cache *cachep = NULL, *pc;  
</span><span class='line'>gfp_t gfp;  
</span><span class='line'>
</span><span class='line'>/* 
</span><span class='line'> * Sanity checks... these are all serious usage bugs. 
</span><span class='line'> */  
</span><span class='line'> /*做一些必要的检查，以下情况都是不合法的: 
</span><span class='line'>   1.缓存名为空 
</span><span class='line'>   2.处于中断环境中 
</span><span class='line'>   3.缓存中的对象大小小于处理器的字长 
</span><span class='line'>   4.缓存中的对象大小大于普通缓存的最大长度*/  
</span><span class='line'>if (!name || in_interrupt() || (size &lt; BYTES_PER_WORD) ||  
</span><span class='line'>    size &gt; KMALLOC_MAX_SIZE) {  
</span><span class='line'>    printk(KERN_ERR "%s: Early error in slab %s\n", __func__,  
</span><span class='line'>            name);  
</span><span class='line'>    BUG();  
</span><span class='line'>}  
</span><span class='line'>
</span><span class='line'>/* 
</span><span class='line'> * We use cache_chain_mutex to ensure a consistent view of 
</span><span class='line'> * cpu_online_mask as well.  Please see cpuup_callback 
</span><span class='line'> */  
</span><span class='line'>if (slab_is_available()) {  
</span><span class='line'>    get_online_cpus();  
</span><span class='line'>    mutex_lock(&amp;cache_chain_mutex);  
</span><span class='line'>}  
</span><span class='line'>
</span><span class='line'>list_for_each_entry(pc, &amp;cache_chain, next) {  
</span><span class='line'>    char tmp;  
</span><span class='line'>    int res;  
</span><span class='line'>
</span><span class='line'>    /* 
</span><span class='line'>     * This happens when the module gets unloaded and doesn't 
</span><span class='line'>     * destroy its slab cache and no-one else reuses the vmalloc 
</span><span class='line'>     * area of the module.  Print a warning. 
</span><span class='line'>     */  
</span><span class='line'>    res = probe_kernel_address(pc-&gt;name, tmp);  
</span><span class='line'>    if (res) {  
</span><span class='line'>        printk(KERN_ERR  
</span><span class='line'>               "SLAB: cache with size %d has lost its name\n",  
</span><span class='line'>               pc-&gt;buffer_size);  
</span><span class='line'>        continue;  
</span><span class='line'>    }  
</span><span class='line'>
</span><span class='line'>    if (!strcmp(pc-&gt;name, name)) {  
</span><span class='line'>        printk(KERN_ERR  
</span><span class='line'>               "kmem_cache_create: duplicate cache %s\n", name);  
</span><span class='line'>        dump_stack();  
</span><span class='line'>        goto oops;  
</span><span class='line'>    }  
</span><span class='line'>}  
</span><span class='line'>
</span><span class='line'>#if DEBUG   
</span><span class='line'>WARN_ON(strchr(name, ' ')); /* It confuses parsers */  
</span><span class='line'>#if FORCED_DEBUG   
</span><span class='line'>/* 
</span><span class='line'> * Enable redzoning and last user accounting, except for caches with 
</span><span class='line'> * large objects, if the increased size would increase the object size 
</span><span class='line'> * above the next power of two: caches with object sizes just above a 
</span><span class='line'> * power of two have a significant amount of internal fragmentation. 
</span><span class='line'> */  
</span><span class='line'>if (size &lt; 4096 || fls(size - 1) == fls(size-1 + REDZONE_ALIGN +  
</span><span class='line'>                    2 * sizeof(unsigned long long)))  
</span><span class='line'>    flags |= SLAB_RED_ZONE | SLAB_STORE_USER;  
</span><span class='line'>if (!(flags &amp; SLAB_DESTROY_BY_RCU))  
</span><span class='line'>    flags |= SLAB_POISON;  
</span><span class='line'>#endif   
</span><span class='line'>if (flags &amp; SLAB_DESTROY_BY_RCU)  
</span><span class='line'>    BUG_ON(flags &amp; SLAB_POISON);  
</span><span class='line'>#endif   
</span><span class='line'>/* 
</span><span class='line'> * Always checks flags, a caller might be expecting debug support which 
</span><span class='line'> * isn't available. 
</span><span class='line'> */  
</span><span class='line'>BUG_ON(flags &amp; ~CREATE_MASK);  
</span><span class='line'>
</span><span class='line'>/* 
</span><span class='line'> * Check that size is in terms of words.  This is needed to avoid 
</span><span class='line'> * unaligned accesses for some archs when redzoning is used, and makes 
</span><span class='line'> * sure any on-slab bufctl's are also correctly aligned. 
</span><span class='line'> */  
</span><span class='line'> /*如果缓存对象大小没有对齐到处理器字长，则对齐之*/  
</span><span class='line'>if (size &amp; (BYTES_PER_WORD - 1)) {  
</span><span class='line'>    size += (BYTES_PER_WORD - 1);  
</span><span class='line'>    size &amp;= ~(BYTES_PER_WORD - 1);  
</span><span class='line'>}  
</span><span class='line'>
</span><span class='line'>/* calculate the final buffer alignment: */  
</span><span class='line'>
</span><span class='line'>/* 1) arch recommendation: can be overridden for debug */  
</span><span class='line'>/*要求按照体系结构对齐*/  
</span><span class='line'>if (flags &amp; SLAB_HWCACHE_ALIGN) {  
</span><span class='line'>    /* 
</span><span class='line'>     * Default alignment: as specified by the arch code.  Except if 
</span><span class='line'>     * an object is really small, then squeeze multiple objects into 
</span><span class='line'>     * one cacheline. 
</span><span class='line'>     */  
</span><span class='line'>    ralign = cache_line_size();/*对齐值取L1缓存行的大小*/  
</span><span class='line'>    /*如果对象大小足够小，则不断压缩对齐值以保证能将足够多的对象装入一个缓存行*/  
</span><span class='line'>    while (size &lt;= ralign / 2)  
</span><span class='line'>        ralign /= 2;  
</span><span class='line'>} else {  
</span><span class='line'>    ralign = BYTES_PER_WORD; /*对齐值取处理器字长*/  
</span><span class='line'>}  
</span><span class='line'>
</span><span class='line'>/* 
</span><span class='line'> * Redzoning and user store require word alignment or possibly larger. 
</span><span class='line'> * Note this will be overridden by architecture or caller mandated 
</span><span class='line'> * alignment if either is greater than BYTES_PER_WORD. 
</span><span class='line'> */  
</span><span class='line'> /*如果开启了DEBUG，则按需要进行相应的对齐*/  
</span><span class='line'>if (flags &amp; SLAB_STORE_USER)  
</span><span class='line'>    ralign = BYTES_PER_WORD;  
</span><span class='line'>
</span><span class='line'>if (flags &amp; SLAB_RED_ZONE) {  
</span><span class='line'>    ralign = REDZONE_ALIGN;  
</span><span class='line'>    /* If redzoning, ensure that the second redzone is suitably 
</span><span class='line'>     * aligned, by adjusting the object size accordingly. */  
</span><span class='line'>    size += REDZONE_ALIGN - 1;  
</span><span class='line'>    size &amp;= ~(REDZONE_ALIGN - 1);  
</span><span class='line'>}  
</span><span class='line'>
</span><span class='line'>/* 2) arch mandated alignment */  
</span><span class='line'>if (ralign &lt; ARCH_SLAB_MINALIGN) {  
</span><span class='line'>    ralign = ARCH_SLAB_MINALIGN;  
</span><span class='line'>}  
</span><span class='line'>/* 3) caller mandated alignment */  
</span><span class='line'>if (ralign &lt; align) {  
</span><span class='line'>    ralign = align;  
</span><span class='line'>}  
</span><span class='line'>/* disable debug if necessary */  
</span><span class='line'>if (ralign &gt; __alignof__(unsigned long long))  
</span><span class='line'>    flags &amp;= ~(SLAB_RED_ZONE | SLAB_STORE_USER);  
</span><span class='line'>/* 
</span><span class='line'> * 4) Store it. 
</span><span class='line'> */  
</span><span class='line'>align = ralign;  
</span><span class='line'>
</span><span class='line'>if (slab_is_available())  
</span><span class='line'>    gfp = GFP_KERNEL;  
</span><span class='line'>else  
</span><span class='line'>    gfp = GFP_NOWAIT;  
</span><span class='line'>
</span><span class='line'>/* Get cache's description obj. */  
</span><span class='line'>/*从cache_cache中分配一个高速缓存描述符*/  
</span><span class='line'>cachep = kmem_cache_zalloc(&amp;cache_cache, gfp);  
</span><span class='line'>if (!cachep)  
</span><span class='line'>    goto oops;  
</span><span class='line'>
</span><span class='line'>#if DEBUG   
</span><span class='line'>cachep-&gt;obj_size = size;  
</span><span class='line'>
</span><span class='line'>/* 
</span><span class='line'> * Both debugging options require word-alignment which is calculated 
</span><span class='line'> * into align above. 
</span><span class='line'> */  
</span><span class='line'>if (flags &amp; SLAB_RED_ZONE) {  
</span><span class='line'>    /* add space for red zone words */  
</span><span class='line'>    cachep-&gt;obj_offset += sizeof(unsigned long long);  
</span><span class='line'>    size += 2 * sizeof(unsigned long long);  
</span><span class='line'>}  
</span><span class='line'>if (flags &amp; SLAB_STORE_USER) {  
</span><span class='line'>    /* user store requires one word storage behind the end of 
</span><span class='line'>     * the real object. But if the second red zone needs to be 
</span><span class='line'>     * aligned to 64 bits, we must allow that much space. 
</span><span class='line'>     */  
</span><span class='line'>    if (flags &amp; SLAB_RED_ZONE)  
</span><span class='line'>        size += REDZONE_ALIGN;  
</span><span class='line'>    else  
</span><span class='line'>        size += BYTES_PER_WORD;  
</span><span class='line'>}  
</span><span class='line'>#if FORCED_DEBUG &amp;&amp; defined(CONFIG_DEBUG_PAGEALLOC)   
</span><span class='line'>if (size &gt;= malloc_sizes[INDEX_L3 + 1].cs_size  
</span><span class='line'>    &amp;&amp; cachep-&gt;obj_size &gt; cache_line_size() &amp;&amp; ALIGN(size, align) &lt; PAGE_SIZE) {  
</span><span class='line'>    cachep-&gt;obj_offset += PAGE_SIZE - ALIGN(size, align);  
</span><span class='line'>    size = PAGE_SIZE;  
</span><span class='line'>}  
</span><span class='line'>#endif   
</span><span class='line'>#endif   
</span><span class='line'>
</span><span class='line'>/* 
</span><span class='line'> * Determine if the slab management is 'on' or 'off' slab. 
</span><span class='line'> * (bootstrapping cannot cope with offslab caches so don't do 
</span><span class='line'> * it too early on.) 
</span><span class='line'> */  
</span><span class='line'> /*如果缓存对象的大小不小于页面大小的1/8并且不处于slab初始化阶段， 
</span><span class='line'>   则选择将slab描述符放在slab外部以腾出更多的空间给对象*/  
</span><span class='line'>if ((size &gt;= (PAGE_SIZE &gt;&gt; 3)) &amp;&amp; !slab_early_init)  
</span><span class='line'>    /* 
</span><span class='line'>     * Size is large, assume best to place the slab management obj 
</span><span class='line'>     * off-slab (should allow better packing of objs). 
</span><span class='line'>     */  
</span><span class='line'>    flags |= CFLGS_OFF_SLAB;  
</span><span class='line'>
</span><span class='line'>/*将对象大小按之前确定的align对齐*/  
</span><span class='line'>size = ALIGN(size, align);  
</span><span class='line'>
</span><span class='line'>/*计算slab的对象数，分配给slab的页框阶数并返回slab的剩余空间，即碎片大小*/  
</span><span class='line'>left_over = calculate_slab_order(cachep, size, align, flags);  
</span><span class='line'>
</span><span class='line'>if (!cachep-&gt;num) {  
</span><span class='line'>    printk(KERN_ERR  
</span><span class='line'>           "kmem_cache_create: couldn't create cache %s.\n", name);  
</span><span class='line'>    kmem_cache_free(&amp;cache_cache, cachep);  
</span><span class='line'>    cachep = NULL;  
</span><span class='line'>    goto oops;  
</span><span class='line'>}  
</span><span class='line'>/*将slab管理区的大小按align进行对齐*/  
</span><span class='line'>slab_size = ALIGN(cachep-&gt;num * sizeof(kmem_bufctl_t)  
</span><span class='line'>          + sizeof(struct slab), align);  
</span><span class='line'>
</span><span class='line'>/* 
</span><span class='line'> * If the slab has been placed off-slab, and we have enough space then 
</span><span class='line'> * move it on-slab. This is at the expense of any extra colouring. 
</span><span class='line'> */  
</span><span class='line'> /*如果之前确定将slab管理区放在slab外部，但是碎片空间大于slab管理区大小， 
</span><span class='line'>   这时改变策略将slab管理区放在slab内部，这样可以节省外部空间，但是会牺牲 
</span><span class='line'>   着色的颜色个数*/  
</span><span class='line'>if (flags &amp; CFLGS_OFF_SLAB &amp;&amp; left_over &gt;= slab_size) {  
</span><span class='line'>    flags &amp;= ~CFLGS_OFF_SLAB;  
</span><span class='line'>    left_over -= slab_size;  
</span><span class='line'>}  
</span><span class='line'>
</span><span class='line'>/*如果的确要将slab管理区放在外部，则不需按照该slab的对齐方式进行对齐了， 
</span><span class='line'> 重新计算slab_size*/  
</span><span class='line'>if (flags &amp; CFLGS_OFF_SLAB) {  
</span><span class='line'>    /* really off slab. No need for manual alignment */  
</span><span class='line'>    slab_size =  
</span><span class='line'>        cachep-&gt;num * sizeof(kmem_bufctl_t) + sizeof(struct slab);  
</span><span class='line'>
</span><span class='line'>#ifdef CONFIG_PAGE_POISONING   
</span><span class='line'>    /* If we're going to use the generic kernel_map_pages() 
</span><span class='line'>     * poisoning, then it's going to smash the contents of 
</span><span class='line'>     * the redzone and userword anyhow, so switch them off. 
</span><span class='line'>     */  
</span><span class='line'>    if (size % PAGE_SIZE == 0 &amp;&amp; flags &amp; SLAB_POISON)  
</span><span class='line'>        flags &amp;= ~(SLAB_RED_ZONE | SLAB_STORE_USER);  
</span><span class='line'>#endif   
</span><span class='line'>}  
</span><span class='line'>
</span><span class='line'>/*着色偏移区L1缓存行的大小*/  
</span><span class='line'>cachep-&gt;colour_off = cache_line_size();  
</span><span class='line'>/* Offset must be a multiple of the alignment. */  
</span><span class='line'>if (cachep-&gt;colour_off &lt; align)/*着色偏移小于align的话则要取对齐值*/  
</span><span class='line'>    cachep-&gt;colour_off = align;  
</span><span class='line'>/*计算着色的颜色数目*/  
</span><span class='line'>cachep-&gt;colour = left_over / cachep-&gt;colour_off;  
</span><span class='line'>cachep-&gt;slab_size = slab_size;  
</span><span class='line'>cachep-&gt;flags = flags;  
</span><span class='line'>cachep-&gt;gfpflags = 0;  
</span><span class='line'>if (CONFIG_ZONE_DMA_FLAG &amp;&amp; (flags &amp; SLAB_CACHE_DMA))  
</span><span class='line'>    cachep-&gt;gfpflags |= GFP_DMA;  
</span><span class='line'>cachep-&gt;buffer_size = size;  
</span><span class='line'>cachep-&gt;reciprocal_buffer_size = reciprocal_value(size);  
</span><span class='line'>
</span><span class='line'>if (flags &amp; CFLGS_OFF_SLAB) {  
</span><span class='line'>    cachep-&gt;slabp_cache = kmem_find_general_cachep(slab_size, 0u);  
</span><span class='line'>    /* 
</span><span class='line'>     * This is a possibility for one of the malloc_sizes caches. 
</span><span class='line'>     * But since we go off slab only for object size greater than 
</span><span class='line'>     * PAGE_SIZE/8, and malloc_sizes gets created in ascending order, 
</span><span class='line'>     * this should not happen at all. 
</span><span class='line'>     * But leave a BUG_ON for some lucky dude. 
</span><span class='line'>     */  
</span><span class='line'>    BUG_ON(ZERO_OR_NULL_PTR(cachep-&gt;slabp_cache));  
</span><span class='line'>}  
</span><span class='line'>cachep-&gt;ctor = ctor;  
</span><span class='line'>cachep-&gt;name = name;  
</span><span class='line'>
</span><span class='line'>if (setup_cpu_cache(cachep, gfp)) {  
</span><span class='line'>    __kmem_cache_destroy(cachep);  
</span><span class='line'>    cachep = NULL;  
</span><span class='line'>    goto oops;  
</span><span class='line'>}  
</span><span class='line'>
</span><span class='line'>/* cache setup completed, link it into the list */  
</span><span class='line'>/*将该高速缓存描述符添加进cache_chain*/  
</span><span class='line'>list_add(&amp;cachep-&gt;next, &amp;cache_chain);  
</span><span class='line'>oops:  
</span><span class='line'>if (!cachep &amp;&amp; (flags &amp; SLAB_PANIC))  
</span><span class='line'>    panic("kmem_cache_create(): failed to create slab `%s'\n",  
</span><span class='line'>          name);  
</span><span class='line'>if (slab_is_available()) {  
</span><span class='line'>    mutex_unlock(&amp;cache_chain_mutex);  
</span><span class='line'>    put_online_cpus();  
</span><span class='line'>}  
</span><span class='line'>return cachep;  
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>* 首先做参数有效性的检查
</span><span class='line'>* 计算对齐值
</span><span class='line'>* 分配一个缓存描述符
</span><span class='line'>* 确定slab管理区(slab描述符+kmem_bufctl_t数组)的存储位置
</span><span class='line'>* 调用calculate_slab_order()进行相关项的计算，包括分配给slab的页阶数，碎片大小，slab的对象数
</span><span class='line'>* 计算着色偏移和可用的颜色数量
</span><span class='line'>* 调用setup_cpu_cache()分配array_cache描述符和kmem_list3描述符并初始化相关变量
</span><span class='line'>* 最后将缓存描述符插入cache_chain中
</span><span class='line'>
</span><span class='line'>##### 再来看看两个辅助函数calculate_slab_order()和setup_cpu_cache()
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static size_t calculate_slab_order(struct kmem_cache *cachep,  
</span><span class='line'>        size_t size, size_t align, unsigned long flags)  
</span><span class='line'>{  
</span><span class='line'>unsigned long offslab_limit;  
</span><span class='line'>size_t left_over = 0;  
</span><span class='line'>int gfporder;  
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>for (gfporder = 0; gfporder &lt;= KMALLOC_MAX_ORDER; gfporder++) {  
</span><span class='line'>    unsigned int num;  
</span><span class='line'>    size_t remainder;  
</span><span class='line'>
</span><span class='line'>    /*根据gfporder计算对象数和剩余空间*/  
</span><span class='line'>    cache_estimate(gfporder, size, align, flags, &amp;remainder, &amp;num);  
</span><span class='line'>    if (!num)/*如果计算出来的对象数为0则要增大分配给slab的页框阶数再进行计算*/  
</span><span class='line'>        continue;  
</span><span class='line'>
</span><span class='line'>    if (flags &amp; CFLGS_OFF_SLAB) {  
</span><span class='line'>        /* 
</span><span class='line'>         * Max number of objs-per-slab for caches which 
</span><span class='line'>         * use off-slab slabs. Needed to avoid a possible 
</span><span class='line'>         * looping condition in cache_grow(). 
</span><span class='line'>         */  
</span><span class='line'>         /*offslab_limit记录了在外部存储slab描述符时所允许的slab最大对象数*/  
</span><span class='line'>        offslab_limit = size - sizeof(struct slab);  
</span><span class='line'>        offslab_limit /= sizeof(kmem_bufctl_t);  
</span><span class='line'>
</span><span class='line'>        /*如果前面计算出的对象数num要大于允许的最大对象数，则不合法*/  
</span><span class='line'>        if (num &gt; offslab_limit)  
</span><span class='line'>            break;  
</span><span class='line'>    }  
</span><span class='line'>
</span><span class='line'>    /* Found something acceptable - save it away */  
</span><span class='line'>    cachep-&gt;num = num;  
</span><span class='line'>    cachep-&gt;gfporder = gfporder;  
</span><span class='line'>    left_over = remainder;  
</span><span class='line'>
</span><span class='line'>    /* 
</span><span class='line'>     * A VFS-reclaimable slab tends to have most allocations 
</span><span class='line'>     * as GFP_NOFS and we really don't want to have to be allocating 
</span><span class='line'>     * higher-order pages when we are unable to shrink dcache. 
</span><span class='line'>     */  
</span><span class='line'>    if (flags &amp; SLAB_RECLAIM_ACCOUNT)  
</span><span class='line'>        break;  
</span><span class='line'>
</span><span class='line'>    /* 
</span><span class='line'>     * Large number of objects is good, but very large slabs are 
</span><span class='line'>     * currently bad for the gfp()s. 
</span><span class='line'>     */  
</span><span class='line'>    if (gfporder &gt;= slab_break_gfp_order)  
</span><span class='line'>        break;  
</span><span class='line'>
</span><span class='line'>    /* 
</span><span class='line'>     * Acceptable internal fragmentation? 
</span><span class='line'>     */  
</span><span class='line'>    if (left_over * 8 &lt;= (PAGE_SIZE &lt;&lt; gfporder))  
</span><span class='line'>        break;  
</span><span class='line'>}  
</span><span class='line'>return left_over;  
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static void cache_estimate(unsigned long gfporder, size_t buffer_size,  
</span><span class='line'>           size_t align, int flags, size_t *left_over,  
</span><span class='line'>           unsigned int *num)  
</span><span class='line'>{  
</span><span class='line'>int nr_objs;  
</span><span class='line'>size_t mgmt_size;  
</span><span class='line'>size_t slab_size = PAGE_SIZE &lt;&lt; gfporder;  
</span><span class='line'>
</span><span class='line'>/* 
</span><span class='line'> * The slab management structure can be either off the slab or 
</span><span class='line'> * on it. For the latter case, the memory allocated for a 
</span><span class='line'> * slab is used for: 
</span><span class='line'> * 
</span><span class='line'> * - The struct slab 
</span><span class='line'> * - One kmem_bufctl_t for each object 
</span><span class='line'> * - Padding to respect alignment of @align 
</span><span class='line'> * - @buffer_size bytes for each object 
</span><span class='line'> * 
</span><span class='line'> * If the slab management structure is off the slab, then the 
</span><span class='line'> * alignment will already be calculated into the size. Because 
</span><span class='line'> * the slabs are all pages aligned, the objects will be at the 
</span><span class='line'> * correct alignment when allocated. 
</span><span class='line'> */  
</span><span class='line'> /*如果slab描述符存储在slab外部，则slab的对象数即为slab_size/buffer_size*/  
</span><span class='line'>if (flags &amp; CFLGS_OFF_SLAB) {  
</span><span class='line'>    mgmt_size = 0;  
</span><span class='line'>    nr_objs = slab_size / buffer_size;  
</span><span class='line'>
</span><span class='line'>    if (nr_objs &gt; SLAB_LIMIT)  
</span><span class='line'>        nr_objs = SLAB_LIMIT;  
</span><span class='line'>} else {/*否则先减去slab管理区的大小再进行计算*/  
</span><span class='line'>    /* 
</span><span class='line'>     * Ignore padding for the initial guess. The padding 
</span><span class='line'>     * is at most @align-1 bytes, and @buffer_size is at 
</span><span class='line'>     * least @align. In the worst case, this result will 
</span><span class='line'>     * be one greater than the number of objects that fit 
</span><span class='line'>     * into the memory allocation when taking the padding 
</span><span class='line'>     * into account. 
</span><span class='line'>     */  
</span><span class='line'>    nr_objs = (slab_size - sizeof(struct slab)) /  
</span><span class='line'>          (buffer_size + sizeof(kmem_bufctl_t));  
</span><span class='line'>
</span><span class='line'>    /* 
</span><span class='line'>     * This calculated number will be either the right 
</span><span class='line'>     * amount, or one greater than what we want. 
</span><span class='line'>     */  
</span><span class='line'>    if (slab_mgmt_size(nr_objs, align) + nr_objs*buffer_size  
</span><span class='line'>           &gt; slab_size)  
</span><span class='line'>        nr_objs--;  
</span><span class='line'>
</span><span class='line'>    if (nr_objs &gt; SLAB_LIMIT)  
</span><span class='line'>        nr_objs = SLAB_LIMIT;  
</span><span class='line'>              /*计算slab管理区的大小*/  
</span><span class='line'>    mgmt_size = slab_mgmt_size(nr_objs, align);  
</span><span class='line'>}  
</span><span class='line'>/*保存slab对象数*/  
</span><span class='line'>*num = nr_objs;  
</span><span class='line'>/*计算并保存slab的剩余空间*/  
</span><span class='line'>*left_over = slab_size - nr_objs*buffer_size - mgmt_size;  
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>##### 在slab初始化完成后，也就是g_cpucache_up变量的值为FULL后
</span><span class='line'>setup_cpu_cache()函数等价于`setup_cpu_cache()--&gt;enable_cpucache()`
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp)  
</span><span class='line'>{  
</span><span class='line'>int err;  
</span><span class='line'>int limit, shared;  
</span><span class='line'>
</span><span class='line'>/* 
</span><span class='line'> * The head array serves three purposes: 
</span><span class='line'> * - create a LIFO ordering, i.e. return objects that are cache-warm 
</span><span class='line'> * - reduce the number of spinlock operations. 
</span><span class='line'> * - reduce the number of linked list operations on the slab and 
</span><span class='line'> *   bufctl chains: array operations are cheaper. 
</span><span class='line'> * The numbers are guessed, we should auto-tune as described by 
</span><span class='line'> * Bonwick. 
</span><span class='line'> */  
</span><span class='line'> /*根据对象的大小来确定本地高速缓存中的空闲对象上限*/  
</span><span class='line'>if (cachep-&gt;buffer_size &gt; 131072)  
</span><span class='line'>    limit = 1;  
</span><span class='line'>else if (cachep-&gt;buffer_size &gt; PAGE_SIZE)  
</span><span class='line'>    limit = 8;  
</span><span class='line'>else if (cachep-&gt;buffer_size &gt; 1024)  
</span><span class='line'>    limit = 24;  
</span><span class='line'>else if (cachep-&gt;buffer_size &gt; 256)  
</span><span class='line'>    limit = 54;  
</span><span class='line'>else  
</span><span class='line'>    limit = 120;  
</span><span class='line'>
</span><span class='line'>/* 
</span><span class='line'> * CPU bound tasks (e.g. network routing) can exhibit cpu bound 
</span><span class='line'> * allocation behaviour: Most allocs on one cpu, most free operations 
</span><span class='line'> * on another cpu. For these cases, an efficient object passing between 
</span><span class='line'> * cpus is necessary. This is provided by a shared array. The array 
</span><span class='line'> * replaces Bonwick's magazine layer. 
</span><span class='line'> * On uniprocessor, it's functionally equivalent (but less efficient) 
</span><span class='line'> * to a larger limit. Thus disabled by default. 
</span><span class='line'> */  
</span><span class='line'>shared = 0;  
</span><span class='line'>if (cachep-&gt;buffer_size &lt;= PAGE_SIZE &amp;&amp; num_possible_cpus() &gt; 1)  
</span><span class='line'>    shared = 8;  
</span><span class='line'>
</span><span class='line'>#if DEBUG   
</span><span class='line'>/* 
</span><span class='line'> * With debugging enabled, large batchcount lead to excessively long 
</span><span class='line'> * periods with disabled local interrupts. Limit the batchcount 
</span><span class='line'> */  
</span><span class='line'>if (limit &gt; 32)  
</span><span class='line'>    limit = 32;  
</span><span class='line'>#endif   
</span><span class='line'>err = do_tune_cpucache(cachep, limit, (limit + 1) / 2, shared, gfp);  
</span><span class='line'>if (err)  
</span><span class='line'>    printk(KERN_ERR "enable_cpucache failed for %s, error %d.\n",  
</span><span class='line'>           cachep-&gt;name, -err);  
</span><span class='line'>return err;  
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static int do_tune_cpucache(struct kmem_cache *cachep, int limit,  
</span><span class='line'>            int batchcount, int shared, gfp_t gfp)  
</span><span class='line'>{  
</span><span class='line'>struct ccupdate_struct *new;  
</span><span class='line'>int i;  
</span><span class='line'>
</span><span class='line'>/*申请一个ccupdate_struct*/  
</span><span class='line'>new = kzalloc(sizeof(*new), gfp);  
</span><span class='line'>if (!new)  
</span><span class='line'>    return -ENOMEM;  
</span><span class='line'>
</span><span class='line'>/*为每个CPU申请array_cache和用来跟踪本地CPU空闲对象的指针数组*/  
</span><span class='line'>for_each_online_cpu(i) {  
</span><span class='line'>    new-&gt;new[i] = alloc_arraycache(cpu_to_node(i), limit,  
</span><span class='line'>                    batchcount, gfp);  
</span><span class='line'>    if (!new-&gt;new[i]) {  
</span><span class='line'>        for (i--; i &gt;= 0; i--)  
</span><span class='line'>            kfree(new-&gt;new[i]);  
</span><span class='line'>        kfree(new);  
</span><span class='line'>        return -ENOMEM;  
</span><span class='line'>    }  
</span><span class='line'>}  
</span><span class='line'>new-&gt;cachep = cachep;  
</span><span class='line'>
</span><span class='line'>/*将cachep和array_cache进关联*/  
</span><span class='line'>on_each_cpu(do_ccupdate_local, (void *)new, 1);  
</span><span class='line'>
</span><span class='line'>check_irq_on();  
</span><span class='line'>cachep-&gt;batchcount = batchcount;  
</span><span class='line'>cachep-&gt;limit = limit;  
</span><span class='line'>cachep-&gt;shared = shared;  
</span><span class='line'>
</span><span class='line'>for_each_online_cpu(i) {  
</span><span class='line'>    struct array_cache *ccold = new-&gt;new[i];  
</span><span class='line'>    if (!ccold)  
</span><span class='line'>        continue;  
</span><span class='line'>    spin_lock_irq(&amp;cachep-&gt;nodelists[cpu_to_node(i)]-&gt;list_lock);  
</span><span class='line'>    free_block(cachep, ccold-&gt;entry, ccold-&gt;avail, cpu_to_node(i));  
</span><span class='line'>    spin_unlock_irq(&amp;cachep-&gt;nodelists[cpu_to_node(i)]-&gt;list_lock);  
</span><span class='line'>    kfree(ccold);  
</span><span class='line'>}  
</span><span class='line'>kfree(new);  
</span><span class='line'>/*申请kmem_list3*/  
</span><span class='line'>return alloc_kmemlist(cachep, gfp);  
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>## 四、分配对象
</span><span class='line'>从一个缓存中分配对象总是遵循下面的原则：  
</span><span class='line'>1. 本地高速缓存中是否有空闲对象，如果有的话则从其中获取对象，这时分配的对象是最“热”的；  
</span><span class='line'>2. 如果本地高速缓存中没有对象，则从kmem_list3中的slab链表中寻找空闲对象并填充到本地高速缓存再分配；  
</span><span class='line'>3. 如果所有的slab中都没有空闲对象了，那么就要创建新的slab,再分配 。
</span><span class='line'>
</span><span class='line'>函数kmem_cache_alloc用于从特定的缓存获取对象，kmalloc用于从普通缓存中获取对象，它们的执行流程如下图所示
</span><span class='line'>
</span><span class='line'>![](/images/kernel/2015-03-03-12.png)
</span><span class='line'>
</span><span class='line'>实质性的工作是从`____cache_alloc()`开始的，因此从这个函数作为入口来分析
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static inline void *____cache_alloc(struct kmem_cache *cachep, gfp_t flags)  
</span><span class='line'>{  
</span><span class='line'>void *objp;  
</span><span class='line'>struct array_cache *ac;  
</span><span class='line'>
</span><span class='line'>check_irq_off();  
</span><span class='line'>
</span><span class='line'>/*获取缓存的本地高速缓存的描述符array_cache*/  
</span><span class='line'>ac = cpu_cache_get(cachep);  
</span><span class='line'>
</span><span class='line'>/*如果本地高速缓存中还有空闲对象可以分配则从本地高速缓存中分配*/  
</span><span class='line'>if (likely(ac-&gt;avail)) {  
</span><span class='line'>    STATS_INC_ALLOCHIT(cachep);  
</span><span class='line'>    ac-&gt;touched = 1;  
</span><span class='line'>    /*先将avail的值减1，这样avail对应的空闲对象是最热的，即最近释放出来的， 
</span><span class='line'>      更有可能驻留在CPU高速缓存中*/  
</span><span class='line'>    objp = ac-&gt;entry[--ac-&gt;avail];  
</span><span class='line'>} else {/*否则需要填充本地高速缓存*/  
</span><span class='line'>    STATS_INC_ALLOCMISS(cachep);  
</span><span class='line'>    objp = cache_alloc_refill(cachep, flags);  
</span><span class='line'>}  
</span><span class='line'>/* 
</span><span class='line'> * To avoid a false negative, if an object that is in one of the 
</span><span class='line'> * per-CPU caches is leaked, we need to make sure kmemleak doesn't 
</span><span class='line'> * treat the array pointers as a reference to the object. 
</span><span class='line'> */  
</span><span class='line'>kmemleak_erase(&amp;ac-&gt;entry[ac-&gt;avail]);  
</span><span class='line'>return objp;  
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static void *cache_alloc_refill(struct kmem_cache *cachep, gfp_t flags)  
</span><span class='line'>{  
</span><span class='line'>int batchcount;  
</span><span class='line'>struct kmem_list3 *l3;  
</span><span class='line'>struct array_cache *ac;  
</span><span class='line'>int node;  
</span><span class='line'>
</span><span class='line'>retry:  
</span><span class='line'>check_irq_off();  
</span><span class='line'>node = numa_node_id();  
</span><span class='line'>ac = cpu_cache_get(cachep);  
</span><span class='line'>batchcount = ac-&gt;batchcount;  /*获取批量转移的数目*/  
</span><span class='line'>if (!ac-&gt;touched &amp;&amp; batchcount &gt; BATCHREFILL_LIMIT) {  
</span><span class='line'>    /* 
</span><span class='line'>     * If there was little recent activity on this cache, then 
</span><span class='line'>     * perform only a partial refill.  Otherwise we could generate 
</span><span class='line'>     * refill bouncing. 
</span><span class='line'>     */  
</span><span class='line'>    batchcount = BATCHREFILL_LIMIT;  
</span><span class='line'>}  
</span><span class='line'>/*获取kmem_list3*/  
</span><span class='line'>l3 = cachep-&gt;nodelists[node];  
</span><span class='line'>
</span><span class='line'>BUG_ON(ac-&gt;avail &gt; 0 || !l3);  
</span><span class='line'>spin_lock(&amp;l3-&gt;list_lock);  
</span><span class='line'>
</span><span class='line'>/* See if we can refill from the shared array */  
</span><span class='line'>/*如果有共享本地高速缓存，则从共享本地高速缓存填充*/  
</span><span class='line'>if (l3-&gt;shared &amp;&amp; transfer_objects(ac, l3-&gt;shared, batchcount))  
</span><span class='line'>    goto alloc_done;  
</span><span class='line'>
</span><span class='line'>while (batchcount &gt; 0) {  
</span><span class='line'>    struct list_head *entry;  
</span><span class='line'>    struct slab *slabp;  
</span><span class='line'>    /* Get slab alloc is to come from. */  
</span><span class='line'>    /*扫描slab链表，先从partial链表开始，如果整个partial链表都无法找到batchcount个空闲对象， 
</span><span class='line'>    再扫描free链表*/  
</span><span class='line'>    entry = l3-&gt;slabs_partial.next;  
</span><span class='line'>
</span><span class='line'>    /*entry回到表头说明partial链表已经扫描完毕，开始扫描free链表*/  
</span><span class='line'>    if (entry == &amp;l3-&gt;slabs_partial) {  
</span><span class='line'>        l3-&gt;free_touched = 1;  
</span><span class='line'>        entry = l3-&gt;slabs_free.next;  
</span><span class='line'>        if (entry == &amp;l3-&gt;slabs_free)  
</span><span class='line'>            goto must_grow;  
</span><span class='line'>    }  
</span><span class='line'>
</span><span class='line'>    /*由链表项得到slab描述符*/  
</span><span class='line'>    slabp = list_entry(entry, struct slab, list);  
</span><span class='line'>    check_slabp(cachep, slabp);  
</span><span class='line'>    check_spinlock_acquired(cachep);  
</span><span class='line'>
</span><span class='line'>    /* 
</span><span class='line'>     * The slab was either on partial or free list so 
</span><span class='line'>     * there must be at least one object available for 
</span><span class='line'>     * allocation. 
</span><span class='line'>     */  
</span><span class='line'>    BUG_ON(slabp-&gt;inuse &gt;= cachep-&gt;num);  
</span><span class='line'>
</span><span class='line'>    /*如果slabp中还存在空闲对象并且还需要继续填充对象到本地高速缓存*/  
</span><span class='line'>    while (slabp-&gt;inuse &lt; cachep-&gt;num &amp;&amp; batchcount--) {  
</span><span class='line'>        STATS_INC_ALLOCED(cachep);  
</span><span class='line'>        STATS_INC_ACTIVE(cachep);  
</span><span class='line'>        STATS_SET_HIGH(cachep);  
</span><span class='line'>
</span><span class='line'>        /*填充的本质就是用ac后面的void*数组元素指向一个空闲对象*/  
</span><span class='line'>        ac-&gt;entry[ac-&gt;avail++] = slab_get_obj(cachep, slabp,  
</span><span class='line'>                            node);  
</span><span class='line'>    }  
</span><span class='line'>    check_slabp(cachep, slabp);  
</span><span class='line'>
</span><span class='line'>    /* move slabp to correct slabp list: */  
</span><span class='line'>    /*由于从slab中分配出去了对象，因此有可能需要将slab移到其他链表中去*/  
</span><span class='line'>    list_del(&amp;slabp-&gt;list);  
</span><span class='line'>    /*free等于BUFCTL_END表示空闲对象已耗尽，将slab插入full链表*/  
</span><span class='line'>    if (slabp-&gt;free == BUFCTL_END)  
</span><span class='line'>        list_add(&amp;slabp-&gt;list, &amp;l3-&gt;slabs_full);  
</span><span class='line'>    else/*否则肯定是插入partial链表*/  
</span><span class='line'>        list_add(&amp;slabp-&gt;list, &amp;l3-&gt;slabs_partial);  
</span><span class='line'>}  
</span><span class='line'>
</span><span class='line'>must_grow:  
</span><span class='line'>l3-&gt;free_objects -= ac-&gt;avail;/*刷新kmem_list3中的空闲对象*/  
</span><span class='line'>alloc_done:  
</span><span class='line'>spin_unlock(&amp;l3-&gt;list_lock);  
</span><span class='line'>
</span><span class='line'>/*avail为0表示kmem_list3中的slab全部处于full状态或者没有slab,则要为缓存分配slab*/  
</span><span class='line'>if (unlikely(!ac-&gt;avail)) {  
</span><span class='line'>    int x;  
</span><span class='line'>    x = cache_grow(cachep, flags | GFP_THISNODE, node, NULL);  
</span><span class='line'>
</span><span class='line'>    /* cache_grow can reenable interrupts, then ac could change. */  
</span><span class='line'>    ac = cpu_cache_get(cachep);  
</span><span class='line'>    if (!x &amp;&amp; ac-&gt;avail == 0)    /* no objects in sight? abort */  
</span><span class='line'>        return NULL;  
</span><span class='line'>
</span><span class='line'>    if (!ac-&gt;avail)      /* objects refilled by interrupt? */  
</span><span class='line'>        goto retry;  
</span><span class='line'>}  
</span><span class='line'>ac-&gt;touched = 1;  
</span><span class='line'>/*返回最后一个末端的对象*/  
</span><span class='line'>return ac-&gt;entry[--ac-&gt;avail];  
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;对于所有slab都空闲对象的情况，需要调用cache_grow()来增加cache的容量，这个函数在后面分析slab的分配时再做介绍。&lt;/p&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[Linux slab 分配器剖析]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2015/03/03/kernel-mm-slab1/"/&gt;
</span><span class='line'>&lt;updated&gt;2015-03-03T17:15:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2015/03/03/kernel-mm-slab1&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;p&gt;&lt;a href="http://www.ibm.com/developerworks/cn/linux/l-linux-slab-allocator/"&gt;http://www.ibm.com/developerworks/cn/linux/l-linux-slab-allocator/&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;动态内存管理&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;内存管理的目标是提供一种方法，为实现各种目的而在各个用户之间实现内存共享。内存管理方法应该实现以下两个功能：&lt;br/&gt;
</span><span class='line'>1. 最小化管理内存所需的时间
</span><span class='line'>2. 最大化用于一般应用的可用内存（最小化管理开销）&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  内存管理实际上是一种关于权衡的零和游戏。您可以开发一种使用少量内存进行管理的算法，但是要花费更多时间来管理可用内存。也可以开发一个算法来有效地管理内存，但却要使用更多的内存。最终，特定应用程序的需求将促使对这种权衡作出选择。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  每个内存管理器都使用了一种基于堆的分配策略。在这种方法中，大块内存（称为 堆）用来为用户定义的目的提供内存。当用户需要一块内存时，就请求给自己分配一定大小的内存。堆管理器会查看可用内存的情况（使用特定算法）并返回一块内存。搜索过程中使用的一些算法有 first-fit（在堆中搜索到的第一个满足请求的内存块 ）和 best-fit（使用堆中满足请求的最合适的内存块）。当用户使用完内存后，就将内存返回给堆。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  这种基于堆的分配策略的根本问题是碎片（fragmentation）。当内存块被分配后，它们会以不同的顺序在不同的时间返回。这样会在堆中留下一些洞，需要花一些时间才能有效地管理空闲内存。这种算法通常具有较高的内存使用效率（分配需要的内存），但是却需要花费更多时间来对堆进行管理。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  另外一种方法称为 buddy memory allocation，是一种更快的内存分配技术，它将内存划分为 2 的幂次方个分区，并使用 best-fit 方法来分配内存请求。当用户释放内存时，就会检查 buddy 块，查看其相邻的内存块是否也已经被释放。如果是的话，将合并内存块以最小化内存碎片。这个算法的时间效率更高，但是由于使用 best-fit 方法的缘故，会产生内存浪费。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;本文将着重介绍 Linux 内核的内存管理，尤其是 slab 分配提供的机制。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;slab 缓存&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  Linux 所使用的 slab 分配器的基础是 Jeff Bonwick 为 SunOS 操作系统首次引入的一种算法。Jeff 的分配器是围绕对象缓存进行的。在内核中，会为有限的对象集（例如文件描述符和其他常见结构）分配大量内存。Jeff 发现对内核中普通对象进行初始化所需的时间超过了对其进行分配和释放所需的时间。因此他的结论是不应该将内存释放回一个全局的内存池，而是将内存保持为针对特定目而初始化的状态。例如，如果内存被分配给了一个互斥锁，那么只需在为互斥锁首次分配内存时执行一次互斥锁初始化函数（mutex_init）即可。后续的内存分配不需要执行这个初始化函数，因为从上次释放和调用析构之后，它已经处于所需的状态中了。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Linux slab 分配器使用了这种思想和其他一些思想来构建一个在空间和时间上都具有高效性的内存分配器。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;图 1 给出了 slab 结构的高层组织结构。在最高层是 cache_chain，这是一个 slab 缓存的链接列表。这对于 best-fit 算法非常有用，可以用来查找最适合所需要的分配大小的缓存（遍历列表）。cache_chain 的每个元素都是一个 kmem_cache 结构的引用（称为一个 cache）。它定义了一个要管理的给定大小的对象池。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;img src="/images/kernel/2015-03-03-1.gif" alt="" /&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;每个缓存都包含了一个 slabs 列表，这是一段连续的内存块（通常都是页面）。存在 3 种 slab：&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;slabs_full&lt;br/&gt;
</span><span class='line'>完全分配的 slab &lt;br/&gt;
</span><span class='line'>slabs_partial&lt;br/&gt;
</span><span class='line'>部分分配的 slab&lt;br/&gt;
</span><span class='line'>slabs_empty&lt;br/&gt;
</span><span class='line'>空 slab，或者没有对象被分配&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  注意 slabs_empty 列表中的 slab 是进行回收（reaping）的主要备选对象。正是通过此过程，slab 所使用的内存被返回给操作系统供其他用户使用。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  slab 列表中的每个 slab 都是一个连续的内存块（一个或多个连续页），它们被划分成一个个对象。这些对象是从特定缓存中进行分配和释放的基本元素。注意 slab 是 slab 分配器进行操作的最小分配单位，因此如果需要对 slab 进行扩展，这也就是所扩展的最小值。通常来说，每个 slab 被分配为多个对象。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  由于对象是从 slab 中进行分配和释放的，因此单个 slab 可以在 slab 列表之间进行移动。例如，当一个 slab 中的所有对象都被使用完时，就从 slabs_partial 列表中移动到 slabs_full 列表中。当一个 slab 完全被分配并且有对象被释放后，就从 slabs_full 列表中移动到 slabs_partial 列表中。当所有对象都被释放之后，就从 slabs_partial 列表移动到 slabs_empty 列表中。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;slab 背后的动机&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  与传统的内存管理模式相比， slab 缓存分配器提供了很多优点。首先，内核通常依赖于对小对象的分配，它们会在系统生命周期内进行无数次分配。slab 缓存分配器通过对类似大小的对象进行缓存而提供这种功能，从而避免了常见的碎片问题。slab 分配器还支持通用对象的初始化，从而避免了为同一目而对一个对象重复进行初始化。最后，slab 分配器还可以支持硬件缓存对齐和着色，这允许不同缓存中的对象占用相同的缓存行，从而提高缓存的利用率并获得更好的性能。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;API 函数&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;现在来看一下能够创建新 slab 缓存、向缓存中增加内存、销毁缓存的应用程序接口（API）以及 slab 中对对象进行分配和释放操作的函数。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;第一个步骤是创建 slab 缓存结构，您可以将其静态创建为：
</span><span class='line'>&lt;code&gt;
</span><span class='line'>struct struct kmem_cache *my_cachep;
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>然后其他 slab 缓存函数将使用该引用进行创建、删除、分配等操作。kmem_cache 结构包含了每个中央处理器单元（CPU）的数据、一组可调整的（可以通过 proc 文件系统访问）参数、统计信息和管理 slab 缓存所必须的元素。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;kmem_cache_create&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;内核函数 kmem_cache_create 用来创建一个新缓存。这通常是在内核初始化时执行的，或者在首次加载内核模块时执行。其原型定义如下：
</span><span class='line'>&lt;code&gt;
</span><span class='line'>struct kmem_cache *
</span><span class='line'>kmem_cache_create( const char *name, size_t size, size_t align,
</span><span class='line'>                       unsigned long flags;
</span><span class='line'>                       void (*ctor)(void*, struct kmem_cache *, unsigned long),
</span><span class='line'>                       void (*dtor)(void*, struct kmem_cache *, unsigned long));
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>name 参数定义了缓存名称，proc 文件系统（在 /proc/slabinfo 中）使用它标识这个缓存。 size 参数指定了为这个缓存创建的对象的大小， align 参数定义了每个对象必需的对齐。 flags 参数指定了为缓存启用的选项。这些标志如表 1 所示。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;表 1. kmem_cache_create 的部分选项（在 flags 参数中指定）&lt;br/&gt;
</span><span class='line'>选项                  说明&lt;br/&gt;
</span><span class='line'>SLAB_RED_ZONE       在对象头、尾插入标志，用来支持对缓冲区溢出的检查。&lt;br/&gt;
</span><span class='line'>SLAB_POISON         使用一种己知模式填充 slab，允许对缓存中的对象进行监视（对象属对象所有，不过可以在外部进行修改）。&lt;br/&gt;
</span><span class='line'>SLAB_HWCACHE_ALIGN  指定缓存对象必须与硬件缓存行对齐。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;ctor 和 dtor 参数定义了一个可选的对象构造器和析构器。构造器和析构器是用户提供的回调函数。当从缓存中分配新对象时，可以通过构造器进行初始化。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;在创建缓存之后， kmem_cache_create 函数会返回对它的引用。注意这个函数并没有向缓存分配任何内存。相反，在试图从缓存（最初为空）分配对象时，refill 操作将内存分配给它。当所有对象都被使用掉时，也可以通过相同的操作向缓存添加内存。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;kmem_cache_destroy&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;内核函数 kmem_cache_destroy 用来销毁缓存。这个调用是由内核模块在被卸载时执行的。在调用这个函数时，缓存必须为空。
</span><span class='line'>&lt;code&gt;
</span><span class='line'>void kmem_cache_destroy( struct kmem_cache *cachep );
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;kmem_cache_alloc&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;要从一个命名的缓存中分配一个对象，可以使用 kmem_cache_alloc 函数。调用者提供了从中分配对象的缓存以及一组标志：
</span><span class='line'>&lt;code&gt;
</span><span class='line'>void kmem_cache_alloc( struct kmem_cache *cachep, gfp_t flags );
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>这个函数从缓存中返回一个对象。注意如果缓存目前为空，那么这个函数就会调用 cache_alloc_refill 向缓存中增加内存。 kmem_cache_alloc 的 flags 选项与 kmalloc 的 flags 选项相同。表 2 给出了标志选项的部分列表。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;表 2. kmem_cache_alloc 和 kmalloc 内核函数的标志选项&lt;br/&gt;
</span><span class='line'>标志              说明&lt;br/&gt;
</span><span class='line'>GFP_USER        为用户分配内存（这个调用可能会睡眠）。&lt;br/&gt;
</span><span class='line'>GFP_KERNEL      从内核 RAM 中分配内存（这个调用可能会睡眠）。&lt;br/&gt;
</span><span class='line'>GFP_ATOMIC      使该调用强制处于非睡眠状态（对中断处理程序非常有用）。&lt;br/&gt;
</span><span class='line'>GFP_HIGHUSER    从高端内存中分配内存。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;kmem_cache_zalloc&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;内核函数 kmem_cache_zalloc 与 kmem_cache_alloc 类似，只不过它对对象执行 memset 操作，用来在将对象返回调用者之前对其进行清除操作。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;kmem_cache_free&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;要将一个对象释放回 slab，可以使用 kmem_cache_free。调用者提供了缓存引用和要释放的对象。
</span><span class='line'>&lt;code&gt;
</span><span class='line'>void kmem_cache_free( struct kmem_cache *cachep, void *objp );
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;kmalloc 和 kfree&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;内核中最常用的内存管理函数是 kmalloc 和 kfree 函数。这两个函数的原型如下：
</span><span class='line'>&lt;code&gt;
</span><span class='line'>void *kmalloc( size_t size, int flags );
</span><span class='line'>void kfree( const void *objp );
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>注意在 kmalloc 中，惟一两个参数是要分配的对象的大小和一组标志（请参看 表 2 中的部分列表）。但是 kmalloc 和 kfree 使用了类似于前面定义的函数的 slab 缓存。kmalloc 没有为要从中分配对象的某个 slab 缓存命名，而是循环遍历可用缓存来查找可以满足大小限制的缓存。找到之后，就（使用 &lt;code&gt;__kmem_cache_alloc&lt;/code&gt;）分配一个对象。要使用 kfree 释放对象，从中分配对象的缓存可以通过调用 virt_to_cache 确定。这个函数会返回一个缓存引用，然后在 &lt;code&gt;__cache_free&lt;/code&gt; 调用中使用该引用释放对象。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;其他函数&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;slab 缓存 API 还提供了其他一些非常有用的函数。 kmem_cache_size 函数会返回这个缓存所管理的对象的大小。您也可以通过调用 kmem_cache_name 来检索给定缓存的名称（在创建缓存时定义）。缓存可以通过释放其中的空闲 slab 进行收缩。这可以通过调用 kmem_cache_shrink 实现。注意这个操作（称为回收）是由内核定期自动执行的（通过 kswapd）。
</span><span class='line'>&lt;code&gt;
</span><span class='line'>unsigned int kmem_cache_size( struct kmem_cache *cachep );
</span><span class='line'>const char *kmem_cache_name( struct kmem_cache *cachep );
</span><span class='line'>int kmem_cache_shrink( struct kmem_cache *cachep );
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;slab 缓存的示例用法&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;下面的代码片断展示了创建新 slab 缓存、从缓存中分配和释放对象然后销毁缓存的过程。首先，必须要定义一个 kmem_cache 对象，然后对其进行初始化（请参看清单 1）。这个特定的缓存包含 32 字节的对象，并且是硬件缓存对齐的（由标志参数 SLAB_HWCACHE_ALIGN 定义）。&lt;br/&gt;
</span><span class='line'>清单 1. 创建新 slab 缓存</span></code></pre></td></tr></table></div></figure>
    static struct kmem_cache *my_cachep;</p>

<pre><code>static void init_my_cache( void )
{

    my_cachep = kmem_cache_create( 
                  "my_cache",            /* Name */
                  32,                    /* Object Size */
                  0,                     /* Alignment */
                  SLAB_HWCACHE_ALIGN,    /* Flags */
                  NULL, NULL );          /* Constructor/Deconstructor */

    return;
}
</code></pre>

<pre><code>使用所分配的 slab 缓存，您现在可以从中分配一个对象了。清单 2 给出了一个从缓存中分配和释放对象的例子。它还展示了两个其他函数的用法。  
清单 2. 分配和释放对象
</code></pre>

<pre><code>int slab_test( void )
{
    void *object;

    printk( "Cache name is %s\n", kmem_cache_name( my_cachep ) );
    printk( "Cache object size is %d\n", kmem_cache_size( my_cachep ) );

    object = kmem_cache_alloc( my_cachep, GFP_KERNEL );
    if (object) {
        kmem_cache_free( my_cachep, object );
    }
    return 0;
}
</code></pre>

<pre><code>最后，清单 3 演示了 slab 缓存的销毁。调用者必须确保在执行销毁操作过程中，不要从缓存中分配对象。  
清单 3. 销毁 slab 缓存
</code></pre>

<pre><code>static void remove_my_cache( void )
{
    if (my_cachep) kmem_cache_destroy( my_cachep );
    return;
}
</code></pre>

<pre><code>
### slab 的 proc 接口
  proc 文件系统提供了一种简单的方法来监视系统中所有活动的 slab 缓存。这个文件称为 /proc/slabinfo，它除了提供一些可以从用户空间访问的可调整参数之外，还提供了有关所有 slab 缓存的详细信息。当前版本的 slabinfo 提供了一个标题，这样输出结果就更具可读性。对于系统中的每个 slab 缓存来说，这个文件提供了对象数量、活动对象数量以及对象大小的信息（除了每个 slab 的对象和页面之外）。另外还提供了一组可调整的参数和 slab 数据。

  要调优特定的 slab 缓存，可以简单地向 /proc/slabinfo 文件中以字符串的形式回转 slab 缓存名称和 3 个可调整的参数。下面的例子展示了如何增加 limit 和 batchcount 的值，而保留 shared factor 不变（格式为 “cache name limit batchcount shared factor”）：
</code></pre>

<pre><code># echo "my_cache 128 64 8" &gt; /proc/slabinfo
</code></pre>

<p>```
limit 字段表示每个 CPU 可以缓存的对象的最大数量。 batchcount 字段是当缓存为空时转换到每个 CPU 缓存中全局缓存对象的最大数量。 shared 参数说明了对称多处理器（Symmetric MultiProcessing，SMP）系统的共享行为。</p>

<p>注意您必须具有超级用户的特权才能在 proc 文件系统中为 slab 缓存调优参数。</p>

<h4>SLOB 分配器</h4>

<p>对于小型的嵌入式系统来说，存在一个 slab 模拟层，名为 SLOB。这个 slab 的替代品在小型嵌入式 Linux 系统中具有优势，但是即使它保存了 512KB 内存，依然存在碎片和难于扩展的问题。在禁用 CONFIG_SLAB 时，内核会回到这个 SLOB 分配器中。更多信息请参看 参考资料 一节。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NUMA技术相关笔记]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/02/09/kernel-mm-numa2/"/>
    <updated>2015-02-09T16:34:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/02/09/kernel-mm-numa2</id>
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/jollyjumper/article/details/17168175">http://blog.csdn.net/jollyjumper/article/details/17168175</a></p>

<p>起源于在mongo启动脚本中看到<code>numactl --interleave=all mongod ...</code>。</p>

<p>  NUMA,非统一内存访问(Non-uniform Memory Access),介于SMP(对称多处理)和MPP(大规模并行处理)之间，各个节点自有内存(甚至IO子系统),访问其它节点的内存则通过高速网络通道。NUMA信息主要通过BIOS中的ACPI(高级配置和编程接口)进行配置,Linux对NUMA系统的物理内存分布信息从系统firmware的ACPi表中获得，最重要的是SRAT(System Resource Affinity Table)和SLIT(System locality Information Table)表。SRAT表包含CPU信息、内存相关性信息,SLIT表则记录了各个节点之间的距离，在系统中由数组node_distance[]记录。这样系统可以就近分配内存，减少延迟。</p>

<p>Linux中用一个struct pg_data_t表示一个numa节点，Linux内核支持numa调度,并实现CPU的负载均衡。</p>

<h5>查看是否支持:</h5>

<p>dmesg | grep -i numa</p>

<h5>要查看具体的numa信息用numastat</h5>

<pre><code>numastat
                           node0           node1
numa_hit             19983469427     20741805466
numa_miss             1981451471      2503049250
numa_foreign          2503049250      1981451471
interleave_hit         849781831       878579884
local_node           19627390917     20298995632
other_node            2337529981      2945859084
</code></pre>

<p>numa_hit是打算在该节点上分配内存，最后从这个节点分配的次数;<br/>
num_miss是打算在该节点分配内存，最后却从其他节点分配的次数;<br/>
num_foregin是打算在其他节点分配内存，最后却从这个节点分配的次数;<br/>
interleave_hit是采用interleave策略最后从该节点分配的次数;<br/>
local_node该节点上的进程在该节点上分配的次数<br/>
other_node是其他节点进程在该节点上分配的次数</p>

<h5>lscpu可以看到两个node的cpu归属:</h5>

<pre><code>lscpu
...
NUMA node0 CPU(s):     0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30
NUMA node1 CPU(s):     1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31
</code></pre>

<h5><code>numactl --hardware</code>命令</h5>

<p>会返回不同节点的内存总大小，可用大小,以及node distance等信息。</p>

<p>各个cpu负载情况，使用命令:mpstat -P ALL(需要安装sysstat)</p>

<p>Linux上使用numactl设定进程的numa策略。常见的情况是,数据库daemon进程(mongodb,mysql)可能会吃掉很多内存，而一个numa节点上的内存很有限，内存不够时虚拟内存频繁与硬盘交换数据，导致性能急剧下降(标识是irqbalance进程top中居高不下),这时应该采用interleave的numa策略，允许从其他节点分配内存。</p>

<p>各个内存的访问延迟如何?numactl man中的example提供了参考,我在公司的服务器上测了一下:</p>

<h5>写速度:</h5>

<pre><code>numactl --cpubind=0 --membind=0 dd if=/dev/zero of=/dev/shm/A bs=1M count=1024

1024+0 records in
1024+0 records out
1073741824 bytes (1.1 GB) copied, 0.546679 s, 2.0 GB/s

numactl --cpubind=0 --membind=1 dd if=/dev/zero of=/dev/shm/A bs=1M count=1024
1024+0 records in
1024+0 records out
1073741824 bytes (1.1 GB) copied, 0.612825 s, 1.8 GB/s
</code></pre>

<h5>读速度:</h5>

<p>测试从同一个节点读取:
<code>
numactl --cpubind=0 --membind=0 dd if=/dev/zero of=/dev/shm/A bs=1M count=1000
date +%s.%N
numactl --cpubind=0 --membind=0 cp /dev/shm/A /dev/null
date +%s.%N
rm /dev/shm/A
</code>
花费0.264556884765625秒,速度是3.779905410081901GB/s。</p>

<p>从另一个节点读取:
<code>
numactl --cpubind=0 --membind=0 dd if=/dev/zero of=/dev/shm/A bs=1M count=1000
date +%s.%N
numactl --cpubind=1 --membind=1 cp /dev/shm/A /dev/null
date +%s.%N
rm /dev/shm/A
</code>
花费0.3308408260345459秒,速度是3.022601569419312GB/s。</p>

<p>加速效果还是很明显的。</p>

<h4>参考:</h4>

<p><a href="http://www.ibm.com/developerworks/cn/linux/l-numa/  ">http://www.ibm.com/developerworks/cn/linux/l-numa/  </a>
<a href="http://www.dedecms.com/knowledge/data-base/nosql/2012/0820/8684.html">http://www.dedecms.com/knowledge/data-base/nosql/2012/0820/8684.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转CPU Topology]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/02/09/kernel-mm-numa/"/>
    <updated>2015-02-09T16:19:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/02/09/kernel-mm-numa</id>
    <content type="html"><![CDATA[<p><a href="http://www.searchtb.com/2012/12/%E7%8E%A9%E8%BD%ACcpu-topology.html">http://www.searchtb.com/2012/12/%E7%8E%A9%E8%BD%ACcpu-topology.html</a></p>

<h4>先温习几个概念</h4>

<p>请原谅对部分术语笔者直接引用了wikipedia上的英文解释，因为哥实在做不到比wikipedia上更准确描述。我会试着解释部分的术语，并在本节的最后梳理一下这些术语之间的关系。注意，笔者对由于不准确的描述导致的性能下降，进程crash等任何问题不承担任何责任☺</p>

<p>NUMA：Non-Uniform Memory Access (NUMA) is a computer memory design used in multiprocessing, where the memory access time depends on the memory location relative to a processor. Under NUMA, a processor can access its own local memory faster than non-local memory, that is, memory local to another processor or memory shared between processors.NUMA architectures logically follow in scaling from symmetric multiprocessing (SMP) architectures.</p>

<p>提到NUMA就不能不对比SMP，</p>

<p>SMP：Symmetric multiprocessing (SMP) involves a multiprocessor computer hardware architecture where two or more identical processors are connected to a single shared main memory and are controlled by a single OS instance.</p>

<p>说了这么多其实都是为了介绍NUMA Node:</p>

<p>A fairly technically correct and also fairly ugly definition of a node is: a region of memory in which every byte has the same distance from each CPU.<br/>
A more common definition is: a block of memory and the CPUs, I/O, etc. physically on the same bus as the memory.</p>

<p>CPU：这个不解释，原因你懂得。想当年CPU拼的是频率，频率越高越NB，但是提升频率和制程密切相关。</p>

<p><img src="/images/kernel/2015-02-09-11.jpg" alt="" /></p>

<p>Intel cpu制程<br/>
但是制程这玩意有一个物理天花板，提升越来越难，有报道指出，现阶段普遍应用的硅晶体管在尺寸上有一个10nm的物理极限。为了提升性能cpu走上了多核的道路，即在一个封装（socket或者processor）里放多个core。这还不够，又发明了超线程技术Hyper-threading</p>

<p>HT：HT Technology is used to improve parallelization of computations (doing multiple tasks at once) performed on PC microprocessors. For each processor core that is physically present, the operating system addresses two virtual or logical cores, and shares the workload between them when possible. They appear to the OS as two processors, thus the OS can schedule two processes at once. 一个core 在HT之后OS看到的就是2个Logical Processor。</p>

<p>下图展示了这些术语之间的逻辑关系：</p>

<p><img src="/images/kernel/2015-02-09-12.jpg" alt="" /></p>

<h4>cpu 概念逻辑关系</h4>

<p>一个NUMA node包括一个或者多个Socket，以及与之相连的local memory。一个多核的Socket有多个Core。如果CPU支持HT，OS还会把这个Core看成 2个Logical Processor。为了避免混淆，在下文中统一用socket指代Processor or Socket;为了偷懒，下文中用Processor指代Logical Processor，击键能省则省不是。</p>

<h4>查看CPU Topology</h4>

<p>本文以笔者能访问的某台Red Hat Enterprise Linux Server release 5.4为例介绍，其他系统请自行google。</p>

<h5>NUMA Node</h5>

<p>第一种方法使用numactl查看
<code>
numactl --hardware
available: 2 nodes (0-1)  //当前机器有2个NUMA node,编号0&amp;amp;1
node 0 size: 12091 MB  //node 0 物理内存大小
node 0 free: 988 MB    //node 0 当前free内存大小
node 1 size: 12120 MB
node 1 free: 1206 MB
node distances:        //node 距离，可以简单认为是CPU本node内存访问和跨node内存访问的成本。从下表可知跨node的内存访问成本（20）是本地node内存（10）的2倍。
node   0   1
  0:  10  20
  1:  20  10
</code></p>

<p>第二种方法是通过sysfs查看，这种方式可以查看到更多的信息
<code>
ls /sys/devices/system/node/
1
</code>
node0  node1 //两个目标表示本机有2个node，每个目录内部有多个文件和子目录描述node内cpu，内存等信息。比如说node0/meminfo描述了node0内存相关信息。</p>

<h5>Socket</h5>

<p>可以直接通过/proc/cpuinfo查看，cpuinfo里的physical id描述的就是Socket的编号，
<code>
cat /proc/cpuinfo | grep "physical id"
physical id     : 0
physical id     : 0
physical id     : 0
physical id     : 0
physical id     : 1
physical id     : 1
physical id     : 1
physical id     : 1
physical id     : 0
physical id     : 0
physical id     : 0
physical id     : 0
physical id     : 1
physical id     : 1
physical id     : 1
physical id     : 1
</code>
由上可知本机有2个Socket，编号为0和1。
还可以简单的使用如下命令直接查看Socket个数
<code>
cat /proc/cpuinfo|grep "physical id" | sort -u | wc –l
2   //本机有2个物理CPU封装
</code></p>

<h5>Core</h5>

<p>仍然是可以通过/proc/cpuinfo查看，cpuinfo中跟core相关的信息有2行。
<code>
cpu cores : 4 //一个socket有4个核，
core id : 1 //一个core在socket内的编号
</code>
通过如下命令可以直接查看core的数量
<code>
cat /proc/cpuinfo | grep "cpu cores" | uniq | cut -d: -f2
4  //1个socket有4个core
</code></p>

<ul>
<li>本机有2个socket，每个有4个core，所以一共有8个core</li>
</ul>


<p>还可以查看core在Socket里的编号
<code>
cat /proc/cpuinfo | grep "core id" | sort -u
core id         : 0
core id         : 1
core id         : 10
core id         : 9
</code></p>

<p>一个socket里面4个core的编号为0,1,9,10。是的，core id是不连续的。如果谁知道为啥麻烦通知我，先谢了。</p>

<h5>Logical Processor</h5>

<p>仍然是可以通过/proc/cpuinfo查看在OS的眼里有多少个Logical Processor
<code>
cat /proc/cpuinfo | grep processor | wc –l
16
</code>
Ok，8个core变成了16个Logical Processor，所以本机开启了HT。</p>

<p>问题来了，cpuinfo里面16个Processor编号为0-15，Core的id为0,1,9,10，Socket的id为0,1。这些编号是如何对应的呢？</p>

<p>我们查看一个Processor完整的cpuinfo就比较清楚了，我剔除了不相关的行：
<code>
processor : 0   processor : 5
physical id : 0
siblings : 8
core id : 0
cpu cores : 4   physical id : 1
siblings : 8
core id : 1
cpu cores : 4
</code>
明白了？<br/>
Processor 0:在socket 0的core 0 里。<br/>
Processor 5：在socket 1的core 1 里。</p>

<h5>Cache</h5>

<p>仍然可以通过/proc/cpuinfo查看，OMG， cpuinfo难道是万能的？
<code>
processor       : 0
cache size      : 12288 KB //cpu cache 大小
cache_alignment : 64
</code></p>

<p>问题又来了，我们知道CPU cache分为L1，L2，L3, L1一般还分为独立的指令cache和数据cache。Cpuinfo里这个cache size指的是？</p>

<p>好吧，cpuinfo也不是万能的。详细的cache信息可以通过sysfs查看
<code>
ls /sys/devices/system/cpu/cpu0/cache/
index0  index1  index2  index3
</code></p>

<p>4个目录 <br/>
index0: 1级数据cache<br/>
index1: 1级指令cache<br/>
index2: 2级cache<br/>
index3: 3级cache ,对应cpuinfo里的cache</p>

<p>目录里的文件是cache信息描述，以本机的cpu0/index0为例简单解释一下：</p>

<table border="1">
<tr>
<td>文件</td>
<td>内容</td>
<td>说明</td>
</tr>
<tr>
<td>type</td>
<td>Data</td>
<td>数据cache，如果查看index1就是Instruction</td>
</tr>
<tr>
<td>Level</td>
<td>1</td>
<td>L1</td>
</tr>
<tr>
<td>Size</td>
<td>32K</td>
<td>大小为32K</td>
</tr>
<tr>
<td>coherency_line_size</td>
<td>64</td>
<th rowspan="4">64*4*128=32K</th>
</tr>
<tr>
<td>physical_line_partition</td>
<td>1</td>
</tr>
<tr>
<td>ways_of_associativity</td>
<td>4</td>
</tr>
<tr>
<td>number_of_sets</td>
<td>128</td>
</tr>
<tr>
<td>shared_cpu_map</td>
<td>00000101</td>
<td>表示这个cache被CPU0和CPU8 share</td>
</tr>
</table>


<p>解释一下shared_cpu_map内容的格式：<br />
表面上看是2进制，其实是16进制表示，每个bit表示一个cpu，1个数字可以表示4个cpu<br />
截取00000101的后4位，转换为2进制表示</p>


<table border="1">
<tr>
<td>CPU id</td>
<td>15</td>
<td>14</td>
<td>13</td>
<td>12</td>
<td>11</td>
<td>10</td>
<td>9</td>
<td>8</td>
<td>7</td>
<td>6</td>
<td>5</td>
<td>4</td>
<td>3</td>
<td>2</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>0&#215;0101的2进制表示</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
</table>


<p>0101表示cpu8和cpu0，即cpu0的L1 data cache是和cpu8共享的。<br/>
验证一下？
<code>
cat /sys/devices/system/cpu/cpu8/cache/index0/shared_cpu_map
00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000101
</code>
再看一下index3 shared_cpu_map的例子
<code>
cat /sys/devices/system/cpu/cpu0/cache/index3/shared_cpu_map
00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000f0f
</code></p>

<table border="1">
<tr>
<td>CPU id</td>
<td>15</td>
<td>14</td>
<td>13</td>
<td>12</td>
<td>11</td>
<td>10</td>
<td>9</td>
<td>8</td>
<td>7</td>
<td>6</td>
<td>5</td>
<td>4</td>
<td>3</td>
<td>2</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>0x0f0f的2进制表示</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</table>


<p>cpu0,1,2,3和cpu8,9,10,11共享L3 cache</p>

<h4>小结</h4>

<p>综合以上信息可以绘制出以下的cpu topology图:</p>

<p><img src="/images/kernel/2015-02-09-13.jpg" alt="" /></p>

<p>抱歉，图比较大，网页上看不清楚，下面放大单node图，另一个node基本上可以类推。</p>

<p><img src="/images/kernel/2015-02-09-14.jpg" alt="" /></p>

<h5>使用CPU Topology</h5>

<p>好吧，现在我们知道了如何查看CPU topology。那么这与各位攻城狮的工作有什么关系呢？</p>

<p>以淘宝搜索常见的服务模型为例，服务端把离线处理的数据load到内存中，开始监听某个服务端口，接收到客户端请求后从线程池中分配一个工作线程，该线程解析请求，读取内存中对应的数据，进行一些计算，然后把结果返回给客户端。</p>

<p>把这个过程简化简化再简化，抽象抽象再抽象，可以得到一个简单的测试程序，程序流程为：<br/>
1. 主线程申请2块256M的内存，使用memset初始化这两块内存的每个byte<br/>
2. 启动2个子线程，每个线程内循环16M次，在每次循环中随机读取2块内存中的各1K数据，对每个byte进行简单加和，返回。<br/>
3. 主线程等待子线程结束，打印每个线程的结果，结束。<br/>
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
<span class='line-number'>206</span>
<span class='line-number'>207</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>#include &lt;pthread.h&gt;
</span><span class='line'>#include &lt;stdlib.h&gt;
</span><span class='line'>#include &lt;string.h&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;char *p1, *p2;
</span><span class='line'>
</span><span class='line'>int run(unsigned r)
</span><span class='line'>{
</span><span class='line'>    int i,j,k,ret=0;
</span><span class='line'>    unsigned r1,r2;
</span><span class='line'>    srand(r);
</span><span class='line'>    for (i=0;i&lt;(16&lt;&lt;20);i++) {
</span><span class='line'>            r1 = (unsigned)(rand() % ((256&lt;&lt;20)-(1&lt;&lt;10)));
</span><span class='line'>            r2 = (unsigned)(rand() % ((256&lt;&lt;20)-(1&lt;&lt;10)));
</span><span class='line'>            k = 0;
</span><span class='line'>            for (j=0;j&lt;(1&lt;&lt;10);j++) {
</span><span class='line'>                    k += *(p1+r1+j);
</span><span class='line'>                    k += *(p2+r2+j);
</span><span class='line'>            }
</span><span class='line'>            ret += k;
</span><span class='line'>    }
</span><span class='line'>    return ret;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>int main()
</span><span class='line'>{
</span><span class='line'>    int i,j;
</span><span class='line'>    pthread_t pth1, pth2;
</span><span class='line'>    p1 = (char*)malloc(256&lt;&lt;20);
</span><span class='line'>    p2 = (char*)malloc(256&lt;&lt;20);
</span><span class='line'>    memset(p1, sizeof(p1), 0);
</span><span class='line'>    memset(p2, sizeof(p2), 0);
</span><span class='line'>    pthread_create(&amp;pth1, NULL, run, 123);
</span><span class='line'>    pthread_create(&amp;pth2, NULL, run, 456);
</span><span class='line'>    pthread_join(pth1, NULL);
</span><span class='line'>    pthread_join(pth2, NULL);
</span><span class='line'>    return 0;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;使用-O2编译出可执行文件test，分别使用下面2个命令运行该程序。运行时间和机器配置以及当前load有关，绝对值没有意义，这里仅比较相对值。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;table border="1"&gt;
</span><span class='line'>&lt;tr&gt;
</span><span class='line'>&lt;td&gt;命令&lt;/td&gt;
</span><span class='line'>&lt;td&gt;time ./test&lt;/td&gt;
</span><span class='line'>&lt;td&gt;time numactl -m 0 &#8211;physcpubind=2,3  ./test&lt;/td&gt;
</span><span class='line'>&lt;/tr&gt;
</span><span class='line'>&lt;tr&gt;
</span><span class='line'>&lt;td&gt;用时&lt;/td&gt;
</span><span class='line'>&lt;td&gt;&lt;strong&gt;real    0m38.678s&lt;/strong&gt;&lt;br /&gt;
</span><span class='line'>user    1m6.270s&lt;br /&gt;
</span><span class='line'>sys     0m5.569s
</span><span class='line'>&lt;/td&gt;
</span><span class='line'>&lt;td&gt;&lt;strong&gt;real    0m28.410s&lt;/strong&gt;&lt;br /&gt;
</span><span class='line'>user    0m54.997s&lt;br /&gt;
</span><span class='line'>sys     0m0.961s
</span><span class='line'>&lt;/td&gt;
</span><span class='line'>&lt;/tr&gt;
</span><span class='line'>&lt;/table&gt;
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>&lt;p&gt;发生了什么？为什么有这么大的差异？
</span><span class='line'>第一个命令直观，那么我们看一下第二个命令具体做了什么：
</span><span class='line'>&lt;code&gt;
</span><span class='line'>numactl -m 0 --physcpubind=2,3 ./test
</span><span class='line'>-m 0：在node 0上分配内存
</span><span class='line'>--physcpubind=2,3：在cpu 2和3上运行程序，即一个线程运行在cpu2上，另一个运行在cpu3上。
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;参考上面的CPUtopology图就很容易理解了，由于线程绑定cpu2和3执行，共享了L3 cache，且全部内存都是本node访问，运行效率自然比随机选择cpu运行，运行中还有可能切换cpu，内存访问有可能跨node的第一种方式要快了。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;接下来，让我们看看完整的表格，读者可以看看有没有惊喜：&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;table border="1"&gt;
</span><span class='line'>&lt;tr&gt;
</span><span class='line'>&lt;td&gt;情况&lt;/td&gt;
</span><span class='line'>&lt;td&gt;命令&lt;/td&gt;
</span><span class='line'>&lt;td&gt;用时&lt;/td&gt;
</span><span class='line'>&lt;td&gt;解释&lt;/td&gt;
</span><span class='line'>&lt;/tr&gt;
</span><span class='line'>&lt;tr&gt;
</span><span class='line'>&lt;td&gt;完全由OS控制&lt;/td&gt;
</span><span class='line'>&lt;td&gt;time ./test&lt;/td&gt;
</span><span class='line'>&lt;td&gt;real    0m38.678s&lt;br /&gt;
</span><span class='line'>user    1m6.270s&lt;br /&gt;
</span><span class='line'>sys     0m5.569s
</span><span class='line'>&lt;/td&gt;
</span><span class='line'>&lt;td&gt;乐观主义者，甩手掌柜型&lt;/td&gt;
</span><span class='line'>&lt;/tr&gt;
</span><span class='line'>&lt;tr&gt;
</span><span class='line'>&lt;td&gt;绑定跨node的Cpu执行&lt;/td&gt;
</span><span class='line'>&lt;td&gt;time numactl &#8211;physcpubind=2,6  ./test&lt;/td&gt;
</span><span class='line'>&lt;td&gt;real    0m38.657s&lt;br /&gt;
</span><span class='line'>user    1m7.126s&lt;br /&gt;
</span><span class='line'>sys     0m5.045s
</span><span class='line'>&lt;/td&gt;
</span><span class='line'>&lt;td&gt;Cpu 2和6不在同一个node，不能share L3 cache&lt;/td&gt;
</span><span class='line'>&lt;/tr&gt;
</span><span class='line'>&lt;tr&gt;
</span><span class='line'>&lt;td&gt;绑定单node的Cpu执行&lt;/td&gt;
</span><span class='line'>&lt;td&gt;time numactl &#8211;physcpubind=2,3  ./test&lt;/td&gt;
</span><span class='line'>&lt;td&gt;real    0m28.605s&lt;br /&gt;
</span><span class='line'>user    0m55.161s&lt;br /&gt;
</span><span class='line'>sys     0m0.856s
</span><span class='line'>&lt;/td&gt;
</span><span class='line'>&lt;td&gt;Cpu 2和3在同一个node，share L3 cache。内存使用由OS控制，一般来说node 0和1内存都会使用。&lt;/td&gt;
</span><span class='line'>&lt;/tr&gt;
</span><span class='line'>&lt;tr&gt;
</span><span class='line'>&lt;td&gt;跨node内存访问+绑定单node CPU执行&lt;/td&gt;
</span><span class='line'>&lt;td&gt;time numactl -m 1 &#8211;physcpubind=2,3  ./test&lt;/td&gt;
</span><span class='line'>&lt;td&gt;real    0m33.218s&lt;br /&gt;
</span><span class='line'>user    1m4.494s&lt;br /&gt;
</span><span class='line'>sys     0m0.911s
</span><span class='line'>&lt;/td&gt;
</span><span class='line'>&lt;td&gt;内存全使用node1，2个cpu在node0，内存访问比较吃亏&lt;/td&gt;
</span><span class='line'>&lt;/tr&gt;
</span><span class='line'>&lt;tr&gt;
</span><span class='line'>&lt;td&gt;单node内存访问+绑定本node CPU执行&lt;/td&gt;
</span><span class='line'>&lt;td&gt;time numactl -m 0 &#8211;physcpubind=2,3  ./test&lt;/td&gt;
</span><span class='line'>&lt;td&gt;real    0m28.367s&lt;br /&gt;
</span><span class='line'>user    0m55.062s&lt;br /&gt;
</span><span class='line'>sys     0m0.825s
</span><span class='line'>&lt;/td&gt;
</span><span class='line'>&lt;td&gt;内存&amp;cpu都使用node0&lt;/td&gt;
</span><span class='line'>&lt;/tr&gt;
</span><span class='line'>&lt;tr&gt;
</span><span class='line'>&lt;td&gt;单node内存访问+绑定本node 单core执行&lt;/td&gt;
</span><span class='line'>&lt;td&gt;time numactl -m 0 &#8211;physcpubind=2,10  ./test&lt;/td&gt;
</span><span class='line'>&lt;td&gt;real    0m58.062s&lt;br /&gt;
</span><span class='line'>user    1m55.520s&lt;br /&gt;
</span><span class='line'>sys     0m0.270s
</span><span class='line'>&lt;/td&gt;
</span><span class='line'>&lt;td&gt;CPU2和10不但在同一个node，且在同一个core，本意是希望共享L1，L2cache，提升性能。但是不要忘了，CPU2和10是HT出来的logical Processor，在本例cpu密集型的线程中硬件争用严重，效率急剧下降。有没有发现和上一个case的时间比率很有意思？&lt;/td&gt;
</span><span class='line'>&lt;/tr&gt;
</span><span class='line'>&lt;/table&gt;
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>&lt;p&gt;现在谁还能说了解点cpu topology没用呢？☺&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;Tips&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;补充几个小tips，方便有兴趣的同学分析上面表格的各个case&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;1.查看进程的内存numa node分布&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;简单的说可以查看进程的numa_maps文件
</span><span class='line'>&lt;code&gt;
</span><span class='line'>cat /proc/pid/numa_maps
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>文件格式可以直接：man numa_maps&lt;br/&gt;
</span><span class='line'>为了避免输入数字pid，我使用如下命令查看：
</span><span class='line'>&lt;code&gt;
</span><span class='line'>cat /proc/$(pidof test|cut –d” ” -f1)/numa_maps
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;2.查看线程run在哪个processor&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;可以使用top命令查看一个进程的各个线程分别run在哪个processor上&lt;br/&gt;
</span><span class='line'>同样，为了避免输入数字pid，我使用如下命令启动top：
</span><span class='line'>&lt;code&gt;
</span><span class='line'>top -p$(pidof test |sed -e ‘s/ /,/g’)
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>在默认配置下不显示线程信息，需要进入Top后按“shift+H”，打开线程显示。&lt;br/&gt;
</span><span class='line'>另外，如果没有P列，还需要按“f”，按“j”，添加，这一列显示的数字就是这个线程上次run的processor id。&lt;br/&gt;
</span><span class='line'>关于top的使用，请读者自行man top&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;3.另一种绑定cpu执行的方法&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;如果读者的程序不涉及大量内存的访问，可以通过taskset绑定cpu执行。别怪我没提醒你，仔细判断是否应该绑定到同一个core的processor上哦。&lt;br/&gt;
</span><span class='line'>关于命令的使用，请读者自行Man taskset&lt;/p&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[Linux的IPC命令 查看共享内存]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2015/02/09/kernel-mm-shm3/"/&gt;
</span><span class='line'>&lt;updated&gt;2015-02-09T15:46:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2015/02/09/kernel-mm-shm3&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;p&gt;&lt;a href="http://www.cnblogs.com/cocowool/archive/2012/05/22/2513027.html"&gt;http://www.cnblogs.com/cocowool/archive/2012/05/22/2513027.html&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;进程间通信概述&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;进程间通信有如下的目的：&lt;br/&gt;
</span><span class='line'>1、数据传输，一个进程需要将它的数据发送给另一个进程，发送的数据量在一个字节到几M之间；&lt;br/&gt;
</span><span class='line'>2、共享数据，多个进程想要操作共享数据，一个进程对数据的修改，其他进程应该立刻看到；&lt;br/&gt;
</span><span class='line'>3、通知事件，一个进程需要向另一个或一组进程发送消息，通知它们发生了某件事情；&lt;br/&gt;
</span><span class='line'>4、资源共享，多个进程之间共享同样的资源。为了做到这一点，需要内核提供锁和同步机制；&lt;br/&gt;
</span><span class='line'>5、进程控制，有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Linux进程间通信由以下几部分发展而来：&lt;br/&gt;
</span><span class='line'>早期UNIX进程间通信：包括管道、FIFO、信号。&lt;br/&gt;
</span><span class='line'>基于System V的进程间通信：包括System V消息队列、System V信号灯（Semaphore）、System V共享内存。&lt;br/&gt;
</span><span class='line'>基于Socket进程间通信。&lt;br/&gt;
</span><span class='line'>基于POSIX进程间通信：包括POSIX消息队列、POSIX信号灯、POSIX共享内存。&lt;br/&gt;
</span><span class='line'>Linux中，与IPC相关的命令包括：ipcs、ipcrm（释放IPC）、&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;IPCS命令是Linux下显示进程间通信设施状态的工具。我们知道，系统进行进程间通信（IPC）的时候，可用的方式包括信号量、共享内存、消息队列、管道、信号（signal）、套接字等形式[2]。使用IPCS可以查看共享内存、信号量、消息队列的状态。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;例如在CentOS6.0上执行ipcs&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;img src="/images/kernel/2015-02-09-2.png" alt="" /&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;具体的用法总结如下：</span></code></pre></td></tr></table></div></figure>
    1、显示所有的IPC设施
    # ipcs -a</p>

<pre><code>2、显示所有的消息队列Message Queue
# ipcs -q

3、显示所有的信号量
# ipcs -s

4、显示所有的共享内存
# ipcs -m

5、显示IPC设施的详细信息
# ipcs -q -i id
id 对应shmid、semid、msgid等。-q对应设施的类型（队列），查看信号量详细情况使用-s，查看共享内存使用-m。

6、显示IPC设施的限制大小
# ipcs -m -l
-m对应设施类型，可选参数包括-q、-m、-s。

7、显示IPC设施的权限关系
# ipcs -c
# ipcs -m -c
# ipcs -q -c
# ipcs -s -c

8、显示最近访问过IPC设施的进程ID。
# ipcs -p
# ipcs -m -p
# ipcs -q -p

9、显示IPC设施的最后操作时间
# ipcs -t
# ipcs -q -t
# ipcs -m -t
# ipcs -s -t

10、显示IPC设施的当前状态
# ipcs -u
</code></pre>

<p>```</p>

<p>Linux上的ipcs命令，不支持UNIX上的-b、-o指令，同样UNIX中不支持-l、-u指令，所以在编写跨平台的脚本时，需要注意这个问题。</p>

<h4>参考资料：</h4>

<p>1、<a href="http://wenku.baidu.com/view/58048caddd3383c4bb4cd26f.html">Linux下IPCS的用法详解</a><br/>
2、<a href="http://www.cnblogs.com/linshui91/archive/2010/09/29/1838770.html">Linux进程间通信</a><br/>
3、<a href="http://blog.csdn.net/bonny95/article/details/6442821">Linux下IPCS的10种用法</a><br/>
4、<a href="http://www.linuxdiyf.com/viewarticle.php?id=6783">Linux IPC小结</a><br/>
5、<a href="http://www.cnblogs.com/wangkangluo1/archive/2012/05/14/2498786.html">Linux IPC总结</a></p>
]]></content>
  </entry>
  
</feed>
