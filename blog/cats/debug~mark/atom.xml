<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: debug~mark | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/debug~mark/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2015-01-15T17:25:17+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[mod_timer会切换cpu]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/01/14/debug-mod-timer/"/>
    <updated>2015-01-14T23:59:01+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/01/14/debug-mod-timer</id>
    <content type="html"><![CDATA[<p><a href="https://lkml.org/lkml/2009/4/16/45">https://lkml.org/lkml/2009/4/16/45</a></p>

<blockquote><p>Ingo, Thomas, all,</p>

<p>In an SMP system, tasks are scheduled on different CPUs by the
scheduler, interrupts are managed by irqbalancer daemon, but timers
are still stuck to the CPUs that they have been initialised.  Timers
queued by tasks gets re-queued on the CPU where the task gets to run
next, but timers from IRQ context like the ones in device drivers are
still stuck on the CPU they were initialised.  This framework will
help move all &lsquo;movable timers&rsquo; using a sysctl interface.</p></blockquote>

<p>kernel/timer.c 中 __mod_timer函数的部分patch：
<code>
+   cpu = smp_processor_id();
+   if (get_sysctl_timer_migration() &amp;&amp; idle_cpu(cpu) &amp;&amp; !pinned) {
+#if defined(CONFIG_NO_HZ) &amp;&amp; (CONFIG_SMP)
+       preferred_cpu = get_nohz_load_balancer();
+#endif
+       if (preferred_cpu &gt;= 0)
+           cpu = preferred_cpu;
+   }
+
+   new_base = per_cpu(tvec_bases, cpu);
+
</code></p>

<hr />

<p>也就是说：如果当前进程是idle（函数idle_cpu(cpu)判定），那么在mod_timer时会根据cpu的struct rq runqueues;中的 struct sched_domain *sd; 来选一个不是idle的cpu，然后把timer移到他上去。如果都是idle，就还在本cpu。<br/>
禁用该功能可以 echo 0 > /proc/sys/kernel/timer_magration，默认的启用是1。</p>

<p>也就是说：系统默认状态下mod_timer有可能会mod_timer到其他cpu上。</p>

<hr />

<p>但是基本只有softirq时（如 <a href="/blog/2015/01/14/debug-softirq-time-count/">/blog/2015/01/14/debug-softirq-time-count/</a>），这时会的当前进程就是idle，但cpu实际并不空闲。这样的话softirq的timer在mod_timer时，会被加到其他cpu的定时器队列。如果这些timer是不允许切换cpu的（如对per_cpu变量的操作），那么就会产生bug。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[中断时间统计]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/01/14/debug-softirq-time-count/"/>
    <updated>2015-01-14T23:59:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/01/14/debug-softirq-time-count</id>
    <content type="html"><![CDATA[<p>软中断运行在中断上下文，不会被抢占调度，只会被硬中断打断，但硬中断退出时还是继续执行没结束的软中断。</p>

<p>因为软中断不是运行在进程上下文，不具备被调度的前提，也不具备统计运行时间。系统是将softirq的时间加到当前被他打断的进程上。</p>

<p>如果当前系统只运行数据包的接收服务，那么系统很可能显示的是100%idle，因为被softirq打断的进程就是idle。</p>

<p>如果softirq足够多，导致启动了ksoftirqd进程来协助处理，那么softirq的时间会被记到ksoftirqd的进程上，显示有“有点正常”了。</p>

<p>这样就会出现：当cpu个数充足时显示100%idle，然后减少到一半cpu就显示X%si。也就是说显示100%idle是不对，应该是近似的(x/2)%si</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[高精度定时器 high-cpu-load]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/11/06/debug-mark-sleep/"/>
    <updated>2014-11-06T14:30:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/11/06/debug-mark-sleep</id>
    <content type="html"><![CDATA[<p><a href="http://stackoverflow.com/questions/1125297/nanosleep-high-cpu-usage">http://stackoverflow.com/questions/1125297/nanosleep-high-cpu-usage</a></p>

<p>I noticed that a little test program which calls nanosleep is showing a huge difference in CPU usage when run on Linux machines with a kernel newer than 2.6.22.
<code>
    #include &lt;time.h&gt;
    int main (void)
    {
        struct timespec sleepTime;
        struct timespec returnTime;
        sleepTime.tv_sec = 0;
        sleepTime.tv_nsec = 1000;
        while (1)
        {
            nanosleep(&amp;sleepTime, &amp;returnTime); // usleep(1); 同样异常
        }
        return 0;
    }
</code>
(Yes, I realise this program does nothing)</p>

<p>  If I compile this and run it on an openSUSE 10.3 machine (2.6.22.19-0.2-default), the program does not even show up on the process list generated by &ldquo;top&rdquo;, indicating to me that it is using very little CPU time.  If I run it on an openSUSE 11.1 machine (2.6.27.23-0.1-default), top shows the program taking 40% of the CPU time.  Running on Fedora 9 (2.6.25-14.fc9.i686) and Fedora 10 also showed the same high CPU usage in &ldquo;top&rdquo;.</p>

<p>Has there been a change in the kernel that affects this?</p>

<hr />

<h4>Answers</h4>

<p>This is due to the introduction of NO_HZ into the mainline scheduler.</p>

<p>Previously, your 1,000 ns sleep was usually sleeping for a whole tick - 1,000,000 ns.  Now, when the machine is otherwise idle, it&rsquo;s actually only sleeping for what you asked for.  So it&rsquo;s running the while() loop and syscall around 1,000 times more frequently - hence a lot more CPU usage.  If you increase tv_nsec you should see a reduction in the CPU usage.</p>

<hr />

<pre><code>    int nanosleep(const struct timespec *req, struct timespec *rem);

    struct timespec
    {
        time_t  tv_sec;         /* seconds */
        long    tv_nsec;        /* nanoseconds */
    };
</code></pre>

<p> 这个函数功能是暂停某个进程直到你规定的时间后恢复，参数req就是你要暂停的时间，其中req->tv_sec是以秒为单位，而tv_nsec以毫 微秒为单位（10的-9次方秒）。由于调用nanosleep是是进程进入TASK_INTERRUPTIBLE,这种状态是会相应信号而进入 TASK_RUNNING状态的，这就意味着有可能会没有等到你规定的时间就因为其它信号而唤醒，此时函数返回-1，切还剩余的时间会被记录在rem中。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bash软件安全漏洞检测及解决方案]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/09/26/debug-mark-bash/"/>
    <updated>2014-09-26T10:16:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/09/26/debug-mark-bash</id>
    <content type="html"><![CDATA[<p><a href="http://www.techweb.com.cn/ucweb/news/id/2079505">http://www.techweb.com.cn/ucweb/news/id/2079505</a></p>

<h4>redhat官方提供漏洞详情</h4>

<p>A flaw was found in the way Bash evaluated certain specially crafted environment variables. An attacker could use this flaw to override or bypass environment restrictions to execute shell commands. Certain services and applications allow remote unauthenticated attackers to provide environment variables, allowing them to exploit this issue.</p>

<h4>redhat官方提供检测方式</h4>

<p>运行命令：<br/>
<code>
  $ env x='() { :;}; echo vulnerable'  bash -c "echo this is a test"
</code>
如果返回以下内容：则请尽快升级。
<code>
 vulnerable
this is a test
</code></p>

<hr />

<p><a href="http://seclists.org/oss-sec/2014/q3/650">http://seclists.org/oss-sec/2014/q3/650</a></p>

<p>The technical details of the vulnerability follow.</p>

<p>Bash supports exporting not just shell variables, but also shell
functions to other bash instances, via the process environment to
(indirect) child processes.  Current bash versions use an environment
variable named by the function name, and a function definition
starting with “() {” in the variable value to propagate function
definitions through the environment.  The vulnerability occurs because
bash does not stop after processing the function definition; it
continues to parse and execute shell commands following the function
definition.  For example, an environment variable setting of
<code>
  VAR=() { ignored; }; /bin/id
</code>
will execute /bin/id when the environment is imported into the bash
process.  (The process is in a slightly undefined state at this point.
The PATH variable may not have been set up yet, and bash could crash
after executing /bin/id, but the damage has already happened at this
point.)</p>

<p>The fact that an environment variable with an arbitrary name can be
used as a carrier for a malicious function definition containing
trailing commands makes this vulnerability particularly severe; it
enables network-based exploitation.</p>

<p>So far, HTTP requests to CGI scripts have been identified as the major
attack vector.</p>

<p>A typical HTTP request looks like this:
<code>
GET /path?query-param-name=query-param-value HTTP/1.1  
Host: www.example.com  
Custom: custom-header-value  
</code>
The CGI specification maps all parts to environment variables.  With
Apache httpd, the magic string “() {” can appear in these places:</p>

<ul>
<li>Host (“www.example.com”, as REMOTE_HOST)</li>
<li>Header value (“custom-header-value”, as HTTP_CUSTOM in this example)</li>
<li>Server protocol (“HTTP/1.1”, as SERVER_PROTOCOL)</li>
</ul>


<p>The user name embedded in an Authorization header could be a vector as
well, but the corresponding REMOTE_USER variable is only set if the
user name corresponds to a known account according to the
authentication configuration, and a configuration which accepts the
magic string appears somewhat unlikely.</p>

<p>In addition, with other CGI implementations, the request method
(“GET”), path (“/path”) and query string
(“query-param-name=query-param-value”) may be vectors, and it is
conceivable for “query-param-value” as well, and perhaps even
“query-param-name”.</p>

<p>The other vector is OpenSSH, either through AcceptEnv variables, TERM
or SSH_ORIGINAL_COMMAND.</p>

<p>Other vectors involving different environment variable set by
additional programs are expected.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TSC时间错误]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/05/29/debug-mark-tsc/"/>
    <updated>2014-05-29T14:03:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/05/29/debug-mark-tsc</id>
    <content type="html"><![CDATA[<p>arch/x86/kernel/tsc.c:<br/>
  开机初始化会调用tsc_init() -> set_cyc2ns_scale() 设置per_cpu变量cyc2ns、cyc2ns_offset。以供后面shced_clock()->native_sched_clock()->__cycles_2_ns()调用。</p>

<p>在cpufreq_tsc()中如果<br/>
   //cpu具有稳定的tsc <br/>
    if (boot_cpu_has(X86_FEATURE_CONSTANT_TSC)) <br/>
        return 0;<br/>
  所以一般不会注册time_cpufreq_notifier函数，也就不会再调用set_cyc2ns_scale。</p>

<ul>
<li>现象：top、ps出来的TIME和CPU的值非常异常。</li>
</ul>


<hr />

<p><a href="https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=733043">https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=733043</a></p>

<p>Xeon E5 has a bug, it doesn&rsquo;t reset TSC on warm reboot, just keep it instead.
 see &ldquo;BT81. X X X No Fix TSC is Not Affected by Warm Reset&rdquo; <a href="http://www.intel.com/content/dam/www/public/us/en/documents/specification-updates/xeon-e5-family-spec-update.pdf">http://www.intel.com/content/dam/www/public/us/en/documents/specification-updates/xeon-e5-family-spec-update.pdf</a></p>

<p> And also kernel 2.6.32 has a bug.<br/>
 Xeon bug + kernel bug = hung after warm reboot (or kexec) after 208.5 days<br/>
 since booting. So, administrators should shutdown it once at all, then<br/>
 boot it again because &ldquo;shutdown -r&rdquo; causes hang up.</p>

<p> Red Hat has released a fix for this as kernel 2.6.32-220, 2.6.32-279<br/>
 and 2.6.32-358 series (RHEL6.x) <a href="https://access.redhat.com/site/solutions/433883">https://access.redhat.com/site/solutions/433883</a> (for detail subscriber only :-(</p>

<p> Attached patch is based on upstream patch.<br/>
 see <a href="http://kernel.opensuse.org/cgit/kernel/patch/?id=9993bc635d01a6ee7f6b833b4ee65ce7c06350b1">http://kernel.opensuse.org/cgit/kernel/patch/?id=9993bc635d01a6ee7f6b833b4ee65ce7c06350b1</a></p>

<hr />

<p>  Red Hat Enterprise Linux 6.1 (kernel-2.6.32-131.26.1.el6 and newer)<br/>
  Red Hat Enterprise Linux 6.2 (kernel-2.6.32-220.4.2.el6 and newer)<br/>
  Red Hat Enterprise Linux 6.3 (kernel-2.6.32-279 series)<br/>
  Red Hat Enterprise Linux 6.4 (kernel-2.6.32-358 series)<br/>
  Any Intel® Xeon® E5, Intel® Xeon® E5 v2, or Intel® Xeon® E7 v2 series processor</p>

<hr />

<p>From 9993bc635d01a6ee7f6b833b4ee65ce7c06350b1 Mon Sep 17 00:00:00 2001<br/>
From: Salman Qazi &lt;<code>sqazi@google.com</code>><br/>
Date: Sat, 10 Mar 2012 00:41:01 +0000<br/>
Subject: sched/x86: Fix overflow in cyc2ns_offset</p>

<p>When a machine boots up, the TSC generally gets reset.  However,
when kexec is used to boot into a kernel, the TSC value would be
carried over from the previous kernel.  The computation of
cycns_offset in set_cyc2ns_scale is prone to an overflow, if the
machine has been up more than 208 days prior to the kexec.  The
overflow happens when we multiply *scale, even though there is
enough room to store the final answer.</p>

<p>We fix this issue by decomposing tsc_now into the quotient and
remainder of division by CYC2NS_SCALE_FACTOR and then performing
the multiplication separately on the two components.</p>

<p>Refactor code to share the calculation with the previous
fix in __cycles_2_ns().</p>

<p>Signed-off-by: Salman Qazi &lt;<code>sqazi@google.com</code>><br/>
Acked-by: John Stultz &lt;<code>john.stultz@linaro.org</code>><br/>
Acked-by: Peter Zijlstra &lt;<code>a.p.zijlstra@chello.nl</code>><br/>
Cc: Paul Turner &lt;<code>pjt@google.com</code>><br/>
Cc: john stultz &lt;<code>johnstul@us.ibm.com</code>><br/>
Link: <a href="http://lkml.kernel.org/r/20120310004027.19291.88460.stgit@dungbeetle.mtv.corp.google.com  ">http://lkml.kernel.org/r/20120310004027.19291.88460.stgit@dungbeetle.mtv.corp.google.com  </a>
Signed-off-by: Ingo Molnar &lt;<code>mingo@elte.hu</code>></p>

<hr />

<pre><code>diff --git a/arch/x86/include/asm/timer.h b/arch/x86/include/asm/timer.h
index 431793e..34baa0e 100644
--- a/arch/x86/include/asm/timer.h
+++ b/arch/x86/include/asm/timer.h
@@ -57,14 +57,10 @@ DECLARE_PER_CPU(unsigned long long, cyc2ns_offset);

 static inline unsigned long long __cycles_2_ns(unsigned long long cyc)
 {
-   unsigned long long quot;
-   unsigned long long rem;
    int cpu = smp_processor_id();
    unsigned long long ns = per_cpu(cyc2ns_offset, cpu);
-   quot = (cyc &gt;&gt; CYC2NS_SCALE_FACTOR);
-   rem = cyc &amp; ((1ULL &lt;&lt; CYC2NS_SCALE_FACTOR) - 1);
-   ns += quot * per_cpu(cyc2ns, cpu) +
-       ((rem * per_cpu(cyc2ns, cpu)) &gt;&gt; CYC2NS_SCALE_FACTOR);
+   ns += mult_frac(cyc, per_cpu(cyc2ns, cpu),
+           (1UL &lt;&lt; CYC2NS_SCALE_FACTOR));
    return ns;
 }

diff --git a/arch/x86/kernel/tsc.c b/arch/x86/kernel/tsc.c
index a62c201..183c592 100644
--- a/arch/x86/kernel/tsc.c
+++ b/arch/x86/kernel/tsc.c
@@ -620,7 +620,8 @@ static void set_cyc2ns_scale(unsigned long cpu_khz, int cpu)

    if (cpu_khz) {
        *scale = (NSEC_PER_MSEC &lt;&lt; CYC2NS_SCALE_FACTOR)/cpu_khz;
-       *offset = ns_now - (tsc_now * *scale &gt;&gt; CYC2NS_SCALE_FACTOR);
+       *offset = ns_now - mult_frac(tsc_now, *scale,
+                        (1UL &lt;&lt; CYC2NS_SCALE_FACTOR));
    }

    sched_clock_idle_wakeup_event(0);
diff --git a/include/linux/kernel.h b/include/linux/kernel.h
index e834342..d801acb 100644
--- a/include/linux/kernel.h
+++ b/include/linux/kernel.h
@@ -85,6 +85,19 @@
 }                          \
 )

+/*
+ * Multiplies an integer by a fraction, while avoiding unnecessary
+ * overflow or loss of precision.
+ */
+#define mult_frac(x, numer, denom)(            \
+{                          \
+   typeof(x) quot = (x) / (denom);         \
+   typeof(x) rem  = (x) % (denom);         \
+   (quot * (numer)) + ((rem * (numer)) / (denom)); \
+}                          \
+)
+
+
 #define _RET_IP_       (unsigned long)__builtin_return_address(0)
 #define _THIS_IP_  ({ __label__ __here; __here: (unsigned long)&amp;&amp;__here; }) 
</code></pre>
]]></content>
  </entry>
  
</feed>
