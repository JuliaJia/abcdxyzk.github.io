<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 2013~05 | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/2013~05/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2014-11-26T18:42:02+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[C语言输出缓冲区函数说明]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/05/07/lang-c-flush-out/"/>
    <updated>2013-05-07T18:15:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/05/07/lang-c-flush-out</id>
    <content type="html"><![CDATA[<pre><code>    #include &lt;stdio.h&gt;
    #include &lt;unistd.h&gt;

    int main(void)
    {
        int i = 0;
        while(1) {
            printf("sleeping %d", i++); //(1)
            fflush(stdout);
            sleep(1);
        }
        return 0;
    }
</code></pre>

<h4>1</h4>

<p>printf将"sleeping %d"输出到标准输出文件的缓冲区中(缓冲区在内存上)，fflush(stdout)将缓冲区中的内容强制刷新到，并将其中的内容输出到显示器上(&ldquo;\n"回车换行 == fflush(stdout)+换行)
<code>
                             fflush()
         buffer(In memroy) -----------&gt; hard disk/monitor
</code></p>

<h4>2</h4>

<p>有三个流(stream)是自动打开的， 相应的FILE结构指针为stdin、stdout、stderr，与之对应的文件描述符是：STDIN_FILENO、STDOUT_FILENO、STDERR_FILENO。</p>

<h4>流缓冲的属性：</h4>

<p>缓冲区类型有：全缓冲(大部分缓冲都是这类型)、行缓冲(例如stdio,stdout)、无缓冲(例如stderr)。<br/>
关于全缓冲，例如普通的文件操作，进行fputs、fprintf操作后，数据并没有立即写入磁盘文件中，当fflush或fclose文件时，数据才真正写入。<br/>
可以用以下函数设置流的缓冲类型：
<code>
void setvbuf()  
void setbuf()  
void setbuffer()  
void setlinebuf()
</code></p>

<h4>3</h4>

<p>fflush() 是把 FILE *里的缓冲区(位于用户态进程空间)刷新到内核中<br/>
fsync() -是把内核中对应的缓冲(是在 vfs 层的缓冲)刷新到硬盘中</p>

<h4>4</h4>

<p>在Linux的标准函数库中，有一套称作“高级I/O”的函数，我们熟知的printf()、fopen()、fread()、fwrite()都在此 列，它们也被称作“缓冲I/O（buffered I/O）”，每次写文件的时候，也仅仅是写入内存中的缓冲区，等满足了一定的条件（达到一定数量，或遇到特定字符，如换行符\n和文件结束符EOF），再 将缓冲区中的内容一次性写入文件，这样就大大增加了文件读写的速度。</p>

<hr />

<p>  The three types of buffering available are unbuffered, block buffered, and line buffered. When an output stream is unbuffered, information appears on the destination file or terminal as soon as written; when it is block buffered many characters are saved up and written as a block; when it is line buffered characters are saved up until a newline is output or input is read from any stream attached to a terminal device (typically stdin). The function fflush(3) may be used to force the block out early. (See fclose(3).) Normally all files are block buffered. When the first I/O operation occurs on a file, malloc(3) is called, and a buffer is obtained. If a stream refers to a terminal (as stdout normally does) it is line buffered. The standard error
stream stderr is always unbuffered by default.</p>

<p>  一般来说，block buffered的效率高些，将多次的操作合并成一次操作。先在标准库里缓存一部分，直到该缓冲区满了，或者程序显示的调用fflush时，将进行更新操作。而setbuf 则可以设置该缓冲区的大小。</p>

<h5>setbuf()</h5>

<pre><code>    #include &lt;stdio.h&gt;
    void setbuf(FILE *stream, char *buf);
</code></pre>

<p>这个函数应该必须在如何输出被写到该文件之前调用。一般放在main里靠前面的语句！但是setbuf有个经典的错误，man手册上也提到了，c陷阱和缺陷上也提到了
You must make sure that both buf and the space it points to still exist by the time stream is closed, which also happens at program termination. For example, the following is illegal:
<code>
        #include &lt;stdio.h&gt;
    int main()
    {
        char buf[BUFSIZ];
        setbuf(stdin, buf);
        printf("Hello, world!\n");
        return 0;
    }
</code>
这个程序是错误的。buf缓冲区最后一次清空应该在main函数结束之后，程序交回控制给操作系统之前C运行库所必须进行的清理工作的一部分，但是此时 buf字符数组已经释放。修改的方法是将buf设置为static，或者全局变量； 或者调用malloc来动态申请内存。
<code>
    char * malloc();
    setbuf(stdout,malloc(BUFSIZE));
</code>
这里不需要判断malloc的返回值，如果malloc调用失败，将返回一个null指针，setbuf的第二个参数可以是null,此时不进行缓冲！</p>

<h5>fflush()</h5>

<p>fflush函数则刷新缓冲区，将缓冲区上的内容更新到文件里。
<code>
    #include &lt;stdio.h&gt;
    int fflush(FILE *stream);
</code>
  The function fflush forces a write of all user-space buffered data for the given output or update stream via the stream underlying write function. The open status of the stream is unaffected. If the stream argument is NULL, fflush flushes all open output streams.</p>

<p>但是fflush仅仅刷新C库里的缓冲。其他的一些数据的刷新需要调用fsync或者sync!</p>

<p>  Note that fflush() only flushes the user space buffers provided by the C library. To ensure that the data is physically stored on disk the kernel buffers must be flushed too, e.g. with sync(2) or fsync(2).</p>

<h5>fsync()和sync()</h5>

<p>  fsync和sync最终将缓冲的数据更新到文件里。
<code>
    #include &lt;unistd.h&gt;
    int fsync(int fd);
</code>
  fsync copies all in-core parts of a file to disk, and waits until the device reports that all parts are on stable storage. It also updates metadata stat information. It does not necessarily ensure that the entry in the directory containing the file has also reached disk. For that an explicit fsync on the file descriptor of the directory is also needed.</p>

<p>  同步命令sync就直接调用了sync函数来更新磁盘上的缓冲！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[通过绝对内存地址进行参数赋值与函数调用]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/05/07/lang-c-call-addr/"/>
    <updated>2013-05-07T18:15:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/05/07/lang-c-call-addr</id>
    <content type="html"><![CDATA[<p>同一个数可以通过不同的方式表达出来，对于函数的访问，变量的赋值除了直接对变量赋值以外，还可以通过绝对内存地址进行参数赋值与函数调用。</p>

<h4>1、通过地址修改变量的值</h4>

<pre><code>    int x;
    int *p;
    printf("%x\n",&amp;x);
    p=(int *)0x0012ff60;
    *p = 3;
    printf("%d\n",x);
</code></pre>

<p>程序的输出结果为：<br/>
12ff603</p>

<p>程序首先输出变量x所在地址为十六进制的0x12ff60（本来应该为8位的十六进制数，高位为0则省略掉），然后定义一个指针变量，让它指向该地址，通过指针变量的值来修改变量x的值。</p>

<p>示例代码：
<code>
    int *ptr=(int*)0xa4000000;
    *ptr=0xaabb;
    printf("%d\n",*ptr);
</code>
以上程序会崩溃，因为这样做会给一个指针分配一个随意的地址，很危险，所以这种做法是不允许的。</p>

<h4>2、通过地址调用函数的执行</h4>

<pre><code>    #include &lt;iostream&gt;using namespace std; 
    typedef void(*FuncPtr)() ;

    void  p()
    { 
        printf("MOP\n");
    }   

    int main()
    {
        void (*ptr)();
        p();
        printf("%x\n",p);
        ptr = (void (*)())0x4110f0;
        ptr();//函数指针执行
        ((void (*)())0x4110f0)();
        ((FuncPtr)0x4110f0)();
        return 0;
    }
</code></pre>

<p>程序执行结果如下：<br/>
MOP4110f0MOP<br/>
MOP<br/>
MOP</p>

<p>首先定义一个ptr的函数指针，第一次通过函数名调用函数，输出Mop，打印函数的入口地址，函数的入口地址为4110f0。然后给函数指针ptr赋地址值为p的入口地址，调用ptr，输出Mop。接着的过程是不通过函数指针直接执行，仍然使用p的入口地址调用，输出为MOP。最后是通过typedef调用的直接执行。</p>

<p>函数名称、代码都是放在代码段的，因为是放在代码段，每次会跳到相同的地方，但参数会压栈，所以函数只根据函数名来获取入口地址，与参数和返回值无关。无论参数和返回值如何不同，函数入口地址都是一个地方。</p>

<p>对以下程序进行分析如下：
```
    #include &lt;stdio.h> int   p(int a,int b)
    {
        return 3;
    }</p>

<pre><code>int main()
{
    printf("%x\n",p);
    int a = p(2,3);
    printf("%d\n",p);
    int b = p(4,5);
    printf("%x\n",p);
    return 0;
}
</code></pre>

<pre><code>程序输出结果如下：  
4111594264281411159  
十六进制的411159转换成十进制的值为4264281。程序中打印的p的入口地址，无论p是否调用函数，入口地址都没有改变。
分析如下代码：
</code></pre>

<pre><code>#include &lt;stdio.h&gt; int  p(int a,int b) 
{ 
    return ((a&gt;b)?a:b);
}  
int main()
{
    int (*ptr)(int ,int);
    ptr = (int (*)(int,int))0x411159;
    int c = ptr(5,6);
    printf("%d\n",c);
    return 0;
}
</code></pre>

<p>```
程序输出为:<br/>
6
通过函数指针调用有返回值和参数的函数，不适用函数名，而是用函数入口地址调用。<br/>
函数存放在内存的代码区域内，也有地址，一个函数在编译时被分配一个入口地址，将这个入口地址称为函数的指针，函数的地址就是函数的名字。
函数指针不能指向不同类型或是带不同形参的函数。</p>
]]></content>
  </entry>
  
</feed>
