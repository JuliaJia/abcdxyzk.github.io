<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 2013~05 | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/2013~05/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2014-11-30T22:48:57+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[RedHat/CentOS发行版本号及内核版本号对照表]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/05/28/centos-versions/"/>
    <updated>2013-05-28T15:35:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/05/28/centos-versions</id>
    <content type="html"><![CDATA[<pre><code>Redhat 9.0———————————————2.4.20-8
RHEL 3 Update 8————————————2.4.21-47
RHEL 4 ————————————————2.6.9-5
RHEL 4 Update 1————————————2.6.9-11
RHEL 4 Update 2————————————2.6.9-22
RHEL 4 Update 3————————————2.6.9-34
RHEL 4 Update 4————————————2.6.9-42
RHEL 4 Update 5————————————2.6.9-55
RHEL 4 Update 6————————————2.6.9-67
RHEL 4 Update 7————————————2.6.9-78

CENTOS 5/RHEL 5 ———————————2.6.18-8
CENTOS 5.1/RHEL 5 Update 1——————2.6.18-53
CENTOS 5.2/RHEL 5 Update 2——————2.6.18-92
CENTOS 5.3/RHEL 5 Update 3——————2.6.18-128
CENTOS 5.4/RHEL 5 Update 4——————2.6.18-164
CENTOS 5.5/RHEL 5 Update 5——————2.6.18-194
CENTOS 5.6/RHEL 5 Update 6——————2.6.18-238
CENTOS 5.7/RHEL 5 Update 7——————2.6.18-274
CENTOS 5.8/RHEL 5 Update 8——————2.6.18-308

CENTOS 6.0/RHEL 6 Update 0——————2.6.32-71
CENTOS 6.1/RHEL 6 Update 1——————2.6.32-131
CENTOS 6.2/RHEL 6 Update 2——————2.6.32-220
CENTOS 6.3/RHEL 6 Update 3——————2.6.32-279
CENTOS 6.4/RHEL 6 Update 4——————2.6.32-358
CENTOS 6.5/RHEL 6 Update 5——————2.6.32-431
CENTOS 6.6/RHEL 6 Update 6——————2.6.32-504

CENTOS 7.0/RHEL 7 Update 0——————3.10.0-123
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux内核kretprobe机制]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/05/24/debug-kretprobe/"/>
    <updated>2013-05-24T10:22:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/05/24/debug-kretprobe</id>
    <content type="html"><![CDATA[<p><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-systemtap1/index.html">http://www.ibm.com/developerworks/cn/linux/l-cn-systemtap1/index.html</a></p>

<p>  kretprobe也使用了kprobes来实现，当用户调用register_kretprobe()时，kprobe在被探测函数的入口建立 了一个探测点，当执行到探测点时，kprobe保存了被探测函数的返回地址并取代返回地址为一个trampoline的地址，kprobe在初始化时定义 了该trampoline并且为该trampoline注册了一个kprobe,当被探测函数执行它的返回指令时，控制传递到该trampoline，因 此kprobe已经注册的对应于trampoline的处理函数将被执行，而该处理函数会调用用户关联到该kretprobe上的处理函数，处理完毕后， 设置指令寄存器指向已经备份的函数返回地址，因而原来的函数返回被正常执行。</p>

<p>  被探测函数的返回地址保存在类型为 kretprobe_instance的变量中，结构kretprobe的maxactive字段指定了被探测函数可以被同时探测的实例数，函数 register_kretprobe()将预分配指定数量的kretprobe_instance。如果被探测函数是非递归的并且调用时已经保持了自旋 锁（spinlock），那么maxactive为1就足够了；  如果被探测函数是非递归的且运行时是抢占失效的，那么maxactive为NR_CPUS就可以了；如果maxactive被设置为小于等于0,  它被设置到缺省值（如果抢占使能， 即配置了  CONFIG_PREEMPT，缺省值为10和2*NR_CPUS中的最大值，否则缺省值为NR_CPUS）。</p>

<p>  如果 maxactive被设置的太小了，一些探测点的执行可能被丢失，但是不影响系统的正常运行，在结构kretprobe中nmissed字段将记录被丢失 的探测点执行数，它在返回探测点被注册时设置为0，每次当执行探测函数而没有kretprobe_instance可用时，它就加1。</p>

<p><a href="http://hi.baidu.com/lixiang1988/item/8884bc286c9920ceddf69acd">http://hi.baidu.com/lixiang1988/item/8884bc286c9920ceddf69acd</a></p>

<h4>kretprobe的实现</h4>

<p>相关数据结构与函数分析</p>

<h5>1)　struct kretprobe结构</h5>

<p>  该结构是kretprobe实现的基础数据结构，以下是该结构的成员：
<code>
    struct kprobe kp; //该成员是kretprobe内嵌的struct kprobe结构。
    kretprobe_handler_t handler;//该成员是调试者定义的回调函数。
    int maxactive;//该成员是最多支持的返回地址实例数。
    int nmissed;//该成员记录有多少次该函数返回没有被回调函数处理。
    struct hlist_head free_instances;
    用于链接未使用的返回地址实例，在注册时初始化。
    struct hlist_head used_instances;//该成员是正在被使用的返回地址实例链表。
</code></p>

<h5>2)　struct kretprobe_instance结构</h5>

<p>  该结构表示一个返回地址实例。因为函数每次被调用的地方不同，这造成了返回地址不同，因此需要为每一次发生的调用记录在这样一个结构里面。以下是该结构的成员：
<code>
    struct hlist_node uflist;
    该成员被链接入kretprobe的used_instances或是free_instances链表。
    struct kretprobe *rp;//该成员指向所属的kretprobe结构。
    kprobe_opcode_t *ret_addr;//该成员用于记录被探测函数正真的返回地址。
    struct task_struct *task;//该成员记录当时运行的进程。
</code></p>

<h5>3)　pre_handler_kretprobe()函数</h5>

<p>  该函数在kretprobe探测点被执行到后，用于修改被探测函数的返回地址。</p>

<h5>4)　trampoline_handler()函数</h5>

<p>  该函数用于执行调试者定义的回调函数以及把被探测函数的返回地址修改回原来的返回地址。</p>

<h4>kretprobe处理流程分析</h4>

<p>  kretprobe探测方式是基于kprobe实现的又一种内核探测方式，该探测方式主要用于在函数返回时进行探测，获得内核函数的返回值，还可以用于计算函数执行时间等方面。</p>

<h5>1)　kretprobe的注册过程</h5>

<p>  调试者要进行kretprobe调试首先要注册处理，这需要在调试模块中调用register_kretprobe()，下文中称该函数为 kretprobe  注册器。kretprobe注册器对传入的kretprobe结构的中kprobe.pre_handler赋值为 pre_handler_kretprobe()函数，用于在探测点被触发时被调用。接着，kretprobe注册器还会初始化kretprobe的一些 成员，比如分配返回地址实例的空间等操作。最后，kretprobe注册器会利用  kretprobe内嵌的structkprobe结构进行kropbe的注册。自此，kretprobe注册过程就完成了。</p>

<h5>2)　kretprobe探测点的触发过程</h5>

<p>  kretprobe触发是在刚进入被探测函数的第一条汇编指令时发生的，因为 kretprobe注册时把该地址修改位int3指令。<br/>
  此时发生了一次CPU异常处理，这与kprobe探测点被触发相同。但与kprobe处理不同的是，这里并不是运行用户定义的pre_handler函 数，而是执行pre_handler_kretprobe()函数，该函数又会调用arch_prepare_kretprobe()函数。 arch_prepare_kretprobe()函数的主要功能是把被探测函数的返回地址变换为&amp;kretprobe_trampoline所 在的地址，这是一个汇编地址标签。这个标签的地址在kretprobe_trampoline_holder()中用汇编伪指令定义。替换函数返回地址是 kretprobe实现的关键。当被探测函数返回时，返回到&amp;kretprobe_trampoline地址处开始运行。</p>

<p>  接着，在 一些保护现场的处理后，又去调用trampoline_handler()函数。该函数的主要有两个作用，一是根据当前的实例去运行用户定义的调试函数， 也就是kretprobe结构中的handler所指向的函数，二是把返回值设成被探测函数正真的返回地址。最后，在进行一些堆栈的处理后，被探测函数又 返回到了正常执行流程中去。</p>

<p>  以上讨论的就是kretprobe的执行过程，可以看出，该调试方式的关键点在于修改被探测函数的返回地址到kprobes的控制流程中，之后再把返回地址修改到原来的返回地址并使得该函数继续正常执行。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux内核kprobe机制]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/05/24/debug-kprobe-base/"/>
    <updated>2013-05-24T10:22:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/05/24/debug-kprobe-base</id>
    <content type="html"><![CDATA[<ul>
<li>探测点处理函数在运行时是失效抢占的，依赖于特定的架构，探测点处理函数运行时也可能是中断失效的。</li>
<li><p>因此，对于任何探测点处理函数，不要使用导致睡眠或进程调度的任何内核函数（如尝试获得semaphore)。</p>

<p>Kprobe机制是内核提供的一种调试机制，它提供了一种方法，能够在不修改现有代码的基础上，灵活的跟踪内核函数的执行。它的基本工作原理是：用户指定一个探测点，并把一个用户定义的处理函数关联到该探测点，当内核执行到该探测点时，相应的关联函数被执行，然后继续执行正常的代码路径。</p>

<p>Kprobe提供了三种形式的探测点，一种是最基本的kprobe，能够在指定代码执行前、执行后进行探测，但此时不能访问被探测函数内的相关变量信 息；一种是jprobe，用于探测某一函数的入口，并且能够访问对应的函数参数；一种是kretprobe，用于完成指定函数返回值的探测功能。其中最基 本的就是kprobe机制，jprobe以及kretprobe的实现都依赖于kprobe，但其代码的实现都很巧妙，强烈建议每一个内核爱好者阅读。</p></li>
</ul>


<h4>代码：</h4>

<h5>首先是struct kprobe结构，每一个探测点的基本结构。</h5>

<pre><code>    structkprobe {
        /*用于保存kprobe的全局hash表，以被探测的addr为key*/
        structhlist_node hlist;

        /* list of kprobes for multi-handler support */
        /*当对同一个探测点存在多个探测函数时，所有的函数挂在这条链上*/
        structlist_head list;

        /*count the number of times this probe was temporarily disarmed */
        unsigned longnmissed;

        /* location of the probe point */
        /*被探测的目标地址*/
        kprobe_opcode_t *addr;

        /* Allow user to indicate symbol name of the probe point */
        /*symblo_name的存在，允许用户指定函数名而非确定的地址*/
        constchar*symbol_name;

        /* Offset into the symbol */
        /*如果被探测点为函数内部某个指令，需要使用addr + offset的方式*/
        unsigned intoffset;

        /* Called before addr is executed. */
        /*探测函数，在目标探测点执行之前调用*/
        kprobe_pre_handler_t pre_handler;

        /* Called after addr is executed, unless... */
        /*探测函数，在目标探测点执行之后调用*/
        kprobe_post_handler_t post_handler;

        /*
         * ... called if executing addr causes a fault (eg. page fault).
         * Return 1 if it handled fault, otherwise kernel will see it.
         */
        kprobe_fault_handler_t fault_handler;

        /*
         * ... called if breakpoint trap occurs in probe handler.
         * Return 1 if it handled break, otherwise kernel will see it.
         */
        kprobe_break_handler_t break_handler;

        /*opcode 以及 ainsn 用于保存被替换的指令码*/

        /* Saved opcode (which has been replaced with breakpoint) */
        kprobe_opcode_t opcode;

        /* copy of the original instruction */
        structarch_specific_insn ainsn;

        /*
         * Indicates various status flags.
         * Protected by kprobe_mutex after this kprobe is registered.
         */
        u32 flags;
    };
</code></pre>

<p>  对于kprobe功能的实现主要利用了内核中的两个功能特性：异常（尤其是int 3），单步执行（EFLAGS中的TF标志）。</p>

<h5>大概的流程：</h5>

<pre><code> 1）在注册探测点的时候，对被探测函数的指令码进行替换，替换为int 3的指令码；
 2）在执行int 3的异常执行中，通过通知链的方式调用kprobe的异常处理函数；
 3）在kprobe的异常出来函数中，判断是否存在pre_handler钩子，存在则执行；
 4）执行完后，准备进入单步调试，通过设置EFLAGS中的TF标志位，并且把异常返回的地址修改为保存的原指令码；
 5）代码返回，执行原有指令，执行结束后触发单步异常；
 6）在单步异常的处理中，清除单步标志，执行post_handler流程，并最终返回；
</code></pre>

<p>  下面又进入代码时间，首先看一下kprobe模块的初始化代码，初始化代码主要做了两件事：标记出哪些代码是不能被探测的，这些代码属于kprobe实现的关键代码；注册通知链到die_notifier，用于接收异常通知。</p>

<h5>初始化代码位于kernel/kprobes.c中</h5>

<pre><code>    staticint__init init_kprobes(void)
    {
        inti,err =0;
            ....

         /*kprobe_blacklist中保存的是kprobe实现的关键代码路径，这些函数不应该被kprobe探测*/
        /*
         * Lookup and populate the kprobe_blacklist.
         *
         * Unlike the kretprobe blacklist, we'll need to determine
         * the range of addresses that belong to the said functions,
         * since a kprobe need not necessarily be at the beginning
         * of a function.
         */
        for(kb =kprobe_blacklist;kb-&gt;name!=NULL;kb++){
            kprobe_lookup_name(kb-&gt;name,addr);
            if(!addr)
                continue;

            kb-&gt;start_addr =(unsigned long)addr;
            symbol_name =kallsyms_lookup(kb-&gt;start_addr,
                    &amp;size,&amp;offset,&amp;modname,namebuf);
            if(!symbol_name)
                kb-&gt;range =0;
            else
                kb-&gt;range =size;
        }
            ....
        if(!err)
            /*注册通知链到die_notifier，用于接收int 3的异常信息*/
            err =register_die_notifier(&amp;kprobe_exceptions_nb);
             ....
    }
</code></pre>

<h5>其中的通知链：</h5>

<pre><code>    staticstructnotifier_block kprobe_exceptions_nb ={
        .notifier_call =kprobe_exceptions_notify,
        /*优先级最高，保证最先执行*/
        .priority =0x7fffffff /* we need to be notified first */
    };
</code></pre>

<h6>kprobe的注册流程register_kprobe。</h6>

<pre><code>    int__kprobes register_kprobe(structkprobe *p)
    {
        intret =0;
        structkprobe *old_p;
        structmodule *probed_mod;
        kprobe_opcode_t *addr;

        /*获取被探测点的地址，指定了symbol_name，则从kallsyms中获取；指定了offset，则返回addr + offset*/
        addr =kprobe_addr(p);
        if(!addr)
            return-EINVAL;
        p-&gt;addr =addr;

        /*判断同一个kprobe是否被重复注册*/
        ret =check_kprobe_rereg(p);
        if(ret)
            returnret;

        jump_label_lock();
        preempt_disable();
        /*判断被注册的函数是否位于内核的代码段内，或位于不能探测的kprobe实现路径中*/
        if(!kernel_text_address((unsigned long)p-&gt;addr)||
            in_kprobes_functions((unsigned long)p-&gt;addr)||
            ftrace_text_reserved(p-&gt;addr,p-&gt;addr)||
            jump_label_text_reserved(p-&gt;addr,p-&gt;addr))
            gotofail_with_jump_label;

        /* User can pass only KPROBE_FLAG_DISABLED to register_kprobe */
        p-&gt;flags&amp;=KPROBE_FLAG_DISABLED;

        /*
         * Check if are we probing a module.
         */
        /*判断被探测的地址是否属于某一个模块，并且位于模块的text section内*/
        probed_mod =__module_text_address((unsigned long)p-&gt;addr);
        if(probed_mod){
            /*如果被探测的为模块地址，首先要增加模块的引用计数*/
            /*
             * We must hold a refcount of the probed module while updating
             * its code to prohibit unexpected unloading.
             */
            if(unlikely(!try_module_get(probed_mod)))
                gotofail_with_jump_label;

            /*
             * If the module freed .init.text, we couldn't insert
             * kprobes in there.
             */
            /*如果被探测的地址位于模块的init地址段内，但该段代码区间已被释放，则直接退出*/
            if(within_module_init((unsigned long)p-&gt;addr,probed_mod)&amp;&amp;
                probed_mod-&gt;state!=MODULE_STATE_COMING){
                module_put(probed_mod);
                gotofail_with_jump_label;
            }
        }
        preempt_enable();
        jump_label_unlock();

        p-&gt;nmissed =0;
        INIT_LIST_HEAD(&amp;p-&gt;list);
        mutex_lock(&amp;kprobe_mutex);

        jump_label_lock();/* needed to call jump_label_text_reserved() */

        get_online_cpus();  /* For avoiding text_mutex deadlock. */
        mutex_lock(&amp;text_mutex);

        /*判断在同一个探测点是否已经注册了其他的探测函数*/
        old_p =get_kprobe(p-&gt;addr);
        if(old_p){
            /* Since this may unoptimize old_p, locking text_mutex. */
            /*如果已经存在注册过的kprobe，则将探测点的函数修改为aggr_pre_handler，并将所有的handler挂载到其链表上，由其负责所有handler函数的执行*/
            ret =register_aggr_kprobe(old_p,p);
            gotoout;
        }

        /* 分配特定的内存地址用于保存原有的指令
         * 按照内核注释，被分配的地址必须must be on special executable page on x86.
         * 该地址被保存在kprobe-&gt;ainsn.insn
         */
        ret =arch_prepare_kprobe(p);
        if(ret)
            gotoout;

        /*将kprobe加入到相应的hash表内*/
        INIT_HLIST_NODE(&amp;p-&gt;hlist);
        hlist_add_head_rcu(&amp;p-&gt;hlist,
                   &amp;kprobe_table[hash_ptr(p-&gt;addr,KPROBE_HASH_BITS)]);

        if(!kprobes_all_disarmed &amp;&amp;!kprobe_disabled(p))
    /*将探测点的指令码修改为int 3指令*/
            __arm_kprobe(p);

        /* Try to optimize kprobe */
        try_to_optimize_kprobe(p);

    out:
        mutex_unlock(&amp;text_mutex);
        put_online_cpus();
        jump_label_unlock();
        mutex_unlock(&amp;kprobe_mutex);

        if(probed_mod)
            module_put(probed_mod);

        returnret;

    fail_with_jump_label:
        preempt_enable();
        jump_label_unlock();
        return-EINVAL;
</code></pre>

<h5>注册完毕，就开始kprobe的执行流程了。对于该探测点，由于其起始指令已经被修改为int3，因此在执行到该地址时，必然会触发3号中断向量的处理流程do_int3.</h5>

<pre><code>    /* May run on IST stack. */
    dotraplinkage void__kprobes do_int3(structpt_regs *regs,longerror_code)
    {
    #ifdef CONFIG_KGDB_LOW_LEVEL_TRAP
        if(kgdb_ll_trap(DIE_INT3,"int3",regs,error_code,3,SIGTRAP)
                ==NOTIFY_STOP)
            return;
    #endif /* CONFIG_KGDB_LOW_LEVEL_TRAP */
    #ifdef CONFIG_KPROBES
        /*在这里以DIE_INT3，通知kprobe注册的通知链*/
        if(notify_die(DIE_INT3,"int3",regs,error_code,3,SIGTRAP)
                ==NOTIFY_STOP)
            return;
    #else
        if(notify_die(DIE_TRAP,"int3",regs,error_code,3,SIGTRAP)
                ==NOTIFY_STOP)
            return;
    #endif

        preempt_conditional_sti(regs);
        do_trap(3,SIGTRAP,"int3",regs,error_code,NULL);
        preempt_conditional_cli(regs);
    }
</code></pre>

<h5>在do_int3中触发kprobe注册的通知链函数，kprobe_exceptions_notify。由于kprobe以及jprobe等机制的处 理核心都在此函数内，这里只针对kprobe的流程进行分析：进入函数的原因是DIE_INT3,并且是第一次进入该函数。</h5>

<pre><code>    int__kprobes kprobe_exceptions_notify(structnotifier_block *self,
                           unsigned longval,void*data)
    {
        structdie_args *args =data;
        intret =NOTIFY_DONE;

        if(args-&gt;regs &amp;&amp;user_mode_vm(args-&gt;regs))
            returnret;

        switch(val){
        caseDIE_INT3:
    /*对于kprobe，进入kprobe_handle*/
            if(kprobe_handler(args-&gt;regs))
                ret =NOTIFY_STOP;
            break;
        caseDIE_DEBUG:
            if(post_kprobe_handler(args-&gt;regs)){
                /*
                 * Reset the BS bit in dr6 (pointed by args-&gt;err) to
                 * denote completion of processing
                 */
                (*(unsigned long*)ERR_PTR(args-&gt;err))&amp;=~DR_STEP;
                ret =NOTIFY_STOP;
            }
            break;
        caseDIE_GPF:
            /*
             * To be potentially processing a kprobe fault and to
             * trust the result from kprobe_running(), we have
             * be non-preemptible.
             */
            if(!preemptible()&amp;&amp;kprobe_running()&amp;&amp;
                kprobe_fault_handler(args-&gt;regs,args-&gt;trapnr))
                ret =NOTIFY_STOP;
            break;
        default:
            break;
        }
        returnret;
    }

    staticint__kprobes kprobe_handler(structpt_regs *regs)
    {
        kprobe_opcode_t *addr;
        structkprobe *p;
        structkprobe_ctlblk *kcb;

        /*对于int 3中断，其被Intel定义为Trap，那么异常发生时EIP寄存器内指向的为异常指令的后一条指令*/
        addr =(kprobe_opcode_t *)(regs-&gt;ip -sizeof(kprobe_opcode_t));
        /*
         * We don't want to be preempted for the entire
         * duration of kprobe processing. We conditionally
         * re-enable preemption at the end of this function,
         * and also in reenter_kprobe() and setup_singlestep().
         */
        preempt_disable();

        kcb =get_kprobe_ctlblk();
        /*获取addr对应的kprobe*/
        p =get_kprobe(addr);

        if(p){
    /*如果异常的进入是由kprobe导致，则进入reenter_kprobe(jprobe需要，到时候分析)*/
            if(kprobe_running()){
                if(reenter_kprobe(p,regs,kcb))
                    return1;
            }else{
                set_current_kprobe(p,regs,kcb);
                kcb-&gt;kprobe_status =KPROBE_HIT_ACTIVE;

                /*
                 * If we have no pre-handler or it returned 0, we
                 * continue with normal processing.  If we have a
                 * pre-handler and it returned non-zero, it prepped
                 * for calling the break_handler below on re-entry
                 * for jprobe processing, so get out doing nothing
                 * more here.
                 */
        /*执行在此地址上挂载的pre_handle函数*/
                if(!p-&gt;pre_handler ||!p-&gt;pre_handler(p,regs))
    /*设置单步调试模式，为post_handle函数的执行做准备*/
                    setup_singlestep(p,regs,kcb,0);
                return1;
            }
        }elseif(*addr !=BREAKPOINT_INSTRUCTION){
            /*
             * The breakpoint instruction was removed right
             * after we hit it.  Another cpu has removed
             * either a probepoint or a debugger breakpoint
             * at this address.  In either case, no further
             * handling of this interrupt is appropriate.
             * Back up over the (now missing) int3 and run
             * the original instruction.
             */
            regs-&gt;ip =(unsigned long)addr;
            preempt_enable_no_resched();
            return1;
        }elseif(kprobe_running()){
            p =__this_cpu_read(current_kprobe);
            if(p-&gt;break_handler &amp;&amp;p-&gt;break_handler(p,regs)){
                setup_singlestep(p,regs,kcb,0);
                return1;
            }
        }/* else: not a kprobe fault; let the kernel handle it */

        preempt_enable_no_resched();
        return0;
    }

    staticvoid__kprobes setup_singlestep(structkprobe *p,structpt_regs *regs,
                           structkprobe_ctlblk *kcb,intreenter)
    {
        if(setup_detour_execution(p,regs,reenter))
            return;

    #if!defined(CONFIG_PREEMPT)
        if(p-&gt;ainsn.boostable ==1 &amp;&amp;!p-&gt;post_handler){
            /* Boost up -- we can execute copied instructions directly */
            if(!reenter)
                reset_current_kprobe();
            /*
             * Reentering boosted probe doesn't reset current_kprobe,
             * nor set current_kprobe, because it doesn't use single
             * stepping.
             */
            regs-&gt;ip =(unsigned long)p-&gt;ainsn.insn;
            preempt_enable_no_resched();
            return;
        }
    #endif
        /*jprobe*/
        if(reenter){
            save_previous_kprobe(kcb);
            set_current_kprobe(p,regs,kcb);
            kcb-&gt;kprobe_status =KPROBE_REENTER;
        }else
            kcb-&gt;kprobe_status =KPROBE_HIT_SS;
        /* Prepare real single stepping */
        /*准备单步模式，设置EFLAGS的TF标志位，清楚IF标志位(禁止中断)*/
        clear_btf();
        regs-&gt;flags|=X86_EFLAGS_TF;
        regs-&gt;flags&amp;=~X86_EFLAGS_IF;
        /* single step inline if the instruction is an int3 */
        if(p-&gt;opcode ==BREAKPOINT_INSTRUCTION)
            regs-&gt;ip =(unsigned long)p-&gt;addr;
        else
    /*设置异常返回的指令为保存的被探测点的指令*/
            regs-&gt;ip =(unsigned long)p-&gt;ainsn.insn;
    }
</code></pre>

<h5>对应kprobe,pre_handle的执行就结束了，按照代码，程序开始执行保存的被探测点的指令，由于开启了单步调试模式，执行完指令后会继续触发异常，这次的是do_debug异常处理流程。</h5>

<pre><code>    dotraplinkage void__kprobes do_debug(structpt_regs *regs,longerror_code)
    {
        ....

        /*在do_debug中，以DIE_DEBUG再一次触发kprobe的通知链*/
        if(notify_die(DIE_DEBUG,"debug",regs,PTR_ERR(&amp;dr6),error_code,
                                SIGTRAP)==NOTIFY_STOP)
            return;

        ....
        return;
    }

    /*对于kprobe_exceptions_notify，其DIE_DEBUG处理流程*/
    caseDIE_DEBUG:
            if(post_kprobe_handler(args-&gt;regs)){
                /*
                 * Reset the BS bit in dr6 (pointed by args-&gt;err) to
                 * denote completion of processing
                 */
                (*(unsigned long*)ERR_PTR(args-&gt;err))&amp;=~DR_STEP;
                ret =NOTIFY_STOP;
            }
            break;

    staticint__kprobes post_kprobe_handler(structpt_regs *regs)
    {
        structkprobe *cur =kprobe_running();
        structkprobe_ctlblk *kcb =get_kprobe_ctlblk();

        if(!cur)
            return0;

        /*设置异常返回的EIP为下一条需要执行的指令*/
        resume_execution(cur,regs,kcb);
        /*恢复异常执行前的EFLAGS*/
        regs-&gt;flags|=kcb-&gt;kprobe_saved_flags;

        /*执行post_handler函数*/
        if((kcb-&gt;kprobe_status !=KPROBE_REENTER)&amp;&amp;cur-&gt;post_handler){
            kcb-&gt;kprobe_status =KPROBE_HIT_SSDONE;
            cur-&gt;post_handler(cur,regs,0);
        }

        /* Restore back the original saved kprobes variables and continue. */
        if(kcb-&gt;kprobe_status ==KPROBE_REENTER){
            restore_previous_kprobe(kcb);
            gotoout;
        }
        reset_current_kprobe();
    out:
        preempt_enable_no_resched();

        /*
         * if somebody else is singlestepping across a probe point, flags
         * will have TF set, in which case, continue the remaining processing
         * of do_debug, as if this is not a probe hit.
         */
        if(regs-&gt;flags&amp;X86_EFLAGS_TF)
            return0;

        return1;
    }
</code></pre>

<p>至此，一个典型的kprobe的流程已经执行完毕了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C语言输出缓冲区函数说明]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/05/07/lang-c-flush-out/"/>
    <updated>2013-05-07T18:15:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/05/07/lang-c-flush-out</id>
    <content type="html"><![CDATA[<pre><code>    #include &lt;stdio.h&gt;
    #include &lt;unistd.h&gt;

    int main(void)
    {
        int i = 0;
        while(1) {
            printf("sleeping %d", i++); //(1)
            fflush(stdout);
            sleep(1);
        }
        return 0;
    }
</code></pre>

<h4>1</h4>

<p>printf将"sleeping %d"输出到标准输出文件的缓冲区中(缓冲区在内存上)，fflush(stdout)将缓冲区中的内容强制刷新到，并将其中的内容输出到显示器上(&ldquo;\n"回车换行 == fflush(stdout)+换行)
<code>
                             fflush()
         buffer(In memroy) -----------&gt; hard disk/monitor
</code></p>

<h4>2</h4>

<p>有三个流(stream)是自动打开的， 相应的FILE结构指针为stdin、stdout、stderr，与之对应的文件描述符是：STDIN_FILENO、STDOUT_FILENO、STDERR_FILENO。</p>

<h4>流缓冲的属性：</h4>

<p>缓冲区类型有：全缓冲(大部分缓冲都是这类型)、行缓冲(例如stdio,stdout)、无缓冲(例如stderr)。<br/>
关于全缓冲，例如普通的文件操作，进行fputs、fprintf操作后，数据并没有立即写入磁盘文件中，当fflush或fclose文件时，数据才真正写入。<br/>
可以用以下函数设置流的缓冲类型：
<code>
void setvbuf()  
void setbuf()  
void setbuffer()  
void setlinebuf()
</code></p>

<h4>3</h4>

<p>fflush() 是把 FILE *里的缓冲区(位于用户态进程空间)刷新到内核中<br/>
fsync() -是把内核中对应的缓冲(是在 vfs 层的缓冲)刷新到硬盘中</p>

<h4>4</h4>

<p>在Linux的标准函数库中，有一套称作“高级I/O”的函数，我们熟知的printf()、fopen()、fread()、fwrite()都在此 列，它们也被称作“缓冲I/O（buffered I/O）”，每次写文件的时候，也仅仅是写入内存中的缓冲区，等满足了一定的条件（达到一定数量，或遇到特定字符，如换行符\n和文件结束符EOF），再 将缓冲区中的内容一次性写入文件，这样就大大增加了文件读写的速度。</p>

<hr />

<p>  The three types of buffering available are unbuffered, block buffered, and line buffered. When an output stream is unbuffered, information appears on the destination file or terminal as soon as written; when it is block buffered many characters are saved up and written as a block; when it is line buffered characters are saved up until a newline is output or input is read from any stream attached to a terminal device (typically stdin). The function fflush(3) may be used to force the block out early. (See fclose(3).) Normally all files are block buffered. When the first I/O operation occurs on a file, malloc(3) is called, and a buffer is obtained. If a stream refers to a terminal (as stdout normally does) it is line buffered. The standard error
stream stderr is always unbuffered by default.</p>

<p>  一般来说，block buffered的效率高些，将多次的操作合并成一次操作。先在标准库里缓存一部分，直到该缓冲区满了，或者程序显示的调用fflush时，将进行更新操作。而setbuf 则可以设置该缓冲区的大小。</p>

<h5>setbuf()</h5>

<pre><code>    #include &lt;stdio.h&gt;
    void setbuf(FILE *stream, char *buf);
</code></pre>

<p>这个函数应该必须在如何输出被写到该文件之前调用。一般放在main里靠前面的语句！但是setbuf有个经典的错误，man手册上也提到了，c陷阱和缺陷上也提到了
You must make sure that both buf and the space it points to still exist by the time stream is closed, which also happens at program termination. For example, the following is illegal:
<code>
        #include &lt;stdio.h&gt;
    int main()
    {
        char buf[BUFSIZ];
        setbuf(stdin, buf);
        printf("Hello, world!\n");
        return 0;
    }
</code>
这个程序是错误的。buf缓冲区最后一次清空应该在main函数结束之后，程序交回控制给操作系统之前C运行库所必须进行的清理工作的一部分，但是此时 buf字符数组已经释放。修改的方法是将buf设置为static，或者全局变量； 或者调用malloc来动态申请内存。
<code>
    char * malloc();
    setbuf(stdout,malloc(BUFSIZE));
</code>
这里不需要判断malloc的返回值，如果malloc调用失败，将返回一个null指针，setbuf的第二个参数可以是null,此时不进行缓冲！</p>

<h5>fflush()</h5>

<p>fflush函数则刷新缓冲区，将缓冲区上的内容更新到文件里。
<code>
    #include &lt;stdio.h&gt;
    int fflush(FILE *stream);
</code>
  The function fflush forces a write of all user-space buffered data for the given output or update stream via the stream underlying write function. The open status of the stream is unaffected. If the stream argument is NULL, fflush flushes all open output streams.</p>

<p>但是fflush仅仅刷新C库里的缓冲。其他的一些数据的刷新需要调用fsync或者sync!</p>

<p>  Note that fflush() only flushes the user space buffers provided by the C library. To ensure that the data is physically stored on disk the kernel buffers must be flushed too, e.g. with sync(2) or fsync(2).</p>

<h5>fsync()和sync()</h5>

<p>  fsync和sync最终将缓冲的数据更新到文件里。
<code>
    #include &lt;unistd.h&gt;
    int fsync(int fd);
</code>
  fsync copies all in-core parts of a file to disk, and waits until the device reports that all parts are on stable storage. It also updates metadata stat information. It does not necessarily ensure that the entry in the directory containing the file has also reached disk. For that an explicit fsync on the file descriptor of the directory is also needed.</p>

<p>  同步命令sync就直接调用了sync函数来更新磁盘上的缓冲！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[通过绝对内存地址进行参数赋值与函数调用]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/05/07/lang-c-call-addr/"/>
    <updated>2013-05-07T18:15:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/05/07/lang-c-call-addr</id>
    <content type="html"><![CDATA[<p>同一个数可以通过不同的方式表达出来，对于函数的访问，变量的赋值除了直接对变量赋值以外，还可以通过绝对内存地址进行参数赋值与函数调用。</p>

<h4>1、通过地址修改变量的值</h4>

<pre><code>    int x;
    int *p;
    printf("%x\n",&amp;x);
    p=(int *)0x0012ff60;
    *p = 3;
    printf("%d\n",x);
</code></pre>

<p>程序的输出结果为：<br/>
12ff603</p>

<p>程序首先输出变量x所在地址为十六进制的0x12ff60（本来应该为8位的十六进制数，高位为0则省略掉），然后定义一个指针变量，让它指向该地址，通过指针变量的值来修改变量x的值。</p>

<p>示例代码：
<code>
    int *ptr=(int*)0xa4000000;
    *ptr=0xaabb;
    printf("%d\n",*ptr);
</code>
以上程序会崩溃，因为这样做会给一个指针分配一个随意的地址，很危险，所以这种做法是不允许的。</p>

<h4>2、通过地址调用函数的执行</h4>

<pre><code>    #include &lt;iostream&gt;using namespace std; 
    typedef void(*FuncPtr)() ;

    void  p()
    { 
        printf("MOP\n");
    }   

    int main()
    {
        void (*ptr)();
        p();
        printf("%x\n",p);
        ptr = (void (*)())0x4110f0;
        ptr();//函数指针执行
        ((void (*)())0x4110f0)();
        ((FuncPtr)0x4110f0)();
        return 0;
    }
</code></pre>

<p>程序执行结果如下：<br/>
MOP4110f0MOP<br/>
MOP<br/>
MOP</p>

<p>首先定义一个ptr的函数指针，第一次通过函数名调用函数，输出Mop，打印函数的入口地址，函数的入口地址为4110f0。然后给函数指针ptr赋地址值为p的入口地址，调用ptr，输出Mop。接着的过程是不通过函数指针直接执行，仍然使用p的入口地址调用，输出为MOP。最后是通过typedef调用的直接执行。</p>

<p>函数名称、代码都是放在代码段的，因为是放在代码段，每次会跳到相同的地方，但参数会压栈，所以函数只根据函数名来获取入口地址，与参数和返回值无关。无论参数和返回值如何不同，函数入口地址都是一个地方。</p>

<p>对以下程序进行分析如下：
```
    #include &lt;stdio.h> int   p(int a,int b)
    {
        return 3;
    }</p>

<pre><code>int main()
{
    printf("%x\n",p);
    int a = p(2,3);
    printf("%d\n",p);
    int b = p(4,5);
    printf("%x\n",p);
    return 0;
}
</code></pre>

<pre><code>程序输出结果如下：  
4111594264281411159  
十六进制的411159转换成十进制的值为4264281。程序中打印的p的入口地址，无论p是否调用函数，入口地址都没有改变。
分析如下代码：
</code></pre>

<pre><code>#include &lt;stdio.h&gt; int  p(int a,int b) 
{ 
    return ((a&gt;b)?a:b);
}  
int main()
{
    int (*ptr)(int ,int);
    ptr = (int (*)(int,int))0x411159;
    int c = ptr(5,6);
    printf("%d\n",c);
    return 0;
}
</code></pre>

<p>```
程序输出为:<br/>
6
通过函数指针调用有返回值和参数的函数，不适用函数名，而是用函数入口地址调用。<br/>
函数存放在内存的代码区域内，也有地址，一个函数在编译时被分配一个入口地址，将这个入口地址称为函数的指针，函数的地址就是函数的名字。
函数指针不能指向不同类型或是带不同形参的函数。</p>
]]></content>
  </entry>
  
</feed>
