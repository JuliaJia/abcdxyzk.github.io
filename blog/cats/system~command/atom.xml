<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: system~command | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/system~command/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2014-11-28T22:31:01+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ar ranlib nm 命令--制作.a文件]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/11/06/command-ar/"/>
    <updated>2014-11-06T23:08:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/11/06/command-ar</id>
    <content type="html"><![CDATA[<h4>1.ar基本用法</h4>

<h5>功能说明：建立或修改备存文件，或是从备存文件中抽取文件。</h5>

<p>ar命令可以用来创建、修改库，也可以从库中提出单个模块。库是一单独的文件，里面包含了按照特定的结构组织起来的其它的一些文件（称做此库文件的member）。原始文件的内容、模式、时间戳、属主、组等属性都保留在库文件中。</p>

<!--more-->


<h5>下面是ar命令的格式：</h5>

<p>　　ar [-]{dmpqrtx}[abcfilNoPsSuvV] [membername] [count] archive files&hellip;<br/>
　　例如我们可以用ar rv libtest.a hello.o hello1.o来 生成一个库，库名字是test，链接时可以用-ltest链接。该库中存放了两个模块hello.o和hello1.o。选项前可以有‘-&lsquo;字符，也可以 没有。下面我们来看看命令的操作选项和任选项。现在我们把{dmpqrtx}部分称为操作选项，而[abcfilNoPsSuvV]部分称为任选项。<br/>
　　{dmpqrtx}中的操作选项在命令中只能并且必须使用其中一个，它们的含义如下：<br/>
    d：从库中删除模块。按模块原来的文件名指定要删除的模块。如果使用了任选项v则列出被删除的每个模块。<br/>
    m：该操作是在一个库中移动成员。当库中如果有若干模块有相同的符号定义(如函数定义)，则成员的位置顺序很重要。如果没有指定任选项，任何指定的成员将移到库的最后。也可以使用'a'，'b'，或'I'任选项移动到指定的位置。<br/>
    p：显示库中指定的成员到标准输出。如果指定任选项v，则在输出成员的内容前，将显示成员的名字。如果没有指定成员的名字，所有库中的文件将显示出来。<br/>
    q：快速追加。增加新模块到库的结尾处。并不检查是否需要替换。'a'，'b'，或'I'任选项对此操作没有影响，模块总是追加的库的结尾处。如果使用了任选项v则列出每个模块。 这时，库的符号表没有更新，可以用'ar s'或ranlib来更新库的符号表索引。<br/>
    r：在库中插入模块(替换)。当插入的模块名已经在库中存在，则替换同名的模块。如果若干模块中有一个模块在库中不存在，ar显示一个错误消息，并不替换其他同名模块。默认的情况下，新的成员增加在库的结尾处，可以使用其他任选项来改变增加的位置。<br/>
    t：显示库的模块表清单。一般只显示模块名。<br/>
    x：从库中提取一个成员。如果不指定要提取的模块，则提取库中所有的模块。<br/>
　　下面在看看可与操作选项结合使用的任选项：<br/>
    a：在库的一个已经存在的成员后面增加一个新的文件。如果使用任选项a，则应该为命令行中membername参数指定一个已经存在的成员名。<br/>
    b：在库的一个已经存在的成员前面增加一个新的文件。如果使用任选项b，则应该为命令行中membername参数指定一个已经存在的成员名。<br/>
    c：创建一个库。不管库是否存在，都将创建。<br/>
    f：在库中截短指定的名字。缺省情况下，文件名的长度是不受限制的，可以使用此参数将文件名截短，以保证与其它系统的兼容。<br/>
    i：在库的一个已经存在的成员前面增加一个新的文件。如果使用任选项i，则应该为命令行中membername参数指定一个已经存在的成员名(类似任选项b)。<br/>
    l：暂未使用<br/>
    N：与count参数一起使用，在库中有多个相同的文件名时指定提取或输出的个数。<br/>
    o：当提取成员时，保留成员的原始数据。如果不指定该任选项，则提取出的模块的时间将标为提取出的时间。<br/>
    P：进行文件名匹配时使用全路径名。ar在创建库时不能使用全路径名（这样的库文件不符合POSIX标准），但是有些工具可以。<br/>
    s：写入一个目标文件索引到库中，或者更新一个存在的目标文件索引。甚至对于没有任何变化的库也作该动作。对一个库做ar s等同于对该库做ranlib。<br/>
    S：不创建目标文件索引，这在创建较大的库时能加快时间。<br/>
    u：一般说来，命令ar r&hellip;插入所有列出的文件到库中，如果你只想插入列出文件中那些比库中同名文件新的文件，就可以使用该任选项。该任选项只用于r操作选项。<br/>
    v：该选项用来显示执行操作选项的附加信息。<br/>
    V：显示ar的版本。</p>

<h4>2.ranlib命令</h4>

<p>静态库文件需要使用“ar”来创建和维护。当给静态库增建一个成员时（加入一个.o文件到静态库中），“ar”可直接 将需要增加的.o文件简单的追加到静态库的末尾。之后当我们使用这个库进行连接生成可执行文件时，链接程序“ld”却提示错误，这可能是：主程序使用了之 前加入到库中的.o文件中定义的一个函数或者全局变量，但连接程序无法找到这个函数或者变量。</p>

<p>这个问题的原因是：之前我们将编译完成的.o文件直接加入到了库的末尾，却并没有更新库的有效符号表。连接程序进行连接时，在静态库的符号索引表中无法定 位刚才加入的.o文件中定义的函数或者变量。这就需要在完成库成员追加以后让加入的所有.o文件中定义的函数（变量）有效，完成这个工作需要使用另外一个 工具“ranlib”来对静态库的符号索引表进行更新。</p>

<p>我们所使用到的静态库（文档文件）中，存在这样一个特殊的成员，它的名字是“<strong>.SYMDEF”。它包含了静态库中所有成员所定义的有效符号（函数名、 变量名）。因此，当为库增加了一个成员时，相应的就需要更新成员“</strong>.SYMDEF”，否则所增加的成员中定义的所有的符号将无法被连接程序定位。完成 更新的命令是：
<code>
    ranlib ARCHIVEFILE
</code>
通常在Makefile中我们可以这样来实现：
<code>
    libfoo.a: libfoo.a(x.o) libfoo.a(y.o) ...
    ranlib libfoo.a
</code>
它所实现的是在更新静态库成员“x.o”和“y.o”之后，对静态库的成员“__.SYMDEF”进行更新（更新库的符号索引表）。
如果我们使用GNU ar工具来维护、管理静态库，我们就不需要考虑这一步。GNU ar本身已经提供了在更新库的同时更新符号索引表的功能（这是默认行为，也可以通过命令行选项控制ar的具体行为。可参考 GNU ar工具的man手册）。</p>

<p>GNU工具中ar是用来制作库文件.a的，但同时还提供了一个ranlib，从手册上看ranlib相当于ar -s，为什么这样呢？<br/>
这是由于最早在Unix系统上ar程序是单纯用来打包多个.o到.a（类似于tar做的事情），而不处理.o里的符号表。Linker程序则需 要.a文件提供一个完整的符号表，所以当时就写了单独的ranlib程序用来产生linker所需要的符号信息。也就是说，产生一个对linker合 格的的.a文件需要做ar和ranlib两步 。<br/>
很快，Unix厂商就发现ranlib做得事情完全可以合并到ar里面去，于是ar程序的升级版本就包括了ranlib的功能，但早期的很多项目的Makefile都已经是按照两步式的方法生成.a，所以为了保证这些早期文件的兼容性，ranlib被保留下来了。<br/>
如今，GNU/Linux系统上，ranlib依然存在，当然大部分项目已经不使用它了，因为ar -s就做了ranlib的工作。<br/>
历史通常是进步和妥协的混合！</p>

<h4>3.nm基本用法命令</h4>

<p>　　nm用来列出目标文件的符号清单。下面是nm命令的格式：
<code>
    nm [-a|--debug-syms] [-g|--extern-only] [-B][-C|--demangle] [-D|--dynamic] [-s|--print-armap][-o|--print-file-name] [-n|--numeric-sort][-p|--no-sort] [-r|--reverse-sort] [--size-sort][-u|--undefined-only] [-l|--line-numbers] [--help][--version] [-t radix|--radix=radix][-P|--portability] [-f format|--format=format][--target=bfdname] [objfile...]
</code>
如果没有为nm命令指出目标文件，则nm假定目标文件是a.out。下面列出该命令的任选项，大部分支持"-&ldquo;开头的短格式和"—"开头的长格式。<br/>
-A、-o或&ndash;print-file-name：在找到的各个符号的名字前加上文件名，而不是在此文件的所有符号前只出现文件名一次。<br/>
    例如nm libtest.a的输出如下：
<code>
    CPThread.o:
    00000068 T Main__8CPThreadPv
    00000038 T Start__8CPThread
    00000014 T _._8CPThread
    00000000 T __8CPThread
    00000000 ? __FRAME_BEGIN__
    .......................................
    则nm -A 的输出如下：
    libtest.a:CPThread.o:00000068 T Main__8CPThreadPv
    libtest.a:CPThread.o:00000038 T Start__8CPThread
    libtest.a:CPThread.o:00000014 T _._8CPThread
    libtest.a:CPThread.o:00000000 T __8CPThread
    libtest.a:CPThread.o:00000000 ? __FRAME_BEGIN__
    ..................................................................
</code>
nm命令<br/>
    -a或&ndash;debug-syms：显示调试符号。<br/>
    -B：等同于&ndash;format=bsd，用来兼容MIPS的nm。<br/>
    -C或&ndash;demangle：将低级符号名解码(demangle)成用户级名字。这样可以使得C++函数名具有可读性。<br/>
    -D或&ndash;dynamic：显示动态符号。该任选项仅对于动态目标(例如特定类型的共享库)有意义。<br/>
    -f format：使用format格式输出。format可以选取bsd、sysv或posix，该选项在GNU的nm中有用。默认为bsd。<br/>
    -g或&ndash;extern-only：仅显示外部符号。<br/>
    -n、-v或&ndash;numeric-sort：按符号对应地址的顺序排序，而非按符号名的字符顺序。<br/>
    -p或&ndash;no-sort：按目标文件中遇到的符号顺序显示，不排序。<br/>
    -P或&ndash;portability：使用POSIX.2标准输出格式代替默认的输出格式。等同于使用任选项-f posix。<br/>
    -s或&ndash;print-armap：当列出库中成员的符号时，包含索引。索引的内容包含：哪些模块包含哪些名字的映射。<br/>
    -r或&ndash;reverse-sort：反转排序的顺序(例如，升序变为降序)。<br/>
    &ndash;size-sort：按大小排列符号顺序。该大小是按照一个符号的值与它下一个符号的值进行计算的。<br/>
    -t radix或&ndash;radix=radix：使用radix进制显示符号值。radix只能为"d"表示十进制、"o"表示八进制或"x"表示十六进制。<br/>
    &ndash;target=bfdname：指定一个目标代码的格式，而非使用系统的默认格式。<br/>
    -u或&ndash;undefined-only：仅显示没有定义的符号(那些外部符号)。<br/>
    -l或&ndash;line-numbers：对每个符号，使用调试信息来试图找到文件名和行号。对于已定义的符号，查找符号地址的行号。对于未定义符号，查找指向符号重定位入口的行号。如果可以找到行号信息，显示在符号信息之后。<br/>
    -V或&ndash;version：显示nm的版本号。<br/>
    &ndash;help：显示nm的任选项。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[patch / git patch]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/10/30/command-git-patch/"/>
    <updated>2014-10-30T10:44:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/10/30/command-git-patch</id>
    <content type="html"><![CDATA[<h4>1、diff</h4>

<pre><code>diff [options] from-file to-file  
</code></pre>

<p>简单的说，diff的功能就是用来比较两个文件的不同，然后记录下来，也就是所谓的diff补丁。语法格式：diff 【选项】 源文件（夹） 目的文件（夹），就是要给源文件（夹）打个补丁，使之变成目的文件（夹），术语也就是“升级”。下面介绍三个最为常用选项：</p>

<blockquote><p>   -r 是一个递归选项，设置了这个选项，diff会将两个不同版本源代码目录中的所有对应文件全部都进行一次比较，包括子目录文件。<br/>
   -N 选项确保补丁文件将正确地处理已经创建或删除文件的情况。<br/>
   -u 选项以统一格式创建补丁文件，这种格式比缺省格式更紧凑些</p></blockquote>

<h4>2、patch</h4>

<pre><code>patch [options] [originalfile [patchfile]]
but usually just
patch -pnum &lt;patchfile&gt;
</code></pre>

<p>简单的说，patch就是利用diff制作的补丁来实现源文件（夹）和目的文件（夹）的转换。这样说就意味着你可以有源文件（夹）――>目的文件（夹），也可以目的文件（夹）――>源文件（夹）。下面介绍几个最常用选项：</p>

<blockquote><p>   -p0 选项要从当前目录查找目的文件（夹）<br/>
   -p1 选项要忽略掉第一层目录，从当前目录开始查找。</p></blockquote>

<hr />

<p>在这里以实例说明：
<code>
--- old/modules/pcitable       Mon Sep 27 11:03:56 1999
+++ new/modules/pcitable       Tue Dec 19 20:05:41 2000
</code>
如果使用参数-p0，那就表示从当前目录找一个叫做old的文件夹，在它下面寻找modules下的pcitable文件来执行patch操作。<br/>
如果使用参数-p1， 那就表示忽略第一层目录（即不管old），从当前目录寻找modules的文件夹，在它下面找pcitable。这样的前提是当前目 录必须为modules所在的目录。而diff补丁文件则可以在任意位置，只要指明了diff补丁文件的路径就可以了。当然，可以用相对路径，也可以用绝 对路径。不过我一般习惯用相对路径。</p>

<blockquote><p>  -E 选项说明如果发现了空文件，那么就删除它<br/>
  -R 选项说明在补丁文件中的“新”文件和“旧”文件现在要调换过来了（实际上就是给新版本打补丁，让它变成老版本）</p></blockquote>

<h4>单个文件</h4>

<pre><code>diff –uN from-file to-file &gt;to-file.patch
patch –p0 &lt; to-file.patch
patch –RE –p0 &lt; to-file.patch
</code></pre>

<h4>目录</h4>

<pre><code>diff –uNr from-docu to-docu &gt;to-docu.patch
patch –p1 &lt; to-docu.patch
patch –R –p1 &lt;to-docu.patch
</code></pre>

<hr />

<h4>git diff或者其他UNIX的diff命令生成patch的过程：</h4>

<pre><code>    git diff  &gt; patch
    git diff  --cached &gt; patch
    git diff  branchname --cached &gt; patch
</code></pre>

<p>这个时候当前目录下就会有一个patch文件，这是一个非git环境也可以使用的patch。对于这种patch，在git上使用要用git apply命令，如下：
<code>
    git apply patch
</code></p>

<p>由于这是一个类似UNIX下更新文件的操作，所以执行完上述操作之后，实际上是等于手动修改了文件，还要做一些git commit之类的操作。git apply 是一个事务性操作的命令，也就是说，要么所有补丁都打上去，要么全部放弃。可以先用git apply &ndash;check 查看补丁是否能够干净顺利地应用到当前分支中：git apply &ndash;check patch，如果执行完该命令之后没有任何输出，表示我们可以顺利采纳该补丁，接下来就是git上的提交了。</p>

<p>git format-patch生成的补丁，这是git专用的。常用命令如下：<br/>
1. 两个节点之间的提交： git format-patch  节点A   节点B<br/>
2. 单个节点： git format-patch -1 节点A （-n就表示要生成几个节点的提交）<br/>
3. 最近一次提交节点的patch ：git format-patch HEAD^ 依次类推……</p>

<p>使用git format-patch命令生成的patch文件，包含了提交的附加信息：比如作者，时间等。再次基础上使用git am命令即可将此补丁应用到当前分支。注意应用完之后，你会发现当前分支多了一次提交记录，并且有完整的信息，而不是简单的修改文件。在对比一下，git diff 和git format-patch生成的patch一个重要不同之处，实际使用中会发现git diff一次只会生成一个patch文件，不管差别了多少个提交，都是一个；而git format-patch是根据提交的节点来的，一个节点一个patch。</p>

<h4>git两种patch的比较：</h4>

<p>兼容性：很明显，git diff生成的Patch兼容性强。如果你在修改的代码的官方版本库不是Git管理的版本库，那么你必须使用git diff生成的patch才能让你的代码被项目的维护人接受。</p>

<p>除错功能：对于git diff生成的patch，你可以用git apply &ndash;check 查看补丁是否能够干净顺利地应用到当前分支中；如果git format-patch 生成的补丁不能打到当前分支，git am会给出提示，并协助你完成打补丁工作，你也可以使用git am -3进行三方合并，详细的做法可以参考git手册或者《Progit》。从这一点上看，两者除错功能都很强。</p>

<p>版本库信息：由于git format-patch生成的补丁中含有这个补丁开发者的名字，因此在应用补丁时，这个名字会被记录进版本库，显然，这样做是恰当的。因此，目前使用Git的开源社区往往建议大家使用format-patch生成补丁。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[grubby edit centos grub args]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/10/24/command-grubby/"/>
    <updated>2014-10-24T15:57:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/10/24/command-grubby</id>
    <content type="html"><![CDATA[<p>In Debian/Ubuntu, grub.cfg is fully generated by scripts and any manual changes made to it will be clobbered. In RHEL/CentOS however, grub.cfg is modified by scripts but manual changes are persisted, and is actually the canonical location for certain settings.</p>

<p>The tool which manages grub.cfg is grubby, which is called by /sbin/new-kernel-pkg when kernels are installed or removed. The &ndash;copy-default parameter is passed to grubby when a new kernel is installed, which causes it to copy the kernel parameters from the current default kernel. Setting the default kernel parameters for future-installed kernels is therefore done by editing the entry for the default kernel in grub.cfg.</p>

<p>If you weren&rsquo;t automating this you could simply edit grub.cfg manually and change all the current kernel entries. However, you can use grubby to modify grub.cfg in order to avoid parsing it or writing regular expressions. For example, this will remove the rhgb and quiet parameters from the specified kernel version.</p>

<pre><code>$ grubby --update-kernel=/boot/vmlinuz-2.6.32-220.13.1.el6.x86_64 --remove-args="rhgb quiet"
</code></pre>

<p>There doesn&rsquo;t seem to be an option to list the currently configured kernels however, so you&rsquo;ll have to discover these another way. One option is to just look for vmlinuz files in /boot/:</p>

<pre><code>#!/bin/sh
for KERNEL in /boot/vmlinuz-*; do
    grubby --update-kernel="$KERNEL" --remove-args="rhgb quiet"
done
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[grep 命令]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/10/17/command-grep/"/>
    <updated>2014-10-17T18:18:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/10/17/command-grep</id>
    <content type="html"><![CDATA[<ul>
<li>^：匹配正则表达式的开始行。</li>
<li>$: 匹配正则表达式的结束行。</li>
</ul>


<h4>1.作用</h4>

<p>Linux系统中grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印出来。grep全称是Global Regular Expression Print，表示全局正则表达式版本，它的使用权限是所有用户。</p>

<h4>2.格式</h4>

<p>grep [options]</p>

<h4>3.主要参数</h4>

<p>[options]主要参数：
<code>
－c：只输出匹配行的计数。
－I：不区分大 小写(只适用于单字符)。
－h：查询多文件时不显示文件名。
－l：查询多文件时只输出包含匹配字符的文件名。
－n：显示匹配行及 行号。
－s：不显示不存在或无匹配文本的错误信息。
－v：显示不包含匹配文本的所有行。
</code>
pattern正则表达式主要参数：
<code>
\： 忽略正则表达式中特殊字符的原有含义。
^：匹配正则表达式的开始行。
$: 匹配正则表达式的结束行。
\&lt;：从匹配正则表达 式的行开始。
\&gt;：到匹配正则表达式的行结束。
[ ]：单个字符，如[A]即A符合要求 。
[ - ]：范围，如[A-Z]，即A、B、C一直到Z都符合要求 。
。：所有的单个字符。
* ：有字符，长度可以为0。
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[dd 命令]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/09/19/command-dd/"/>
    <updated>2014-09-19T15:13:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/09/19/command-dd</id>
    <content type="html"><![CDATA[<p>贴自<a href="http://www.chinaunix.net/old_jh/4/1025448.html">http://www.chinaunix.net/old_jh/4/1025448.html</a>
dd 是 Linux/UNIX 下的一个非常有用的命令，作用是用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换。</p>

<h4>1. 命令简介</h4>

<p>dd 的主要选项：
<code>
指定数字的地方若以下列字符结尾乘以相应的数字:
b=512, c=1, k=1024, w=2, xm=number m
if=file
输入文件名，缺省为标准输入。
of=file
输出文件名，缺省为标准输出。
ibs=bytes
一次读入 bytes 个字节(即一个块大小为 bytes 个字节)。
obs=bytes
一次写 bytes 个字节(即一个块大小为 bytes 个字节)。
bs=bytes
同时设置读写块的大小为 bytes ，可代替 ibs 和 obs 。
cbs=bytes
一次转换 bytes 个字节，即转换缓冲区大小。
skip=blocks
从输入文件开头跳过 blocks 个块后再开始复制。
seek=blocks
从输出文件开头跳过 blocks 个块后再开始复制。(通常只有当输出文件是磁盘或磁带时才有效)。
count=blocks
仅拷贝 blocks 个块，块大小等于 ibs 指定的字节数。
conv=conversion[,conversion...]
用指定的参数转换文件。
转换参数:
ascii 转换 EBCDIC 为 ASCII。
ebcdic 转换 ASCII 为 EBCDIC。
ibm 转换 ASCII 为 alternate EBCDIC.
block 把每一行转换为长度为 cbs 的记录，不足部分用空格填充。
unblock 使每一行的长度都为 cbs ，不足部分用空格填充。
lcase 把大写字符转换为小写字符。
ucase 把小写字符转换为大写字符。
swab 交换输入的每对字节。
noerror 出错时不停止。
notrunc 不截短输出文件。
sync 把每个输入块填充到ibs个字节，不足部分用空(NUL)字符补齐。
</code></p>

<h4>2.实例分析</h4>

<h5>2.1.数据备份与恢复</h5>

<h6>2.1.1整盘数据备份与恢复</h6>

<p>备份：<br/>
dd if=/dev/hdx of=/dev/hdy<br/>
将本地的/dev/hdx整盘备份到/dev/hdy <br/>
dd if=/dev/hdx of=/path/to/image<br/>
将/dev/hdx全盘数据备份到指定路径的image文件<br/>
dd if=/dev/hdx | gzip >/path/to/image.gz<br/>
备份/dev/hdx全盘数据，并利用gzip工具进行压缩，保存到指定路径<br/>
恢复：<br/>
dd if=/path/to/image of=/dev/hdx<br/>
将备份文件恢复到指定盘<br/>
gzip -dc /path/to/image.gz | dd of=/dev/hdx<br/>
将压缩的备份文件恢复到指定盘</p>

<h6>2.1.2.利用netcat远程备份</h6>

<p>dd if=/dev/hda bs=16065b | netcat &lt; targethost-IP > 1234<br/>
在源主机上执行此命令备份/dev/hda<br/>
netcat -l -p 1234 | dd of=/dev/hdc bs=16065b<br/>
在目的主机上执行此命令来接收数据并写入/dev/hdc<br/>
netcat -l -p 1234 | bzip2 > partition.img<br/>
netcat -l -p 1234 | gzip > partition.img<br/>
以上两条指令是目的主机指令的变化分别采用bzip2  gzip对数据进行压缩，并将备份文件保存在当前目录。</p>

<h6>2.1.3.备份MBR</h6>

<p>备份：<br/>
dd if=/dev/hdx of=/path/to/image count=1 bs=512<br/>
备份磁盘开始的512Byte大小的MBR信息到指定文件<br/>
恢复：<br/>
dd if=/path/to/image of=/dev/hdx<br/>
将备份的MBR信息写到磁盘开始部分</p>

<h6>2.1.4.备份软盘</h6>

<p>dd if=/dev/fd0 of=disk.img count=1 bs=1440k<br/>
将软驱数据备份到当前目录的disk.img文件</p>

<h6>2.1.5.拷贝内存资料到硬盘</h6>

<p>dd if=/dev/mem of=/root/mem.bin bs=1024<br/>
将内存里的数据拷贝到root目录下的mem.bin文件</p>

<h6>2.1.6.从光盘拷贝iso镜像</h6>

<p>dd if=/dev/cdrom of=/root/cd.iso<br/>
拷贝光盘数据到root文件夹下，并保存为cd.iso文件</p>

<h5>2.2.增加Swap分区文件大小</h5>

<p>dd if=/dev/zero of=/swapfile bs=1024 count=262144<br/>
创建一个足够大的文件（此处为256M）<br/>
mkswap /swapfile<br/>
把这个文件变成swap文件<br/>
swapon /swapfile<br/>
启用这个swap文件<br/>
/swapfile swap swap defaults 0 0<br/>
在每次开机的时候自动加载swap文件, 需要在 /etc/fstab 文件中增加一行</p>

<h5>2.3销毁磁盘数据</h5>

<p>dd if=/dev/urandom of=/dev/hda1<br/>
利用随机的数据填充硬盘，在某些必要的场合可以用来销毁数据。执行此操作以后，/dev/hda1将无法挂载，创建和拷贝操作无法执行。</p>

<h5>2.4磁盘管理</h5>

<h6>2.4.1.得到最恰当的block size</h6>

<pre><code>dd if=/dev/zero bs=1024 count=1000000 of=/root/1Gb.file
dd if=/dev/zero bs=2048 count=500000 of=/root/1Gb.file
dd if=/dev/zero bs=4096 count=250000 of=/root/1Gb.file  
dd if=/dev/zero bs=8192 count=125000 of=/root/1Gb.file
</code></pre>

<p>通过比较dd指令输出中所显示的命令执行时间，即可确定系统最佳的block size大小</p>

<h6>2.4.2测试硬盘读写速度</h6>

<pre><code>dd if=/root/1Gb.file bs=64k | dd of=/dev/null
dd if=/dev/zero of=/root/1Gb.file bs=1024 count=1000000
</code></pre>

<p>通过上两个命令输出的执行时间，可以计算出测试硬盘的读／写速度</p>

<h6>2.4.3.修复硬盘</h6>

<p>dd if=/dev/sda of=/dev/sda<br/>
当硬盘较长时间（比如1，2年）放置不使用后，磁盘上会产生magnetic flux point。当磁头读到这些区域时会遇到困难，并可能导致I/O 错误。当这种情况影响到硬盘的第一个扇区时，可能导致硬盘报废。上边的命令有可能使这些数据起死回生。且这个过程是安全，高效的。</p>
]]></content>
  </entry>
  
</feed>
