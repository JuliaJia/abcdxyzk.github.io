<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 2013 | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/2013/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2014-11-29T16:26:34+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[深入浅出指令编码之三：64位计算]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/12/23/assembly-opcode/"/>
    <updated>2013-12-23T17:55:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/12/23/assembly-opcode</id>
    <content type="html"><![CDATA[<p><a href="http://www.pediy.com/kssd/pediy10/77824.html">http://www.pediy.com/kssd/pediy10/77824.html</a></p>

<p>  AMD 在x86体系的32位计算扩展为64位计算，这是通过什么来实现的？它是怎样设计的？具体细节是什么？这就是这一节要讲解的。</p>

<h4>一、硬件编程资源</h4>

<p>　　了解现在processor提供编程资源是很重要的，对要进一步学习提供材料，下面分别讲解x86的编程资源和x64的编程资源。</p>

<h5>1、x86的32位编程资源</h5>

<pre><code>●  8个32位通用寄存器：EAX、ECX、EDX、EBX、ESP、EBP、ESI、EDI
　　　这些寄存器还可分解为8个8位寄存器：AL、CL、DL、BL、AH、CH、DH、BH
　　　和8个16位寄存器：AX、CX、DX、BX、SP、BP、SI、DI
●  6个段寄存器：ES、CS、SS、DS、FS、GS
●  32位的EFLAGS 标志位寄存器
●  32位的指令指针寄存器EIP
●  8个64位MMX寄存器
●  8个128位XMM寄存器
●  还有就是32位的寻址空间（Virtual Address Space）
</code></pre>

<h5>2、x64的64位编程资源</h5>

<pre><code>●  32位通用寄存器被扩展至64位，除了原有的8个寄存器，新增8个寄存器，共16个通用寄存器：RAX、RCX、RDX、RBX、RSP、RBP、RSI、RDI、R8、R9、R10、R11、R12、R13、R14、R15
●  保留了原有的6个寄存器，但是作用被限制
●  32位的标志寄存器被扩展为64位的标志寄存器RELAGS
●  8个64位MMX寄存器不变
●  新增8个XMM寄存器，共16个XMM寄存器
●  还有就是64位的寻址空间（Virtaul Address Space）
</code></pre>

<h4>二、寄存器编码（或者说ID值）</h4>

<pre><code>●  16个64位通用寄存器是： 0000 ~ 1111，也就是：0 ~ 15
　　　　8个32位通用寄存器是：　000 ~ 111 也就是：0 ~ 7
●  6个段寄存器的编码是：000 ~ 101　也就是：0 ~ 5
●  MMX寄存器编码是： 000 ~ 111　也就是：0 ~ 7
●  16个XMM寄存器编码是： 0000 ~ 1111 也就是：0 ~ 15
　　　　8个XMM寄存器编码是：000 ~ 111 也就是：0 ~ 7
</code></pre>

<p>所谓寄存器编码是寄存器对应的二进制编码，按顺序来定义，看下面的表格：</p>

<pre><code>RAX/ES/MMX0/XMM0　-&gt;  0000
RCX/CS/MMX1/XMM1  -&gt;  0001
RDX/SS/MMX2/XMM2  -&gt;  0010
RBX/DS/MMX3/XMM3  -&gt;  0011
RSP/FS/MMX4/XMM4   -&gt;  0100
RBP/GS/MMX5/XMM5  -&gt;  0101
RSI/MMX6/XMM6      -&gt;  0110
RDI/MMX7/XMM7     -&gt;  0111
R8/XMM8 　 -&gt;  1000
R9/XMM9 　 -&gt;  1001
R10/XMM10  -&gt;  1010
R11/XMM11  -&gt;  1011
R12/XMM12  -&gt;  1100
R13/XMM13  -&gt;  1101
R14/XMM14  -&gt;  1110
R15/XMM15  -&gt;  1111
</code></pre>

<p>  RAX ~ RDI　与　EAX ~ EDI　的编码是相同的，这里有一个情况是，EAX ~ EDI的编码是3位，为什么RAX~RDI的编码却是4位呢？这就是下面要讲到的REX prefix会将寄存器编码进行扩展。</p>

<h4>三、  开启64位计算的基石（REX prefix）</h4>

<p>　　AMD64体系的64位计算是这样设计：操作数的Default Operand-Size是32位，而Address-Size是固定为64位的，这里就引发3个问题要解决的：
<code>
●  问题1：当要访问是64位的寄存器时，那么必须要有一种机制去开启或者说确认访问的寄存器是64位的。
●  问题2：而要访问的内存操作数寄存器寻址的话，那么也必须要去开启或确认寄存器是64位的以及访问新增寄存的问题。
●  问题3：如何去访问新增加的几个寄存器呢？那么也必须要有方法去访问增加的寄存器？
</code>
  那么在64位Long模式下，为什么不将操作数的Default Operand-Size设计为64位呢？那是由于体系限制，本来AMD64就是在 x86的基础上扩展为64位的。x86体系当初设计时就没想到有会被扩展到64位的时候。所以在Segment-Descriptor（段描述符）里就没 有可以扩展为64位的标志位。DS.D位只有置1时是32位，清0时为16位，这两种情况。</p>

<p>  AMD在保持兼容的大提前下，只好令谋计策，AMD的解决方案是：增加一个64位模式下特有Prefix，以起到扩展访问64位的能力。这就是 REX prefix。</p>

<h5>1、REX prefix 的具体格式及含义</h5>

<p>  REX prefix的取值范围是：40 ~ 4F（0100 0000 ~ 0100 1111），来看下原来opcode取值范围的40 ~ 4F的是什么指令：<br/>
  Opcode为40 ~ 47在x86下是inc eax ~ inc edi　指令，48 ~ 4F在x86下是dec eax ~ dec edi　指令。<br/>
  在64位模式下，40 ~ 4F 就已经不是指令而变身为 prefix了。</p>

<h6>1.1  REX prefix字节的组成部分：</h6>

<pre><code>●  bit0：REX.B
●  bit1：REX.X
●  bit2：REX.R
●  bit3：REX.W
●  bit4 ~ bit7：此域固定为0100，也就是高半字节为4。
</code></pre>

<p>★  REX.W域是设定操作数的大小（Operand-Size），当REX.W为1时，操作数是64位，为0时，操作数的大小是缺省大小（Default Opeand-Size）。这就解决了访问64位寄存器的问题。</p>

<p>★  REX.R域是用于扩展ModRM字节中的R（Reg）域，ModRM中的Reg域除了对Opcode的补充外，是用来定义寄存器的编码，即寄存器 值。REX.R将原来3位的寄存器ID（000 ~ 111）扩展为4位（0000 ~ 1111），这就解决了访新增寄存器的问题。</p>

<p>★  REX.X域是用于扩展SIB字节中的Index域，SIB中的Index域是指明Index 寄存器的编码，即ID值。这就解决了寄存器寻址内存中使用新增寄存器的问题。</p>

<p>★  REX.B域是用于扩展ModRM字节中的r/m域和SIB中的Base域，SIB中的Base域指明Base寄存器编码即ID值。这就解决了寄存器寻址内存中使用新增寄存器的问题。</p>

<p>★  REX.B域的另一个作用是：若指令中没有ModRM和SIB，也就是在Opcode中直接给出寄存器ID值，REX.B起到扩展寄存器的作用。</p>

<h6>1.2、下面使用几个例子来说明问题：</h6>

<p>例1：指令 mov eax, 1　　
这条指令的Default Operand-Size是32位，在32位下它的机器编码是：b8 01 00 00 00（其5个字节）若改成64位编码时，变成 mov rax, 1。<br/>
　　此时，它的机器编码是 48 b8 01 00 00 00 00 00 00 00 （共10个字节）<br/>
  在这里48 就是 REX prefix字节，即：0100 1000　它的各个域值是：REX.W = 1，定义操作数是64位的，REX.R = 0、REX.X = 0、 REX.B = 0　这条指令不需要ModRM和SIB字节，所以RXB域都为0。<br/>
　　这里有个值得思考的地方，若 REX.W域为0时，这条指令的操作数是32位的，也就是说，机器编码：40 b8 01 00 00 00（其6个字节）是与 b8 01 00 00 00结果一样的，都是mov eax, 1</p>

<p>例2：指令：mov rax, r14<br/>
　　这是一条常见64位指令，源寄存器是r14，目标寄存器是rax 它的机器编码是：<br/>
　　　4c 89 f0（共3个字节）<br/>
在这个编码里4c是REX prefix，89是opcode，f0是ModRM。<br/>
REX Prefix的值是4c （0100 1100），其中REX.W = 1，REX.R = 1，XB都为0。<br/>
ModRM的值是F0（11-110-000），Mod=11，Reg=110, R/M = 000，在这里先不讲ModRM的含义，在后面的章节再详述。在这条指令里，Reg表示源操作数r14的ID值。<br/>
r14是新增加寄存器，所以需要REX.R进行扩展，得出最终寄存器的ID值，1+110 = 1110，这是r14寄存器的ID值，从而得出正确的编码。</p>

<p>例3：回到序言里的例子：mov word ptr es:[eax + ecx * 8 + 0x11223344], 0x12345678<br/>
作为例子，我将它改为64位指令，如下：<br/>
mov qword ptr [rax + rcx * 8 + 0x11223344], 0x12345678<br/>
操作数大小变为64位，而base 寄存器和index寄存器都改为64位，disp（offset）和imme（值不变），为啥不变？在以后的章节会有详述。</p>

<p>好，现在来看看指令怎么译：<br/>
<code>
(1)  REX.W：　要置为 1 以扩展64位大小。
(2)  REX.B：  由于base不是新增的寄存器，所以置为 0
(3)  REX.X：　由于index 也不是新增的寄存器，所以置为 0
(4)  REX.R：　源操作数和目标作数不是寄存器，所以置为 0
</code></p>

<p>所以，REX prefix就等于 48（0100 1000）<br/>
故，整条指令编码是：48 c7 84 c8 44 33 22 11 78 56 34 12（共12个字节）</p>

<p>例4：我将上面的例子再改一改，变为：mov qword ptr [r8 + r9 * 8 + 0x11223344], 0x12345678<br/>
那么，看看这指令怎么译：
<code>
（1）  REX.W：置1，使用64位大小
（2）  REX.B：base寄存器是r8，是新增寄存器，所以置为1
（3）  REX.X：index寄存器是r9，是新增寄存器，所以置为1
（4）  REX.R：操作数中没有寄存器，所在置为0
</code>
所以，REX　prefix就等于（0100 1011）4b<br/>
故，整条指令编码是：4b c7 84 c8 44 33 22 11 78 56 34 12（共12个字节）</p>

<p>例5：看看这条指令 mov r8, 1
<code>
（1）  REX.W：置1
（2）  REX.B：访问Opcode中的寄存器ID值，它是新增寄存器，所为置1
（3）  REX.X：置0
（4）  REX.R：置0
</code>
所以，REX是 49（0100 1001）<br/>
故整条指令编码是：49 b8 01 00 00 00 00 00 00 00</p>

<h5>2、REX prefix补充说明</h5>

<p>（1）关于顺序：REX一定是在x86 prefix之后，而在Opcode之前。<br/>
（2）关于冲突：当x86 prefix和 REX prefix同时出现，而又出现冲突时，REX的优先权要优于 x86 prefix，<br/>
  举个例子：指令 mov r8, 1<br/>
  若出现以下编码怎么办：66 49 b8 01 00 00 00 00 00 00 00　既有66 又有49，那么结果66会被忽略，也就等于：49 b8 01 00 00 00 00 00 00 00。<br/>
  而对于 66 b8 01 00 00 00 00 00 00 00　这个编码来说：会被解析为：mov ax, 1<br/>
  去掉了49这个REX prefix操作数被调整为 16　位。<br/>
（3）关于原来Opcode码，由于40 ~ 4F被作为 REX prefix，那么原指令inc reg/dec reg，只能使用 FF/0　和 FF/1　这两个Opcode了。<br/>
（4）缺省操作数大小（Default Operand-Size）<br/>
  64位绝大部分缺省操作数是32位的，但有一部分是64位的，依赖于rsp的寻址和短跳转（near jmp/near call）是64位的。<br/>
  如下指令：push r8<br/>
  REX值是41（0100 0001），即REX.W为0，使用default opearnd-size<br/>
  它的编码是 41 ff f0</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[freeBSD9.2 安装 && 允许root用户用SSH登录]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/11/21/freebsd/"/>
    <updated>2013-11-21T16:15:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/11/21/freebsd</id>
    <content type="html"><![CDATA[<h4>一</h4>

<p><a href="http://forums.freebsd.org/showthread.php?t=36579">http://forums.freebsd.org/showthread.php?t=36579</a></p>

<p>Issue:<br/>
Here is the error message that I&rsquo;ve got:
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Code:&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;cd0 at umass-sim0 bus 0 scbus3 target 0 lun 0
</span><span class='line'>cd0: &lt;ASUS SDRW-08D2S-U B302&gt; Removable CD-ROM SCSI-0 device
</span><span class='line'>cd0: 40.000MB/s transfers
</span><span class='line'>cd0: cd present [1166275 x 2048 byte records]Mounting from cd9660:/dev/iso9660/FREEBSD_INSTALL failed with error 19.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Loader variables:
</span><span class='line'>    vfs.root.mountfrom=cd9660:/dev/iso9660/FREEBSD_INSTALL
</span><span class='line'>    vfs.root.mountfrom.option=ro&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Manual root filesystem specification:
</span><span class='line'>    &lt;fstype&gt;:&lt;device&gt; [option]
</span><span class='line'>        Mount &lt;device&gt; using filesystem &lt;fstype&gt;
</span><span class='line'>        and with the specified (optional) option list.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;eg. ufs:/dev/da0s1a
</span><span class='line'>    zf:tank
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;The system seems to recognize the DVD drive but is unable to mount the media correctly.
</span><span class='line'>
</span><span class='line'>You need to get a boot prompt and disable ACPI support before booting:  
</span><span class='line'>这两句好像没效果  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;h1&gt;set debug.acpi.disabled =&ldquo;hostres&rdquo;&lt;/h1&gt;
</span><span class='line'>
</span><span class='line'>&lt;h1&gt;boot&lt;/h1&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;The solution is actually in the FreeBSD 9 errata (section 3)  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;mountroot&gt; cd9660:/dev/cd0  用这句通过
</span><span class='line'>&lt;code&gt;
</span><span class='line'>这句不只道可不可以：
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>mountroot&gt; cd9660:/iso9660/FREEBSD_INSTALL</span></code></pre></td></tr></table></div></figure></p>

<h4>二 FreeBSD 允许root用户用SSH登录</h4>

<p>修改freebsd可以用sshd权限用户登录ssh<br/>
在/etc/ssh/sshd_config最后中加入<br/>
<code>
PermitRootLogin yes #允许root登录
PermitEmptyPasswords no #不允许空密码登录
PasswordAuthentication yes # 设置是否使用口令验证。
</code></p>

<hr />

<p>FreeBSD SSH配置详解
首先vi编辑/etc/inetd.conf,去掉ssh前的#，保存退出 (开启监听ssh服务)<br/>
编辑/etc/rc.conf<br/>
最后加入:sshd_enable=&ldquo;yes"即可</p>

<p>激活sshd服务：<br/>
    #/etc/rc.d/sshd start</p>

<p>用下面命令检查服务是否启动，在22端口应该有监听。<br/>
    #netstat -an ## check port number 22<br/>
最后<br/>
vi /etc/ssh/sshd_config
<code>
...
Subsystem sftp /usr/libexec/sftp-server
IgnoreRhosts yes
IgnoreUserKnownHosts yes
PrintMotd yes
StrictModes no
RSAAuthentication yes
PermitRootLogin yes #允许root登录
PermitEmptyPasswords no #不允许空密码登录
PasswordAuthentication yes # 设置是否使用口令验证。
</code></p>

<hr />

<p>记得修改完配置文件后，重新启动sshd服务器(/etc/rc.d/sshd restart)即可。<br/>
几点补充说明<br/>
<code>
1,如果重启后还是不行请重新载入sshd_config 文件
/etc/rc.d/sshd reload
2,如果出现using keyboard-interactive authentication
password:
请确认PasswordAuthentication是否已经改成yes
另外如果客户端是putty那么请确认"尝试'智能键盘'认证（SSH-2）"的勾是否有去掉
3,如果是使用root帐号登陆
请确认密码是否为空
空密码无法登陆
4请确认是否有安装SSH
sysinstall&gt;&gt;&gt;configure&gt;&gt;&gt;networking&gt;&gt;&gt;sshd是否的勾是否有打上
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[binutils(含as、ld等)静态编译]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/10/31/compiler-binutil-static/"/>
    <updated>2013-10-31T14:47:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/10/31/compiler-binutil-static</id>
    <content type="html"><![CDATA[<h4>静态编译</h4>

<pre><code>./configure 后加   CFLAGS=-static --enable-static LDFLAGS=-static --disable-shared
./configure 后加   CFLAGS=-static LDFLAGS=-static
</code></pre>

<h4>binutils-2.23.2 中gas、ld静态编译：</h4>

<pre><code>./configure
make
cd gas
make clean
make LDFLAGS=-all-static
</code></pre>

<p>或者
<code>
./configure
vim gas/Makefile
     搜 --mode=link，找到 LINK = $(LIBTOOL) --tag=CC ...
     在CC后面加个参数 -all-static
make
</code></p>

<h5>原因：</h5>

<p>他们链接的时候是通过 ./libtool 完成的，在libtool里有一行提示（./libtool &ndash;help没有显示这个提示)：
<code>
-all-static       do not do any dynamic linking at all
</code>
所以就是要libtool增加-all-static参数</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[--prefix]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/10/23/compiler-makefile-prefix/"/>
    <updated>2013-10-23T10:49:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/10/23/compiler-makefile-prefix</id>
    <content type="html"><![CDATA[<p>以安装supersparrow-0.0.0为例，我们打算把他安装到目录 /usr/local/supersparrow,于是在supersparrow-0.0.0目录执行带选项的脚本
<code>
./configure –prefix=/usr/local/supersparrow
</code>
执行成功后再编译、安装（make，make install）；安装完成将自动生成目录supersparrow,而且该软件任何的文档都被复制到这个目录。为什么要指定这个安装目录？是为了以后的维护方便，假如没有用这个选项，安装过程结束后，该软件所需的软件被复制到不同的系统目录下，很难弄清楚到底复制了那些文档、都复制到哪里去了—基本上是一塌糊涂。</p>

<p>用了—prefix选项的另一个好处是卸载软件或移植软件。当某个安装的软件不再需要时，只须简单的删除该安装目录，就能够把软件卸载得干干净净；移植软件只需拷贝整个目录到另外一个机器即可（相同的操作系统，不同系统用&ndash;target XXX）。</p>

<p>一个小选项有这么方便的作用，建议在实际工作中多多使用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LD_PRELOAD环境变量]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/10/22/tools-LD_PRELOAD/"/>
    <updated>2013-10-22T16:08:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/10/22/tools-LD_PRELOAD</id>
    <content type="html"><![CDATA[<p>在Linux的动态链接库的世界中，LD_PRELOAD就是这样一个环境变量，它可以影响程序的运行时的链接（Runtime linker），它允许你定义在程序运行前优先加载的动态链接库。这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。一方面，我们可以以此功能来使用自己的或是更好的函数（无需别人的源码），而另一方面，我们也可以以向别人的程序注入恶意程序，从而达到那不可告人的罪恶的目的。</p>

<p>我们知道，Linux的用的都是glibc，有一个叫libc.so.6的文件，这是几乎所有Linux下命令的动态链接中，其中有标准C的各种函数。对于GCC而言，默认情况下，所编译的程序中对标准C函数的链接，都是通过动态链接方式来链接libc.so.6这个函数库的。</p>

<p>OK。还是让我用一个例子来看一下用LD_PRELOAD来hack别人的程序。</p>

<h5>示例一</h5>

<p>我们写下面一段例程：
<code>
    /* 文件名：verifypasswd.c */
    /* 这是一段判断用户口令的程序，其中使用到了标准C函数strcmp*/
    #include &lt;stdio.h&gt;
    #include &lt;string.h&gt;
    int main(int argc, char **argv)
    {
        char passwd[] = "password";
        if (argc &lt; 2) {
            printf("usage: %s &lt;password&gt;/n", argv[0]);
            return 1;
        }
        if (!strcmp(passwd, argv[1])) {
            printf("Correct Password!/n");
            return 1;
        }
        printf("Invalid Password!/n");
        return 0;
    }
</code>
在上面这段程序中，我们使用了strcmp函数来判断两个字符串是否相等。下面，我们使用一个动态函数库来重载strcmp函数：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/&lt;em&gt; 文件名：hack.c &lt;/em&gt;/
</span><span class='line'>#include &lt;stdio.h&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;#include &lt;string.h&gt;
</span><span class='line'>int strcmp(const char *s1, const char *s2)
</span><span class='line'>{
</span><span class='line'>printf("hack function invoked. s1=&lt;%s&gt; s2=&lt;%s&gt;/n", s1, s2);
</span><span class='line'>/* 永远返回0，表示两个字符串相等 */
</span><span class='line'>return 0;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;编译程序：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;$ gcc -o verifypasswd verifypasswd.c
</span><span class='line'>$ gcc -shared -o hack.so hack.c
</span><span class='line'>&lt;code&gt;
</span><span class='line'>测试一下程序：（得到正确结果）
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>$ ./verifypasswd asdf
</span><span class='line'>Invalid Password!</span></code></pre></td></tr></table></div></figure></p>

<h5>设置LD_PRELOAD变量：</h5>

<p>（使我们重写过的strcmp函数的hack.so成为优先载入链接库）
<code>
$ export LD_PRELOAD="./hack.so"
</code>
再次运行程序：
<code>
$ ./verifypasswd  asdf
hack function invoked. s1=&lt;password&gt; s2=&lt;asdf&gt;
Correct Password!
</code>
我们可以看到，<br/>
1）我们的hack.so中的strcmp被调用了。<br/>
2）主程序中运行结果被影响了。<br/>
如果这是一个系统登录程序，那么这也就意味着我们用任意口令都可以进入系统了。</p>
]]></content>
  </entry>
  
</feed>
