<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 2013 | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/2013/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2014-11-28T00:04:33+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[binutils(含as、ld等)静态编译]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/10/31/compiler-binutil-static/"/>
    <updated>2013-10-31T14:47:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/10/31/compiler-binutil-static</id>
    <content type="html"><![CDATA[<h4>静态编译</h4>

<pre><code>./configure 后加   CFLAGS=-static --enable-static LDFLAGS=-static --disable-shared
./configure 后加   CFLAGS=-static LDFLAGS=-static
</code></pre>

<h4>binutils-2.23.2 中gas、ld静态编译：</h4>

<pre><code>./configure
make
cd gas
make clean
make LDFLAGS=-all-static
</code></pre>

<p>或者
<code>
./configure
vim gas/Makefile
     搜 --mode=link，找到 LINK = $(LIBTOOL) --tag=CC ...
     在CC后面加个参数 -all-static
make
</code></p>

<h5>原因：</h5>

<p>他们链接的时候是通过 ./libtool 完成的，在libtool里有一行提示（./libtool &ndash;help没有显示这个提示)：
<code>
-all-static       do not do any dynamic linking at all
</code>
所以就是要libtool增加-all-static参数</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[--prefix]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/10/23/compiler-makefile-prefix/"/>
    <updated>2013-10-23T10:49:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/10/23/compiler-makefile-prefix</id>
    <content type="html"><![CDATA[<p>以安装supersparrow-0.0.0为例，我们打算把他安装到目录 /usr/local/supersparrow,于是在supersparrow-0.0.0目录执行带选项的脚本
<code>
./configure –prefix=/usr/local/supersparrow
</code>
执行成功后再编译、安装（make，make install）；安装完成将自动生成目录supersparrow,而且该软件任何的文档都被复制到这个目录。为什么要指定这个安装目录？是为了以后的维护方便，假如没有用这个选项，安装过程结束后，该软件所需的软件被复制到不同的系统目录下，很难弄清楚到底复制了那些文档、都复制到哪里去了—基本上是一塌糊涂。</p>

<p>用了—prefix选项的另一个好处是卸载软件或移植软件。当某个安装的软件不再需要时，只须简单的删除该安装目录，就能够把软件卸载得干干净净；移植软件只需拷贝整个目录到另外一个机器即可（相同的操作系统，不同系统用&ndash;target XXX）。</p>

<p>一个小选项有这么方便的作用，建议在实际工作中多多使用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LD_PRELOAD环境变量]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/10/22/tools-LD_PRELOAD/"/>
    <updated>2013-10-22T16:08:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/10/22/tools-LD_PRELOAD</id>
    <content type="html"><![CDATA[<p>在Linux的动态链接库的世界中，LD_PRELOAD就是这样一个环境变量，它可以影响程序的运行时的链接（Runtime linker），它允许你定义在程序运行前优先加载的动态链接库。这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。一方面，我们可以以此功能来使用自己的或是更好的函数（无需别人的源码），而另一方面，我们也可以以向别人的程序注入恶意程序，从而达到那不可告人的罪恶的目的。</p>

<p>我们知道，Linux的用的都是glibc，有一个叫libc.so.6的文件，这是几乎所有Linux下命令的动态链接中，其中有标准C的各种函数。对于GCC而言，默认情况下，所编译的程序中对标准C函数的链接，都是通过动态链接方式来链接libc.so.6这个函数库的。</p>

<p>OK。还是让我用一个例子来看一下用LD_PRELOAD来hack别人的程序。</p>

<h5>示例一</h5>

<p>我们写下面一段例程：
<code>
    /* 文件名：verifypasswd.c */
    /* 这是一段判断用户口令的程序，其中使用到了标准C函数strcmp*/
    #include &lt;stdio.h&gt;
    #include &lt;string.h&gt;
    int main(int argc, char **argv)
    {
        char passwd[] = "password";
        if (argc &lt; 2) {
            printf("usage: %s &lt;password&gt;/n", argv[0]);
            return 1;
        }
        if (!strcmp(passwd, argv[1])) {
            printf("Correct Password!/n");
            return 1;
        }
        printf("Invalid Password!/n");
        return 0;
    }
</code>
在上面这段程序中，我们使用了strcmp函数来判断两个字符串是否相等。下面，我们使用一个动态函数库来重载strcmp函数：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/&lt;em&gt; 文件名：hack.c &lt;/em&gt;/
</span><span class='line'>#include &lt;stdio.h&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;#include &lt;string.h&gt;
</span><span class='line'>int strcmp(const char *s1, const char *s2)
</span><span class='line'>{
</span><span class='line'>printf("hack function invoked. s1=&lt;%s&gt; s2=&lt;%s&gt;/n", s1, s2);
</span><span class='line'>/* 永远返回0，表示两个字符串相等 */
</span><span class='line'>return 0;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;编译程序：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;$ gcc -o verifypasswd verifypasswd.c
</span><span class='line'>$ gcc -shared -o hack.so hack.c
</span><span class='line'>&lt;code&gt;
</span><span class='line'>测试一下程序：（得到正确结果）
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>$ ./verifypasswd asdf
</span><span class='line'>Invalid Password!</span></code></pre></td></tr></table></div></figure></p>

<h5>设置LD_PRELOAD变量：</h5>

<p>（使我们重写过的strcmp函数的hack.so成为优先载入链接库）
<code>
$ export LD_PRELOAD="./hack.so"
</code>
再次运行程序：
<code>
$ ./verifypasswd  asdf
hack function invoked. s1=&lt;password&gt; s2=&lt;asdf&gt;
Correct Password!
</code>
我们可以看到，<br/>
1）我们的hack.so中的strcmp被调用了。<br/>
2）主程序中运行结果被影响了。<br/>
如果这是一个系统登录程序，那么这也就意味着我们用任意口令都可以进入系统了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Thunderbird]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/10/15/tools-thunderbird/"/>
    <updated>2013-10-15T10:10:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/10/15/tools-thunderbird</id>
    <content type="html"><![CDATA[<h4>Mozilla Thunderbird 最小化附加组建</h4>

<p>在工具->附加组建中<br/>
1、搜索minimize，安装firetray<br/>
2、firetray 首选项->邮件->邮件通知类型   选第二个：显示新邮件图示<br/>
不想最小化到托盘： firetray 首选项->视窗   去掉第二个勾选</p>

<h4>Mozilla Thunderbird 导入导出邮件</h4>

<p>一种Mozilla Thunderbird的扩展ImportExportTools。<br/>
<a href="https://addons.mozilla.org/zh-CN/thunderbird/addon/importexporttools/">https://addons.mozilla.org/zh-CN/thunderbird/addon/importexporttools/</a></p>

<h5>安装流程 （本地安装）</h5>

<pre><code>1 进入Mozilla Thunderbird
2 点击菜单栏的“工具”-&gt;“附加软件”
3 从附加组件搜索框旁边的选项按钮中，选择“从文件安装附加组件...”选项
4 选择本地文件（ImportExportTools-X.X.xpi）位置 安装
5 安装完成 重启Mozilla Thunderbird
</code></pre>

<h5>如何用呢</h5>

<pre><code>1 进入Mozilla Thunderbird
2 右键“收件箱”
3 “导入/导出”
4 “汇出此资料夹所以的邮件” 进行选择格式
5 汇出完成 查看本地文件夹
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[git-svn]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/08/29/tools-git-svn-base/"/>
    <updated>2013-08-29T14:37:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/08/29/tools-git-svn-base</id>
    <content type="html"><![CDATA[<h4>常用</h4>

<pre><code>1、git-svn clone your_svn_repository
2、git add/commit
3、git-svn rebase  获取中心svn repository的更新；
4、git-svn dcommit 将本地git库的修改同步到中心svn库。
</code></pre>

<hr />

<p>git-svn默认包含在Git的安装包中，不过在Ubuntu中，git-svn是作为一个独立的Package需要额外安装的(sudo apt-get install git-svn)。安装后你就可以使用git svn xxx命令来操作中心SVN代码库了。当然如果你要使用与git svn等价的git-svn命令的话，你还需要将/usr/lib/git-core配置到你的PATH环境变量中，否则Shell会提示你无法找到 git-svn这个命令。</p>

<ul>
<li><p>检出一个已存在svn repository(类似于svn checkout)<br/>
我们可以通过git-svn clone命令完成这个操作： git-svn clone your_svn_repository_url</p></li>
<li><p>从中心服务器的svn repository获取最新更新<br/>
这个操作可以通过"git-svn rebase"完成。注意这里用的是rebase，而不是update。update命令对于通过git-svn检出的svn repostory的git版本库是不可用的。</p></li>
<li><p>查看提交历史日志<br/>
这个简单，使用"git-svn log"，加上-v选项，还可以提供每次commit操作涉及的相关文件的详细信息。</p></li>
<li><p>将本地代码同步到Svn服务器<br/>
完成这一操作需要通过"git-svn dcommit"命令。这个命令会将你在本地使用git commit提交到本地代码库的所有更改逐一提交到svn库中。加上-n选项，则该命令不会真正执行commit到svn的操作，而是会显示会有哪些本地 变动将被commit到svn服务器。git-svn dcommit似乎不能单独提交某个本地版本的修改，而是一次批量提交所有与svn中心版本库的差异。</p></li>
</ul>


<h5>下面是一个git-svn的一般使用流程：</h5>

<p>1、git-svn clone your_svn_repository；<br/>
2、修改本地代码，使用git add/commit将修改提交到本地git库；<br/>
3、定期使用git-svn rebase获取中心svn repository的更新；<br/>
4、使用git-svn dcommit命令将本地git库的修改同步到中心svn库。</p>

<h5>冲突</h5>

<p>使用git-svn处理代码冲突的步骤有些繁琐，不过瑕不掩瑜吧。这里用一个小例子来说明一下。</p>

<p>假设某svn中心库上的某个项目foo中只有一个源码文件foo.c：<br/>
* 我在使用git-svn clone检出版本时，foo.c当时只有一个commit版本信息："svn v1"；<br/>
* clone出来后，我在本地git库中修改foo.c，并通过git commit提交到本地git库中，版本为"git v1"；<br/>
* 不过与此同时另外一个同事也在修改foo.c这个文件，并已经将他的修改提交到了svn库中，版本为"svn v2"；<br/>
* 此时我使用git-svn dcommit尝试提交我的改动，git-svn提示我：<br/>
  Committing to svn://10.10.1.1:80/foo &hellip;<br/>
  M foo.c<br/>
  事务过时: 过期: ”foo/foo.c“在事务“260-1” at /usr/lib/git-core/git-svn line 570<br/>
* 使用git-svn rebase获取svn服务器上的最新foo.c，导致与foo.c冲突，不过此时svn版本信息已经添加到本地git库中(通过git log可以查看)，git-svn rebase提示你在解决foo.c的冲突后，运行git rebase &ndash;continue完成rebase操作；<br/>
* 打开foo.c，修改代码，解决冲突；<br/>
* 执行git rebase &ndash;continue，git提示我：<br/>
    You must edit all merge conflicts and then<br/>
    mark them as resolved using git add<br/>
* 执行git add foo.c，告知git已完成冲突解决；<br/>
* 再次执行git rebase &ndash;continue，提示"Applying: git v1"，此时"git v1"版本又一次成功加入本地版本库，你可通过git log查看；<br/>
* 执行git-svn dcommit将foo.c的改动同步到svn中心库，到此算是完成一次冲突解决。</p>

<ul>
<li>设置忽略文件<br/>
要忽略某些文件, 需要首先执行如下命令:<br/>
git config &ndash;global core.excludesfile ~/.gitignore<br/>
然后编辑 vi ~/.gitignore.<br/>
例如: 需要忽略vim的临时文件，就写:<br/>
.*.swp</li>
</ul>

]]></content>
  </entry>
  
</feed>
