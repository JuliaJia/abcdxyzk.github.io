<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 2013 | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/2013/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2014-11-26T18:42:02+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[LD_PRELOAD环境变量]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/10/22/tools-LD_PRELOAD/"/>
    <updated>2013-10-22T16:08:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/10/22/tools-LD_PRELOAD</id>
    <content type="html"><![CDATA[<p>在Linux的动态链接库的世界中，LD_PRELOAD就是这样一个环境变量，它可以影响程序的运行时的链接（Runtime linker），它允许你定义在程序运行前优先加载的动态链接库。这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。一方面，我们可以以此功能来使用自己的或是更好的函数（无需别人的源码），而另一方面，我们也可以以向别人的程序注入恶意程序，从而达到那不可告人的罪恶的目的。</p>

<p>我们知道，Linux的用的都是glibc，有一个叫libc.so.6的文件，这是几乎所有Linux下命令的动态链接中，其中有标准C的各种函数。对于GCC而言，默认情况下，所编译的程序中对标准C函数的链接，都是通过动态链接方式来链接libc.so.6这个函数库的。</p>

<p>OK。还是让我用一个例子来看一下用LD_PRELOAD来hack别人的程序。</p>

<h5>示例一</h5>

<p>我们写下面一段例程：
<code>
    /* 文件名：verifypasswd.c */
    /* 这是一段判断用户口令的程序，其中使用到了标准C函数strcmp*/
    #include &lt;stdio.h&gt;
    #include &lt;string.h&gt;
    int main(int argc, char **argv)
    {
        char passwd[] = "password";
        if (argc &lt; 2) {
            printf("usage: %s &lt;password&gt;/n", argv[0]);
            return 1;
        }
        if (!strcmp(passwd, argv[1])) {
            printf("Correct Password!/n");
            return 1;
        }
        printf("Invalid Password!/n");
        return 0;
    }
</code>
在上面这段程序中，我们使用了strcmp函数来判断两个字符串是否相等。下面，我们使用一个动态函数库来重载strcmp函数：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/&lt;em&gt; 文件名：hack.c &lt;/em&gt;/
</span><span class='line'>#include &lt;stdio.h&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;#include &lt;string.h&gt;
</span><span class='line'>int strcmp(const char *s1, const char *s2)
</span><span class='line'>{
</span><span class='line'>printf("hack function invoked. s1=&lt;%s&gt; s2=&lt;%s&gt;/n", s1, s2);
</span><span class='line'>/* 永远返回0，表示两个字符串相等 */
</span><span class='line'>return 0;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;编译程序：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;$ gcc -o verifypasswd verifypasswd.c
</span><span class='line'>$ gcc -shared -o hack.so hack.c
</span><span class='line'>&lt;code&gt;
</span><span class='line'>测试一下程序：（得到正确结果）
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>$ ./verifypasswd asdf
</span><span class='line'>Invalid Password!</span></code></pre></td></tr></table></div></figure></p>

<h5>设置LD_PRELOAD变量：</h5>

<p>（使我们重写过的strcmp函数的hack.so成为优先载入链接库）
<code>
$ export LD_PRELOAD="./hack.so"
</code>
再次运行程序：
<code>
$ ./verifypasswd  asdf
hack function invoked. s1=&lt;password&gt; s2=&lt;asdf&gt;
Correct Password!
</code>
我们可以看到，<br/>
1）我们的hack.so中的strcmp被调用了。<br/>
2）主程序中运行结果被影响了。<br/>
如果这是一个系统登录程序，那么这也就意味着我们用任意口令都可以进入系统了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Thunderbird]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/10/15/tools-thunderbird/"/>
    <updated>2013-10-15T10:10:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/10/15/tools-thunderbird</id>
    <content type="html"><![CDATA[<h4>Mozilla Thunderbird 最小化附加组建</h4>

<p>在工具->附加组建中<br/>
1、搜索minimize，安装firetray<br/>
2、firetray 首选项->邮件->邮件通知类型   选第二个：显示新邮件图示<br/>
不想最小化到托盘： firetray 首选项->视窗   去掉第二个勾选</p>

<h4>Mozilla Thunderbird 导入导出邮件</h4>

<p>一种Mozilla Thunderbird的扩展ImportExportTools。<br/>
<a href="https://addons.mozilla.org/zh-CN/thunderbird/addon/importexporttools/">https://addons.mozilla.org/zh-CN/thunderbird/addon/importexporttools/</a></p>

<h5>安装流程 （本地安装）</h5>

<pre><code>1 进入Mozilla Thunderbird
2 点击菜单栏的“工具”-&gt;“附加软件”
3 从附加组件搜索框旁边的选项按钮中，选择“从文件安装附加组件...”选项
4 选择本地文件（ImportExportTools-X.X.xpi）位置 安装
5 安装完成 重启Mozilla Thunderbird
</code></pre>

<h5>如何用呢</h5>

<pre><code>1 进入Mozilla Thunderbird
2 右键“收件箱”
3 “导入/导出”
4 “汇出此资料夹所以的邮件” 进行选择格式
5 汇出完成 查看本地文件夹
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[git-svn]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/08/29/tools-git-svn-base/"/>
    <updated>2013-08-29T14:37:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/08/29/tools-git-svn-base</id>
    <content type="html"><![CDATA[<h4>常用</h4>

<pre><code>1、git-svn clone your_svn_repository
2、git add/commit
3、git-svn rebase  获取中心svn repository的更新；
4、git-svn dcommit 将本地git库的修改同步到中心svn库。
</code></pre>

<hr />

<p>git-svn默认包含在Git的安装包中，不过在Ubuntu中，git-svn是作为一个独立的Package需要额外安装的(sudo apt-get install git-svn)。安装后你就可以使用git svn xxx命令来操作中心SVN代码库了。当然如果你要使用与git svn等价的git-svn命令的话，你还需要将/usr/lib/git-core配置到你的PATH环境变量中，否则Shell会提示你无法找到 git-svn这个命令。</p>

<ul>
<li><p>检出一个已存在svn repository(类似于svn checkout)<br/>
我们可以通过git-svn clone命令完成这个操作： git-svn clone your_svn_repository_url</p></li>
<li><p>从中心服务器的svn repository获取最新更新<br/>
这个操作可以通过"git-svn rebase"完成。注意这里用的是rebase，而不是update。update命令对于通过git-svn检出的svn repostory的git版本库是不可用的。</p></li>
<li><p>查看提交历史日志<br/>
这个简单，使用"git-svn log"，加上-v选项，还可以提供每次commit操作涉及的相关文件的详细信息。</p></li>
<li><p>将本地代码同步到Svn服务器<br/>
完成这一操作需要通过"git-svn dcommit"命令。这个命令会将你在本地使用git commit提交到本地代码库的所有更改逐一提交到svn库中。加上-n选项，则该命令不会真正执行commit到svn的操作，而是会显示会有哪些本地 变动将被commit到svn服务器。git-svn dcommit似乎不能单独提交某个本地版本的修改，而是一次批量提交所有与svn中心版本库的差异。</p></li>
</ul>


<h5>下面是一个git-svn的一般使用流程：</h5>

<p>1、git-svn clone your_svn_repository；<br/>
2、修改本地代码，使用git add/commit将修改提交到本地git库；<br/>
3、定期使用git-svn rebase获取中心svn repository的更新；<br/>
4、使用git-svn dcommit命令将本地git库的修改同步到中心svn库。</p>

<h5>冲突</h5>

<p>使用git-svn处理代码冲突的步骤有些繁琐，不过瑕不掩瑜吧。这里用一个小例子来说明一下。</p>

<p>假设某svn中心库上的某个项目foo中只有一个源码文件foo.c：<br/>
* 我在使用git-svn clone检出版本时，foo.c当时只有一个commit版本信息："svn v1"；<br/>
* clone出来后，我在本地git库中修改foo.c，并通过git commit提交到本地git库中，版本为"git v1"；<br/>
* 不过与此同时另外一个同事也在修改foo.c这个文件，并已经将他的修改提交到了svn库中，版本为"svn v2"；<br/>
* 此时我使用git-svn dcommit尝试提交我的改动，git-svn提示我：<br/>
  Committing to svn://10.10.1.1:80/foo &hellip;<br/>
  M foo.c<br/>
  事务过时: 过期: ”foo/foo.c“在事务“260-1” at /usr/lib/git-core/git-svn line 570<br/>
* 使用git-svn rebase获取svn服务器上的最新foo.c，导致与foo.c冲突，不过此时svn版本信息已经添加到本地git库中(通过git log可以查看)，git-svn rebase提示你在解决foo.c的冲突后，运行git rebase &ndash;continue完成rebase操作；<br/>
* 打开foo.c，修改代码，解决冲突；<br/>
* 执行git rebase &ndash;continue，git提示我：<br/>
    You must edit all merge conflicts and then<br/>
    mark them as resolved using git add<br/>
* 执行git add foo.c，告知git已完成冲突解决；<br/>
* 再次执行git rebase &ndash;continue，提示"Applying: git v1"，此时"git v1"版本又一次成功加入本地版本库，你可通过git log查看；<br/>
* 执行git-svn dcommit将foo.c的改动同步到svn中心库，到此算是完成一次冲突解决。</p>

<ul>
<li>设置忽略文件<br/>
要忽略某些文件, 需要首先执行如下命令:<br/>
git config &ndash;global core.excludesfile ~/.gitignore<br/>
然后编辑 vi ~/.gitignore.<br/>
例如: 需要忽略vim的临时文件，就写:<br/>
.*.swp</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[字节序和比特序]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/06/20/lang-c-B_b_byte/"/>
    <updated>2013-06-20T18:23:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/06/20/lang-c-B_b_byte</id>
    <content type="html"><![CDATA[<p>字节序和比特序，因为比特序对所有代码（包括汇编）是透明的，所以对于小端系统，有说是用大端比特序，也有说是用小端比特序。<br/>
下面是copy一部分觉得靠谱的内容：<br/>
大小端
我们对"endianness"这个名词估计都很熟悉了。它首先被Danny Cohen于1980引入，用来表述计算机系统表示多字节整数的方式。
endianness分为两种：大端和小端。(从字节序的角度来看)大端方式是将整数中最高位byte存放在最低地址中。而小端方式则相反，将整数中的最高位byte存放在最高地址中。
对于某个确定的计算机系统，比特序通常与字节序保持一致。换言之，在大端系统中，每个byte中最高位bit存放在内存最低位；在小端系统中，最低位bit存放在内存最低位。
正如大部分人是按照从左至右的顺序书写数字，一个多字节整数的内存布局也应该遵循同样的方式，即从左至右为数值的最高位至最低位。正如我们在下面的例子中所看到的，这是书写整数最清晰的方式。</p>

<p>根据上述规则，我们按以下方式分别在大端和小端系统中值为0x0a0b0c0d的整数。
在大端系统中书写整数：
byte  addr  0   1   2   3
bit offset  01234567 01234567 01234567 01234567</p>

<pre><code>binary  00001010 00001011 00001100 00001101
  hex      0a       0b       0c       0d
</code></pre>

<p>在小端系统中书写整数(认真看)
byte  addr  0   1   2   3
bit offset  01234567 01234567 01234567 01234567</p>

<pre><code>binary  10110000 00110000 11010000 01010000
  hex      d0       c0       b0       a0
</code></pre>

<p>说明字节序：
<code>
    #include &lt;stdio.h&gt;  
    int main (void)  
    {  
        union b  
        {  
            short k;  //测试环境short占2字节  
            char i[2];  //测试环境char占1字节  
        }*s,a;  
        s=&amp;a;  
        s-&gt;i[0]=0x41;  
        s-&gt;i[1]=0x52;  
        printf("%x\n",s-&gt;k);  
        return 0;  
    }
</code>
输出：5241</p>

<hr />

<p>self code:
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>union W
</span><span class='line'>{
</span><span class='line'>    struct Y
</span><span class='line'>    {
</span><span class='line'>        unsigned int s1:4;
</span><span class='line'>        unsigned int s2:8;
</span><span class='line'>        unsigned int s3:20;
</span><span class='line'>    } y;
</span><span class='line'>    unsigned int c;
</span><span class='line'>} w;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;union V 
</span><span class='line'>{
</span><span class='line'>struct X
</span><span class='line'>{
</span><span class='line'>    unsigned char s1:3;
</span><span class='line'>    unsigned char s2:3;
</span><span class='line'>    unsigned char s3:2;
</span><span class='line'>} x;
</span><span class='line'>unsigned char c;
</span><span class='line'>} v;
</span><span class='line'>
</span><span class='line'>int main()
</span><span class='line'>{
</span><span class='line'>w.c = 0x12345678;
</span><span class='line'>printf("%x %x %x %x\n", w.c, w.y.s1, w.y.s2, w.y.s3); 
</span><span class='line'>
</span><span class='line'>v.c = 100;
</span><span class='line'>printf("%d %x %x %x\n", v.c, v.x.s1, v.x.s2, v.x.s3); 
</span><span class='line'>return 0;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;输出：&lt;br/&gt;
</span><span class='line'>12345678 8 67 12345&lt;br/&gt;
</span><span class='line'>100 4 4 1&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;100 = （01100100）2&lt;br/&gt;
</span><span class='line'>因为字节序是小端的所以第一行输出说明：位域变量从左到右分配位，所以第二行的输出的位域变量也应该从左到右分配位。所以&lt;br/&gt;
</span><span class='line'>100 = 001 001 10  （小端比特序二进制）&lt;br/&gt;
</span><span class='line'>对应:  s1  s2  s3  （位域变量从左到右分配位）&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;符合。&lt;/p&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[内核编译模块]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2013/06/06/kernel-mod-compiler/"/&gt;
</span><span class='line'>&lt;updated&gt;2013-06-06T14:28:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2013/06/06/kernel-mod-compiler&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;pre&gt;&lt;code&gt;    /*filename: test.c*/
</span><span class='line'>#include &lt;linux/init.h&gt;
</span><span class='line'>#include &lt;linux/kernel.h&gt;
</span><span class='line'>#include &lt;linux/module.h&gt;
</span><span class='line'>
</span><span class='line'>staticintdummy_init(void)
</span><span class='line'>{
</span><span class='line'>    printk("hello,world.\n");
</span><span class='line'>    return0;
</span><span class='line'>}
</span><span class='line'>staticvoiddummy_exit(void)
</span><span class='line'>{
</span><span class='line'>    return;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>module_init(dummy_init);
</span><span class='line'>module_exit(dummy_exit);
</span><span class='line'>
</span><span class='line'>MODULE_LICENSE("GPL")
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;执行如下命令：
</span><span class='line'>&lt;code&gt;
</span><span class='line'>$ gcc -c -O2 -DMODULE -D__KERNEL__ -I/usr/src/linux test.c
</span><span class='line'>$ insmod test.o
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>No module found in object&lt;br/&gt;
</span><span class='line'>insmod: error inserting &lsquo;test.o&rsquo;: -1 Invalid module format&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;正确的做法是写一个Makefile,由内核的Kbuild来帮你编译。&lt;br/&gt;
</span><span class='line'>&lt;code&gt;
</span><span class='line'>$ cat Makefile
</span><span class='line'>obj-m :=test.o
</span><span class='line'>KDIR :=/lib/modules/$(shell uname -r)/build
</span><span class='line'>PWD :=$(shell pwd)
</span><span class='line'>default:
</span><span class='line'>    $(MAKE)-C $(KDIR)SUBDIRS=$(PWD)modules
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>执行如下命令：
</span><span class='line'>&lt;code&gt;
</span><span class='line'>$make
</span><span class='line'>make -C /lib/modules/2.6.5-1.358/build SUBDIRS=/test modules
</span><span class='line'>make[1]:Entering directory `/lib/modules/2.6.5-1.358/build'
</span><span class='line'>  CC [M]  /test/modinject/test.o
</span><span class='line'>  Building modules, stage 2.
</span><span class='line'>  MODPOST
</span><span class='line'>  CC      /test/modinject/test.mod.o
</span><span class='line'>  LD [M]  /test/modinject/test.ko
</span><span class='line'>make[1]: Leaving directory `/lib/modules/2.6.5-1.358/build'
</span><span class='line'>$ls -l
</span><span class='line'>-rw-r--r--1 root root   268 Jan  7 08:31 test.c
</span><span class='line'>-rw-r--r--1 root root  2483 Jan  8 09:19 test.ko
</span><span class='line'>-rw-r--r--1 root root   691 Jan  8 09:19 test.mod.c
</span><span class='line'>-rw-r--r--1 root root  1964 Jan  8 09:19 test.mod.o
</span><span class='line'>-rw-r--r--1 root root  1064 Jan  8 09:19 test.o
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>其实上边的test.o就是用gcc生成的test.o,而test.ko是使用下列命令来生成的。
</span><span class='line'>&lt;code&gt;
</span><span class='line'>$ld -m elf_i386  -r -o test.ko test.o  test.mod.o
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;再来看看test.mod.c，它是由/usr/src/linux/scripts/modpost.c来生成的。</span></code></pre></td></tr></table></div></figure>
    $ cat test.mod.c
    #include &lt;linux/module.h>
    #include &lt;linux/vermagic.h>
    #include &lt;linux/compiler.h></p>

<pre><code>MODULE_INFO(vermagic,VERMAGIC_STRING);
#undef unix

struct module __this_module
__attribute__((section(".gnu.linkonce.this_module")))={
.name =__stringify(KBUILD_MODNAME),
.init =init_module,
#ifdef CONFIG_MODULE_UNLOAD

.exit=cleanup_module,
#endif

};
static const struct modversion_info ____versions[]
__attribute_used__
__attribute__((section("__versions")))={
    {0,"cleanup_module"},
    {0,"init_module"},
    {0,"struct_module"},
    {0,"printk"},
};
static const char __module_depends[]
__attribute_used__
__attribute__((section(".modinfo")))=
"depends=";
</code></pre>

<p>```
可见，test.mod.o只是产生了几个ELF的节，分别是modinfo,  .gun.linkonce.this_module(用于重定位，引进了rel.gnu.linkonce.this_module),  __versions。而test.ko是test.o和test.mod.o合并的结果。</p>
]]></content>
  </entry>
  
</feed>
