<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 2014~04 | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/2014~04/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2014-12-11T01:25:43+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[x86—EFLAGS寄存器详解]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/05/06/assembly-x86-falgs/"/>
    <updated>2014-05-06T14:33:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/05/06/assembly-x86-falgs</id>
    <content type="html"><![CDATA[<p>  鉴于EFLAGS寄存器的重要性，所以将这一部分内容从处理器体系结构及寻址模式一文中单独抽出另成一文，这部分内容主要来自Intel Developer Mannual，在后续的内核系列中遇到的许多和EFLAGS寄存器有关的内容将直接从本文引用。众所周知，IA-32体系结构为通用系统(general system)提供了16个基本的程序执行寄存器：包含一些通用目的寄存器(General-purpose registers)、段寄存器(Segment registers)以及EFLAGS和EIP寄存器，而后两者对于程序的执行来说可谓至关重要。</p>

<p>  其中EIP寄存器主要用于存放当前代码段即将被执行的下一条指令的偏移，但其本质上并 不能直接被指令直接访问。 【it is controlled implicitly by control-transfer instructions (such as JMP, Jcc, CALL, and RET), interrupts, and exceptions.】 很显然，这个寄存器指令由控制转移指令、中断及异常所控制。 【The only way to read the EIP register is to execute a CALL instruction and then read the value of the return instruction pointer from the procedure stack.The EIP register can be loaded indirectly by modifying the value of a return instruction pointer on the procedure stack and executing a return instruction (RET or IRET)】  这里也已经说的很清楚了，读操作通过执行call指令并取得栈中所存放的地址来实现，而写操作则通过修改程序栈中的返回指令指针并执行RET/IRET指 令来完成，因此尽管这个寄存器相当重要，但其实并不是操作系统在实现过程中所需关注的焦点。</p>

<p>  相对来讲，EFLAGS寄存器对于操作系统则重要得多。EFLAGS(program status and control) register主要用于提供程序的状态及进行相应的控制， 【The EFLGAS register report on the status of the program being executed and allows limited(application-program level) control of the process.】 在64-bit模式下，EFLGAS寄存器被扩展为64位的RFLGAS寄存器，高32位被保留，而低32位则与EFLAGS寄存器相同。</p>

<p>  32位的EFLAGS寄存器包含一组状态标志、系统标志以及一个控制标志。在x86处理器初始化之后，EFLAGS寄存器的状态值为0000 0002H。 第1、3、5、15以及22到31位均被保留，这个寄存器中的有些标志通过使用特殊的通用指令可以直接被修改，但并没有指令能够检查或者修改整个寄存器。 通过使用LAHF/SAHF/PUSHF/POPF/POPFD等指令，可以将EFLAGS寄存器的标志位成组移到程序栈或EAX寄存器，或者从这些设施 中将操作后的结果保存到EFLAGS寄存器中。在EFLAGS寄存器的内容被传送到栈或是EAX寄存器后，可以通过位操作指令(BT, BTS, BTR, BTC)检查或修改这些标志位。当调用中断或异常处理程序时，处理器将在程序栈上自动保存EFLAGS的状态值。若 在中断或异常处理时发生任务切换，那么EFLAGS寄存器的状态将被保存在TSS中 【the state of the EFLAGS register is saved in the TSS for the task being suspended.】 ，注意是将要被挂起的本次任务的状态。</p>

<p><img src="/images/assembly/2014-05-06.jpg" alt="" /></p>

<h5>1、状态标志(Status Flags)</h5>

<p>EFLAGS寄存器的状态标志(0、2、4、6、7以及11位)指示算术指令（如ADD, SUB, MUL以及DIV指令）的结果，这些状态标志的作用如下：
<code>
    CF(bit 0) [Carry flag]   若算术操作产生的结果在最高有效位(most-significant bit)发生进位或借位则将其置1，反之清零。这个标志指示无符号整型运算的溢出状态，这个标志同样在多倍精度运算(multiple-precision arithmetic)中使用。
    PF(bit 2) [Parity flag]   如果结果的最低有效字节(least-significant byte)包含偶数个1位则该位置1，否则清零。
    AF(bit 4) [Adjust flag]   如果算术操作在结果的第3位发生进位或借位则将该标志置1，否则清零。这个标志在BCD(binary-code decimal)算术运算中被使用。
    ZF(bit 6) [Zero flag]   若结果为0则将其置1，反之清零。
    SF(bit 7) [Sign flag]   该标志被设置为有符号整型的最高有效位。(0指示结果为正，反之则为负)
    OF(bit 11) [Overflow flag]   如果整型结果是较大的正数或较小的负数，并且无法匹配目的操作数时将该位置1，反之清零。这个标志为带符号整型运算指示溢出状态。
</code>
在这些状态标志中，只有CF标志能够通过使用STC, CLC以及CMC指令被直接修改，或者通过位指令(BT, BTS, BTR以及BTC)将指定的位拷贝至CF标志中。</p>

<p>这些状态标志允许单个的算术操作产生三种不同数据类型的结果：无符号整型，有符号整型 以及BCD整型。如果把该结果当做无符号整型，那么CF标志指示越界(out-of-range)状态——即进位或借位，如果被当做有符号整型，则OF标 志指示进位或借位，若作为BCD数，那么AF标志指示进位或借位。SF标志指示有符号整数的符号位，ZF指示结果为零。此外在执行多倍精度算术运算时，CF标志用来将一次运算过程中带进位的加法(ADC)或带借位的减法(SBB)产生的进位或借位传递到下一次运算过程中。</p>

<h5>2、DF标志(DF flag)</h5>

<p>这个方向标志(位于EFLAGS寄存器的第10位)控制串指令(MOVS, CMPS, SCAS, LODS以及STOS)。设置DF标志使得串指令自动递减（从高地址向低地址方向处理字符串），清除该标志则使得串指令自动递增。STD以及CLD指令分 别用于设置以及清除DF标志。</p>

<h5>3、系统标志以及IOPL域(System Flags and IOPL Field)</h5>

<p>EFLAGS寄存器中的这部分标志用于控制操作系统或是执行操作，它们不允许被应用程序所修改。这些标志的作用如下：
<code>
    TF(bit 8) [Trap flag]   将该位设置为1以允许单步调试模式，清零则禁用该模式。
    IF(bit 9) [Interrupt enable flag]   该标志用于控制处理器对可屏蔽中断请求(maskable interrupt requests)的响应。置1以响应可屏蔽中断，反之则禁止可屏蔽中断。
    IOPL(bits 12 and 13) [I/O privilege level field]   指示当前运行任务的I/O特权级(I/O privilege level)，正在运行任务的当前特权级(CPL)必须小于或等于I/O特权级才能允许访问I/O地址空间。这个域只能在CPL为0时才能通过POPF以及IRET指令修改。
    NT(bit 14) [Nested task flag]   这个标志控制中断链和被调用任务。若当前任务与前一个执行任务相关则置1，反之则清零。
    RF(bit 16) [Resume flag]   控制处理器对调试异常的响应。
    VM(bit 17) [Virtual-8086 mode flag]   置1以允许虚拟8086模式，清除则返回保护模式。
    AC(bit 18) [Alignment check flag]   该标志以及在CR0寄存器中的AM位置1时将允许内存引用的对齐检查，以上两个标志中至少有一个被清零则禁用对齐检查。
    VIF(bit 19) [Virtual interrupt flag]   该标志是IF标志的虚拟镜像(Virtual image)，与VIP标志结合起来使用。使用这个标志以及VIP标志，并设置CR4控制寄存器中的VME标志就可以允许虚拟模式扩展(virtual mode extensions)
    VIP(bit 20) [Virtual interrupt pending flag]   该位置1以指示一个中断正在被挂起，当没有中断挂起时该位清零。【Software sets and clears this flag; the processor only reads it.】与VIF标志结合使用。
    ID(bit 21) [Identification flag]   程序能够设置或清除这个标志指示了处理器对CPUID指令的支持。
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux内核获取当前进程指针]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/04/30/kernel-mm-current-rbp/"/>
    <updated>2014-04-30T16:10:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/04/30/kernel-mm-current-rbp</id>
    <content type="html"><![CDATA[<h4>一、内存数据表示：</h4>

<p>  我们在教材或阅读中，经常需要直观的用图示来展示数据在内存中的分布，那么数据是如何在内存中组织的呢？不同的机器有不同的表示法，我们以最常见的Intel X86系列计算机为例来说明这个问题。</p>

<p><img src="/images/kernel/20140430-1.jpg" alt="" /></p>

<p>  如上图示内存示意图：内存低址在上。内存高址在下，内存单位为16bit。对于基于intel i386架构的计算机，系统采用小端字节序来存放数据，所谓小端字节序是指低序字节低地址，高序字节高地址(内存地址增大方向)，大端字节序反之，给定系统所用的字节序称为主机字节序；CPU也以小端字节序形式读取数据，如上图所示，如果变量num是16位的short短整类型，则CPU从内存中读出的num=0x1234；如果num是32位的int类型，则CPU从内存中读出的是num=0x56781234,其中num地址是0x12345678，即&amp;num=0x12345678</p>

<h4>二、linux内核获取进程任务结构的指针</h4>

<p>  明白了系统内存数据表示，我们现在来看看linux内核是如何获取当前进程的任务结构指针的，以下代码均参照linux内核2.4.0的源码。<br/>
  在include\asm-i386\ current.h中
<code>
    #ifndef _I386_CURRENT_H
    #define _I386_CURRENT_H
    struct task_struct;
    static inline struct task_struct * get_current(void)
    {
        struct task_struct *current;
        __asm__("andl %%esp,%0; ":"=r" (current) : "0" (~8191UL));
        return current;
    }
    #define current get_current()
    #endif /* !(_I386_CURRENT_H) */
</code>
  每个进程都有一个task_struct任务结构，和一片用于系统空间堆栈的存储空间，他们在物理内存空间中也是联系在一起的，当给进程申请task_struct任务结构空间时，系统将连同系统的堆栈空间一起分配，如下图为某个进程切换时刻的内存图：</p>

<p><img src="/images/kernel/20140430-2.jpg" alt="" /></p>

<p>  下面针对代码实现来分析一下系统如何通过一系列操作获取进程在内核中的任务结构指针的：
  由于linux内核分配进程任务结构空间时，是以8KB(2个页面空间，即2<sup>1</sup>*4KB，linux对物理内存空间和虚拟内存空间管理时，均规定其页面单位的尺寸为4KB)为单位来分配的，所以内存应用地址是8KB(2<sup>13</sup>)的整数倍，即指针地址的低13位全为0，所以根据小端字节序，分配内存返回地址应该是指向struct task_struct结构，如图中的0xc2342000地址所指，至于为何采用代码中的做法而不是直接将此指针保存在全局变量中以供应用，内核是从其自身的效率方面来考虑的，我们在此只针对代码解释：
  根据上图，此刻内存esp内容必定在0xc2342000和0xc2344000之间的一个数值，我们假设取0xc2343ffe(即堆栈压栈EIP、返回地址、内部数据等相关数据了，地址值要减小；只要符合0xc2342xxx 、0xc2343xxx的地址指针都是正确的)，来通过代码运算看是否current的指针是0xc2342000。
<code>
    __asm__("andl %%esp,%0; ":"=r" (current) : "0" (~8191UL));
</code>
语句的意思是将ESP的内容与8191UL的反码按位进行与操作，之后再把结果赋值给current，其中8191UL=8192-1=2<sup>13</sup>-1,计算过程如下：
<code>
    8192UL=2^13 0000 0000 0000 0000 0010 0000 0000 0000
    8191UL 0000 0000 0000 0000 0001 1111 1111 1111
    ~8191UL(反码) 1111 1111 1111 1111 1110 0000 0000 0000
    0xc2343ffe 1100 0010 0011 0100 0011 1111 1111 1110
    andl结果： 1100 0010 0011 0100 0010 0000 0000 0000
    || (对照着看)
    0x c 2 3 4 2 0 0 0
</code>
  所以按位与操作之后的结果位0xc2342000，正好是struct task_struct结构的地址指针.通过观察可知，只要符合0xc2342xxx 、0xc2343xxx的地址指针经过相同的计算，都可以得到内核进程任务结构的指针。<br/>
  另外，在进入中断或系统调用时所引用的宏操作(include\asm-i386\ hw_irq.h):
<code>
    #define GET_CURRENT \
        "movl %esp, %ebx\n\t" \
        "andl $-8192, %ebx\n\t"
</code>
  其原理与上述描述也是一致的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux内存分配]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/04/30/kernel-mm-map/"/>
    <updated>2014-04-30T16:04:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/04/30/kernel-mm-map</id>
    <content type="html"><![CDATA[<h5>关于虚拟内存有三点需要注意：</h5>

<p>  1、4G的进程地址空间被人为的分为两个部分&ndash;用户空间与内核空间。用户空间从0到3G（0xc0000000）,内核空间占据3G到4G。用户进程通常情况下只能访问用户空间的虚拟地址，不能访问内核空间的虚拟地址。例外情况只有用户进程进行系统调用（代表用户进程在内核态执行）等时刻可以访问到内核空间。<br/>
  2、用户空间对应进程，所以每当进程切换，用户空间就会跟着变化；而内核空间是由内核负责映射，它并不会跟着进程变化，是固定的。内核空间地址有自己对应的页表，用户进程各自有不同的页表。<br/>
  3、每个进程的用户空间都是完全独立、互不相干的。</p>

<h4>一、4G地址空间解析图</h4>

<p><img src="/images/kernel/20140430-1.jpeg" alt="" /></p>

<p>  上图展示了整个进程地址空间的分布，其中4G的地址空间分为两部分，在用户空间内，对应了内存分布的五个段：数据段、代码段、BSS段、堆、栈。在上篇文章中有详细的介绍。</p>

<p>二、虚拟地址空间分配及其与物理内存对应图</p>

<p><img src="/images/kernel/20140430-2.jpeg" alt="" /></p>

<p>  这个图示内核用户空间的划分，图中最重要的就是高端内存的映射<br/>
  其中kmalloc和vmalloc函数申请的空间对应着不同的区域，同时又不同的含义。</p>

<p>三、物理内存分配图</p>

<p><img src="/images/kernel/20140430-3.jpeg" alt="" /></p>

<p>  这张图中页解释了三者的不同关系，和上篇文章中的内容有相似之处。</p>

<h5>伙伴算法：</h5>

<p>  一种物理内存分配和回收的方法，物理内存所有空闲页都记录在BUDDY链表中。首选，系统建立一个链表，链表中的每个元素代表一类大小的物理内存，分别为2的0次方、1次方、2次方，个页大小，对应4K、8K、16K的内存，没一类大小的内存又有一个链表，表示目前可以分配的物理内存。例如现在仅存需要分配8K的物理内存，系统首先从8K那个链表中查询有无可分配的内存，若有直接分配；否则查找16K大小的链表，若有，首先将16K一分为二，将其中一个分配给进程，另一个插入8K的链表中，若无，继续查找32K，若有，首先把32K一分为二，其中一个16K大小的内存插入16K链表中，然后另一个16K继续一分为二，将其中一个插入8K的链表中，另一个分配给进程&hellip;&hellip;..以此类推。当内存释放时，查看相邻内存有无空闲，若存在两个联系的8K的空闲内存，直接合并成一个16K的内存，插入16K链表中。（伙伴算法用于物理内存分配方案）</p>

<h5>SLAB算法：</h5>

<p>  是一种对伙伴算的一种补充，对于用户进程的内存分配，伙伴算法已经够好了，但对于内核进程，还需要存在一类很小的数据（字节大小，比如进程描述符、虚拟内存描述符等），若每次给几个字节的数据分配一个4KB的页，实在太浪费，于是就有了SLBA算法，SLAB算法其实就是把一个页用力劈成一小块一小块，然后再分配。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[利用kexec快速切换内核]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/04/23/kernel-kexec-setup/"/>
    <updated>2014-04-23T15:35:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/04/23/kernel-kexec-setup</id>
    <content type="html"><![CDATA[<p>kexec是一个用于在当前系统下快速切换到另一个内核的一种办法，它采用了一定的机制略过了硬件的初始化，所以切换速度会很快。</p>

<p>自2.6.13以后，Linux内核就已经自置了kexec，而Debian采用的内核已经是2.6.26，而且默认就支持kexec，所以在Debian下我们只要安装kexec-tools就行了。</p>

<pre><code>$ yum install kexec-tools
$ sudo apt-get install kexec-tools
</code></pre>

<p>安装好以后，就可以开始加载其他的内核了。<br/>
先看看我有哪些内核可以用：
<code>
$ ls /boot/vmlinuz-2.6.26-1-*
/boot/vmlinuz-2.6.26-1-amd64         
/boot/vmlinuz-2.6.26-1-vserver-amd64
</code>
好多好多，再看看当前的内核
<code>
$ uname -r
2.6.26-1-vserver-amd64
</code>
好了，现在我打算切换到2.6.26-1-amd64去：<br/>
记得，需要root权限的
<code>
$ sudo -s
</code>
先要用kexec加载它，先看看该追加哪些参数
<code>
$ cat /boot/grub/menu.lst | grep 2.6.26-1-amd64
title Debian GNU/Linux, kernel 2.6.26-1-amd64
kernel /vmlinuz-2.6.26-1-amd64 root=/dev/sda1 ro
initrd /initrd.img-2.6.26-1-amd64
</code>
找到了，对照上面开始用kexec加载了
<code>
$ kexec -l /boot/vmlinuz-2.6.26-1-amd64 --initrd /boot/initrd.img-2.6.26-1-amd64 --append="root=/dev/sda1 ro"
</code>
加载以后并不直接执行哦，所以我们要执行一下才会切换
<code>
$ kexec -e
</code>
不要紧张，等一下下就好了，起来以后还会提示登录的<br/>
看看我的效果：<br/>
<code>
$ uname -r
2.6.26-1-amd64
</code>
切换到我想要的内核了</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[大牛的]后缀数组总结]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/04/09/alg-suffix/"/>
    <updated>2014-04-09T17:57:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/04/09/alg-suffix</id>
    <content type="html"><![CDATA[<h5>双关键字的基数排序</h5>

<p>先对关键字2进行排序，然后再对关键字1进行稳定排序。 后缀数组中用到了这点。</p>

<hr />

<p><a href="http://hi.baidu.com/ahnkftravhdhkyr">大牛在这里</a></p>

<p>  后缀数组是处理字符串的有力工具。后缀数组是后缀树的一个非常精巧的替代品，它比后缀树容易编程实现，能够实现后缀树的很多功能而时间复杂度也并不逊色，而且它比后缀树所占用的内存空间小很多。可以说，后缀数组比后缀树要更为实用。自从拜读了罗穗骞大牛的WC2009论文《后缀数组——处理字符串的有力工具》后，经过若干星期的努力（中间有因某些原因而缓下来），终于把论文上面的练习题全部完成了，现在写写自己对后缀数组的理解和感悟。在看本笔记时，请不要忘记了，这是笔记，而教材是《后缀数组——处理字符串的有力工具》。</p>

<h4>一：后缀数组的实现</h4>

<ol>
<li>定义：Suffix Array数组（SA数组）用于保存从小到大排好序之后的后缀。RANK名次数组用来保存后缀S[i..n]在所有后缀中是第几小的后缀。简单来说，SA数组表示的是“排第几的是谁”，RANK数组表示的是“你的排名是多少”。</li>
<li>求SA数组以及RANK数组的方法：详细的请转到罗穗骞大牛的论文，我的学习笔记重点不是要介绍这个。</li>
<li>对DA（倍增算法）的一些个人理解：由于我只学习了倍增算法，所以我只能谈谈我对它的理解。DC3算法我没有去研究&hellip;.</li>
</ol>


<p>DA算法我是根据罗穗骞的模板写的，根据自己的理解做了些许的小优化。我们现在来看看罗穗骞大牛的模板：
<code>
    int wa[maxn],wb[maxn],wv[maxn],ws[maxn];
    int cmp(int *r,int a,int b,int l)
    {return r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];}
    void da(int *r,int *sa,int n,int m)
    {
        int i,j,p,*x=wa,*y=wb,*t;
        for(i=0;i&lt;m;i++) ws[i]=0;
        for(i=0;i&lt;n;i++) ws[x[i]=r[i]]++;
        for(i=1;i&lt;m;i++) ws[i]+=ws[i-1];
        for(i=n-1;i&gt;=0;i--) sa[--ws[x[i]]]=i;
        for(j=1,p=1;p&lt;n;j*=2,m=p)
        {
            for(p=0,i=n-j;i&lt;n;i++) y[p++]=i;
            for(i=0;i&lt;n;i++) if(sa[i]&gt;=j) y[p++]=sa[i]-j;
            for(i=0;i&lt;n;i++) wv[i]=x[y[i]];
            for(i=0;i&lt;m;i++) ws[i]=0;
            for(i=0;i&lt;n;i++) ws[wv[i]]++;
            for(i=1;i&lt;m;i++) ws[i]+=ws[i-1];
            for(i=n-1;i&gt;=0;i--) sa[--ws[wv[i]]]=y[i];
            for(t=x,x=y,y=t,p=1,x[sa[0]]=0,i=1;i&lt;n;i++)
            x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;
        }
        return;
    }
</code>
其实，我个人认为，对于这个算法以及代码，无需过分深入地理解，只需记忆即可，理解只是为了帮助记忆罢了。先解释变量：n为字符串长度，m为字符的取值范围，r为字符串。后面的j为每次排序时子串的长度。
<code>
    for(i=0;i&lt;m;i++) ws[i]=0;
    for(i=0;i&lt;n;i++) ws[x[i]=r[i]]++;
    for(i=1;i&lt;m;i++) ws[i]+=ws[i-1];
    for(i=n-1;i&gt;=0;i--) sa[--ws[x[i]]]=i;
</code>
这四行代码，进行的是对R中长度为1的子串进行基数排序。x数组在后面需要用到，所以先复制r数组的值。特别需要注意的是，第四行的for语句，初始化语句为i=n-1，如果写得不太熟练，很容易习惯性地写成i=0，我一开始就是。理解这是基数排序的最好方法，找个例子，自己推推&hellip;.
<code>
    for(p=0,i=n-j;i&lt;n;i++) y[p++]=i;
    for(i=0;i&lt;n;i++) if(sa[i]&gt;=j) y[p++]=sa[i]-j;
</code>
这两行代码，利用了上一次基数排序的结果，对待排序的子串的第二关键字进行了一次高效地基数排序。我们可以结合下面的图来理解：</p>

<p>不难发现，除了第一次基数排序以外，之后的每次双关键字排序，设此次排序子串长度为j，则从第n-j位开始的子串，其第二关键字均为0，所以得到第一个for语句：for(p=0,i=n-j;i&lt;n;i++) y[p++]=i;使用pascal的朋友们注意了，这里之所以是n-j位，是因为c++的字符串是从第0位开始表示的。这里，p暂时成为了一个计数变量。第二个语句的意义，分析上图也不难理解，这里留给朋友们你们自行思考啦。（不如说我懒&hellip;）
<code>
    for(i=0;i&lt;n;i++) wv[i]=x[y[i]];
    for(i=0;i&lt;m;i++) ws[i]=0;
    for(i=0;i&lt;n;i++) ws[wv[i]]++;
    for(i=1;i&lt;m;i++) ws[i]+=ws[i-1];
    for(i=n-1;i&gt;=0;i--) sa[--ws[wv[i]]]=y[i];
</code>
与一开始的4个for语句意义相同，基数排序。至于为什么wv[i]=x[y[i]]，这个我想了蛮久没想通&hellip;硬记算了- -哪位朋友理解的希望能告诉我一声&hellip;
<code>
    for(t=x,x=y,y=t,p=1,x[sa[0]]=0,i=1;i&lt;n;i++)
        x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;
</code>
这个for语句中的初始化语句里，完成了x数组和y数组的交换，用了指针的交换节约时间，简化代码。这里需要注意的是p和i的初始值都是1，不是0.其实如果记得后面的语句，不难看出它们的初始值不能为0，因为后面有i-1和p-1嘛。这个for语句的意义要结合cmp函数来理解。反正，你知道这里p的值表示的是此时关键字不同的串的数量就对了。当 p=n 的时候，说明所有串都已经排好序了（它们的排名都唯一确定）。所以，一开始的循环语句中，循环条件是（p&lt;n）。</p>

<p>另外，在使用倍增算法前，需要保证r数组的值均大于0。然后要在原字符串后添加一个0号字符，具体原因参见罗穗骞的论文。这时候，若原串的长度为n，则实际要进行后缀数组构建的r数组的长度应该为n+1.所以调用da函数时，对应的n应为n+1.</p>

<h4>二、后缀数组的应用&ndash;height数组</h4>

<p>在介绍后缀数组的应用前，先介绍后缀数组的一个重要附属数组：height数组。
1、height 数组：定义height[i]=suffix(sa[i-1])和suffix(sa[i])的最长公
共前缀，也就是排名相邻的两个后缀的最长公共前缀。
height数组是应用后缀数组解题是的核心，基本上使用后缀数组解决的题目都是依赖height数组完成的。</p>

<p>2、height数组的求法：具体的求法参见罗穗骞的论文。对于height数组的求法，我并没有去深刻理解，单纯地记忆了而已&hellip;有兴趣的朋友可以去钻研钻研再和我交流交流
这里给出代码：
<code>
    int rank[maxn],height[maxn];
    void calheight(int *r,int *sa,int n)
    {
        int i,j,k=0;
        for(i=1;i&lt;=n;i++) rank[sa[i]]=i;
        for(i=0;i&lt;n;height[rank[i++]]=k)
        for(k?k--:0,j=sa[rank[i]-1];r[i+k]==r[j+k];k++);
        return;
    }
</code>
3、一些注意事项：height数组的值应该是从height[1]开始的，而且height[1]应该是等于0的。原因是，因为我们在字符串后面添加了一个0号字符，所以它必然是最小的一个后缀。而字符串中的其他字符都应该是大于0的（前面有提到，使用倍增算法前需要确保这点），所以排名第二的字符串和0号字符的公共前缀（即height[1]）应当为0.在调用calheight函数时，要注意height数组的范围应该是[1..n]。所以调用时应该是calheight(r,sa,n)而不是calheight(r,sa,n+1)。要理解清楚这里的n的含义是什么。</p>

<p>calheight过程中，对rank数组求值的for语句的初始语句是i=1 而不是i=0 的原因，和上面说的类似，因为sa[0]总是等于那个已经失去作用的0号字符，所以没必要求出其rank值。当然你错写成for (i=0 ..)，也不会有什么问题。</p>

<h4>三、后缀数组解题总结：</h4>

<h5>1、求单个子串的不重复子串个数。SPOJ 694、SPOJ 705.</h5>

<p>  这个问题是一个特殊求值问题。要认识到这样一个事实：一个字符串中的所有子串都必然是它的后缀的前缀。（这句话稍微有点绕&hellip;）对于每一个sa[i]后缀，它的起始位置sa[i]，那么它最多能得到该后缀长度个子串（n-sa[i]个），而其中有height[i]个是与前一个后缀相同的，所以它能产生的实际后缀个数便是n-sa[i]-height[i]。遍历一次所有的后缀，将它产生的后缀数加起来便是答案。<br/>
代码及题解：<a href="http://hi.baidu.com/fhnstephen/blog/item/68f919f849748668024f56fb.html">http://hi.baidu.com/fhnstephen/blog/item/68f919f849748668024f56fb.html</a></p>

<h5>2、后缀的最长公共前缀。（记为lcp（x，y））</h5>

<p>这是height数组的最基本性质之一。具体的可以参看罗穗骞的论文。后缀i和后缀j的最长公共前缀的长度为它们在sa数组中所在排位之间的height值中的最小值。这个描述可能有点乱，正规的说，令x=rank[i],y=rank[j]，x&lt;y,那么lcp(i,j)=min(height[x+1],height[x+2]&hellip;height[y])。lcp(i,i)=n-sa[i]。解决这个问题，用RMQ的ST算法即可（我只会这个，或者用最近公共祖先那个转化的做法）。</p>

<h5>3、最长重复子串（可重叠）</h5>

<p>  要看到，任何一个重复子串，都必然是某两个后缀的最长公共前缀。因为，两个后缀的公共前缀，它出现在这两个后缀中，并且起始位置时不同的，所以这个公共前缀必然重复出现两次以上（可重叠）。而任何两个后缀的最长公共前缀为某一段height值中的最小值，所以最大为height值中的最大值（即某个lcp(sa[i],sa[i+1]））。所以只要算出height数组，然后输出最大值就可以了。<br/>
一道题目和代码：<a href="http://hi.baidu.com/fhnstephen/blog/item/4ed09dffdec0a78eb801a0ba.html">http://hi.baidu.com/fhnstephen/blog/item/4ed09dffdec0a78eb801a0ba.html</a></p>

<h5>4、最长重复不重叠子串 PKU1743</h5>

<p>  这个问题和3的唯一区别在于能否重叠。加上不能重叠这个限制后，直接求解比较困难，所以我们选择二分枚举答案，将问题转换为判定性问题。假设当时枚举的长度为k，那么要怎样判断是否存在长度为k的重复不重叠子串呢？</p>

<p>  首先，根据height数组，将后缀分成若干组，使得每组后缀中，后缀之间的height值不小于k。这样分组之后，不难看出，如果某组后缀数量大于1，那么它们之中存在一个公共前缀，其长度为它们之间的height值的最小值。而我们分组之后，每组后缀之间height值的最小值大于等于k。所以，后缀数大于1的分组中，有可能存在满足题目限制条件的长度不小于k的子串。只要判断满足题目限制条件成立，那么说明存在长度至少为k的合法子串。</p>

<p>  对于本题，限制条件是不重叠，判断的方法是，一组后缀中，起始位置最大的后缀的起始位置减去起始位置最小的后缀的起始位置>=k。满足这个条件的话，那么这两个后缀的公共前缀不但出现两次，而且出现两次的起始位置间隔大于等于k，所以不会重叠。</p>

<p>深刻理解这种height分组方法以及判断重叠与否的方法，在后面的问题中起到举足轻重的作用。<br/>
练习及题解：<a href="http://hi.baidu.com/fhnstephen/blog/item/85a25b208263794293580759.html">http://hi.baidu.com/fhnstephen/blog/item/85a25b208263794293580759.html</a></p>

<h5>5、最长的出现k次的重复（可重叠）子串。 PKU3261</h5>

<p>  使用后缀数组解题时，遇到“最长”，除了特殊情况外（如问题3），一般需要二分答案，利用height值进行分组。本题的限制条件为出现k次。只需判断，有没有哪一组后缀数量不少于k就可以了。相信有了我前面问题的分析作为基础，这个应该不难理解。注意理解“不少于k次”而不是“等于k次”的原因。如果理解不了，可以找个具体的例子来分析分析。<br/>
题目及题解：<a href="http://hi.baidu.com/fhnstephen/blog/item/be7d15133ccbe7f0c2ce79bb.html">http://hi.baidu.com/fhnstephen/blog/item/be7d15133ccbe7f0c2ce79bb.html</a></p>

<h5>6、最长回文子串 ural1297</h5>

<p>  这个问题没有很直接的方法可以解决，但可以采用枚举的方法。具体的就是枚举回文子串的中心所在位置i。注意要分回文子串的长度为奇数还是偶数两种情况分析。然后，我们要做的，是要求出以i为中心的回文子串最长为多长。利用后缀数组，可以设计出这样一种求法：求i往后的后缀与i往前的前缀的最长公共前缀。我这里的表述有些问题，不过不影响理解。</p>

<p>  要快速地求这个最长前缀，可以将原串反写之后接在原串后面。在使用后缀数组的题目中，连接两个（n个）字符串时，中间要用不可能会出现在原串中，不一样的非0号的字符将它们隔开。这样可以做到不影响后缀数组的性质。然后，问题就可以转化为求两个后缀的最长公共前缀了。具体的细节，留给大家自己思考&hellip;（懒&hellip;原谅我吧，都打这么多字了..一个多小时了啊TOT ）<br/>
题目及题解：<a href="http://hi.baidu.com/fhnstephen/blog/item/68342f1d5f9e3cf81ad576ef.html">http://hi.baidu.com/fhnstephen/blog/item/68342f1d5f9e3cf81ad576ef.html</a></p>

<h5>7、求一个串最多由哪个串复制若干次得到 PKU2406</h5>

<p>  具体的问题描述请参考PKU2406.这个问题可以用KMP解决，而且效率比后缀数组好。
利用后缀数组直接解决本题也很困难（主要是，就算二分答案，也难以解决转变而成的判定性问题。上题也是），但可以同过枚举模板串的长度k（模板串指被复制的那个串）将问题变成一个后缀数组可以解决的判定性问题。首先判断k能否被n整除，然后只要看lcp(1,k+1)（实际在用c写程序时是lcp(0,k)）是否为n-k就可以了。</p>

<p>  为什么这样就行了呢？这要充分考虑到后缀的性质。当lcp（1，k+1）=n-k时，后缀k+1是后缀1（即整个字符串）的一个前缀。（因为后缀k+1的长度为n-k）那么，后缀1的前k个字符必然和后缀k+1的前k个字符对应相同。而后缀1的第k+1..2k个字符，又相当于后缀k+1的前k个字符，所以与后缀1的前k个字符对应相同，且和后缀k的k+1..2k又对应相同。依次类推，只要lcp(1,k+1)=n-k,那么s[1..k]就可以通过自复制n/k次得到整个字符串。找出k的最小值，就可以得到n/k的最大值了。<br/>
题目及题解：<a href="http://hi.baidu.com/fhnstephen/blog/item/5d79f2efe1c3623127979124.html">http://hi.baidu.com/fhnstephen/blog/item/5d79f2efe1c3623127979124.html</a></p>

<h5>8、求两个字符串的最长公共子串。Pku2774、Ural1517</h5>

<p>  首先区分好“最长公共子串”和“最长公共子序列”。前者的子串是连续的，后者是可以不连续的。</p>

<p>  对于两个字符串的问题，一般情况下均将它们连起来，构造height数组。然后，最长公共子串问题等价于后缀的最长公共前缀问题。只不过，并非所有的lcp值都能作为问题的答案。只有当两个后缀分属两个字符串时，它们的lcp值才能作为答案。与问题3一样，本题的答案必然是某个height值，因为lcp值是某段height值中的最小值。当区间长度为1时，lcp值等于某个height值。所以，本题只要扫描一遍后缀，找出后缀分属两个字符串的height值中的最大值就可以了。判断方法这里就不说明了，留给大家自己思考&hellip;<br/>
题目及题解：<br/>
<a href="http://hi.baidu.com/fhnstephen/blog/item/8666a400cd949d7b3812bb44.html  ">http://hi.baidu.com/fhnstephen/blog/item/8666a400cd949d7b3812bb44.html  </a>
<a href="http://hi.baidu.com/fhnstephen/blog/item/b5c7585600cadfc8b645aebe.html">http://hi.baidu.com/fhnstephen/blog/item/b5c7585600cadfc8b645aebe.html</a></p>

<h5>9、重复次数最多的重复子串 SPOJ 687，Pku3693</h5>

<p>  难度比较大的一个问题，主要是罗穗骞的论文里的题解写得有点含糊不清。题目的具体含义可以去参考Pku3693.</p>

<p>  又是一题难以通过二分枚举答案解决的问题（因为要求的是重复次数），所以选择朴素枚举的方法。先枚举重复子串的长度k，再利用后缀数组来求长度为k的子串最多重复出现多少次。注意到一点，假如一个字符串它重复出现2次（这里不讨论一次的情况，因为那是必然的），那么它必然包含s[0],s[k],s[2<em>k]&hellip;之中的相邻的两个。所以，我们可以枚举一个数i，然后判断从i</em>k这个位置起的长度为k的字符串能重复出现多少次。判断方法和8中的相似，lcp(i<em>k,(i+1)</em>k)/k+1。但是，仅仅这样会忽略点一些特殊情况，即重复子串的起点不在[i<em>k]位置上时的情况。这种情况应该怎么求解呢？<br/>
看下面这个例子：<br/>
aabababc<br/>
当k=2，i=1时，枚举到2的位置，此时的重复子串为ba(注意第一位是0),lcp(2，4)=3，所以ba重复出现了2次。但实际上，起始位置为1的字符串ab出现次数更多，为3次。我们注意到，这种情况下，lcp(2,4)=3，3不是2的整数倍。说明当前重复子串在最后没有多重复出现一次，而重复出现了部分（这里是多重复出现了一个b）。如果我这样说你没有看懂，那么更具体地：<br/>
sa[2]=bababc<br/>
sa[4]=babc<br/>
lcp=bab<br/>
现在注意到了吧，ba重复出现了两次之后，出现了一个b，而a没有出现。那么，不难想到，可以将枚举的位置往前挪一位，这样这个最后的b就能和前面的一个a构成一个重复子串了，而假如前挪的一位正好是a，那么答案可以多1。所以，我们需要求出a=lcp(i</em>k,(i+1)*k)%n，然后向前挪k-a位，再用同样的方法求其重复出现的长度。这里，令b=k-a,只需要lcp(b,b+k)>=k就可以了。实际上，lcp(b,b+k)>=k时，lcp(b,b+k)必然大于等于之前求得的lcp值，而此时答案的长度只加1。没有理解的朋友细细体会下上图吧。<br/>
题目及题解：<a href="http://hi.baidu.com/fhnstephen/blog/item/870da9ee3651404379f0555f.html">http://hi.baidu.com/fhnstephen/blog/item/870da9ee3651404379f0555f.html</a></p>

<h5>10.多个串的公共子串问题 PKU3294</h5>

<p>首先将串连接起来，然后构造height数组，然后怎么办呢？<br/>
对，二分答案再判断是否可行就行了。可行条件很直观：有一组后缀，有超过题目要求的个数个不同的字符串中的后缀存在。即，假如题目要求要出现在至少k个串中，那么就得有一组后缀，在不同字符串中的后缀数大于等于k。<br/>
题目及题解：<a href="http://hi.baidu.com/fhnstephen/blog/item/49c3b7dec79ec5e377c638f1.html">http://hi.baidu.com/fhnstephen/blog/item/49c3b7dec79ec5e377c638f1.html</a></p>

<h5>11、出现或反转后出现所有字符串中的最长子串 PKU1226</h5>

<p><a href="http://hi.baidu.com/fhnstephen/blog/item/7fead5020a16d2da267fb5c0.html">http://hi.baidu.com/fhnstephen/blog/item/7fead5020a16d2da267fb5c0.html</a></p>

<h5>12、不重叠地至少两次出现在所有字符串中的最长子串</h5>

<p>spoj220 <a href="http://hi.baidu.com/fhnstephen/blog/item/1dffe1dda1c98754cdbf1a35.html">http://hi.baidu.com/fhnstephen/blog/item/1dffe1dda1c98754cdbf1a35.html</a></p>

<p>之所以把两题一起说，因为它们大同小异，方法在前面的题目均出现过。对于多个串，连起来；反转后出现，将每个字符串反写后和原串都连起来，将反写后的串和原串看成同一个串；求最长，二分答案后height分组；出现在所有字符串中（反写后的也行），判断方法和10一样，k=n而已；不重叠见问题4，只不过这里对于每个字符串都要进行检验而已。</p>

<h5>13、两个字符串的重复子串个数。 Pku3415</h5>

<p>我个人觉得颇有难度的一个问题。具体的题目描述参看Pku3415。<br/>
大家可以移步到这：<a href="http://hi.baidu.com/fhnstephen/blog/item/bf06d001de30fc034afb51c1.html">http://hi.baidu.com/fhnstephen/blog/item/bf06d001de30fc034afb51c1.html</a></p>

<h5>14、最后的总结</h5>

<p>用后缀数组解题有着一定的规律可循，这是后缀的性质所决定的，具体归纳如下：<br/>
1、N个字符串的问题（N>1）<br/>
方法：将它们连接起来，中间用不会出现在原串中的，互不相同的，非0号字符分隔开。</p>

<p>2、无限制条件下的最长公共子串（重复子串算是后缀们的最长公共前缀）<br/>
方法：height的最大值。这里的无限制条件是对子串无限制条件。最多只能是两个串的最长公共子串，才可以直接是height的最大值。</p>

<p>3、特殊条件下的最长子串<br/>
方法：二分答案，再根据height数组进行分组，根据条件完成判定性问题。三个或以上的字符串的公共子串问题也需要二分答案。设此时要验证的串长度为len，特殊条件有：<br/>
3.1、出现在k个串中<br/>
条件：属于不同字符串的后缀个数不小于k。（在一组后缀中，下面省略）<br/>
3.2、不重叠<br/>
条件：出现在同一字符串中的后缀中，出现位置的最大值减最小值大于等于len。<br/>
3.3、可重叠出现k次<br/>
条件：出现在同一字符串中的后缀个数大于等于k。若对于每个字符串都需要满足，需要逐个字符串进行判断。</p>

<p>4、特殊计数<br/>
方法：根据后缀的性质，和题目的要求，通过自己的思考，看看用后缀数组能否实现。一般和“子串”有关的题目，用后缀数组应该是可以解决的。</p>

<p>5、重复问题<br/>
知道一点：lcp(i,i+k)可以判断，以i为起点，长度为k的一个字符串，它向后自复制的长度为多少，再根据具体题目具体分析，得出算法即可。</p>
]]></content>
  </entry>
  
</feed>
