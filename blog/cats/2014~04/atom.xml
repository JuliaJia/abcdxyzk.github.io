<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 2014~04 | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/2014~04/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2014-11-30T22:48:57+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Linux内核获取当前进程指针]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/04/30/kernel-mm-current-rbp/"/>
    <updated>2014-04-30T16:10:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/04/30/kernel-mm-current-rbp</id>
    <content type="html"><![CDATA[<h4>一、内存数据表示：</h4>

<p>  我们在教材或阅读中，经常需要直观的用图示来展示数据在内存中的分布，那么数据是如何在内存中组织的呢？不同的机器有不同的表示法，我们以最常见的Intel X86系列计算机为例来说明这个问题。</p>

<p><img src="/images/kernel/20140430-1.jpg" alt="" /></p>

<p>  如上图示内存示意图：内存低址在上。内存高址在下，内存单位为16bit。对于基于intel i386架构的计算机，系统采用小端字节序来存放数据，所谓小端字节序是指低序字节低地址，高序字节高地址(内存地址增大方向)，大端字节序反之，给定系统所用的字节序称为主机字节序；CPU也以小端字节序形式读取数据，如上图所示，如果变量num是16位的short短整类型，则CPU从内存中读出的num=0x1234；如果num是32位的int类型，则CPU从内存中读出的是num=0x56781234,其中num地址是0x12345678，即&amp;num=0x12345678</p>

<h4>二、linux内核获取进程任务结构的指针</h4>

<p>  明白了系统内存数据表示，我们现在来看看linux内核是如何获取当前进程的任务结构指针的，以下代码均参照linux内核2.4.0的源码。<br/>
  在include\asm-i386\ current.h中
<code>
    #ifndef _I386_CURRENT_H
    #define _I386_CURRENT_H
    struct task_struct;
    static inline struct task_struct * get_current(void)
    {
        struct task_struct *current;
        __asm__("andl %%esp,%0; ":"=r" (current) : "0" (~8191UL));
        return current;
    }
    #define current get_current()
    #endif /* !(_I386_CURRENT_H) */
</code>
  每个进程都有一个task_struct任务结构，和一片用于系统空间堆栈的存储空间，他们在物理内存空间中也是联系在一起的，当给进程申请task_struct任务结构空间时，系统将连同系统的堆栈空间一起分配，如下图为某个进程切换时刻的内存图：</p>

<p><img src="/images/kernel/20140430-2.jpg" alt="" /></p>

<p>  下面针对代码实现来分析一下系统如何通过一系列操作获取进程在内核中的任务结构指针的：
  由于linux内核分配进程任务结构空间时，是以8KB(2个页面空间，即2<sup>1</sup>*4KB，linux对物理内存空间和虚拟内存空间管理时，均规定其页面单位的尺寸为4KB)为单位来分配的，所以内存应用地址是8KB(2<sup>13</sup>)的整数倍，即指针地址的低13位全为0，所以根据小端字节序，分配内存返回地址应该是指向struct task_struct结构，如图中的0xc2342000地址所指，至于为何采用代码中的做法而不是直接将此指针保存在全局变量中以供应用，内核是从其自身的效率方面来考虑的，我们在此只针对代码解释：
  根据上图，此刻内存esp内容必定在0xc2342000和0xc2344000之间的一个数值，我们假设取0xc2343ffe(即堆栈压栈EIP、返回地址、内部数据等相关数据了，地址值要减小；只要符合0xc2342xxx 、0xc2343xxx的地址指针都是正确的)，来通过代码运算看是否current的指针是0xc2342000。
<code>
    __asm__("andl %%esp,%0; ":"=r" (current) : "0" (~8191UL));
</code>
语句的意思是将ESP的内容与8191UL的反码按位进行与操作，之后再把结果赋值给current，其中8191UL=8192-1=2<sup>13</sup>-1,计算过程如下：
<code>
    8192UL=2^13 0000 0000 0000 0000 0010 0000 0000 0000
    8191UL 0000 0000 0000 0000 0001 1111 1111 1111
    ~8191UL(反码) 1111 1111 1111 1111 1110 0000 0000 0000
    0xc2343ffe 1100 0010 0011 0100 0011 1111 1111 1110
    andl结果： 1100 0010 0011 0100 0010 0000 0000 0000
    || (对照着看)
    0x c 2 3 4 2 0 0 0
</code>
  所以按位与操作之后的结果位0xc2342000，正好是struct task_struct结构的地址指针.通过观察可知，只要符合0xc2342xxx 、0xc2343xxx的地址指针经过相同的计算，都可以得到内核进程任务结构的指针。<br/>
  另外，在进入中断或系统调用时所引用的宏操作(include\asm-i386\ hw_irq.h):
<code>
    #define GET_CURRENT \
        "movl %esp, %ebx\n\t" \
        "andl $-8192, %ebx\n\t"
</code>
  其原理与上述描述也是一致的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux内存分配]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/04/30/kernel-mm-map/"/>
    <updated>2014-04-30T16:04:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/04/30/kernel-mm-map</id>
    <content type="html"><![CDATA[<h5>关于虚拟内存有三点需要注意：</h5>

<p>  1、4G的进程地址空间被人为的分为两个部分&ndash;用户空间与内核空间。用户空间从0到3G（0xc0000000）,内核空间占据3G到4G。用户进程通常情况下只能访问用户空间的虚拟地址，不能访问内核空间的虚拟地址。例外情况只有用户进程进行系统调用（代表用户进程在内核态执行）等时刻可以访问到内核空间。<br/>
  2、用户空间对应进程，所以每当进程切换，用户空间就会跟着变化；而内核空间是由内核负责映射，它并不会跟着进程变化，是固定的。内核空间地址有自己对应的页表，用户进程各自有不同的页表。<br/>
  3、每个进程的用户空间都是完全独立、互不相干的。</p>

<h4>一、4G地址空间解析图</h4>

<p><img src="/images/kernel/20140430-1.jpeg" alt="" /></p>

<p>  上图展示了整个进程地址空间的分布，其中4G的地址空间分为两部分，在用户空间内，对应了内存分布的五个段：数据段、代码段、BSS段、堆、栈。在上篇文章中有详细的介绍。</p>

<p>二、虚拟地址空间分配及其与物理内存对应图</p>

<p><img src="/images/kernel/20140430-2.jpeg" alt="" /></p>

<p>  这个图示内核用户空间的划分，图中最重要的就是高端内存的映射<br/>
  其中kmalloc和vmalloc函数申请的空间对应着不同的区域，同时又不同的含义。</p>

<p>三、物理内存分配图</p>

<p><img src="/images/kernel/20140430-3.jpeg" alt="" /></p>

<p>  这张图中页解释了三者的不同关系，和上篇文章中的内容有相似之处。</p>

<h5>伙伴算法：</h5>

<p>  一种物理内存分配和回收的方法，物理内存所有空闲页都记录在BUDDY链表中。首选，系统建立一个链表，链表中的每个元素代表一类大小的物理内存，分别为2的0次方、1次方、2次方，个页大小，对应4K、8K、16K的内存，没一类大小的内存又有一个链表，表示目前可以分配的物理内存。例如现在仅存需要分配8K的物理内存，系统首先从8K那个链表中查询有无可分配的内存，若有直接分配；否则查找16K大小的链表，若有，首先将16K一分为二，将其中一个分配给进程，另一个插入8K的链表中，若无，继续查找32K，若有，首先把32K一分为二，其中一个16K大小的内存插入16K链表中，然后另一个16K继续一分为二，将其中一个插入8K的链表中，另一个分配给进程&hellip;&hellip;..以此类推。当内存释放时，查看相邻内存有无空闲，若存在两个联系的8K的空闲内存，直接合并成一个16K的内存，插入16K链表中。（伙伴算法用于物理内存分配方案）</p>

<h5>SLAB算法：</h5>

<p>  是一种对伙伴算的一种补充，对于用户进程的内存分配，伙伴算法已经够好了，但对于内核进程，还需要存在一类很小的数据（字节大小，比如进程描述符、虚拟内存描述符等），若每次给几个字节的数据分配一个4KB的页，实在太浪费，于是就有了SLBA算法，SLAB算法其实就是把一个页用力劈成一小块一小块，然后再分配。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[利用kexec快速切换内核]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/04/23/kernel-kexec-setup/"/>
    <updated>2014-04-23T15:35:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/04/23/kernel-kexec-setup</id>
    <content type="html"><![CDATA[<p>kexec是一个用于在当前系统下快速切换到另一个内核的一种办法，它采用了一定的机制略过了硬件的初始化，所以切换速度会很快。</p>

<p>自2.6.13以后，Linux内核就已经自置了kexec，而Debian采用的内核已经是2.6.26，而且默认就支持kexec，所以在Debian下我们只要安装kexec-tools就行了。</p>

<pre><code>$ yum install kexec-tools
$ sudo apt-get install kexec-tools
</code></pre>

<p>安装好以后，就可以开始加载其他的内核了。<br/>
先看看我有哪些内核可以用：
<code>
$ ls /boot/vmlinuz-2.6.26-1-*
/boot/vmlinuz-2.6.26-1-amd64         
/boot/vmlinuz-2.6.26-1-vserver-amd64
</code>
好多好多，再看看当前的内核
<code>
$ uname -r
2.6.26-1-vserver-amd64
</code>
好了，现在我打算切换到2.6.26-1-amd64去：<br/>
记得，需要root权限的
<code>
$ sudo -s
</code>
先要用kexec加载它，先看看该追加哪些参数
<code>
$ cat /boot/grub/menu.lst | grep 2.6.26-1-amd64
title Debian GNU/Linux, kernel 2.6.26-1-amd64
kernel /vmlinuz-2.6.26-1-amd64 root=/dev/sda1 ro
initrd /initrd.img-2.6.26-1-amd64
</code>
找到了，对照上面开始用kexec加载了
<code>
$ kexec -l /boot/vmlinuz-2.6.26-1-amd64 --initrd /boot/initrd.img-2.6.26-1-amd64 --append="root=/dev/sda1 ro"
</code>
加载以后并不直接执行哦，所以我们要执行一下才会切换
<code>
$ kexec -e
</code>
不要紧张，等一下下就好了，起来以后还会提示登录的<br/>
看看我的效果：<br/>
<code>
$ uname -r
2.6.26-1-amd64
</code>
切换到我想要的内核了</p>
]]></content>
  </entry>
  
</feed>
