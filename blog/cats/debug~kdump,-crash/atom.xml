<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: debug~kdump、crash | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/debug~kdump,-crash/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2014-11-29T16:26:34+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[crash vs gdb work]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/11/06/debug-crash-work/"/>
    <updated>2014-11-06T10:51:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/11/06/debug-crash-work</id>
    <content type="html"><![CDATA[<p><a href="https://www.redhat.com/archives/crash-utility/2014-October/msg00002.html">贴自https://www.redhat.com/archives/crash-utility/2014-October/msg00002.html</a><br/>
Yes, sure. GDB works very differently from crash. There main conceptual<br/>
difference is that GDB only handles with VIRTUAL addresses, while the<br/>
crash utility first translates everything to PHYSICAL addresses.<br/>
Consequently, GDB ignores the PhysAddr field in ELF program headers,<br/>
and crash ignores the VirtAddr field.</p>

<p>I have looked at some of my ELF dump files, and it seems to me that<br/>
VirtAddr is not filled correctly, except for kernel text and static<br/>
data (address range 0xffffffff80000000-0xffffffff9fffffff). Your linked<br/>
list is most likely allocated in the direct mapping<br/>
(0xffff880000000000-0xffffc7ffffffffff). However, I found out that the<br/>
virtual addresses for the direct mapping segments are wrong, e.g. my<br/>
dump file specifies it at 0xffff810000000000 (hypervisor area). This is<br/>
most likely a bug in the kernel code that implements /proc/vmcore.</p>

<p>But that&rsquo;s beside the point. Why?  The Linux kernel maps many physical<br/>
pages more than once into the virtual address space. It would be waste<br/>
of space if you saved it multiple times (for each virtual address that<br/>
maps to it). The crash utility can translate each virtual address to<br/>
the physical address and map it onto ELF segments using PhysAddr.<br/>
Incidentally, the PhysAddr fields are correct in my dump files&hellip;</p>

<p>I&rsquo;m glad you&rsquo;re interested in using GDB to read kernel dump files,<br/>
especially if you&rsquo;re willing to make it work for real. I have proposed<br/>
more than once that the crash utility be re-implemented in pure gdb.<br/>
Last time I looked (approx. 1.5 years ago) the main missing pieces were:</p>

<ol>
<li> Use of physical addresses (described above)</li>
<li> Support for multiple virtual address spaces (for different process<br/>
 contexts)</li>
<li> Ability to read compressed kdump files</li>
<li> Ability to use 64-bit files on 32-bit platforms (to handle PAE)</li>
</ol>


<p>HTH,<br/>
Petr Tesarik</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[静态编译crash + xbt + bt -H]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/11/04/debug-crash-static/"/>
    <updated>2014-11-04T18:23:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/11/04/debug-crash-static</id>
    <content type="html"><![CDATA[<h5>要在centos6上编译，为了能在centos5用，用静态编译</h5>

<h5>有两个显示函数参数的patch，但是不一定能起作用</h5>

<h5>patch1:</h5>

<p><a href="https://github.com/jhammond/xbt">https://github.com/jhammond/xbt</a>
<a href="https://www.redhat.com/archives/crash-utility/2013-September/msg00010.html">https://www.redhat.com/archives/crash-utility/2013-September/msg00010.html</a></p>

<h5>patch2:</h5>

<p><a href="https://github.com/hziSot/crash-stack-parser">https://github.com/hziSot/crash-stack-parser</a>
<a href="https://github.com/hziSot/crash-stack-parser/blob/master/crash-parse-stack-7.0.1.patch">https://github.com/hziSot/crash-stack-parser/blob/master/crash-parse-stack-7.0.1.patch</a></p>

<h4>一、依赖包：</h4>

<p>yum install bison zlib zlib-static glibc-static elfutils-devel elfutils-devel-static elfutils-libelf-devel-static ncurses ncurses-static crash-devel</p>

<h4>二、patch1: xbt 显示参数</h4>

<p>patch: <a href="https://github.com/hziSot/crash-stack-parser  ">https://github.com/hziSot/crash-stack-parser  </a>
make CFLAGS+=&ndash;static LDFLAGS+=&ndash;static</p>

<h4>三、patch2: bt -H 显示参数</h4>

<pre><code>    依赖：有些没有静态包，要自己编译安装：
    liblzma.a: http://tukaani.org/xz/xz-5.0.7.tar.bz2
    libbz2.a:  http://www.bzip.org/1.0.6/bzip2-1.0.6.tar.gz
    下载代码：git clone https://github.com/jhammond/xbt.git xbt.git
    把xbt.git/xbt_crash.c中函数xbt_func前的static删了
    把xbt.git/xbt_crash.c中函数xmod_init的register_extension删了
    把 xbt 命令加到global_data.c        函数x86_64_exception_frame已经在其他库中定义了，所以要换个名字
    编译xbt代码：make   ==  rm -rf *.so
    把 xbt.git/xbt_crash.o  xbt.git/xbt_dwarf.o  xbt.git/xbt_dwfl.o  xbt.git/xbt_eval.o  xbt.git/xbt_frame_print.o 加到 Makefile 的 OBJECT_FILES= 中
    make CFLAGS+=--static LDFLAGS+="--static -lc  -lm -ldl -ldw -lebl -lelf -lbz2 -llzma"


    注意:-lelf -lebl要放在-ldw后面。
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[kdump el5 --dump-dmesg 错误]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/08/28/debug-kdump-cannot--dump-dmesg/"/>
    <updated>2014-08-28T16:35:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/08/28/debug-kdump-cannot--dump-dmesg</id>
    <content type="html"><![CDATA[<h4>原因：</h4>

<p><a href="http://vault.centos.org/5.11/os/SRPMS/kexec-tools-1.102pre-165.el5.src.rpm  ">http://vault.centos.org/5.11/os/SRPMS/kexec-tools-1.102pre-165.el5.src.rpm  </a>
这个包的一个patch(kexec-tools-1.102pre-makedumpfile-dump-dmesg.patch)是为了得到dmesg的，<br/>
但是它判断dmesg的结束是用logged_chars(看kernel/printk.c)，logged_chars应该是输出的结束，所以不对。<br/>
改成log_end就行，<br/>
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>diff &ndash;git a/kexec-tools-1.102pre-makedumpfile-dump-dmesg.patch b/kexec-tools-1.102pre-makedumpfile-dump-dmesg.patch
</span><span class='line'>index 3938280..76c402a 100644
</span><span class='line'>&mdash; a/kexec-tools-1.102pre-makedumpfile-dump-dmesg.patch
</span><span class='line'>+++ b/kexec-tools-1.102pre-makedumpfile-dump-dmesg.patch
</span><span class='line'>@@ -68,7 +68,7 @@ diff -up kexec-tools-testing-20070330/makedumpfile/makedumpfile.c.orig kexec-too
</span><span class='line'> +dump_dmesg()
</span><span class='line'> +{
</span><span class='line'> +      int log_buf_len, length_log, length_oldlog, ret = FALSE;
</span><span class='line'>-+      unsigned long log_addr, logged_chars, index;
</span><span class='line'>++      unsigned long log_addr, logged_chars, log_end, index;
</span><span class='line'> +      char *log_buffer = NULL;
</span><span class='line'> +
</span><span class='line'> +      if (!open_files_for_creating_dumpfile())
</span><span class='line'>@@ -101,10 +101,15 @@ diff -up kexec-tools-testing-20070330/makedumpfile/makedumpfile.c.orig kexec-too
</span><span class='line'> +               printf(&ldquo;Failed to get logged_chars.\n&rdquo;);
</span><span class='line'> +               return FALSE;
</span><span class='line'> +      }
</span><span class='line'>++      if (!readmem(VADDR, SYMBOL(log_end), &amp;log_end, sizeof(log_end))) {
</span><span class='line'>++               printf(&ldquo;Failed to get log_end.\n&rdquo;);
</span><span class='line'>++               return FALSE;
</span><span class='line'>++      }
</span><span class='line'> +      DEBUG_MSG(&ldquo;\n&rdquo;);
</span><span class='line'> +      DEBUG_MSG(&ldquo;log_addr     : %lx\n&rdquo;, log_addr);
</span><span class='line'> +      DEBUG_MSG(&ldquo;log_buf_len  : %d\n&rdquo;, log_buf_len);
</span><span class='line'> +      DEBUG_MSG(&ldquo;logged_chars : %ld\n&rdquo;, logged_chars);
</span><span class='line'>++      DEBUG_MSG(&ldquo;log_end      : %ld\n&rdquo;, log_end);
</span><span class='line'> +
</span><span class='line'> +      if ((log_buffer = malloc(log_buf_len)) == NULL) {
</span><span class='line'> +               ERRMSG(&ldquo;Can&rsquo;t allocate memory for log_buf. %s\n&rdquo;,
</span><span class='line'>@@ -112,21 +117,16 @@ diff -up kexec-tools-testing-20070330/makedumpfile/makedumpfile.c.orig kexec-too
</span><span class='line'> +               return FALSE;
</span><span class='line'> +       }
</span><span class='line'> +
</span><span class='line'>-+      if (logged_chars &lt; log_buf_len) {
</span><span class='line'>++      if (log_end &lt; log_buf_len) {
</span><span class='line'> +               index = 0;
</span><span class='line'>-+               length_log = logged_chars;
</span><span class='line'>++               length_log = log_end;
</span><span class='line'> +
</span><span class='line'> +               if(!readmem(VADDR, log_addr, log_buffer, length_log)) {
</span><span class='line'> +                        printf(&ldquo;Failed to read dmesg log.\n&rdquo;);
</span><span class='line'> +                        goto out;
</span><span class='line'> +               }
</span><span class='line'> +      } else {
</span><span class='line'>-+               if (!readmem(VADDR, SYMBOL(log_end), &amp;index, sizeof(index))) {
</span><span class='line'>-+                        printf(&ldquo;Failed to get log_end.\n&rdquo;);
</span><span class='line'>-+                        goto out;
</span><span class='line'>-+               }
</span><span class='line'>-+               DEBUG_MSG(&ldquo;log_end      : %lx\n&rdquo;, index);
</span><span class='line'>-+               index &amp;= log_buf_len - 1;
</span><span class='line'>++               index = log_end &amp; (log_buf_len - 1);
</span><span class='line'> +               length_log = log_buf_len;
</span><span class='line'> +               length_oldlog = log_buf_len - index;
</span><span class='line'> +&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;----------------
</span><span class='line'>----------------
</span><span class='line'>#### 如果不修改上面bug，kdump得到vmcore后用 makedumpfile --dump-dmesg 无法解得dmesg，补救办法如下：  
</span><span class='line'>kdump得到vmcore后  
</span><span class='line'> 1、vmlinux没有debuginfo，crash不能运行  
</span><span class='line'> 2、makedumpfile -F --dump-dmesg vmcore &gt; dmesg 只能显示开头一下部分dmesg （不懂为什么）  
</span><span class='line'>解决：
</span><span class='line'>
</span><span class='line'>##### 方法一、
</span><span class='line'>通过/boot/System.map 或者 /proc/kallsyms 找到 log_buf 地址，例如 0xffffffff81a9ac30
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;gdb vmlinux vmcore&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;set print repeats 100
</span><span class='line'>set print elements 0
</span><span class='line'>set logging file XXX
</span><span class='line'>set pagination off
</span><span class='line'>set logging on
</span><span class='line'>p {char*} 0xffffffff81a9ac30
</span><span class='line'>quit&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;hr /&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;vi XXX
</span><span class='line'>:%s/\n/\r/g</span></code></pre></td></tr></table></div></figure></p>

<h5>方法二、</h5>

<p>是另一命令，但不好用
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cat /proc/kallsyms | grep log_end
</span><span class='line'>ffffffff81e30de0 b log_end&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;x/1dw 0xffffffff81e30de0
</span><span class='line'>0xffffffff81e30de0:     85689&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;x/1xg 0xffffffff81a9ac30
</span><span class='line'>0xffffffff81a9ac30:     0xffffffff81e30ee0&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;显示最后4000字符
</span><span class='line'>x/5s 0xffffffff81e30ee0+85689-4000</span></code></pre></td></tr></table></div></figure></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[kdump conf]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/08/07/debug-kdump-conf/"/>
    <updated>2014-08-07T15:36:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/08/07/debug-kdump-conf</id>
    <content type="html"><![CDATA[<p>cat /etc/kdump.conf</p>

<pre><code># Configures where to put the kdump /proc/vmcore files
#
# This file contains a series of commands to perform (in order) when a
# kernel crash has happened and the kdump kernel has been loaded.  Directives in
# this file are only applicable to the kdump initramfs, and have no effect if
# the root filesystem is mounted and the normal init scripts are processed
#
# Currently only one dump target and path may be configured at a time. If dump
# to configured dump target fails, the default action will be preformed.
# Default action may be configured with the "default" directive below.
#
# Basics commands supported are:
# path &lt;path&gt;           - Append path to the filesystem device which you are
#                         dumping to.  Ignored for raw device dumps.
#                         If unset, will default to /var/crash.
#
# core_collector &lt;command&gt; &lt;options&gt;
#                       - This allows you to specify the command to copy the
#                         vmcore.  You could use the dump filtering program
#                         makedumpfile, the default one, to retrieve your core,
#                         which on some arches can drastically reduce core file
#                         size. See /usr/sbin/makedumpfile --help for a list of
#                         options. Note that the -i and -g options are not
#                         needed here, as the initrd will automatically be
#                         populated with a config file appropriate for the
#                         running kernel.
#                         For ssh dump, scp should be used instead of cp.
#
# raw &lt;partition&gt;       - Will write /proc/vmcore into raw &lt;partition&gt;.
#
# nfs &lt;nfs mount&gt;       - Will mount fs and copy /proc/vmcore to
#                         &lt;mnt&gt;/&lt;path&gt;/%HOST-%DATE/, supports DNS.
#
# nfs4 &lt;nfs mount&gt;      - Will use NFSv4 instead of NFSv3
#
# net &lt;nfs mount&gt;       - This is a deprecated option to transfer vmcore over
#                         nfs.  Use "nfs" option instead.
#
# ssh &lt;user@server&gt;     - Will copy /proc/vmcore to
#                         &lt;user@server&gt;:&lt;path&gt;/%HOST-%DATE/ via SSH,
#                         supports DNS. If makedumpfile is the core_collector,
#                         it is piped to an "ssh" shell, otherwise use the
#                         specified core_collector like scp.
#                         NOTE: make sure user has necessary write
#                         permissions on server
#
# net &lt;user@server&gt;     - This is a deprecated option to transfer vmcore over
#                         ssh.  Use "ssh" option instead.
#
# &lt;fs type&gt; &lt;partition&gt; - Will mount -t &lt;fs type&gt; &lt;partition&gt; /mnt and copy
#                         /proc/vmcore to /mnt/&lt;path&gt;/127.0.0.1-%DATE/.
#                         NOTE: &lt;partition&gt; can be a device node, label or uuid.
#
# disk_timeout &lt;seconds&gt;
#                       - Number of seconds to wait for disks to appear prior
#                         to continue to save dump. By default kdump waits
#                         180 seconds for the disks to show up it needs. This
#                         can be useful in some cases if disk never shows up
#                         (Either because disk was removed or because kdump is
#                         waiting on wrong disk).
#
# link_delay &lt;seconds&gt;
#                       - Some network cards take a long time to initialize, and
#                         some spanning tree enabled networks do not transmit
#                         user traffic for long periods after a link state
#                         changes.  This optional parameter defines a wait
#                         period after a link is activated in which the
#                         initramfs will wait before attempting to transmit
#                         user data.
#
# kdump_post &lt;binary | script&gt;
#                       - This directive allows you to run a specified
#                         executable just after the memory dump process
#                         terminates. The exit status from the dump process
#                         is fed to the kdump_post executable, which can be
#                         used to trigger different actions for success or
#                         failure.
#
# kdump_pre &lt;binary | script&gt;
#                       - works just like the kdump_post directive, but instead
#                         of running after the dump process, runs immediately
#                         before.  Exit status of this binary is interpreted
#                         as follows:
#                         0 - continue with dump process as usual
#                         non 0 - reboot/halt the system
#
# extra_bins &lt;binaries | shell scripts&gt;
#                       - This directive allows you to specify additional
#                         binaries or shell scripts you'd like to include in
#                         your kdump initrd. Generally only useful in
#                         conjunction with a kdump_post binary or script that
#                         relies on other binaries or scripts.
#
# extra_modules &lt;module(s)&gt;
#                       - This directive allows you to specify extra kernel
#                         modules that you want to be loaded in the kdump
#                         initrd, typically used to set up access to
#                         non-boot-path dump targets that might otherwise
#                         not be accessible in the kdump environment. Multiple
#                         modules can be listed, separated by a space, and any
#                         dependent modules will automatically be included.
#                         Module name should be specified without ".ko" suffix.
#
# options &lt;module&gt; &lt;option list&gt;
#                       - This directive allows you to specify options to apply
#                         to modules in the initramfs.  This directive overrides
#                         options specified in /etc/modprobe.conf. Module name
#                         should be specified without ".ko" suffix.
#
# blacklist &lt;module|directory&gt;
#                       - Prevents modules from being loaded in the initframfs,
#                         either directly during auto-created insmod calls or as
#                         a dependency of another module load. A specific module
#                         or a directory can be specified. In the latter case,
#                         all modules found below the specified directory will
#                         be excluded. This directive can be specified multiple
#                         times or as a space separated list. Module name should
#                         be specified without ".ko" suffix.
#
# sshkey &lt;path&gt;
#                       - Specifies the path of the ssh identity file you want
#                         to use when doing ssh dump. It must be a private key,
#                         the default value is /root/.ssh/kdump_id_rsa. When
#                         progagating public key, the key is assumed to be
#                         identity_file.pub which by default is
#                         /root/.ssh/kdump_id_rsa.pub.
#
# default &lt;reboot | halt | poweroff | shell | mount_root_run_init&gt;
#                       - Action to preform in case dumping to intended target
#                         fails. If no default action is specified, "reboot"
#                         is assumed default.
#
#                         reboot: If the default action is reboot simply reboot
#                                 the system and loose the core that you are
#                                 trying to retrieve.
#                         halt:   If the default action is halt, then simply
#                                 halt the system after attempting to capture
#                                 a vmcore, regardless of success or failure.
#                         poweroff: The system will be powered down
#                         shell:  If the default action is shell, then drop to
#                                 an hush session inside the initramfs from
#                                 where you can try to record the core manually.
#                                 Exiting this shell reboots the system.
#            mount_root_run_init: Mount root filesystem and run init. Kdump
#                                   initscript will try to save dump to root
#                                   filesystem in /var/crash dir. This will
#                                   likely require a lot more memory to
#                                   be reserved for kdump kernel.
#
# debug_mem_level &lt;0-3&gt;
#                       - Turns on debug/verbose output of kdump scripts
#                         regarding free/used memory at various points of
#                         execution. Higher level means more debugging output.
#                         0 - no output
#                         1 - partial /proc/meminfo
#                         2 - /proc/meminfo
#                         3 - /proc/meminfo + /proc/slabinfo
#
# force_rebuild &lt;0 | 1&gt;
#                       - By default, kdump initrd only will be rebuilt when
#                         necessary. Specify 1 here to force rebuilding kdump
#                         initrd every time when kdump service starts.
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[makedumpfile.8]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/08/06/debug-makedumpfile/"/>
    <updated>2014-08-06T14:46:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/08/06/debug-makedumpfile</id>
    <content type="html"><![CDATA[<h4>makedumpfile.8</h4>

<pre><code>NAME

       makedumpfile - make a small dumpfile of kdump

SYNOPSIS

       makedumpfile    [OPTION] [-x VMLINUX|-i VMCOREINFO] VMCORE DUMPFILE
       makedumpfile -F [OPTION] [-x VMLINUX|-i VMCOREINFO] VMCORE
       makedumpfile -R DUMPFILE
       makedumpfile   --split   [OPTION]  [-x  VMLINUX|-i  VMCOREINFO]  VMCORE
       DUMPFILE1 DUMPFILE2 [DUMPFILE3 ..]
       makedumpfile --reassemble DUMPFILE1 DUMPFILE2 [DUMPFILE3 ..] DUMPFILE
       makedumpfile -g VMCOREINFO -x VMLINUX
       makedumpfile  -E  [--xen-syms   XEN-SYMS|--xen-vmcoreinfo   VMCOREINFO]
       VMCORE DUMPFILE
       makedumpfile --dump-dmesg [-x VMLINUX|-i VMCOREINFO] VMCORE LOGFILE
       makedumpfile -h
       makedumpfile -v

DESCRIPTION

       With  kdump,  the  memory  image  of the first kernel (called "panicked
       kernel") can be taken as /proc/vmcore while the second  kernel  (called
       "kdump   kernel"   or  "capture  kernel")  is  running.  This  document
       represents /proc/vmcore as VMCORE. makedumpfile makes a small  DUMPFILE
       by  compressing  dump  data  or  by  excluding  unnecessary  pages  for
       analysis,  or  both.  makedumpfile  needs  the  first  kernel's   debug
       information,  so that it can distinguish unnecessary pages by analyzing
       how the first kernel uses the memory.  The  information  can  be  taken
       from VMLINUX or VMCOREINFO.

       makedumpfile  can  exclude  the  following types of pages while copying
       VMCORE to DUMPFILE, and a user can choose which type of pages  will  be
       excluded.
       - Pages filled with zero
       - Cache pages
       - User process data pages
       - Free pages

       makedumpfile  provides  two  DUMPFILE  formats  (the ELF format and the
       kdump-compressed format). By default, makedumpfile makes a DUMPFILE  in
       the  kdump-compressed  format.  The kdump-compressed format is readable
       only with the crash utility, and it can be smaller than the ELF  format
       because of the compression support. The ELF format is readable with GDB
       and the crash utility.  If a user wants to use GDB, DUMPFILE format has
       to be explicitly specified to be the ELF format.

       To  analyze  the first kernel's memory usage, makedumpfile can refer to
       VMCOREINFO instead of VMLINUX. VMCOREINFO contains the  first  kernel's
       information  (structure  size,  field  offset, etc.), and VMCOREINFO is
       small enough to be included into the second kernel's initrd.
       If the second kernel is running on its initrd without mounting  a  root
       file  system,  makedumpfile  cannot refer to VMLINUX because the second
       kernel's initrd cannot include a large file like VMLINUX. To solve  the
       problem,  makedumpfile  makes  VMCOREINFO  beforehand, and it refers to
       VMCOREINFO instead of VMLINUX while the second kernel is running.
       VMCORE has contained VMCOREINFO since linux-2.6.24, and a user does not
       need to specify neither -x nor -i option.

       If the second kernel is running on its initrd without mounting any file
       system, a user needs to transport the dump data to a  remote  host.  To
       transport  the  dump data by SSH, makedumpfile outputs the dump data in
       the intermediate format (the flattened format) to the standard  output.
       By piping the output data to SSH, a user can transport the dump data to
       a remote host. Note that  analysis  tools  cannot  read  the  flattened
       format directly, so on a remote host the received data in the flattened
       format needs  to  be  rearranged  to  a  readable  DUMPFILE  format  by
       makedumpfile (or makedumpfile-R.pl).

       makedumpfile can read a DUMPFILE in the kdump-compressed format instead
       of VMCORE and re-filter it. This feature is useful  in  situation  that
       users need to reduce the file size of DUMPFILE for sending it somewhere
       by ftp/scp/etc. (If all of the page types, which are specified by a new
       dump_level,  are  excluded  from  an  original  DUMPFILE already, a new
       DUMPFILE is the same as an original DUMPFILE.)
       For example, makedumpfile can create a DUMPFILE of dump_level  31  from
       the one of dump_level 3 like the following:
       Example:
       # makedumpfile -c -d 3 /proc/vmcore dumpfile.1
       # makedumpfile -c -d 31 dumpfile.1 dumpfile.2

OPTIONS

       -c     Compress dump data by each page.
              A  user  cannot  specify this option with -E option, because the
              ELF format does not support compressed data.
              Example:
              # makedumpfile -c -d 31 -x vmlinux /proc/vmcore dumpfile

       -d dump_level
              Specify the type of unnecessary page for analysis.
              Pages of the specified type are not copied to DUMPFILE. The page
              type  marked  in  the  following  table  is excluded. A user can
              specify multiple page types by setting the sum of each page type
              for  dump_level.  The  maximum  of dump_level is 31. Note that a
              dump_level for Xen dump filtering is 0 or 1 on a  machine  other
              than  x86_64  (On an x86_64 machine, it is possible to specify 2
              or bigger as a dump_level).
              If specifying  multiple  dump_levels  with  the  delimiter  ',',
              makedumpfile  retries  to  create a DUMPFILE by other dump_level
              when "No  space  on  device"  error  happens.  For  example,  if
              dump_level  is  "11,31" and makedumpfile fails by dump_level 11,
              makedumpfile retries it by dump_level 31.
              Example:
              # makedumpfile -d 11 -x vmlinux /proc/vmcore dumpfile
              # makedumpfile -d 11,31 -x vmlinux /proc/vmcore dumpfile

                dump | zero | cache|cache  | user | free
               level | page | page |private| data | page
              -------+------+------+-------+------+------
                   0 |      |      |       |      |
                   1 |  X   |      |       |      |
                   2 |      |  X   |       |      |
                   3 |  X   |  X   |       |      |
                   4 |      |  X   |  X    |      |
                   5 |  X   |  X   |  X    |      |
                   6 |      |  X   |  X    |      |
                   7 |  X   |  X   |  X    |      |
                   8 |      |      |       |  X   |
                   9 |  X   |      |       |  X   |
                  10 |      |  X   |       |  X   |
                  11 |  X   |  X   |       |  X   |
                  12 |      |  X   |  X    |  X   |
                  13 |  X   |  X   |  X    |  X   |
                  14 |      |  X   |  X    |  X   |
                  15 |  X   |  X   |  X    |  X   |
                  16 |      |      |       |      |  X
                  17 |  X   |      |       |      |  X
                  18 |      |  X   |       |      |  X
                  19 |  X   |  X   |       |      |  X
                  20 |      |  X   |  X    |      |  X
                  21 |  X   |  X   |  X    |      |  X
                  22 |      |  X   |  X    |      |  X
                  23 |  X   |  X   |  X    |      |  X
                  24 |      |      |       |  X   |  X
                  25 |  X   |      |       |  X   |  X
                  26 |      |  X   |       |  X   |  X
                  27 |  X   |  X   |       |  X   |  X
                  28 |      |  X   |  X    |  X   |  X
                  29 |  X   |  X   |  X    |  X   |  X
                  30 |      |  X   |  X    |  X   |  X
                  31 |  X   |  X   |  X    |  X   |  X

       -E     Create DUMPFILE in the ELF format.
              This option cannot be specified with -c option, because the  ELF
              format does not support compressed data.
              Example:
              # makedumpfile -E -d 31 -x vmlinux /proc/vmcore dumpfile

       -f     Force existing DUMPFILE to be overwritten.
              Example:
              # makedumpfile -f -d 31 -x vmlinux /proc/vmcore dumpfile
              This command overwrites DUMPFILE even if it already exists.

       -x VMLINUX
              Specify  the  first  kernel's  VMLINUX with debug information to
              analyze the first kernel's memory usage.
              This option is necessary if VMCORE does not contain  VMCOREINFO,
              [-i VMCOREINFO] is not specified, and dump_level is 2 or more.
              The  page  size of the first kernel and the second kernel should
              match.
              Example:
              # makedumpfile -d 31 -x vmlinux /proc/vmcore dumpfile

       -i VMCOREINFO
              Specify VMCOREINFO instead of VMLINUX for  analyzing  the  first
              kernel's memory usage.
              VMCOREINFO  should  be  made  beforehand by makedumpfile with -g
              option, and it contains the first kernel's information.
              This option is necessary if VMCORE does not contain  VMCOREINFO,
              [-x VMLINUX] is not specified, and dump_level is 2 or more.
              Example:
              # makedumpfile -d 31 -i vmcoreinfo /proc/vmcore dumpfile

       -g VMCOREINFO
              Generate  VMCOREINFO  from the first kernel's VMLINUX with debug
              information.
              VMCOREINFO must be generated on the system that is  running  the
              first  kernel.  With  -i  option,  a user can specify VMCOREINFO
              generated on the other system that is  running  the  same  first
              kernel. [-x VMLINUX] must be specified.
              Example:
              # makedumpfile -g vmcoreinfo -x vmlinux

       -F     Output  the  dump  data  in the flattened format to the standard
              output for transporting the dump data by SSH.
              Analysis tools cannot read the flattened  format  directly.  For
              analysis,  the  dump  data  in  the  flattened  format should be
              rearranged to a normal DUMPFILE (readable with  analysis  tools)
              by  -R  option. By which option is specified with -F option, the
              format of the rearranged DUMPFILE is fixed.  In other words,  it
              is  impossible to specify the DUMPFILE format when the dump data
              is rearranged with -R option. If specifying -E  option  with  -F
              option, the format of the rearranged DUMPFILE is the ELF format.
              Otherwise, it is the kdump-compressed format. All  the  messages
              are  output  to  standard  error  output  by  -F  option because
              standard output is used for the dump data.
              Example:
              # makedumpfile -F -c -d 31 -x vmlinux /proc/vmcore \
              | ssh user@host "cat &gt; dumpfile.tmp"
              # makedumpfile -F -c -d 31 -x vmlinux /proc/vmcore \
              | ssh user@host "makedumpfile -R dumpfile"
              # makedumpfile -F -E -d 31 -i vmcoreinfo  /proc/vmcore \
              | ssh user@host "makedumpfile -R dumpfile"
              # makedumpfile -F -E --xen-vmcoreinfo VMCOREINFO /proc/vmcore \
              | ssh user@host "makedumpfile -R dumpfile"

       -R     Rearrange the  dump  data  in  the  flattened  format  from  the
              standard  input  to  a  normal  DUMPFILE (readable with analysis
              tools).
              Example:
              # makedumpfile -R dumpfile &lt; dumpfile.tmp
              # makedumpfile -F -d 31 -x vmlinux /proc/vmcore \
              | ssh user@host "makedumpfile -R dumpfile"

              Instead of using -R option, a  perl  script  "makedumpfile-R.pl"
              rearranges  the  dump  data  in the flattened format to a normal
              DUMPFILE, too. The perl script does not depend on  architecture,
              and  most systems have perl command.  Even if a remote host does
              not have makedumpfile, it is possible to rearrange the dump data
              in  the flattened format to a readable DUMPFILE on a remote host
              by running this script.
              Example:
              # makedumpfile -F -d 31 -x vmlinux /proc/vmcore \
              | ssh user@host "makedumpfile-R.pl dumpfile"

       --split
              Split the dump  data  to  multiple  DUMPFILEs  in  parallel.  If
              specifying  DUMPFILEs on different storage devices, a device can
              share I/O load with other devices and it reduces time for saving
              the  dump  data.  The file size of each DUMPFILE is smaller than
              the system memory  size  which  is  divided  by  the  number  of
              DUMPFILEs.  This  feature  supports  only  the  kdump-compressed
              format.
              Example:
              # makedumpfile --split -d 31 -x vmlinux  /proc/vmcore  dumpfile1
              dumpfile2

       --reassemble
              Reassemble  multiple  DUMPFILEs,  which  are  created by --split
              option,  into  one  DUMPFILE.  dumpfile1   and   dumpfile2   are
              reassembled into dumpfile on the following example.
              Example:
              # makedumpfile --reassemble dumpfile1 dumpfile2 dumpfile

       --xen-syms XEN-SYMS
              Specify the XEN-SYMS with debug information to analyze the xen's
              memory  usage.   This  option  extracts  the  part  of  xen  and
              domain-0.  -E option must be specified with this option.
              Example:
              # makedumpfile -E --xen-syms xen-syms /proc/vmcore dumpfile

       --xen-vmcoreinfo VMCOREINFO
              Specify  VMCOREINFO  instead of XEN-SYMS for analyzing the xen's
              memory usage.
              VMCOREINFO should be made beforehand  by  makedumpfile  with  -g
              option,  and  it contains the xen's information.  -E option must
              be specified with this option.
              Example:
              #  makedumpfile  -E  --xen-vmcoreinfo  VMCOREINFO   /proc/vmcore
              dumpfile

       -X     Exclude  all  the user domain pages from Xen kdump's VMCORE, and
              extracts the part  of  xen  and  domain-0.  If  VMCORE  contains
              VMCOREINFO  for  Xen,  it is not necessary to specify --xen-syms
              and --xen-vmcoreinfo.  -E option must  be  specified  with  this
              option.
              Example:
              # makedumpfile -E -X /proc/vmcore dumpfile

       --xen_phys_start xen_phys_start_address
              This    option    is    only    for    x86_64.     Specify   the
              xen_phys_start_address, if the xen code/data is relocatable  and
              VMCORE does not contain xen_phys_start_address in the CRASHINFO.
              xen_phys_start_address can be taken from the line of "Hypervisor
              code  and  data" in /proc/iomem. For example, specify 0xcee00000
              as xen_phys_start_address if /proc/iomem is the following:
                -------------------------------------------------------
                # cat /proc/iomem
                ...
                  cee00000-cfd99999 : Hypervisor code and data
                ...
                -------------------------------------------------------

              Example:
              # makedumpfile -E -X  --xen_phys_start  0xcee00000  /proc/vmcore
              dumpfile

       --message-level message_level
              Specify the message types.
              Users  can  restrict outputs printed by specifying message_level
              with this option. The message type  marked  with  an  X  in  the
              following table is printed. For example, according to the table,
              specifying 7 as message_level means progress  indicator,  common
              message,  and  error  message are printed, and this is a default
              value. Note that the maximum value of message_level is 31.

               message | progress | common  | error   | debug   | report
               level   | indicator| message | message | message | message
              ---------+----------+---------+---------+---------+---------
                     0 |          |         |         |         |
                     1 |    X     |         |         |         |
                     2 |          |    X    |         |         |
                     3 |    X     |    X    |         |         |
                     4 |          |         |    X    |         |
                     5 |    X     |         |    X    |         |
                     6 |          |    X    |    X    |         |
                   * 7 |    X     |    X    |    X    |         |
                     8 |          |         |         |    X    |
                     9 |    X     |         |         |    X    |
                    10 |          |    X    |         |    X    |
                    11 |    X     |    X    |         |    X    |
                    12 |          |         |    X    |    X    |
                    13 |    X     |         |    X    |    X    |
                    14 |          |    X    |    X    |    X    |
                    15 |    X     |    X    |    X    |    X    |
                    16 |          |         |         |         |    X
                    17 |    X     |         |         |         |    X
                    18 |          |    X    |         |         |    X
                    19 |    X     |    X    |         |         |    X
                    20 |          |         |    X    |         |    X
                    21 |    X     |         |    X    |         |    X
                    22 |          |    X    |    X    |         |    X
                    23 |    X     |    X    |    X    |         |    X
                    24 |          |         |         |    X    |    X
                    25 |    X     |         |         |    X    |    X
                    26 |          |    X    |         |    X    |    X
                    27 |    X     |    X    |         |    X    |    X
                    28 |          |         |    X    |    X    |    X
                    29 |    X     |         |    X    |    X    |    X
                    30 |          |    X    |    X    |    X    |    X
                    31 |    X     |    X    |    X    |    X    |    X

       --vtop virtual_address
              This option is useful, when user debugs the translation  problem
              of  virtual  address. If specifing virtual_address, its physical
              address is printed. It makes debugging  easy  by  comparing  the
              output  of  this option with the one of "vtop" subcommand of the
              crash utility.  "--vtop"  option  only  prints  the  translation
              output, and it does not affect the dumpfile creation.

       --dump-dmesg
              This  option  overrides  the  normal  behavior  of makedumpfile.
              Instead of  compressing  and  filtering  a  VMCORE  to  make  it
              smaller,  it  simply  extracts  the  dmesg log from a VMCORE and
              writes it to the specified LOGFILE. If a VMCORE does not contain
              VMCOREINFO for dmesg, it is necessary to specfiy [-x VMLINUX] or
              [-i VMCOREINFO].

              Example:
              # makedumpfile --dump-dmesg /proc/vmcore dmesgfile
              # makedumpfile --dump-dmesg -x vmlinux /proc/vmcore dmesgfile

       -D     Print debugging message.

       -h     Show help message.

       -v     Show the version of makedumpfile.

ENVIRONMENT VARIABLES

       TMPDIR  This environment variable is  for  a  temporary  memory  bitmap
               file.   If  your machine has a lots of memory and you use tmpfs
               on /tmp, makedumpfile can fail for a little memory in  the  2nd
               kernel because makedumpfile makes a very large temporary memory
               bitmap file in this case. To avoid this failure, you can set  a
               TMPDIR  environment  variable.  If  you  do  not  set  a TMPDIR
               environment variable, makedumpfile uses /tmp  directory  for  a
               temporary bitmap file as a default.

DIAGNOSTICS

       makedumpfile exits with the following value.

       0 : makedumpfile succeeded.

       1 : makedumpfile failed without the following reasons.

       2  :  makedumpfile failed due to the different version between  VMLINUX
       and VMCORE.

       3 : makedumpfile failed due to the analysis error of the memory.

AUTHORS

       Written by Masaki Tachibana, and Ken'ichi Ohmichi.
</code></pre>

<p>precise (8) <a href="http://manpages.ubuntu.com/manpages.gz/precise/man8/makedumpfile.8.gz">makedumpfile.8.gz</a></p>

<p>Provided by: <a href="https://launchpad.net/ubuntu/precise/+package/makedumpfile">makedumpfile_1.3.7-2_i386</a></p>
]]></content>
  </entry>
  
</feed>
