<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 2015 | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/2015/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2015-01-03T23:26:57+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[中断，进程]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/01/03/kernel-sched-irq-mark/"/>
    <updated>2015-01-03T15:45:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/01/03/kernel-sched-irq-mark</id>
    <content type="html"><![CDATA[<p>blog.chinaunix.net/uid-20806345-id-3203602.html</p>

<p>  中断不是进程，不受内核调度器的管辖。在系统处理进程的过程中，对于某个cpu来说，如果有内部中断或外部中断到来，则切换到中断处理程序，切换首先要将进程由用户态要切到进程的内核态，然后再将cpu切换到中断态，待处理完中断返回进程的内核态，再返回进程的用户态，如果中断时进程刚好处于内核态中不用由用户态切到内核态了。<br/>
  中断处理时是不分优先级的，处理中断的过程中如果有任意中断到来，都会抢占当前的中断处理过程。所以对于要及时响应的中断，需要通过关中断来屏蔽其他中断。通常所说的中断优先级是指中断控制器端的优先级，当有多个中断触发时，首先选择优先级高的中断发出请求给处理器。中断优先级只是对中断控制器而言的，所有的中断对cpu来说都是一样的，没有优先级高低之分。<br/>
  关中断是关闭所有的外部可屏蔽中断，和优先级没有关系，如果在某中断处理程序中关中断，则不会被任何可屏蔽中断抢占，但是会被任意的不可屏蔽中断抢占。关中断是中断处理程序可选的。</p>

<p>bbs.chinaunix.net/thread-2306027-1-8.html</p>

<p>软中断做的是一些可延迟的费时间的事，当然不能在中断里执行了。<br/>
  <code>__do_softirq</code>代码，可以看到在执行可延迟函数第一件事就是开中断。但在开始之前，禁用了下半部中断（<code>__local_bh_disable</code>）。这样就算被中断了，返回内核时也不会被抢占，还是执行这里的代码。也不会被调度。<br/>
  那么这样的后果就是软中断上下文里的会一直执行下去，直到到达了限定次数，然后唤醒守护进程。<br/>
  因为软中断切换了栈，不再使用进程上下文，那么如果在软中断上下文直接或简洁调用了shedule，那么只有死翘翘了！！因为schedule调度回来的时候是依赖进程内核栈的thread_info。</p>

<p>  内核抢占点之一就是中断返回的时候检查是否可以抢占，检查的内容之一就是preempt_count是否等于0，因为禁用了下半部中断，那么肯定就不会等于0的，所以不会被抢占。也就是说返回的时候不会发生调度。</p>

<p>  个人理解 中断上下文 最大的特征 禁掉了某种中断（硬中断和软中断），所以导致 不能阻塞。<br/>
  softirq 有可能在两种方式下被调用，一是中断处理程序退出时，开放硬件中断之后，会去调用do_softirq()。
  do_softirq()会禁掉后半部抢占，并且现在执行流使用的是被中断的进程的栈，所以无法阻塞。<br/>
  softirq的另一种调用方式是ksoftirq内核线程，同样do_softirq()被调用，后半部中断被禁掉，同样禁止阻塞。<br/>
  工作队列，可以被任何中断或者软中断中断，运行在进程上下文，有自己的栈，可以阻塞。</p>

<p>看一下__do_softirq()的代码,新的硬中断确实可能触发更高优先级的软中断，但是这个软中断并不会在被中断的软中断之前得到执行，软中断始终是顺序执行的。从代码看来，新一批的软中断，无论优先级多高，也得等到前一批的软中断被处理完成之后才能得到处理。而优先级只能帮助软中断在对应的批次中优先得到处理。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[硬中断和软中断]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/01/03/kernel-sched-irq/"/>
    <updated>2015-01-03T15:15:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/01/03/kernel-sched-irq</id>
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/zhangskd/article/details/21992933">http://blog.csdn.net/zhangskd/article/details/21992933</a></p>

<h4>概述</h4>

<p>从本质上来讲，中断是一种电信号，当设备有某种事件发生时，它就会产生中断，通过总线把电信号发送给中断控制器。
如果中断的线是激活的，中断控制器就把电信号发送给处理器的某个特定引脚。处理器于是立即停止自己正在做的事，
跳到中断处理程序的入口点，进行中断处理。</p>

<h5>(1) 硬中断</h5>

<p>由与系统相连的外设(比如网卡、硬盘)自动产生的。主要是用来通知操作系统系统外设状态的变化。比如当网卡收到数据包的时候，就会发出一个中断。我们通常所说的中断指的是硬中断(hardirq)。</p>

<h5>(2) 软中断</h5>

<p>为了满足实时系统的要求，中断处理应该是越快越好。linux为了实现这个特点，当中断发生的时候，硬中断处理那些短时间就可以完成的工作，而将那些处理事件比较长的工作，放到中断之后来完成，也就是软中断(softirq)来完成。</p>

<h5>(3) 中断嵌套</h5>

<p>Linux下硬中断是可以嵌套的，但是没有优先级的概念，也就是说任何一个新的中断都可以打断正在执行的中断，但同种中断除外。软中断不能嵌套，但相同类型的软中断可以在不同CPU上并行执行。</p>

<h5>(4) 软中断指令</h5>

<p>int是软中断指令。<br/>
中断向量表是中断号和中断处理函数地址的对应表。<br/>
int n - 触发软中断n。相应的中断处理函数的地址为：中断向量表地址 + 4 * n。</p>

<h5>(5)硬中断和软中断的区别</h5>

<p>软中断是执行中断指令产生的，而硬中断是由外设引发的。<br/>
硬中断的中断号是由中断控制器提供的，软中断的中断号由指令直接指出，无需使用中断控制器。<br/>
硬中断是可屏蔽的，软中断不可屏蔽。<br/>
硬中断处理程序要确保它能快速地完成任务，这样程序执行时才不会等待较长时间，称为上半部。<br/>
软中断处理硬中断未完成的工作，是一种推后执行的机制，属于下半部。</p>

<h4>开关</h4>

<h5>(1) 硬中断的开关</h5>

<p>简单禁止和激活当前处理器上的本地中断：
<code>
local_irq_disable();
local_irq_enable();
</code>
保存本地中断系统状态下的禁止和激活：
<code>
unsigned long flags;
local_irq_save(flags);
local_irq_restore(flags);
</code></p>

<h5>(2) 软中断的开关</h5>

<p>禁止下半部，如softirq、tasklet和workqueue等：
<code>
local_bh_disable();
local_bh_enable();
</code>
需要注意的是，禁止下半部时仍然可以被硬中断抢占。</p>

<h5>(3) 判断中断状态</h5>

<pre><code>    #define in_interrupt() (irq_count()) // 是否处于中断状态(硬中断或软中断)
    #define in_irq() (hardirq_count()) // 是否处于硬中断
    #define in_softirq() (softirq_count()) // 是否处于软中断
</code></pre>

<h4>硬中断</h4>

<h5>(1) 注册中断处理函数</h5>

<p>注册中断处理函数：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/&lt;em&gt;&lt;em&gt;
</span><span class='line'> * irq: 要分配的中断号
</span><span class='line'> * handler: 要注册的中断处理函数
</span><span class='line'> * flags: 标志(一般为0)
</span><span class='line'> * name: 设备名(dev-&gt;name)
</span><span class='line'> * dev: 设备(struct net_device &lt;/em&gt;dev)，作为中断处理函数的参数
</span><span class='line'> * 成功返回0
</span><span class='line'> &lt;/em&gt;/&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;int request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags,   
</span><span class='line'>const char *name, void *dev);  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>中断处理函数本身：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;typedef irqreturn_t (*irq_handler_t) (int, void *);  
</span><span class='line'>
</span><span class='line'>/** 
</span><span class='line'> * enum irqreturn 
</span><span class='line'> * @IRQ_NONE: interrupt was not from this device 
</span><span class='line'> * @IRQ_HANDLED: interrupt was handled by this device 
</span><span class='line'> * @IRQ_WAKE_THREAD: handler requests to wake the handler thread 
</span><span class='line'> */  
</span><span class='line'>enum irqreturn {  
</span><span class='line'>IRQ_NONE,  
</span><span class='line'>IRQ_HANDLED,  
</span><span class='line'>IRQ_WAKE_THREAD,  
</span><span class='line'>};  
</span><span class='line'>typedef enum irqreturn irqreturn_t;  
</span><span class='line'>#define IRQ_RETVAL(x) ((x) != IRQ_NONE)  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>##### (2) 注销中断处理函数
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;/** 
</span><span class='line'> * free_irq - free an interrupt allocated with request_irq 
</span><span class='line'> * @irq: Interrupt line to free 
</span><span class='line'> * @dev_id: Device identity to free 
</span><span class='line'> * 
</span><span class='line'> * Remove an interrupt handler. The handler is removed and if the 
</span><span class='line'> * interrupt line is no longer in use by any driver it is disabled. 
</span><span class='line'> * On a shared IRQ the caller must ensure the interrupt is disabled 
</span><span class='line'> * on the card it drives before calling this function. The function does 
</span><span class='line'> * not return until any executing interrupts for this IRQ have completed. 
</span><span class='line'> * This function must not be called from interrupt context. 
</span><span class='line'> */  
</span><span class='line'>
</span><span class='line'>void free_irq(unsigned int irq, void *dev_id);  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>#### 软中断
</span><span class='line'>##### (1) 定义
</span><span class='line'>软中断是一组静态定义的下半部接口，可以在所有处理器上同时执行，即使两个类型相同也可以。  
</span><span class='line'>但一个软中断不会抢占另一个软中断，唯一可以抢占软中断的是硬中断。
</span><span class='line'>
</span><span class='line'>软中断由softirq_action结构体表示：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;struct softirq_action {  
</span><span class='line'>void (*action) (struct softirq_action *); /* 软中断的处理函数 */  
</span><span class='line'>};  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>目前已注册的软中断有10种，定义为一个全局数组：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static struct softirq_action softirq_vec[NR_SOFTIRQS];  
</span><span class='line'>
</span><span class='line'>enum {  
</span><span class='line'>HI_SOFTIRQ = 0, /* 优先级高的tasklets */  
</span><span class='line'>TIMER_SOFTIRQ, /* 定时器的下半部 */  
</span><span class='line'>NET_TX_SOFTIRQ, /* 发送网络数据包 */  
</span><span class='line'>NET_RX_SOFTIRQ, /* 接收网络数据包 */  
</span><span class='line'>BLOCK_SOFTIRQ, /* BLOCK装置 */  
</span><span class='line'>BLOCK_IOPOLL_SOFTIRQ,  
</span><span class='line'>TASKLET_SOFTIRQ, /* 正常优先级的tasklets */  
</span><span class='line'>SCHED_SOFTIRQ, /* 调度程序 */  
</span><span class='line'>HRTIMER_SOFTIRQ, /* 高分辨率定时器 */  
</span><span class='line'>RCU_SOFTIRQ, /* RCU锁定 */  
</span><span class='line'>NR_SOFTIRQS /* 10 */  
</span><span class='line'>};  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>##### (2) 注册软中断处理函数
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;/** 
</span><span class='line'> * @nr: 软中断的索引号 
</span><span class='line'> * @action: 软中断的处理函数 
</span><span class='line'> */  
</span><span class='line'>
</span><span class='line'>void open_softirq(int nr, void (*action) (struct softirq_action *))  
</span><span class='line'>{  
</span><span class='line'>softirq_vec[nr].action = action;  
</span><span class='line'>}  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;例如：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;open_softirq(NET_TX_SOFTIRQ, net_tx_action);
</span><span class='line'>open_softirq(NET_RX_SOFTIRQ, net_rx_action);</span></code></pre></td></tr></table></div></figure></p>

<h5>(3) 触发软中断</h5>

<p>调用raise_softirq()来触发软中断。
```
    void raise_softirq(unsigned int nr)<br/>
    {<br/>
        unsigned long flags;<br/>
        local_irq_save(flags);<br/>
        raise_softirq_irqoff(nr);<br/>
        local_irq_restore(flags);<br/>
    }</p>

<pre><code>/* This function must run with irqs disabled */  
inline void rasie_softirq_irqsoff(unsigned int nr)  
{  
    __raise_softirq_irqoff(nr);  

    /* If we're in an interrupt or softirq, we're done 
     * (this also catches softirq-disabled code). We will 
     * actually run the softirq once we return from the irq 
     * or softirq. 
     * Otherwise we wake up ksoftirqd to make sure we 
     * schedule the softirq soon. 
     */  
    if (! in_interrupt()) /* 如果不处于硬中断或软中断 */  
        wakeup_softirqd(void); /* 唤醒ksoftirqd/n进程 */  
}  
</code></pre>

<pre><code>
Percpu变量irq_cpustat_t中的__softirq_pending是等待处理的软中断的位图，通过设置此变量

即可告诉内核该执行哪些软中断。
</code></pre>

<pre><code>static inline void __rasie_softirq_irqoff(unsigned int nr)  
{  
    trace_softirq_raise(nr);  
    or_softirq_pending(1UL &lt;&lt; nr);  
}  

typedef struct {  
    unsigned int __softirq_pending;  
    unsigned int __nmi_count; /* arch dependent */  
} irq_cpustat_t;  

irq_cpustat_t irq_stat[];  
#define __IRQ_STAT(cpu, member) (irq_stat[cpu].member)  
#define or_softirq_pending(x) percpu_or(irq_stat.__softirq_pending, (x))  
#define local_softirq_pending() percpu_read(irq_stat.__softirq_pending)  
</code></pre>

<pre><code>
唤醒ksoftirqd内核线程处理软中断。
</code></pre>

<pre><code>static void wakeup_softirqd(void)  
{  
    /* Interrupts are disabled: no need to stop preemption */  
    struct task_struct *tsk = __get_cpu_var(ksoftirqd);  

    if (tsk &amp;&amp; tsk-&gt;state != TASK_RUNNING)  
        wake_up_process(tsk);  
}  
</code></pre>

<pre><code>
在下列地方，待处理的软中断会被检查和执行：  
1. 从一个硬件中断代码处返回时  
2. 在ksoftirqd内核线程中  
3. 在那些显示检查和执行待处理的软中断的代码中，如网络子系统中

而不管是用什么方法唤起，软中断都要在do_softirq()中执行。如果有待处理的软中断，do_softirq()会循环遍历每一个，调用它们的相应的处理程序。在中断处理程序中触发软中断是最常见的形式。中断处理程序执行硬件设备的相关操作，然后触发相应的软中断，最后退出。内核在执行完中断处理程序以后，马上就会调用do_softirq()，于是软中断开始执行中断处理程序完成剩余的任务。

下面来看下do_softirq()的具体实现。
</code></pre>

<pre><code>asmlinkage void do_softirq(void)  
{  
    __u32 pending;  
    unsigned long flags;  

    /* 如果当前已处于硬中断或软中断中，直接返回 */  
    if (in_interrupt())   
        return;  

    local_irq_save(flags);  
    pending = local_softirq_pending();  
    if (pending) /* 如果有激活的软中断 */  
        __do_softirq(); /* 处理函数 */  
    local_irq_restore(flags);  
}  
</code></pre>

<p><code>
</code>
    /<em> We restart softirq processing MAX_SOFTIRQ_RESTART times,
     * and we fall back to softirqd after that.
     * This number has been established via experimentation.
     * The two things to balance is latency against fairness - we want
     * to handle softirqs as soon as possible, but they should not be
     * able to lock up the box.
     </em>/<br/>
    asmlinkage void <strong>do_softirq(void)<br/>
    {<br/>
        struct softirq_action *h;<br/>
        </strong>u32 pending;<br/>
        /<em> 本函数能重复触发执行的次数，防止占用过多的cpu时间 </em>/<br/>
        int max_restart = MAX_SOFTIRQ_RESTART;<br/>
        int cpu;</p>

<pre><code>    pending = local_softirq_pending(); /* 激活的软中断位图 */  
    account_system_vtime(current);  
    /* 本地禁止当前的软中断 */  
    __local_bh_disable((unsigned long)__builtin_return_address(0), SOFTIRQ_OFFSET);  
    lockdep_softirq_enter(); /* current-&gt;softirq_context++ */  
    cpu = smp_processor_id(); /* 当前cpu编号 */  

restart:  
    /* Reset the pending bitmask before enabling irqs */  
    set_softirq_pending(0); /* 重置位图 */  
    local_irq_enable();  
    h = softirq_vec;  
    do {  
        if (pending &amp; 1) {  
            unsigned int vec_nr = h - softirq_vec; /* 软中断索引 */  
            int prev_count = preempt_count();  
            kstat_incr_softirqs_this_cpu(vec_nr);  

            trace_softirq_entry(vec_nr);  
            h-&gt;action(h); /* 调用软中断的处理函数 */  
            trace_softirq_exit(vec_nr);  

            if (unlikely(prev_count != preempt_count())) {  
                printk(KERN_ERR "huh, entered softirq %u %s %p" "with preempt_count %08x,"  
                    "exited with %08x?\n", vec_nr, softirq_to_name[vec_nr], h-&gt;action, prev_count,  
                    preempt_count());  
            }  
            rcu_bh_qs(cpu);  
        }  
        h++;  
        pending &gt;&gt;= 1;  
    } while(pending);  

    local_irq_disable();  
    pending = local_softirq_pending();  
    if (pending &amp; --max_restart) /* 重复触发 */  
        goto restart;  

    /* 如果重复触发了10次了，接下来唤醒ksoftirqd/n内核线程来处理 */  
    if (pending)  
        wakeup_softirqd();   

    lockdep_softirq_exit();  
    account_system_vtime(current);  
    __local_bh_enable(SOFTIRQ_OFFSET);  
}  
</code></pre>

<pre><code>
##### (4) ksoftirqd内核线程
内核不会立即处理重新触发的软中断。  
当大量软中断出现的时候，内核会唤醒一组内核线程来处理。  
这些线程的优先级最低(nice值为19)，这能避免它们跟其它重要的任务抢夺资源。  
但它们最终肯定会被执行，所以这个折中的方案能够保证在软中断很多时用户程序不会因为得不到处理时间而处于饥饿状态，同时也保证过量的软中断最终会得到处理。

每个处理器都有一个这样的线程，名字为ksoftirqd/n，n为处理器的编号。
</code></pre>

<pre><code>static int run_ksoftirqd(void *__bind_cpu)  
{  
    set_current_state(TASK_INTERRUPTIBLE);  
    current-&gt;flags |= PF_KSOFTIRQD; /* I am ksoftirqd */  

    while(! kthread_should_stop()) {  
        preempt_disable();  

        if (! local_softirq_pending()) { /* 如果没有要处理的软中断 */  
            preempt_enable_no_resched();  
            schedule();  
            preempt_disable():  
        }  

        __set_current_state(TASK_RUNNING);  

        while(local_softirq_pending()) {  
            /* Preempt disable stops cpu going offline. 
             * If already offline, we'll be on wrong CPU: don't process. 
             */  
             if (cpu_is_offline(long)__bind_cpu))/* 被要求释放cpu */  
                 goto wait_to_die;  

            do_softirq(); /* 软中断的统一处理函数 */  

            preempt_enable_no_resched();  
            cond_resched();  
            preempt_disable();  
            rcu_note_context_switch((long)__bind_cpu);  
        }  

        preempt_enable();  
        set_current_state(TASK_INTERRUPTIBLE);  
    }  

    __set_current_state(TASK_RUNNING);  
    return 0;  

wait_to_die:  
    preempt_enable();  
    /* Wait for kthread_stop */  
    set_current_state(TASK_INTERRUPTIBLE);  
    while(! kthread_should_stop()) {  
        schedule();  
        set_current_state(TASK_INTERRUPTIBLE);  
    }  

    __set_current_state(TASK_RUNNING);  
    return 0;  
}
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于ksoftirqd进程]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/01/03/kernel-sched-ksoftirqd/"/>
    <updated>2015-01-03T15:01:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/01/03/kernel-sched-ksoftirqd</id>
    <content type="html"><![CDATA[<p>blog.chinaunix.net/uid-20737871-id-1881243.html</p>

<p>每个处理器都有一组辅助处理器软中断(和tasklet)的内核线程。当内核中出现大量软中断的时候，这些内核进程就会辅助处理它们。</p>

<h4>引入ksoftirq内核线程的原因：</h4>

<p>对于软中断，内核会选择在几个特殊时机进行处理。而在中断处理程序返回时处理是最常见的。软中断被触发的频率有时可能很高，更不利的是，处理函数有时还会 字形重复触发，那么就会导致用户空间进程无法获得足够的处理时间，因而处于饥饿状态。单纯的对重新触发的软中断采取不立即处理的策略，也无法让人接受。</p>

<h4>最初的解决方案：</h4>

<p>1）只要还有被触发并等待处理的软中断，本次执行就要负责处理，重新触发的软中断也在本次执行返回前被处理。这样做可以保证对内核的软中断采取即时处理的 方式，关键在于，对重新触发的软中断也会立即处理。当负载很高的时候，此时若有大量被触发的软中断，而它们本身又会重复触发。系统可能会一直处理软中断根 本不能完成其他任务。</p>

<p>2）不处理重新触发的软中断。在从中断返回的时候，内核和平常一样，也会检查所有挂起的软中断并处理他们。但是，任何自行重新触发的软中断不会马上处理， 它们被放到下一个软中断执行时机去处理。而这个时机通常也就是下一次中断返回的时候。可是，在比较空闲的系统中，立即处理软中断才是比较好的做法。尽管它 能保证用户空间不处于饥饿状态，但它却让软中断忍受饥饿的痛苦，而根本没有好好利用闲置的系统资源。</p>

<h4>改进：</h4>

<p>最终在内核中实现的方案是不会立即处理处理重新触发的软中断。而作为改进，当大量软中断出现的时候，内核会唤醒一组内核线程来处理这些负载。这些线程在最 低的优先级上运行（nice值是19），这能避免它们跟其他重要的任务抢夺资源。但它们最终肯定会被执行，所以这个折中方案能够保证在软中断负担很中的时 候用户程序不会因为得不到处理时间处于饥饿状态。相应的，也能保证”过量“的软中断终究会得到处理。</p>

<p>每个处理器都有一个这样的线程。所有线程的名字都叫做ksoftirq/n，区别在于n，它对应的是处理器的编号。在一个双CPU的机器上就有两个这样的 线程，分别叫做ksoftirqd/0和ksoftirqd/1。为了保证只要有空闲的处理器，它们就会处理软中断，所以给每个处理器都分配一个这样的线 程。一旦该线程被初始化，它就会执行类似下面这样的死循环：</p>

<p>在kernel/softirq.c中
<code>
    static int ksoftirqd(void * __bind_cpu)
    {
        set_user_nice(current, 19);
        current-&gt;flags |= PF_NOFREEZE;
        set_current_state(TASK_INTERRUPTIBLE);
        while (!kthread_should_stop()) {
            preempt_disable();
            if (!local_softirq_pending()) {
                preempt_enable_no_resched();
                schedule();
                preempt_disable();
            }
            __set_current_state(TASK_RUNNING);
            while (local_softirq_pending()) {
                /* Preempt disable stops cpu going offline.
                    If already offline, we'll be on wrong CPU:
                    don't process */
                if (cpu_is_offline((long)__bind_cpu))
                    goto wait_to_die;
                do_softirq();
                preempt_enable_no_resched();
                cond_resched();
                preempt_disable();
            }
            preempt_enable();
            set_current_state(TASK_INTERRUPTIBLE);
        }
        __set_current_state(TASK_RUNNING);
        return 0;
    wait_to_die:
        preempt_enable();
        /* Wait for kthread_stop */
        set_current_state(TASK_INTERRUPTIBLE);
        while (!kthread_should_stop()) {
            schedule();
            set_current_state(TASK_INTERRUPTIBLE);
        }
        __set_current_state(TASK_RUNNING);
        return 0;
    }
</code></p>

<p>只要有待处理的软中断(由softirq_pending()函数负责发现)，ksoftirq就会调用do_softirq去处理它们。通过重复执行这 样的操作，重新触发的软中断也会被执行。如果有必要，每次迭代后都会调用schedule()以便让更重要的进程得到处理机会。当所有需要执行的操作都完 成以后，该内核线程将自己设置为TASK_INTERRUPTIBLE状态，唤起调度程序选择其他可执行进程投入运行。</p>

<p>只要do_softirq()函数发现已经执行过的内核线程重新触发了它自己，软中断内核线程就会被唤醒.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[编译I9507V内核]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/01/03/android-I9507V-kernel/"/>
    <updated>2015-01-03T14:52:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/01/03/android-I9507V-kernel</id>
    <content type="html"><![CDATA[<p>源码地址 <a href="http://opensource.samsung.com/reception/receptionSub.do?method=sub&amp;sub=F&amp;searchValue=9507">http://opensource.samsung.com/reception/receptionSub.do?method=sub&amp;sub=F&amp;searchValue=9507</a></p>

<p>好像三星android4.3版本后的bootloader会检测是否三星自编译内核，不是的会开机提示一下，不影响正常使用。</p>

<p>按照README_Kernel.txt的做。</p>

<p>内核中说明是用4.7编译器，但是4.7编译出来的装上去会挂，不知道为什么。<br/>
但是换成4.6编译器就没问题。</p>

<p>最后作成boot.img
<code>
    mkbootimg --kernel zImage --ramdisk boot.img-ramdisk.cpio.gz --base 80200000 --ramdisk_offset 1FF8000 --pagesize 2048 --cmdline "console=null androidboot.hardware=qcom user_debug=31 msm_rtb.filter=0x3F ehci-hcd.park=3 maxcpus=4" -o boot.img
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[img.ext4格式]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/01/03/android-img.ext4/"/>
    <updated>2015-01-03T14:36:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/01/03/android-img.ext4</id>
    <content type="html"><![CDATA[<p>工具 <a href="https://github.com/abcdxyzk/ext4_utils">https://github.com/abcdxyzk/ext4_utils</a></p>

<h4>一、转换源文件为ext4格式</h4>

<p>然后，我们可以使用./simg2img src des命令来转换system.img.ext4格式文件了
<code>
    ./simg2img system.img.ext4 system.img
</code></p>

<h4>二、挂载镜像到指定目录</h4>

<p>然后挂载此img到一个目录上
<code>
    mount -o loop system.img sysmain
</code>
成功挂载。然后你就可以进入目录了查看里面的文件了！！！！！</p>

<h4>三、修改镜像内的文件</h4>

<p>这时候可以进入挂载的目录mysys里面查看各个文件，甚至是修改了。不过这时候要注意一点，就是保持文件的原始权限。</p>

<h4>四、打包文件</h4>

<p>当你所有文件搞定后，下来需要一个命令来打包了。
<code>
    ./mkuserimg.sh -s sysmain systest.img.ext4 ext4 tmp 512M
</code>
这里需要注意，temp是我在当前目录新建立的一个目录，后面的512M是这个镜像打包后占用空间大小。如果你不知道你的镜像包应该多大，你查看你景象挂载到目录后，这个景象分区的大小。</p>

<p>恩，当你完成以上步骤，新的systest.img.ext4成功生成了，好了，你可以在fastboot模式下刷入了！！！</p>
]]></content>
  </entry>
  
</feed>
