<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 2015 | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/2015/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2015-06-01T15:48:01+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SystemTap---嵌入C代码]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/06/01/debug-systemtap-with-c/"/>
    <updated>2015-06-01T15:36:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/06/01/debug-systemtap-with-c</id>
    <content type="html"><![CDATA[<ul>
<li>访问参数的值是以STAP_ARG_+参数名的形式，这种方式是最新版本的SystemTap中的方式。1.7及更早的版本是通过THIS->+参数名的方式, 返回值<code>THIS-&gt;__returnval</code></li>
</ul>


<hr />

<p><a href="http://www.4byte.cn/learning/53860.html">http://www.4byte.cn/learning/53860.html</a></p>

<p>  SystemTap支持guru模式，通过-g选项来以这种模式执行SystemTap脚本。在guru模式下，嵌入的C代码在“%{&ldquo;和“%}"标记之间，这些代码会原封不动地放到生成的模块中。嵌入的C代码不仅可以作为函数体，还可以出现在SystemTap描述中（例如函数等），示例如下：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>%{
</span><span class='line'>    #include &lt;linux/in.h&gt;
</span><span class='line'>    #include &lt;linux/ip.h&gt;
</span><span class='line'>%} /&lt;em&gt; &lt;&ndash; top level &lt;/em&gt;/&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;function read_iphdr:long(skb:long)
</span><span class='line'>%{
</span><span class='line'>struct iphdr *iph = ip_hdr((struct sk_buff *)STAP_ARG_skb);
</span><span class='line'>STAP_RETVALUE = (long)iph;
</span><span class='line'>%}
</span><span class='line'>
</span><span class='line'>/* Determines whether an IP packet is TCP, based on the iphdr: */
</span><span class='line'>function is_tcp_packet:long(iphdr)
</span><span class='line'>{
</span><span class='line'>protocol = @cast(iphdr, "iphdr")-&gt;protocol
</span><span class='line'>return (protocol == %{ IPPROTO_TCP %}) /* &lt;-- expression */
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>probe begin {
</span><span class='line'>printf("SystemTap start!\n");
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>probe kernel.function("ip_local_deliver") {
</span><span class='line'>iph = read_iphdr(pointer_arg(1));
</span><span class='line'>printf("tcp packet ? %s\n", is_tcp_packet(iph) ? "yes" : "no");
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>在这里read_iphdr函数就是使用嵌入的C代码作为函数体，is_tcp_packet中是作为systemtap辅助函数中的一部分。
</span><span class='line'>
</span><span class='line'>在使用嵌入C代码作为函数体的函数中，访问参数的值是以STAP_ARG_+参数名的形式，这种方式是最新版本的SystemTap中的方式。1.7及更早的版本是通过THIS-&gt;+参数名的方式。CentOS6.4中的SystemTap版本是1.8，所以你如果在SystemTap脚本中仍然使用老的访问方式会报错。同样，最新的设置返回值的方式是STAP_RETVALUE，1.7及更早的版本是THIS-&gt;__retvalue。
</span><span class='line'>
</span><span class='line'>由于在guru模式下，SystemTap对嵌入的C代码没有做任何的处理，所以如果在C代码中出现异常的访问或者其他错误，就会导致内核crash。不过SystemTap提供了kread宏来安全地访问指针，如下所示：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;struct net_device *dev;
</span><span class='line'>char *name;
</span><span class='line'>dev = kread(&amp;(skb-&gt;dev));
</span><span class='line'>name = kread(&amp;(dev-&gt;name));
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;还有一点要特别注意，所有的SystemTap函数和probe都是在关闭中断下执行，所以在所有嵌入的C代码中都不能睡眠！&lt;/p&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[SystemTap Beginner]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2015/06/01/debug-systemtap-beginner/"/&gt;
</span><span class='line'>&lt;updated&gt;2015-06-01T15:03:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2015/06/01/debug-systemtap-beginner&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;p&gt;&lt;a href="http://blog.csdn.net/kafeiflynn/article/details/6429976"&gt;http://blog.csdn.net/kafeiflynn/article/details/6429976&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h3&gt;SystemTap&lt;/h3&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;应用：&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  对管理员，SystemTap可用于监控系统性能，找出系统瓶颈，而对于开发者，可以查看他们的程序运行时在linux系统内核内部的运行情况。主要用于查看内核空间事件信息，对用户空间事件的探测，目前正加紧改进。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;安装&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;1、SystemTap的安装及使用需要针对正在使用的内核安装相应的kernel-devel、kernel-debuginfo和kernel-debuginfo-common包，以插入探针。&lt;br/&gt;
</span><span class='line'>2、安装SystemTap和SystemTap-runtime包&lt;br/&gt;
</span><span class='line'>3、使用如下命令测试一下：&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    stap -v -e 'probe vfs.read {printf("read performed/n"); exit()}'
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;为目标机产生SystemTap instrumentation:&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;这样就可以在一台机器上为多种内核产生SystemTap instrumentation，而且目标机上只安装SystemTap-runtime即可。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;操作如下：&lt;br/&gt;
</span><span class='line'>1.在目标机上安装systemtap-runtime RPM包；&lt;br/&gt;
</span><span class='line'>2.使用uname –r查看目标机内核；&lt;br/&gt;
</span><span class='line'>3.在host system上安装SystemTap；&lt;br/&gt;
</span><span class='line'>4.在host system上安装目标机内核及相关RPMs&lt;br/&gt;
</span><span class='line'>5.在host name上运行命令：&lt;br/&gt;
</span><span class='line'>&lt;code&gt;
</span><span class='line'>stap -r kernel_version script -m module_name
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;6.把新产生的模块拷贝到目标机，并运行如下命令：
</span><span class='line'>&lt;code&gt;
</span><span class='line'>staprun module_name.ko
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;注意：host system和目标机架构及操作系统版本必须一致。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;运行SystemTap脚本&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;运行stap和staprun需要被授以权限，一般用户需要运行SystemTap，则需要被加入到以下用户组的一个：&lt;br/&gt;
</span><span class='line'>1、stapdev：用stap编译SystemTap脚本成内核模块，并加载进内核；&lt;br/&gt;
</span><span class='line'>2、stapusr：仅能运行staprun加载/lib/modules/kernel_version/systemtap/目录下模块。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;SystemTap Flight Recorder模式&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;该模式允许长时间运行SystemTap脚本，但仅focus on 最近的输出，有2个变种：in-memory和file模式，两种情况下SystemTap都作为后台进程运行。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;In-memory模式：&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    stap -F iotime.stp
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;一旦脚本启动后，你可以看到以下输出信息以辅助命令重新连到运行中的脚本：
</span><span class='line'>&lt;code&gt;
</span><span class='line'>Disconnecting from systemtap module.
</span><span class='line'>To reconnect, type "staprun -A stap_5dd0073edcb1f13f7565d8c343063e68_19556"
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>当感兴趣的事件发生时，可以重新连接到运行中的脚本，并在内存Buffer中输出最近的数据并持续输出：
</span><span class='line'>&lt;code&gt;
</span><span class='line'>staprun -A stap_5dd0073edcb1f13f7565d8c343063e68_19556
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>内存Buffer默认1MB，可以使用-S选项，例如-S2指定为2MB
</span><span class='line'>&lt;code&gt;
</span><span class='line'>File Flight Recorder
</span><span class='line'>stap -F -o /tmp/pfaults.log -S 1,2  pfaults.stp
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>命令结果输出到/tmp/pfaults.log.[0-9]，每个文件1MB，并且仅保存最近的两个文件，-S指定了第一个参数：每个输出文件大小1MB，第二个参数：仅保留最近的两个文件，systemtap在pfaults.log后面加.[0-9]后缀。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;该命令的输出是systemtap脚本进程ID，使用如下命令可以终止systemtap脚本&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    kill -s SIGTERM 7590
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;运行</span></code></pre></td></tr></table></div></figure>
    ls –sh /tmp/pfaults.log.*</p>

<pre><code>1020K /tmp/pfaults.log.5    44K /tmp/pfaults.log.6
</code></pre>

<pre><code>
#### SystemTap如何工作

SystemTap的基本工作原理就是：event/handler，运行systemtap脚本产生的加载模块时刻监控事件的发生，一旦发生，内核就调用相关的handler处理。

一运行一个SystemTap脚本就会产生一个SystemTap session：  
1.SystemTap检查脚本以及所使用的相关tapset库；  
2.SystemTap将脚本转换成C语言文件，并运行C语言编译器编译之创建一个内核模块；  
3.SystemTap加载该模块，从而使用所有探针(events和handlers)；  
4.事件发生时，执行相关handlers  
5.一旦SystemTap session停止，则探针被禁止，该内核模块被卸载。  

探针：event及其handler，一个SystemTap脚本可以包含多个探针。

SystemTap脚本以.stp为扩展名，其基本格式如下所示：
</code></pre>

<pre><code>probe event {statements}
</code></pre>

<pre><code>
允许一个探针内多个event，以,隔开，任一个event发生时，都会执行statements，各个语句之间不需要特殊的结束符号标记。而且可以在一个statements block中包含其他的statements block。

函数编写：
</code></pre>

<pre><code>function function_name(arguments) {statements}

probe event {function_name(arguments)}
</code></pre>

<pre><code>
#### SystemTap Event

可大致划分为synchronous和asynchronous。

##### 同步事件：

执行到定位到内核代码中的特定位置时触发event

1.syscall.system_call  
系统调用入口和exit处：syscall.system_call和syscall.system_call.return，比如对于close系统调用：syscall.close和syscall.close.return

2.vfs.file_operation  
vfs.file_operation和vfs.file_operation.return

3.kernel.function("function")  
如：kernel.function(“sys_open”)和kernel.function(“sys_open”).return

可使用*来代表wildcards：
</code></pre>

<pre><code>probe kernel.function("*@net/socket.c") { }
probe kernel.function("*@net/socket.c").return { }
</code></pre>

<pre><code>
代表了net/socket.c中所有函数的入口和exit口。

4.kernel.trace("tracepoint")  
2.6.30及newer为内核中的特定事件定义了instrumentation，入kernel.trace(“kfree_skb”)代表内核中每次网络buffer被释放掉时的event。

5.module("module").function("function")
</code></pre>

<pre><code>probe module("ext3").function("*") { }
probe module("ext3").function("*").return { }
</code></pre>

<pre><code>
系统内核模块多存放在/lib/modules/kernel_version

#### Asynchronous Events

不绑定到内核的特定指令或位置处。包括：  
1、begin：SystemTap session开始时触发，当SystemTap脚本开始运行时触发；  
2、end ：SystemTap session终止时触发；  
3、timer事件：  
</code></pre>

<pre><code>probe timer.s(4)
{
    printf("hello world/n")
}
</code></pre>

<pre><code>
• timer.ms(milliseconds)  
• timer.us(microseconds)  
• timer.ns(nanoseconds)  
• timer.hz(hertz)  
• timer.jiffies(jiffies)

可查看man stapprobes来查看其它支持的events

#### SystemTap Handler/Body

支持的函数：  
1、  printf ("format string/n", arguments)，%s：字符串，%d数字，以 , 隔开；  
2、  tid()：当前线程ID；  
3、  uid()：当前用户ID；  
4、  cpu()：当前CPU号；  
5、  gettimeofday_s()：自从Epoch开始的秒数；  
6、  ctime()将从Unix Epoch开始的秒数转换成date；  
7、  pp()：描述当前被处理的探针点的字符串；  
8、  thread_indent()：  
</code></pre>

<pre><code>probe kernel.function("*@net/socket.c")
{
    printf ("%s -&gt; %s/n", thread_indent(1), probefunc())
}

probe kernel.function("*@net/socket.c").return
{
    printf ("%s &lt;- %s/n", thread_indent(-1), probefunc())
}

0 ftp(7223): -&gt; sys_socketcall
1159 ftp(7223):  -&gt; sys_socket
2173 ftp(7223):   -&gt; __sock_create
2286 ftp(7223):    -&gt; sock_alloc_inode
2737 ftp(7223):    &lt;- sock_alloc_inode
3349 ftp(7223):    -&gt; sock_alloc
3389 ftp(7223):    &lt;- sock_alloc
3417 ftp(7223):   &lt;- __sock_create
4117 ftp(7223):   -&gt; sock_create
4160 ftp(7223):   &lt;- sock_create
4301 ftp(7223):   -&gt; sock_map_fd
4644 ftp(7223):    -&gt; sock_map_file
4699 ftp(7223):    &lt;- sock_map_file
4715 ftp(7223):   &lt;- sock_map_fd
4732 ftp(7223):  &lt;- sys_socket
4775 ftp(7223): &lt;- sys_socketcall
</code></pre>

<pre><code>
  函数thread_indent()只有1个参数：代表对线程的”indentation counter”的增减数，即系统调用显示的步数，返回字符串(自从第一次调用thread_indent()以来的描述：进程名(进程ID))

9、name  
标记系统调用的名字，仅用于syscall.system_call中。

10、target()  
与stap script -x process ID or stap script -c command联合使用，如果想在脚本中获得进程ID或命令可以如此做
</code></pre>

<pre><code>probe syscall.* {
    if (pid() == target())
        printf("%s/n", name)
}
</code></pre>

<pre><code>
#### SystemTap Handler构造

##### 变量
1、不必事先声明，直接使用即可，由SystemTap自动判断其属于string还是integer，整数则默认为0，默认在probe中声明的是local变量  
2、在各个probe之间共享的变量使用global声明  
</code></pre>

<pre><code>global count_jiffies, count_ms
probe timer.jiffies(100) { count_jiffies ++ }
probe timer.ms(100) { count_ms ++ }
probe timer.ms(12345)
{
    hz=(1000*count_jiffies) / count_ms
    printf ("jiffies:ms ratio %d:%d =&gt; CONFIG_HZ=%d/n",
        count_jiffies, count_ms, hz)
    exit()
}
</code></pre>

<pre><code>
##### Target变量

Probe event可以映射到代码的实际位置，如kernel.function(“function”)、kernel.statement(“statement”)，这允许使用target变量来记录代码中指定位置处可视变量的值。

运行如下命令：可以显示指定vfs_read处可视target变量
</code></pre>

<pre><code>stap -L 'kernel.function("vfs_read")'
</code></pre>

<pre><code>
显示
</code></pre>

<pre><code>kernel.function("vfs_read@fs/read_write.c:277") $file:struct file* $buf:char* $count:size_t

$pos:loff_t*
</code></pre>

<pre><code>
每个target变量以$开头：变量类型。如果是结构体类型，则SystemTap可以使用-&gt;来查看其成员。对基本类型，integer或string，SystemTap有函数可以直接读取address处的值，如：
</code></pre>

<pre><code># 好像有时对于小于8位的函数，会取出8为长度的值
kernel_char(address)
Obtain the character at address from kernel memory.

kernel_short(address)
Obtain the short at address from kernel memory.

kernel_int(address)
Obtain the int at address from kernel memory.

kernel_long(address)
Obtain the long at address from kernel memory

kernel_string(address)
Obtain the string at address from kernel memory.

kernel_string_n(address, n)
Obtain the string at address from the kernel memory and limits the string to n bytes.
</code></pre>

<pre><code>
##### 打印target变量
</code></pre>

<pre><code>$$vars：类似sprintf("parm1=%x ... parmN=%x var1=%x ... varN=%x", parm1, ..., parmN, var1, ..., varN)，目的是打印probe点处的每个变量；

$$locals：$$vars子集，仅打印local变量；

$$parms：$$vars子集，仅包含函数参数；

$$return：仅在return probes存在，类似sprintf("return=%x", $return)，如果没有返回值，则是空串
</code></pre>

<pre><code>
例子如下：
</code></pre>

<pre><code>stap -e 'probe kernel.function("vfs_read") {printf("%s/n", $$parms); exit(); }'
</code></pre>

<pre><code>
函数vfs_read有4个参数：file、buf、count和pos，输出如下：
</code></pre>

<pre><code>file=0xffff8800b40d4c80 buf=0x7fff634403e0 count=0x2004 pos=0xffff8800af96df48
</code></pre>

<pre><code>如果你想知道数据结构里面的成员信息，可以在”$$params”后面加一个”$”，如下所示：
</code></pre>

<pre><code>stap -e 'probe kernel.function("vfs_read") {printf("%s/n", $$parms$); exit(); }'
</code></pre>

<pre><code>输出如下：
</code></pre>

<pre><code>file={.f_u={...}, .f_path={...}, .f_op=0xffffffffa06e1d80, .f_lock={...}, .f_count={...}, .f_flags=34818, buf="" count=8196 pos=-131938753921208
</code></pre>

<pre><code>
仅一个”$”表示，不展开数据结构域成员，如想展开，则需使用”$$”
</code></pre>

<pre><code>stap -e 'probe kernel.function("vfs_read") {printf("%s/n", parms); exit(); }'
</code></pre>

<pre><code>
输出受限于最大字符串大小：
</code></pre>

<pre><code>file={.f_u={.fu_list={.next=0xffff8801336ca0e8, .prev=0xffff88012ded0840}, .fu_rcuhead={.next=0xffff8801336ca0e8
</code></pre>

<pre><code>
##### 强制类型转换

大多数情况下，SystemTap都可以从debuginfo中获得变量类型，但对于代码中void指针则debuginfo中类型信息不可用，同样probe handler里面的类型信息在function里面也不可用，怎么办呢？

SystemTap函数参数使用long来代替typed pointer，SystemTap的@cast操作可以指出对象正确类型：
</code></pre>

<pre><code>function task_state:long (task:long)
{
    return @cast(task, "task_struct", "kernel&lt;linux/sched.h&gt;")-&gt;state
}
</code></pre>

<pre><code>
第一个参数是指向对象的指针， 第二个参数是将该对象(参数1)要强制类型转换成的类型，第三个参数指出类型定义的出处，是可选的。

##### 检查Target变量可用性

随着代码运行，变量可能失效，因此需要用@defined来判断该变量是否可用：
</code></pre>

<pre><code>probe vm.pagefault = kernel.function("__handle_mm_fault@mm/memory.c") ?,

kernel.function("handle_mm_fault@mm/memory.c") ?
{
    name = "pagefault"
    write_access = (@defined($flags) ? $flags &amp; FAULT_FLAG_WRITE : $write_access)
    address = $address
}
</code></pre>

<pre><code>
##### 条件语句
</code></pre>

<pre><code>if (condition)
    statement1
else
    statement2
</code></pre>

<pre><code></code></pre>

<pre><code>global countread, countnonread
probe kernel.function("vfs_read"),kernel.function("vfs_write")
{
    if (probefunc()=="vfs_read")
        countread ++
    else
        countnonread ++
}

probe timer.s(5) { exit() }

probe end
{
    printf("VFS reads total %d/n VFS writes total %d/n", countread, countnonread)
}
</code></pre>

<pre><code>
##### 循环语句
</code></pre>

<pre><code>while (condition)
    statement

for (initialization; conditional; increment) statement
</code></pre>

<pre><code>
##### 比较：
</code></pre>

<pre><code>==、&gt;=、&lt;=、!=
</code></pre>

<pre><code>
##### 命令行参数：
使用$标志着希望输入的是integer类型命令行参数，@：string
</code></pre>

<pre><code>probe kernel.function(@1) { }
probe kernel.function(@1).return { }
</code></pre>

<pre><code>
#### 关联数组

关联数组一般在multiple probes里面处理，所以必须声明为global，不管是在一个还是多个probes里面用，要读取数组成员值，可以：
</code></pre>

<pre><code>array_name[index_expression]
</code></pre>

<pre><code>如下所示：
</code></pre>

<pre><code>foo["tom"] = 23
foo["dick"] = 24
foo["harry"] = 25
</code></pre>

<pre><code>
一个索引可以包含最多9个索引表达式，用 , 隔开：
</code></pre>

<pre><code>device[pid(),execname(),uid(),ppid(),"W"] = devname
</code></pre>

<pre><code>
##### SystemTap的数组操作

###### 赋值：
</code></pre>

<pre><code>array_name[index_expression] = value
</code></pre>

<pre><code>例子：索引和值可以使用handler function：
</code></pre>

<pre><code>foo[tid()] = gettimeofday_s()
</code></pre>

<pre><code>
每次触发这个语句，多次后就会构成一个关联数组，如果tid()返回值在foo索引中已有一个，则用新值代替旧值。

###### 读取数组值：
</code></pre>

<pre><code>delta = gettimeofday_s() - foo[tid()]
</code></pre>

<pre><code>
如果无法找到指定”索引”对应的值，则数组读返回0(int)或null/empty值(string)

###### 增加关联数组值
</code></pre>

<pre><code>array_name[index_expression] ++
</code></pre>

<pre><code>
处理数组的多个成员：
</code></pre>

<pre><code>global reads
probe vfs.read
{
    reads[execname()] ++
}

probe timer.s(3)
{
    foreach (count in reads)
    printf("%s : %d /n", count, reads[count])
}
</code></pre>

<pre><code>
这个foreach无序打印所有reads数组值，如果想升序/降序，则需要使用升序(+)、降序(-)，也可以限制处理的数组数目：
</code></pre>

<pre><code>probe timer.s(3)
{
    foreach (count in reads- limit 10)
    printf("%s : %d /n", count, reads[count])
}
</code></pre>

<pre><code>
##### Clearing/Deleting数组和数组成员
</code></pre>

<pre><code>global reads
probe vfs.read
{
    reads[execname()] ++
}

probe timer.s(3)
{
    foreach (count in reads)
    printf("%s : %d /n", count, reads[count])

    delete reads
}
</code></pre>

<pre><code>
使用delete操作来删除数组成员或整个数组。
</code></pre>

<pre><code>global reads, totalreads
probe vfs.read
{
    reads[execname()] ++
    totalreads[execname()] ++
}

probe timer.s(3)
{
    printf("=======/n")
    foreach (count in reads-)
        printf("%s : %d /n", count, reads[count])
    delete reads
}

probe end
{
    printf("TOTALS/n")
    foreach (total in totalreads-)
    printf("%s : %d /n", total, totalreads[total])
}
</code></pre>

<pre><code>
在if语句中使用数组：
</code></pre>

<pre><code>global reads
probe vfs.read
{
    reads[execname()] ++
}

probe timer.s(3)
{
    printf("=======/n")
    foreach (count in reads-)
    if (reads[count] &gt;= 1024)
        printf("%s : %dkB /n", count, reads[count]/1024)
    else
        printf("%s : %dB /n", count, reads[count])
}
</code></pre>

<pre><code>
##### 检查成员

可以检查是否一个指定健是数组键值：
</code></pre>

<pre><code>if([index_expression] in array_name) statement
</code></pre>

<pre><code></code></pre>

<pre><code>global reads
probe vfs.read
{
    reads[execname()] ++
}

probe timer.s(3)
{
    printf("=======/n")
    foreach (count in reads+)
        printf("%s : %d /n", count, reads[count])
    if(["stapio"] in reads) {
        printf("stapio read detected, exiting/n")
        exit()
    }
}
</code></pre>

<pre><code>
##### 计算统计集合

统计集合用于收集数值的统计信息，用于计算新值
</code></pre>

<pre><code>global reads
probe vfs.read
{
    reads[execname()] &lt;&lt;&lt; count
}
</code></pre>

<pre><code>
操作符&lt;&lt;&lt;用于将count返回的值存放在read数组中execname()相关的值中，即一个键值关联多个相关值。

为计算统计信息，使用@extractor(variable/array index expression)，extractor可以是如下integer extractor：
</code></pre>

<pre><code>count：@count(writes[execname()])返回存放在writes数组中某单一键值对应的值数目；
sum：@sum(writes[execname()])返回在writes数组中某单一键值对应的值的和
min：最小值
max：最大值
avg：variable/array作为索引的统计集合中数据的平均值
</code></pre>

<pre><code></code></pre>

<pre><code>global reads
probe vfs.read
{
    reads[execname(),pid()] &lt;&lt;&lt; 1
}

probe timer.s(3)
{
    foreach([var1,var2] in reads)
    printf("%s (%d) : %d /n", var1, var2, @count(reads[var1,var2]))
}
</code></pre>

<p>```</p>

<h4>Tapsets</h4>

<p>Tapsets是脚本库，里面预写好了probes和functions可以被SystemTap脚本调用，tapsets也使用.stp作为后缀，默认位于：/usr/share/systemtap/tapset，但无法直接运行。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TCP三次握手源码详解]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/06/01/kernel-net-shark-hand/"/>
    <updated>2015-06-01T14:24:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/06/01/kernel-net-shark-hand</id>
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/qy532846454/article/details/7882819">http://blog.csdn.net/qy532846454/article/details/7882819</a></p>

<p><a href="http://m.bianceng.cn/OS/Linux/201301/35179_6.htm">http://m.bianceng.cn/OS/Linux/201301/35179_6.htm</a></p>

<p>内核：2.6.34</p>

<p>TCP是应用最广泛的传输层协议，其提供了面向连接的、可靠的字节流服务，但也正是因为这些特性，使得TCP较之UDP异常复杂，还是分两部分[创建与使用]来进行分析。这篇主要包括TCP的创建及三次握手的过程。</p>

<p>编程时一般用如下语句创建TCP Socket：</p>

<pre><code>    socket(AF_INET, SOCK_DGRAM, IPPROTO_TCP)  
</code></pre>

<p>由此开始分析，调用接口[net/socket.c]: SYSCALL_DEFINE3(socket)</p>

<p>其中执行两步关键操作：sock_create()与sock_map_fd()</p>

<pre><code>    retval = sock_create(family, type, protocol, &amp;sock);  
    if (retval &lt; 0)  
        goto out;  
    retval = sock_map_fd(sock, flags &amp; (O_CLOEXEC | O_NONBLOCK));  
    if (retval &lt; 0)  
        goto out_release;  
</code></pre>

<p>  sock_create()用于创建socket，sock_map_fd()将之映射到文件描述符，使socket能通过fd进行访问，着重分析sock_create()的创建过程。</p>

<pre><code>    sock_create() -&gt; __sock_create()
</code></pre>

<p>  从__sock_create()代码看到创建包含两步：sock_alloc()和pf->create()。sock_alloc()分配了sock内存空间并初始化inode；pf->create()初始化了sk。</p>

<pre><code>    sock = sock_alloc();  
    sock-&gt;type = type;  
    ……  
    pf = rcu_dereference(net_families[family]);  
    ……  
    pf-&gt;create(net, sock, protocol, kern);  
</code></pre>

<h4>sock_alloc()</h4>

<p>  分配空间，通过new_inode()分配了节点(包括socket)，然后通过SOCKET_I宏获得sock，实际上inode和sock是在new_inode()中一起分配的，结构体叫作sock_alloc。</p>

<pre><code>    inode = new_inode(sock_mnt-&gt;mnt_sb);  
    sock = SOCKET_I(inode);  
</code></pre>

<p>  设置inode的参数，并返回sock。</p>

<pre><code>    inode-&gt;i_mode = S_IFSOCK | S_IRWXUGO;  
    inode-&gt;i_uid = current_fsuid();  
    inode-&gt;i_gid = current_fsgid();  
    return sock;  
</code></pre>

<p>  继续往下看具体的创建过程：new_inode()，在分配后，会设置i_ino和i_state的值。</p>

<pre><code>    struct inode *new_inode(struct super_block *sb)  
    {  
        ……  
        inode = alloc_inode(sb);  
        if (inode) {  
            spin_lock(&amp;inode_lock);  
            __inode_add_to_lists(sb, NULL, inode);  
            inode-&gt;i_ino = ++last_ino;  
            inode-&gt;i_state = 0;  
            spin_unlock(&amp;inode_lock);  
        }  
        return inode;  
    }  
</code></pre>

<p>  其中的alloc_inode() -> sb->s_op->alloc_inode()，sb是sock_mnt->mnt_sb，所以alloc_inode()指向的是sockfs的操作函数sock_alloc_inode。</p>

<pre><code>    static const struct super_operations sockfs_ops = {  
        .alloc_inode = sock_alloc_inode,  
        .destroy_inode =sock_destroy_inode,  
        .statfs = simple_statfs,  
    };  
</code></pre>

<p>  sock_alloc_inode()中通过kmem_cache_alloc()分配了struct socket_alloc结构体大小的空间，而struct socket_alloc结构体定义如下，但只返回了inode，实际上socket和inode都已经分配了空间，在之后就可以通过container_of取到socket。</p>

<pre><code>    static struct inode *sock_alloc_inode(struct super_block *sb)  
    {  
        struct socket_alloc *ei;  
        ei = kmem_cache_alloc(sock_inode_cachep, GFP_KERNEL);  
        ......  
        return &amp;ei-&gt;vfs_inode;  
    }  
    struct socket_alloc {  
        struct socket socket;  
        struct inode vfs_inode;  
    };  

    net_families[AF_INET]:  
    static const struct net_proto_family inet_family_ops = {  
        .family = PF_INET,  
        .create = inet_create,  
        .owner = THIS_MODULE,  
    };  
</code></pre>

<p>err = pf->create(net, sock, protocol, kern); ==> inet_create()
这段代码就是从inetsw[]中取到适合的协议类型answer，sock->type就是传入socket()函数的type参数SOCK_DGRAM，最终取得结果answer->ops==inet_stream_ops，从上面这段代码还可以看出以下问题：</p>

<p>  socket(AF_INET, SOCK_RAW, IPPROTO_IP)这样是不合法的，因为SOCK_RAW没有默认的协议类型；同样socket(AF_INET, SOCK_DGRAM, IPPROTO_IP)与socket(AF_INET, SOCK_DGRAM, IPPROTO_TCP)是一样的，因为TCP的默认协议类型是IPPTOTO_TCP；SOCK_STREAM与IPPROTO_UDP同上。</p>

<pre><code>    sock-&gt;state = SS_UNCONNECTED;  
    list_for_each_entry_rcu(answer, &amp;inetsw[sock-&gt;type], list) {  
        err = 0;  
        /* Check the non-wild match. */  
        if (protocol == answer-&gt;protocol) {  
            if (protocol != IPPROTO_IP)  
                break;  
        } else {  
            /* Check for the two wild cases. */  
            if (IPPROTO_IP == protocol) {  
                protocol = answer-&gt;protocol;  
                break;  
            }  
            if (IPPROTO_IP == answer-&gt;protocol)  
                break;  
        }  
        err = -EPROTONOSUPPORT;  
    }  
</code></pre>

<p>sock->ops指向inet_stream_ops，然后创建sk，sk->proto指向tcp_prot，注意这里分配的大小是struct tcp_sock，而不仅仅是struct sock大小</p>

<pre><code>    sock-&gt;ops = answer-&gt;ops;  
    answer_prot = answer-&gt;prot;  
    ……  
    sk = sk_alloc(net, PF_INET, GFP_KERNEL, answer_prot);  
</code></pre>

<p>然后设置inet的一些参数，这里直接将sk类型转换为inet，因为在sk_alloc()中分配的是struct tcp_sock结构大小，返回的是struct sock，利用了第一个成员的特性，三者之间的关系如下图：
<code>
    inet = inet_sk(sk);  
    ……  
    inet-&gt;inet_id = 0;  
    sock_init_data(sock, sk);  
</code>
其中有些设置是比较重要的，如
<code>
    sk-&gt;sk_state = TCP_CLOSE;  
    sk_set_socket(sk, sock);  
    sk-&gt;sk_protocol = protocol;  
    sk-&gt;sk_backlog_rcv = sk-&gt;sk_prot-&gt;backlog_rcv;  
</code></p>

<p>创建socket后，接下来的流程会因为客户端或服务器的不同而有所差异，下面着重于分析建立连接的三次握手过程。典型的客户端流程：<br/>
connect() -> send() -> recv()</p>

<p>典型的服务器流程：<br/>
bind() -> listen() -> accept() -> recv() -> send()</p>

<h4>客户端流程</h4>

<p>发送SYN报文，向服务器发起tcp连接</p>

<pre><code>            connect(fd, servaddr, addrlen);
                -&gt; SYSCALL＿DEFINE3() 
                -&gt; sock-&gt;ops-&gt;connect() == inet_stream_connect (sock-&gt;ops即inet_stream_ops)
                -&gt; tcp_v4_connect()
</code></pre>

<p>查找到达[daddr, dport]的路由项，路由项的查找与更新与”路由表”章节所述一样。要注意的是由于是作为客户端调用，创建socket后调用connect，因而saddr, sport都是0，同样在未查找路由前，要走的出接口oif也是不知道的，因此也是0。在查找完路由表后(注意不是路由缓存)，可以得知出接口，但并未存储到sk中。因此插入的路由缓存是特别要注意的：它的键值与实际值是不相同的，这个不同点就在于oif与saddr，键值是[saddr=0, sport=0, daddr, dport, oif=0]，而缓存项值是[saddr, sport=0, daddr, dport, oif]。</p>

<pre><code>    tmp = ip_route_connect(&amp;rt, nexthop, inet-&gt;inet_saddr,  
                            RT_CONN_FLAGS(sk), sk-&gt;sk_bound_dev_if,  
                            IPPROTO_TCP,  
                            inet-&gt;inet_sport, usin-&gt;sin_port, sk, 1);  
    if (tmp &lt; 0) {  
        if (tmp == -ENETUNREACH)  
            IP_INC_STATS_BH(sock_net(sk), IPSTATS_MIB_OUTNOROUTES);  
        return tmp;  
    }  
</code></pre>

<p>通过查找到的路由项，对inet进行赋值，可以看到，除了sport，都赋予了值，sport的选择复杂点，因为它要随机从未使用的本地端口中选择一个。</p>

<pre><code>    if (!inet-&gt;inet_saddr)  
        inet-&gt;inet_saddr = rt_rt_src;   
    inet-&gt;inet_rcv_addr = inet-&gt;inet_saddr;  
    ……  
    inet-&gt;inet_dport = usin-&gt;sin_port;  
    inet-&gt;inet_daddr = daddr;  
</code></pre>

<p>状态从CLOSING转到TCP_SYN_SENT，也就是我们熟知的TCP的状态转移图。</p>

<pre><code>    tcp_set_state(sk, TCP_SYN_SENT);  
</code></pre>

<p>插入到bind链表中</p>

<pre><code>    err = inet_hash_connect(&amp;tcp_death_row, sk); //== &gt; __inet_hash_connect()  
</code></pre>

<p>当snum==0时，表明此时源端口没有指定，此时会随机选择一个空闲端口作为此次连接的源端口。low和high分别表示可用端口的下限和上限，remaining表示可用端口的数，注意这里的可用只是指端口可以用作源端口，其中部分端口可能已经作为其它socket的端口号在使用了，所以要循环1~remaining，直到查找到空闲的源端口。</p>

<pre><code>    if (!snum) {  
        inet_get_local_port_range(&amp;low, &amp;high);  
        remaining = (high - low) + 1;  
        ……  
        for (i = 1; i &lt;= remaining; i++) {  
            ……// choose a valid port  
        }  
    }  
</code></pre>

<p>下面来看下对每个端口的检查，即//choose a valid port部分的代码。这里要先了解下tcp的内核表组成，udp的表内核表udptable只是一张hash表，tcp的表则稍复杂，它的名字是tcp_hashinfo，在tcp_init()中被初始化，这个数据结构定义如下(省略了不相关的数据)：</p>

<pre><code>    struct inet_hashinfo {  
        struct inet_ehash_bucket *ehash;  
        ……  
        struct inet_bind_hashbucket *bhash;  
        ……  
        struct inet_listen_hashbucket  listening_hash[INET_LHTABLE_SIZE]  
                        ____cacheline_aligned_in_smp;  
    };  
</code></pre>

<p>从定义可以看出，tcp表又分成了三张表ehash, bhash, listening_hash，其中ehash, listening_hash对应于socket处在TCP的ESTABLISHED, LISTEN状态，bhash对应于socket已绑定了本地地址。三者间并不互斥，如一个socket可同时在bhash和ehash中，由于TIME_WAIT是一个比较特殊的状态，所以ehash又分成了chain和twchain，为TIME_WAIT的socket单独形成一张表。</p>

<p>回到刚才的代码，现在还只是建立socket连接，使用的就应该是tcp表中的bhash。首先取得内核tcp表的bind表 – bhash，查看是否已有socket占用：<br/>
  如果没有，则调用inet_bind_bucket_create()创建一个bind表项tb，并插入到bind表中，跳转至goto ok代码段；<br/>
  如果有，则跳转至goto ok代码段。<br/>
  进入ok代码段表明已找到合适的bind表项(无论是创建的还是查找到的)，调用inet_bind_hash()赋值源端口inet_num。</p>

<pre><code>    for (i = 1; i &lt;= remaining; i++) {  
        port = low + (i + offset) % remaining;  
        head = &amp;hinfo-&gt;bhash[inet_bhashfn(net, port, hinfo-&gt;bhash_size)];  
        ……  
        inet_bind_bucket_for_each(tb, node, &amp;head-&gt;chain) {  
            if (net_eq(ib_net(tb), net) &amp;&amp; tb-&gt;port == port) {  
                if (tb-&gt;fastreuse &gt;= 0)  
                    goto next_port;  
                WARN_ON(hlist_empty(&amp;tb-&gt;owners));  
                if (!check_established(death_row, sk, port, &amp;tw))  
                    goto ok;  
                goto next_port;  
            }  
        }  

        tb = inet_bind_bucket_create(hinfo-&gt;bind_bucket_cachep, net, head, port);  
        ……  
        next_port:  
            spin_unlock(&amp;head-&gt;lock);  
    }  

    ok:  
        ……  
    inet_bind_hash(sk, tb, port);  
        ……  
        goto out;  
</code></pre>

<p>在获取到合适的源端口号后，会重建路由项来进行更新：</p>

<pre><code>    err = ip_route_newports(&amp;rt, IPPROTO_TCP, inet-&gt;inet_sport, inet-&gt;inet_dport, sk);  
</code></pre>

<p>函数比较简单，在获取sport前已经查找过一次路由表，并插入了key=[saddr=0, sport=0, daddr, dport, oif=0]的路由缓存项；现在获取到了sport，调用ip_route_output_flow()再次更新路由缓存表，它会添加key=[saddr=0, sport, daddr, dport, oif=0]的路由缓存项。这里可以看出一个策略选择，查询路由表->获取sport->查询路由表，为什么不是获取sport->查询路由表的原因可能是效率的问题。</p>

<pre><code>    if (sport != (*rp)-&gt;fl.fl_ip_sport ||  
                    dport != (*rp)-&gt;fl.fl_ip_dport) {  
        struct flowi fl;  

        memcpy(&amp;fl, &amp;(*rp)-&gt;fl, sizeof(fl));  
        fl.fl_ip_sport = sport;  
        fl.fl_ip_dport = dport;  
        fl.proto = protocol;  
        ip_rt_put(*rp);  
        *rp = NULL;  
        security_sk_classify_flow(sk, &amp;fl);  
        return ip_route_output_flow(sock_net(sk), rp, &amp;fl, sk, 0);  
    }  
</code></pre>

<p>write_seq相当于第一次发送TCP报文的ISN，如果为0，则通过计算获取初始值，否则延用上次的值。在获取完源端口号，并查询过路由表后，TCP正式发送SYN报文，注意在这之前TCP状态已经更新成了TCP_SYN_SENT，而在函数最后才调用tcp_connect(sk)发送SYN报文，这中间是有时差的。</p>

<pre><code>    if (!tp-&gt;write_seq)  
        tp-&gt;write_seq = secure_tcp_sequence_number(inet-&gt;inet_saddr,  
                                        inet-&gt;inet_daddr,  
                                        inet-&gt;inet_sport,  
                                        usin-&gt;sin_port);  
    inet-&gt;inet_id = tp-&gt;write_seq ^ jiffies;  
    err = tcp_connect(sk);  
</code></pre>

<h5>tcp_connect()　发送SYN报文</h5>

<p>几步重要的代码如下，tcp_connect_init()中设置了tp->rcv_nxt=0，tcp_transmit_skb()负责发送报文，其中seq=tcb->seq=tp->write_seq，ack_seq=tp->rcv_nxt。</p>

<pre><code>    tcp_connect_init(sk);  
    tp-&gt;snd_nxt = tp-&gt;write_seq;  
    ……  
    tcp_transmit_skb(sk, buff, 1, sk-&gt;sk_allocation);  
</code></pre>

<h5>收到服务端的SYN+ACK，发送ACK</h5>

<h5>tcp_rcv_synsent_state_process()</h5>

<p>此时已接收到对方的ACK，状态变迁到TCP_ESTABLISHED。最后发送对方SYN的ACK报文。</p>

<pre><code>    tcp_set_state(sk, TCP_ESTABLISHED);  
    tcp_send_ack(sk);  
</code></pre>

<h4>服务端流程</h4>

<h5>bind() -> inet_bind()</h5>

<p>  bind操作的主要作用是将创建的socket与给定的地址相绑定，这样创建的服务才能公开的让外部调用。当然对于socket服务器的创建来说，这一步不是必须的，在listen()时如果没有绑定地址，系统会选择一个随机可用地址作为服务器地址。</p>

<p>  一个socket地址分为ip和port，inet->inet_saddr赋值了传入的ip，snum是传入的port，对于端口，要检查它是否已被占用，这是由sk->sk_prot->get_port()完成的(这个函数前面已经分析过，在传入port时它检查是否被占用；传入port=0时它选择未用的端口)。如果没有被占用，inet->inet_sport被赋值port，因为是服务监听端，不需要远端地址，inet_daddr和inet_dport都置0。</p>

<p>  注意bind操作不会改变socket的状态，仍为创建时的TCP_CLOSE。</p>

<pre><code>    snum = ntohs(addr-&gt;sin_port);  
    ……  
    inet-&gt;inet_rcv_saddr = inet-&gt;inet_saddr = addr-&gt;sin_addr.s_addr;  
    if (sk-&gt;sk_prot-&gt;get_port(sk, snum)) {  
        inet-&gt;inet_saddr = inet-&gt;inet_rcv_saddr = 0;  
        err = -EADDRINUSE;  
        goto out_release_sock;  
    }  
    ……  
    inet-&gt;inet_sport = htons(inet-&gt;inet_num);  
    inet-&gt;inet_daddr = 0;  
    inet-&gt;inet_dport = 0;  
</code></pre>

<h5>listen() -> inet_listen()</h5>

<p>  listen操作开始服务器的监听，此时服务就可以接受到外部连接了。在开始监听前，要检查状态是否正确，sock->state==SS_UNCONNECTED确保仍是未连接的socket，sock->type==SOCK_STREAM确保是TCP协议，old_state确保此时状态是TCP_CLOSE或TCP_LISTEN，在其它状态下进行listen都是错误的。</p>

<pre><code>    if (sock-&gt;state != SS_UNCONNECTED || sock-&gt;type != SOCK_STREAM)  
        goto out;  
    old_state = sk-&gt;sk_state;  
    if (!((1 &lt;&lt; old_state) &amp; (TCPF_CLOSE | TCPF_LISTEN)))  
        goto out;  
</code></pre>

<p>  如果已是TCP_LISTEN态，则直接跳过，不用再执行listen了，而只是重新设置listen队列长度sk_max_ack_backlog，改变listen队列长也是多次执行listen的作用。如果还没有执行listen，则还要调用inet_csk_listen_start()开始监听。</p>

<p>  inet_csk_listen_start()变迁状态至TCP_LISTEN，分配监听队列，如果之前没有调用bind()绑定地址，则这里会分配一个随机地址。</p>

<pre><code>    if (old_state != TCP_LISTEN) {  
        err = inet_csk_listen_start(sk, backlog);  
        if (err)  
            goto out;  
    }  
    sk-&gt;sk_max_ack_backlog = backlog;  
</code></pre>

<h5>accept()</h5>

<p>accept() -> sys_accept4() -> inet_accept() -> inet_csk_accept()</p>

<p>  accept()实际要做的事件并不多，它的作用是返回一个已经建立连接的socket(即经过了三次握手)，这个过程是异步的，accept()并不亲自去处理三次握手过程，而只是监听icsk_accept_queue队列，当有socket经过了三次握手，它就会被加到icsk_accept_queue中，所以accept要做的就是等待队列中插入socket，然后被唤醒并返回这个socket。而三次握手的过程完全是协议栈本身去完成的。换句话说，协议栈相当于写者，将socket写入队列，accept()相当于读者，将socket从队列读出。这个过程从listen就已开始，所以即使不调用accept()，客户仍可以和服务器建立连接，但由于没有处理，队列很快会被占满。</p>

<pre><code>    if (reqsk_queue_empty(&amp;icsk-&gt;icsk_accept_queue)) {  
        long timeo = sock_rcvtimeo(sk, flags &amp; O_NONBLOCK);  
        ……  
        error = inet_csk_wait_for_connect(sk, timeo);  
        ……  
    }  

    newsk = reqsk_queue_get_child(&amp;icsk-&gt;icsk_accept_queue, sk);  
</code></pre>

<p>  协议栈向队列中加入socket的过程就是完成三次握手的过程，客户端通过向已知的listen fd发起连接请求，对于到来的每个连接，都会创建一个新的sock，当它经历了TCP_SYN_RCV -> TCP_ESTABLISHED后，就会被添加到icsk_accept_queue中，而监听的socket状态始终为TCP_LISTEN，保证连接的建立不会影响socket的接收。</p>

<h4>接收客户端发来的SYN，发送SYN+ACK</h4>

<h5>tcp_v4_do_rcv()</h5>

<p>  tcp_v4_do_rcv()是TCP模块接收的入口函数，客户端发起请求的对象是listen fd，所以sk->sk_state == TCP_LISTEN，调用tcp_v4_hnd_req()来检查是否处于半连接，只要三次握手没有完成，这样的连接就称为半连接，具体而言就是收到了SYN，但还没有收到ACK的连接，所以对于这个查找函数，如果是SYN报文，则会返回listen的socket(连接尚未创建)；如果是ACK报文，则会返回SYN报文处理中插入的半连接socket。其中存储这些半连接的数据结构是syn_table，它在listen()调用时被创建，大小由sys_ctl_max_syn_backlog和listen()传入的队列长度决定。</p>

<p>此时是收到SYN报文，tcp_v4_hnd_req()返回的仍是sk，调用tcp_rcv_state_process()来接收SYN报文，并发送SYN+ACK报文，同时向syn_table中插入一项表明此次连接的sk。</p>

<pre><code>    if (sk-&gt;sk_state == TCP_LISTEN) {  
        struct sock *nsk = tcp_v4_hnd_req(sk, skb);  
        if (!nsk)  
            goto discard;  
        if (nsk != sk) {  
            if (tcp_child_process(sk, nsk, skb)) {  
                rsk = nsk;  
                goto reset;  
            }  
            return 0;  
        }  
    }  
    TCP_CHECK_TIMER(sk);  
    if (tcp_rcv_state_process(sk, skb, tcp_hdr(skb), skb-&gt;len)) {  
        rsk = sk;  
        goto reset;  
    }  
</code></pre>

<p>  tcp_rcv_state_process()处理各个状态上socket的情况。下面是处于TCP_LISTEN的代码段，处于TCP_LISTEN的socket不会再向其它状态变迁，它负责监听，并在连接建立时创建新的socket。实际上，当收到第一个SYN报文时，会执行这段代码，conn_request() => tcp_v4_conn_request。</p>

<pre><code>    case TCP_LISTEN:  
    ……  
        if (th-&gt;syn) {  
            if (icsk-&gt;icsk_af_ops-&gt;conn_request(sk, skb) &lt; 0)  
                return 1;  
            kfree_skb(skb);  
            return 0;  
        }  
</code></pre>

<p>  tcp_v4_conn_request()中注意两个函数就可以了：tcp_v4_send_synack()向客户端发送了SYN+ACK报文，inet_csk_reqsk_queue_hash_add()将sk添加到了syn_table中，填充了该客户端相关的信息。这样，再次收到客户端的ACK报文时，就可以在syn_table中找到相应项了。</p>

<pre><code>    if (tcp_v4_send_synack(sk, dst, req, (struct request_values *)&amp;tmp_ext) || want_cookie)  
        goto drop_and_free;  
    inet_csk_reqsk_queue_hash_add(sk, req, TCP_TIMEOUT_INIT);  
</code></pre>

<h4>接收客户端发来的ACK</h4>

<h5>tcp_v4_do_rcv()</h5>

<p>  过程与收到SYN报文相同，不同点在于syn_table中已经插入了有关该连接的条目，tcp_v4_hnd_req()会返回一个新的sock: nsk，然后会调用tcp_child_process()来进行处理。在tcp_v4_hnd_req()中会创建新的sock，下面详细看下这个函数。</p>

<pre><code>    if (sk-&gt;sk_state == TCP_LISTEN) {  
        struct sock *nsk = tcp_v4_hnd_req(sk, skb);  
        if (!nsk)  
            goto discard;  
        if (nsk != sk) {  
            if (tcp_child_process(sk, nsk, skb)) {  
                rsk = nsk;  
                goto reset;  
            }  
            return 0;  
        }  
    }  
</code></pre>

<h5>tcp_v4_hnd_req()</h5>

<p>之前已经分析过，inet_csk_search_req()会在syn_table中找到req，此时进入tcp_check_req()</p>

<pre><code>    struct request_sock *req = inet_csk_search_req(sk, &amp;prev, th-&gt;source, iph-&gt;saddr, iph-&gt;daddr);  
    if (req)  
        return tcp_check_req(sk, skb, req, prev);  
</code></pre>

<h5>tcp_check_req()</h5>

<p>  syn_recv_sock() -> tcp_v4_syn_recv_sock()会创建一个新的sock并返回，创建的sock状态被直接设置为TCP_SYN_RECV，然后因为此时socket已经建立，将它添加到icsk_accept_queue中。</p>

<p>  状态TCP_SYN_RECV的设置可能比较奇怪，按照TCP的状态转移图，在服务端收到SYN报文后变迁为TCP_SYN_RECV，但看到在实现中收到ACK后才有了状态TCP_SYN_RECV，并且马上会变为TCP_ESTABLISHED，所以这个状态变得无足轻重。这样做的原因是listen和accept返回的socket是不同的，而只有真正连接建立时才会创建这个新的socket，在收到SYN报文时新的socket还没有建立，就无从谈状态变迁了。这里同样是一个平衡的存在，你也可以在收到SYN时创建一个新的socket，代价就是无用的socket大大增加了。</p>

<pre><code>    child = inet_csk(sk)-&gt;icsk_af_ops-&gt;syn_recv_sock(sk, skb, req, NULL);  
    if (child == NULL)  
        goto listen_overflow;  
    inet_csk_reqsk_queue_unlink(sk, req, prev);  
    inet_csk_reqsk_queue_removed(sk, req);  
    inet_csk_reqsk_queue_add(sk, req, child);  
</code></pre>

<h5>tcp_child_process()</h5>

<p>如果此时sock: child被用户进程锁住了，那么就先添加到backlog中__sk_add_backlog()，待解锁时再处理backlog上的sock；如果此时没有被锁住，则先调用tcp_rcv_state_process()进行处理，处理完后，如果child状态到达TCP_ESTABLISHED，则表明其已就绪，调用sk_data_ready()唤醒等待在isck_accept_queue上的函数accept()。</p>

<pre><code>    if (!sock_owned_by_user(child)) {  
        ret = tcp_rcv_state_process(child, skb, tcp_hdr(skb), skb-&gt;len);  
        if (state == TCP_SYN_RECV &amp;&amp; child-&gt;sk_state != state)  
            parent-&gt;sk_data_ready(parent, 0);  
    } else {  
        __sk_add_backlog(child, skb);  
    }  
</code></pre>

<p>  tcp_rcv_state_process()处理各个状态上socket的情况。下面是处于TCP_SYN_RECV的代码段，注意此时传入函数的sk已经是新创建的sock了(在tcp_v4_hnd_req()中)，并且状态是TCP_SYN_RECV，而不再是listen socket，在收到ACK后，sk状态变迁为TCP_ESTABLISHED，而在tcp_v4_hnd_req()中也已将sk插入到了icsk_accept_queue上，此时它就已经完全就绪了，回到tcp_child_process()便可执行sk_data_ready()。</p>

<pre><code>    case TCP_SYN_RECV:  
        if (acceptable) {  
            ……  
            tcp_set_state(sk, TCP_ESTABLISHED);  
            sk-&gt;sk_state_change(sk);  
            ……  
            tp-&gt;snd_una = TCP_SKB_CB(skb)-&gt;ack_seq;  
            tp-&gt;snd_wnd = ntohs(th-&gt;window) &lt;&lt; tp-&gt;rx_opt.snd_wscale;  
            tcp_init_wl(tp, TCP_SKB_CB(skb)-&gt;seq);   
            ……  
    }  
</code></pre>

<p>最后总结三次握手的过程</p>

<p><img src="/images/kernel/2015-06-01.png" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RHEL5/CentOS5 上支持 Ext4]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/05/29/system-base-ext/"/>
    <updated>2015-05-29T15:40:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/05/29/system-base-ext</id>
    <content type="html"><![CDATA[<ul>
<li><p>记住，只能改数据分区，<code>/</code> 和 <code>/boot</code> 分区不要试，至少我没成功，启动参数加rootfstype=ext4也起不来。</p></li>
<li><p><code>/</code> 分区要改成ext4的话，可以直接改<code>/etc/fstab</code>文件，ext3支持以ext4形式挂载。</p></li>
<li><p>extents属性加上后去不掉，所以该不会ext3的，除非不加这个属性？？，去掉属性<code>tune4fs -O ^flex_bg /dev/sdb1</code></p></li>
</ul>


<hr />

<p><a href="http://www.php-oa.com/2010/08/04/linux-rhel5-centos5-ext4.html">http://www.php-oa.com/2010/08/04/linux-rhel5-centos5-ext4.html</a></p>

<p>根据我以前的测试 Ext4 的性能好过 Ext3,在 RHEL5 上的 2.6.18-110 也有加入 Ext4 了.但默认没有让我们使用,怎么样才能不重起,能使用这个啦.
其实我们只要加入一个包e4fsprogs 就行,它其实和 e2fsprogs 是一样的功能,这 RHEL-6 中,会变成一个默认的包的.所以我们目前还只能使用这个包来调整和设置Ext4.
<code>
    yum -y install e4fsprogs
</code>
在 RHEL 和 Centos5 中使用 Ext4 前,很多想可能想先给现有的文件系统转换成 Ext4 ,只要运行下面的命令就行了
<code>
    tune4fs -O extents,uninit_bg,dir_index,flex_bg /dev/sdb1
</code></p>

<p>记住，转换成 ext4 后必须用 fsck 扫描，否则不能 mount，-p 参数说明 “自动修复” 文件系统：
<code>
    fsck -pf /dev/sdb1 或 fsck -y /dev/sdb1
</code></p>

<h5>下面这个好像不需要</h5>

<p>在重起前,我还要让内核支持 Ext4 的文件系统,需要修改 initrd 的文件本身的内容.如下命令来生成 支持 Ext4 的 initrd.
<code>
    mkinitrd --with=ext4 --with=ext3 -f /boot/initrd-2.6.18-404.el5.img 2.6.18-404.el5
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[网络硬盘NFS的安装与配置]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/05/29/system-base-net-nfs/"/>
    <updated>2015-05-29T14:23:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/05/29/system-base-net-nfs</id>
    <content type="html"><![CDATA[<p><a href="http://www.linuxidc.com/Linux/2014-11/109637.htm">http://www.linuxidc.com/Linux/2014-11/109637.htm</a></p>

<p>NFS 是共享文件的服务的一种协议 下面给大家介绍一下这个服务器的的安装和配置。</p>

<h4>安装</h4>

<pre><code>    sudo apt-get install nfs-common nfs-kernel-server
</code></pre>

<h4>配置</h4>

<pre><code>    vim /etc/exprots
</code></pre>

<p>在正文的最下面输入一行
```
    /srv/nfs_share *(rw)</p>

<pre><code>/srv/nfs_share 表示的是我们要共享的文件目录
* 表示互联网上任何主机都可以访问 
(rw) 表示对服务器进行访问的主机可以进行的操作 也就是可读可写
</code></pre>

<pre><code>
如果我们只想让我们本地局域网上的主机对我们的服务器进行访问的话  可以这样写
</code></pre>

<pre><code>/srv/nfs_share 192.168.*.*(rw)
</code></pre>

<pre><code>
#### 访问

本机访问
</code></pre>

<pre><code>sudo mount -o rw locahost:/srv/nfs_share /mnt/nfs
</code></pre>

<pre><code>
上面的意思是把本地的目录/srv/nfs_share 挂载到 目录/mnt/nfs上 ，这时候我们体会不到挂载点发生了变化 我们可以自己用相关的命令查询，我就不多介绍了

非本地的主机
</code></pre>

<pre><code>sudo mount -o rw 域名:/srv/nfs_share /mnt/nfs
</code></pre>

<pre><code>
这个时候我们会发现NFS太简单了，所以系统管理员就麻烦了

##### 假如在共享的目录中有我们的重要的文件，怎么办？
</code></pre>

<pre><code>/srv/nfs_share/secret (noaccess)
</code></pre>

<pre><code>就是任何主机都不能访问/srv/nfs_share/secret 这个子目录


##### 如何限制root的权限
</code></pre>

<pre><code>/srv/nfs_share 192.168.*。*（rw,root-aquash）
</code></pre>

<pre><code>
##### 查看客户端挂载共享目录的状态
</code></pre>

<pre><code>$ nfsstat -c
</code></pre>

<pre><code>
##### 查看服务器的状态
</code></pre>

<pre><code>$ nfsstat -s
</code></pre>

<pre><code>
-----------------

http://stevenz.blog.hexun.com/16127677_d.html


服务器IP：172.0.0.1，主机名：p470-1, 通过NFS共享/disk1目录

在客户端使用 `mount -t nfs p470-1:/disk1 /disk1` 时出现
</code></pre>

<pre><code>mount: mount to NFS server 'p470-1' failed: RPC Error: Program not registered.
</code></pre>

<p>```
错误提示。</p>

<p>出错原因：p470-1由于网络原因nfs服务被中断，重新开启p470-1的nfs服务然后在客户端重新mount disk1即可</p>

<p>service nfs restart 或 /etc/rc.d/init.d/nfs restart</p>
]]></content>
  </entry>
  
</feed>
