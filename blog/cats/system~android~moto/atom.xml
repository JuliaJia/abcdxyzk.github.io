<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: system~android～moto | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/system~android~moto/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2014-12-23T01:47:18+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[查看所有(挂载、未挂载)的分区]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/12/22/android-partitions/"/>
    <updated>2014-12-22T22:15:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/12/22/android-partitions</id>
    <content type="html"><![CDATA[<p>blog.chinaunix.net/uid-22731254-id-3222708.html</p>

<p>下面的例子都是围绕/system目录。</p>

<p>使用df命令查看
<code>
    # df
    df
    Filesystem Size Used Free Blksize
    /dev       197M 64K   197M 4096
    /mnt/asec  197M 0K    197M 4096
    /mnt/obb   197M 0K    197M 4096
    /system    295M 245M  50M  4096
    /data      755M 26M   728M 4096
    /cache     188M 4M    184M 4096
    /HWUserData 2G 1024K  2G   32768
    /cust      59M 14M    44M  4096
    /mnt/sdcard 7G 753M   6G   32768
    /mnt/secure/asec 7G 753M 6G 32768
</code>
看到/system分区有295MB的大小。</p>

<p>接着查看/proc下的partitions
```
    # cat /proc/partitions
    cat /proc/partitions
    major minor #blocks name</p>

<pre><code>179    0    3817472 mmcblk0
179    1    20      mmcblk0p1
179    2    300     mmcblk0p2
179    3    133120  mmcblk0p3
179    4    1       mmcblk0p4
179    5    12288   mmcblk0p5
179    6    196608  mmcblk0p6
179    7    4096    mmcblk0p7
179    8    3072    mmcblk0p8
179    9    4096    mmcblk0p9
179    10   3072    mmcblk0p10
179    11   3072    mmcblk0p11
179    12   393216  mmcblk0p12
179    13   786432  mmcblk0p13
179    14   4096    mmcblk0p14
179    15   8192    mmcblk0p15
179    16   20480   mmcblk0p16
179    17   4096    mmcblk0p17
179    18   81920   mmcblk0p18
179    19   2154496 mmcblk0p19
179    32   7761920 mmcblk1
179    33   7757824 mmcblk1p1
31     0    4096    mtdblock0
</code></pre>

<p>```</p>

<p>其实，可以在/proc/mounts下面看的更直接。。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[完整版刷android内核及定制内核模块攻略]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/12/22/android-kernel-2/"/>
    <updated>2014-12-22T22:15:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/12/22/android-kernel-2</id>
    <content type="html"><![CDATA[<p>blog.sina.com.cn/s/blog_706845a5010129da.html</p>

<p>终于很恶心的把流程走通了</p>

<p>首先列出需要的东西，从网上搜一下就能搜到了：<br/>
&mdash;&mdash;&mdash;源码类&mdash;&mdash;&mdash;&ndash;<br/>
1. kernel source<br/>
2. .config文件</p>

<p>&mdash;&mdash;&mdash;工具类&mdash;&mdash;&mdash;&ndash;<br/>
1. 交叉编译器arm-eabi-<br/>
2. fastboot,adb等android工具<br/>
3. mkbootimg用于解包boot.img使用</p>

<p>&mdash;&mdash;&mdash;脚本类&mdash;&mdash;&mdash;&ndash;<br/>
1. repack-bootimg.pl //不一定需要<br/>
2. unpack-bootimg.pl</p>

<h5>下面是完整版刷内核及内核模块攻略（基于恶心的Galaxy Nexus）</h5>

<h5>1. 配置交叉编译器等各种环境</h5>

<p>  1)下载交叉编译器：<br/>
  $ git clone <a href="https://android.googlesource.com/platform/prebuilt">https://android.googlesource.com/platform/prebuilt</a></p>

<p>  2)写入环境变量中：<br/>
  export PATH=&ldquo;/home/xxx/android-toolchain/prebuilt/linux-x86/toolchain/arm-eabi-4.4.3/bin:$PATH&rdquo;</p>

<h5>2. 编译内核</h5>

<p>  1)修改内核根目录下的Makefile(一劳永逸的方法&hellip;)：<br/>
<code>
        #ARCH           ?= $(SUBARCH)
        #CROSS_COMPILE  ?= $(CONFIG_CROSS_COMPILE:"%"=%)
        ARCH            ?= arm
        CROSS_COMPILE   ?= arm-eabi-
</code>
  2)从手机目录： /proc/下找到config.gz压缩文件，拿出来解压成.config，复制到内核源码根目录下<br/>
        很多情况下手机中没有config.gz，我们刷了N多的rom加内核才找到一个能正常跑并且里面有这个文件的内核&hellip;<br/>
        但是找到了可以一直使用，即使换了别的rom或者内核也没关系<br/>
        实在没有的话，看第三步。<br/>
  3)如果2)成功了，执行make menuconfig，看看该配置是否支持netfilter，如果不支持安下面的选上<br/>
<code>
        To use netfilter
        Networking support  -&gt; Networking options -&gt;  Network packet filtering framework (Netfilter)
        Choose related choices
</code>
  如果找到config.gz，执行make tuna_defconfig（这个是默认的德州仪器CPU的配置文件，理论上可用，但是我没有成功），然后同样看netfilter配置<br/>
  4)执行make -j 2<br/>
  5)完成编译，得到arch/arm/boot/zImage文件</p>

<h5>3. 将zImage扔到手机中</h5>

<p>  1)从手机中拿出boot.img，或者从刷入手机的rom或kernel中拿也可，总之拿到一个手机在用的boot.img<br/>
  2)执行前确保各个脚本permission正确，将boot.img,zImage,脚本unpack-bootimg.pl,可执行文件mkbootimg,放于同一个目录下。<br/>
  3)执行脚本com.sh：（com.sh内容如下），用于将zImage打包进boot.img形成我们自己的kernel：newtestboot.img<br/>
<code>
        ./unpack-bootimg.pl boot.img
        cd boot.img-ramdisk/
        find . | cpio -o -H newc | gzip &gt; ../ramdisk-repack.cpio.gz
        cd ..       
        ./mkbootimg --kernel zImage --ramdisk boot.img-ramdisk/ramdisk-repack.cpio.gz --base 0x30000000 -o newtestboot.img
</code></p>

<h5>4. 手机进入bootloader模式,利用fastboot刷入newtestboot.img</h5>

<p>  1)$ adb reboot bootloader<br/>
  2)$ fastboot boot newtestboot.img<br/>
        若出现permission denied，waiting for devices之类的问题，执行<br/>
        $ sudo vim /etc/udev/rules.d/51-android.rules<br/>
        在规则中添加<br/>
        若出现permission denied之类的错误，执行<br/>
        $ sudo vim /etc/udev/rules.d/51-android.rules<br/>
        在规则中添加：
<code>
            SUBSYSTEM=="usb", ATTRS{idVendor}=="0bb4", MODE="0666"
            SUBSYSTEM=="usb", SYSFS{idVendor}=="18d1", MODE="0666"
</code>
        这个的作用是将usb权限以及配置与adb或者fastboot配对，特别是fastboot由于是通过usb线刷的，必须保证usb口是匹配的。</p>

<h5>5. 此时不出意外就是完成了内核刷入，下面将内核模块加载进去就简单了</h5>

<h5>6. 编译内核模块</h5>

<p>  1)利用我们的内核源码作为头文件，交叉编译器作为编译器来编译内核模块，Makefile文件写法如下：
<code>
        KERNELDIR := /home/carelife/android_icecream/android_kernel/CyanogenMod
        PWD :=$(shell pwd)
        ARCH=arm
        CROSS_COMPILE=arm-eabi-
        CC=$(CROSS_COMPILE)gcc
        LD=$(CROSS_COMPILE)ld
        obj-m := netCatch.o
        modules:
                $(MAKE) -C $(KERNELDIR) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) M=$(PWD) modules  
        clean:
                $(MAKE) -C $(KERNELDIR) M=$(PWD) clean
</code></p>

<h5>7. 加载KM</h5>

<pre><code>  1)$ adb push /your_kernel_module_position /sdcard/
  2)$ adb shell
        #cd sdcard
        #insmod your_kernel_module_name
</code></pre>

<h5>8. 查看debug信息</h5>

<p>  1)$ adb shell dmesg<br/>
        这个方法的实质是从手机IO缓存中读取print信息，输出到电脑屏幕上，所以是一个固定时间更新的静态查看信息的方法，十分不利于调试<br/>
  2)等待寻找其他debug方法&hellip;</p>
]]></content>
  </entry>
  
</feed>
