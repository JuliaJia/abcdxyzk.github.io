<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: language | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/language/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2014-11-30T22:48:57+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[css 二级菜单]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/11/13/lang-css-menu/"/>
    <updated>2014-11-13T14:52:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/11/13/lang-css-menu</id>
    <content type="html"><![CDATA[<pre><code>    &lt;style type="text/css"&gt;

    .divclass
    {
        display:none;
        font-size:12px;
        position:relative;
        left:0px;
        top:0px;
        padding:5px 10px 0px 10px;
        width:320px;
    }
    &lt;/style&gt;
    &lt;script language="javascript" type="text/javascript"&gt;

    function showDiv(divName)
    {
        if (document.getElementById(divName).style.display == "block")
            document.getElementById(divName).style.display = "none"; //隐藏层
        else
            document.getElementById(divName).style.display = "block"; //显示层
    }
    &lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;div id="menu"&gt;
    &lt;ul&gt;
    &lt;li&gt;&lt;a href="#" onmousedown="showDiv('div1')"&gt;菜单一&lt;/a&gt;&lt;/li&gt;
        &lt;div id="div1" class=divclass&gt;
        &lt;a href="#" onmousedown="showDiv('div2')"&gt;子菜单一&lt;/a&gt;
            &lt;div id="div2" class=divclass&gt;
            &lt;ul&gt;
            &lt;li&gt;&lt;a href="#"&gt;子菜单一&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href="#"&gt;子菜单二&lt;/a&gt;&lt;/li&gt;
            &lt;ul&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;li&gt;&lt;a href="#" onmousedown="showDiv('div3')"&gt;菜单三&lt;/a&gt;&lt;/li&gt;
    &lt;div id="div3" class=divclass&gt;
    &lt;ul&gt;
    &lt;ul&gt;
    &lt;/div&gt;
    &lt;li&gt;&lt;a href="#" onmousedown="showDiv('div4')"&gt;菜单四&lt;/a&gt;&lt;/li&gt;
    &lt;div id="div4" class=divclass&gt;
    &lt;ul&gt;
        &lt;li&gt;&lt;a href="#"&gt;子菜单一&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href="#"&gt;子菜单二&lt;/a&gt;&lt;/li&gt;
    &lt;ul&gt;
    &lt;/div&gt;
    &lt;/ul&gt;
    &lt;/div&gt;
    &lt;/body&gt;
    &lt;/html&gt;
    &lt;script language="javascript" type="text/javascript"&gt;
    showDiv('div1');
    &lt;/script&gt;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[强制内联和强制不内联]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/09/11/lang-c-inline-noinline/"/>
    <updated>2014-09-11T09:34:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/09/11/lang-c-inline-noinline</id>
    <content type="html"><![CDATA[<h4>1.强制不内联</h4>

<p>一个函数，如果代码量比较少的话，用 -O3优化开关的话，gcc有可能将这个函数强制内联(inline)即使，你在函数前没有写inline助记符。<br/>
如果是一个手写汇编的函数，那样的话很有可能破坏参数。gcc里有强制不内联的，用法如下
<code>
    void foo() __attribute__((noinline));
</code>
但是有的gcc可能会忽略 noinline。<br/>
那么你可以将你实现的这个函数写到调用函数之后，就不会被inline了。这是因为编译器gcc只内联当前函数之前可见(实现代码在前)的函数。</p>

<h4>2.优化时无法识别inline函数中的ASM汇编</h4>

<p>当GCC尝试内联一个函数时，如果该函数中存在内联汇编，则该汇编语句块可能被丢弃；
<code>
    __inline__ __attribute__((always_inline))int Increment(int volatile *add, int inc)
    {
        int res;
        __asm__
        (
        "lock \n\t"
        "xaddl %0,(%1)\n\t"
        :"=r"(res)
        :"r"(add),"0"(inc)
        :"memory"
        );
        return res;
    }
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[const的使用]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/03/17/lang-c-const/"/>
    <updated>2014-03-17T17:31:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/03/17/lang-c-const</id>
    <content type="html"><![CDATA[<h4>1、定义常量</h4>

<h5>(1)const修饰变量</h5>

<p>以下两种定义形式在本质上是一样的。<br/>
它的含义是：const修饰的类型为TYPE的变量value是不可变的。
<code>
    TYPE const ValueName = value;
    const TYPE ValueName = value;
</code></p>

<h5>(2)将const改为外部连接</h5>

<p>作用于扩大至全局,编译时会分配内存,并且可以不进行初始化,仅仅作为声明,编译器认为在程序其他地方进行了定义.
<code>
    extend const int ValueName = value;
</code></p>

<h4><span style="color:red">2、指针使用CONST</span></h4>

<h5>(1)指针本身是常量不可变</h5>

<pre><code>    (char*) const pContent;
    const (char*) pContent;
</code></pre>

<h5>(2)指针所指向的内容是常量不可变</h5>

<pre><code>    const (char) *pContent;
    (char) const *pContent;
</code></pre>

<h5>(3)两者都不可变</h5>

<pre><code>    const char* const pContent;
</code></pre>

<h5>(4)还有其中区别方法，沿着*号划一条线：</h5>

<p>如果const位于<em>的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；<br/>
如果const位于</em>的右侧，const就是修饰指针本身，即指针本身是常量。</p>

<h4>3、函数中使用CONST</h4>

<h5>(1)const修饰函数参数</h5>

<h6>a.传递过来的参数在函数内不可以改变(无意义，因为Var本身就是形参)</h6>

<pre><code>    void function(const int Var);
</code></pre>

<h6>b.参数指针所指内容为常量不可变</h6>

<pre><code>    void function(const char* Var);
</code></pre>

<h6>c.参数指针本身为常量不可变(也无意义，因为char* Var也是形参)</h6>

<pre><code>    void function(char* const Var);
</code></pre>

<h6>d.参数为引用，为了增加效率同时防止修改。修饰引用参数时：</h6>

<pre><code>    void function(const Class&amp; Var);//引用参数在函数内不可以改变
    void function(const TYPE&amp; Var); //引用参数在函数内为常量不可变
</code></pre>

<p>这样的一个const引用传递和最普通的函数按值传递的效果是一模一样的,他禁止对引用的对象的一切修改,唯一不同的是按值传递会先建立一个类对象的副本, 然后传递过去,而它直接传递地址,所以这种传递比按值传递更有效.另外只有引用的const传递可以传递一个临时对象,因为临时对象都是const属性, 且是不可见的,他短时间存在一个局部域中,所以不能使用指针,只有引用的const传递能够捕捉到这个家伙.</p>

<h5>(2)const 修饰函数返回值</h5>

<p>const修饰函数返回值其实用的并不是很多，它的含义和const修饰普通变量以及指针的含义基本相同。</p>

<h6>a.</h6>

<p>const int fun1() // 这个其实无意义，因为参数返回本身就是赋值。</p>

<h6>b.</h6>

<p>const int * fun2() //调用时 const int *pValue = fun2();<br/>
                   //我们可以把fun2()看作成一个变量，即指针内容不可变。</p>

<h6>c.</h6>

<p>int* const fun3()   //调用时 int * const pValue = fun2();<br/>
                    //我们可以把fun2()看作成一个变量，即指针本身不可变。</p>

<p>一般情况下，函数的返回值为某个对象时，如果将其声明为const时，多用于操作符的重载。<br/>
通常，不建议用const修饰函数的返回值类型为某个对象或对某个对象引用的情况。<br/>
原因如下：<br/>
如果返回值为某个对象为const（const A test = A 实例）或某个对象的引用为const（const A&amp; test = A实例） ，<br/>
则返回值具有const属性，则返回实例只能访问类A中的公有（保护）数据成员和const成员函数，<br/>
并且不允许对其进行赋值操作，这在一般情况下很少用到。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[可重入函数与不可重入函数]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/01/09/lang-c-re-enter-fun/"/>
    <updated>2014-01-09T17:29:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/01/09/lang-c-re-enter-fun</id>
    <content type="html"><![CDATA[<p>可重入函数主要用于多任务环境中，简单来说就是可以被中断的函数，即在这个函数执行的任何时刻中断它，转入OS调度下去执行另外一段代 码，返回控制时不会出现什么错误；也意味着它除了使用自己栈上的变量以外不依赖于任何环境（包括static），这样的函数就是 purecode（纯代码）可重入，可以允许有该函数的多个副本在运行，由于它们使用的是分离的栈，所以不会互相干扰。而不可重入的函数由于使用了一些系 统资源，比如全局变量区、中断向量表等，所以它如果被中断的话，可能会出现问题，这类函数是不能运行在多任务环境下的。</p>

<p>可重入函数确实需要访问全局变量（包括 static），一定要注意实施互斥手段。它在并行运行环境中非常重要，但是一般要为访问全局变量付出一些性能代价。编写可重入函数时，若使用全局变量，则应通过关中断、信号量（即P、V操作）等手段对其加以保护。若对所使用的全局变量不加以保护，则此函数就不具有可重入性，即当多个进程调用此函数时，很有可能使有关全局变量变为不可知状态。</p>

<p>示例：假设Exam是 int型全局变量，函数Squre_Exam返回Exam平方值。那么如下函数不具有可重入性。
<code>
    int Exam = 0;
    unsigned int example( int para )
    {
        unsigned int temp;
        Exam = para; // （**）
         temp = Square_Exam( );
        return temp;  
    }
</code>
此函数若被多个进程调用的话，其结果可能是未知的，因为当（**）语句刚执行完后，另外一个使用本函数的进程可能正好被激活，那么当新激活的进程执行到此 函数时，将使Exam赋与另一个不同的para值，所以当控制重新回到“temp = Square_Exam( )”后，计算出的temp很可能不是预想中的结果。此函数应如下改进。
<code>
    int Exam = 0;
    unsigned int example( int para )
    {
        unsigned int temp;  
        [申请信号量操作] //(1)  加锁  
        Exam = para;  
        temp = Square_Exam( );  
        [释放信号量操作] //   解锁   
        return temp;  
    }
</code>
申请不到“信号量”，说明另外的进程正处于给Exam赋值并计算其平方过程中（即正在使用此信号）,本进程必须等待其释放信号后，才可继续执行。若申请到 信号，则可继续执行，但其它进程必须等待本进程释放信号量后，才能再使用本信号。保证函数的可重入性的方法：<br/>
     1、在写函数时候尽量使用局部变量（例如寄存器、堆栈中的变量）；<br/>
     2、对于要使用的全局变量要加以保护（如采取关中断、信号量等方法），这样构成的函数就一定是一个可重入的函数。</p>

<p>满足下列条件的函数多数是不可重入的：<br/>
     1、函数体内使用了静态的数据结构；<br/>
     2、函数体内调用了malloc()或者free()函数；<br/>
     3、函数体内调用了标准I/O函数。</p>

<p>如何将一个不可重入的函数改写成可重入函数呢？把一个不可重入函数变成可重入的唯一方法是用可重入规则来重写它。其实很简单，只要遵守了几条很容易理解的规则，那么写出来的函数就是可重入的：<br/>
     1、不要使用全局变量。因为别的代码很可能覆盖这些变量值。<br/>
     2、在和硬件发生交互的时候，切记执行类似disinterrupt()之类的操作，就是关闭硬件中断。完成交互记得打开中断，在有些系列上，这叫做“进入/ 退出核心”。<br/>
     3、不能调用其它任何不可重入的函数。<br/>
     4、谨慎使用堆栈。最好先在使用前先OS_ENTER_KERNAL。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[字节序和比特序]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/06/20/lang-c-B_b_byte/"/>
    <updated>2013-06-20T18:23:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/06/20/lang-c-B_b_byte</id>
    <content type="html"><![CDATA[<p>字节序和比特序，因为比特序对所有代码（包括汇编）是透明的，所以对于小端系统，有说是用大端比特序，也有说是用小端比特序。<br/>
下面是copy一部分觉得靠谱的内容：<br/>
大小端
我们对"endianness"这个名词估计都很熟悉了。它首先被Danny Cohen于1980引入，用来表述计算机系统表示多字节整数的方式。
endianness分为两种：大端和小端。(从字节序的角度来看)大端方式是将整数中最高位byte存放在最低地址中。而小端方式则相反，将整数中的最高位byte存放在最高地址中。
对于某个确定的计算机系统，比特序通常与字节序保持一致。换言之，在大端系统中，每个byte中最高位bit存放在内存最低位；在小端系统中，最低位bit存放在内存最低位。
正如大部分人是按照从左至右的顺序书写数字，一个多字节整数的内存布局也应该遵循同样的方式，即从左至右为数值的最高位至最低位。正如我们在下面的例子中所看到的，这是书写整数最清晰的方式。</p>

<p>根据上述规则，我们按以下方式分别在大端和小端系统中值为0x0a0b0c0d的整数。
在大端系统中书写整数：
byte  addr  0   1   2   3
bit offset  01234567 01234567 01234567 01234567</p>

<pre><code>binary  00001010 00001011 00001100 00001101
  hex      0a       0b       0c       0d
</code></pre>

<p>在小端系统中书写整数(认真看)
byte  addr  0   1   2   3
bit offset  01234567 01234567 01234567 01234567</p>

<pre><code>binary  10110000 00110000 11010000 01010000
  hex      d0       c0       b0       a0
</code></pre>

<p>说明字节序：
<code>
    #include &lt;stdio.h&gt;  
    int main (void)  
    {  
        union b  
        {  
            short k;  //测试环境short占2字节  
            char i[2];  //测试环境char占1字节  
        }*s,a;  
        s=&amp;a;  
        s-&gt;i[0]=0x41;  
        s-&gt;i[1]=0x52;  
        printf("%x\n",s-&gt;k);  
        return 0;  
    }
</code>
输出：5241</p>

<hr />

<p>self code:
```
    #include &lt;stdio.h>
    union W
    {
        struct Y
        {
            unsigned int s1:4;
            unsigned int s2:8;
            unsigned int s3:20;
        } y;
        unsigned int c;
    } w;</p>

<pre><code>union V 
{
    struct X
    {
        unsigned char s1:3;
        unsigned char s2:3;
        unsigned char s3:2;
    } x;
    unsigned char c;
} v;

int main()
{
    w.c = 0x12345678;
    printf("%x %x %x %x\n", w.c, w.y.s1, w.y.s2, w.y.s3); 

    v.c = 100;
    printf("%d %x %x %x\n", v.c, v.x.s1, v.x.s2, v.x.s3); 
    return 0;
}
</code></pre>

<p>```</p>

<p>输出：<br/>
12345678 8 67 12345<br/>
100 4 4 1</p>

<p>100 = （01100100）2<br/>
因为字节序是小端的所以第一行输出说明：位域变量从左到右分配位，所以第二行的输出的位域变量也应该从左到右分配位。所以<br/>
100 = 001 001 10  （小端比特序二进制）<br/>
对应:  s1  s2  s3  （位域变量从左到右分配位）</p>

<p>符合。</p>
]]></content>
  </entry>
  
</feed>
