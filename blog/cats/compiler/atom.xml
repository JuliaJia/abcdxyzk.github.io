<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: compiler | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/compiler/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2014-12-04T23:52:07+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[编译Android的kernel]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/12/04/compiler-android-kernel/"/>
    <updated>2014-12-04T17:34:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/12/04/compiler-android-kernel</id>
    <content type="html"><![CDATA[<h4>一 下载</h4>

<ol>
<li><p>下载arm编译器<br/>
<a href="https://launchpad.net/gcc-arm-embedded/+download">https://launchpad.net/gcc-arm-embedded/+download</a></p></li>
<li><p>进入到你的android源代码目录，敲入下面命令：<br/>
git clone <a href="http://android.googlesource.com/kernel/goldfish.git">http://android.googlesource.com/kernel/goldfish.git</a> kernel</p></li>
<li><p>cd kernel  进入我们刚才创建的kernel文件夹</p></li>
<li><p>git branch -avv 查看远程的git 库<br/>
我们选择remotes/origin/android-goldfish-2.6.29分支来下载</p></li>
<li><p>git checkout -b android-goldfish-2.6.29 remotes/origin/android-goldfish-2.6.29</p></li>
</ol>


<h4>二  编译kernel代码</h4>

<ol>
<li><p>设置环境变量<br/>
export PATH=$PATH:~/andr-perf/gcc-arm-none-eabi-4_8-2014q3/bin</p></li>
<li><p>修改kernel下面的makefile文件，修改<br/>
ARCH        ?= $(SUBARCH)<br/>
CROSS_COMPILE    ?=<br/>
这两个字段成如下内容：<br/>
ARCH        ?= arm<br/>
CROSS_COMPILE    ?= arm-none-eabi-</p></li>
<li><p>开始编译,敲入如下命令<br/>
make goldfish_defconfig<br/>
或者看arch/arm/configs/目录下有什么，就挑一个make XXX</p></li>
<li><p>正式编译,敲入如下命令<br/>
make</p></li>
</ol>


<p>正式编译成功之后，我们会看到如下文字：<br/>
OBJCOPY arch/arm/boot/zImage<br/>
Kernel: arch/arm/boot/zImage is ready</p>

<h4>三  利用新编译的kernel来启动模拟器</h4>

<ol>
<li><p>在启动模拟器之前，先设置模拟器的目录到环境变量$PATH中去：<br/>
  USER-NAME@MACHINE-NAME:~/Android$ export PATH=$PATH:~/android_prj/out/host/linux-x86/bin</p></li>
<li><p>设置ANDROID_PRODUCT_OUT环境变量：<br/>
USER-NAME@MACHINE-NAME:~/Android$ export ANDROID_PRODUCT_OUT=~/android_prj/out/target/product/generic<br/>
同样，如果你的源代码目录不是android_prj，请注意修改下。另外，如果你已经配置了环境变量。则不必如此。建议最好写到配置文件 ~/.bash_rc配置文件里面去。 免得每次都要配置</p></li>
<li><p>启动模拟器<br/>
cd ~/android_prj  回到源代码目录<br/>
sandy@ubuntu:~/android_prj$ emulator -kernel ./kernel/arch/arm/boot/zImage 利用刚才我们编译的kernel内核启动模拟器</p></li>
<li><p>验证结果<br/>
待模拟器启动完毕之后，我们敲入adb shell<br/>
第一次会说device offline，不管它，再敲入一遍，就会进入adb 调试<br/>
然后cd proc 进入proc目录，cat version</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[部分GCC选项]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/12/04/compiler-gcc-args/"/>
    <updated>2014-12-04T17:23:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/12/04/compiler-gcc-args</id>
    <content type="html"><![CDATA[<h5>-Werror 和 -I 很有用</h5>

<table>
<tr bgcolor="#c0c0c0">
<th>命令</th><th>描述</th>
</tr>
<tr>
<td>-l&nbsp;<em>library</em>-l<em>library</em></td>
<td>进行链接时搜索名为library的库。例子： $ gcc test.c -lm -o test</td>
</tr>
<tr>
<td>-I<em>dir</em></td>
<td>把<em>dir</em>加入到搜索头文件的路径列表中。例子： $ gcc test.c -I../inc -o test</td>
</tr>
<tr>
<td>-L<em>dir</em></td>
<td>把<em>dir</em>加入到搜索库文件的路径列表中。例子： $ gcc -I/home/foo -L/home/foo -ltest test.c -o test</td>
</tr>
<tr>
<td>-D<em>name</em></td>
<td>预定义一个名为<em>name</em>的宏，值为1。例子： $ gcc -DTEST_CONFIG test.c -o test</td>
</tr>
<tr>
<td>-D<em>name</em>=<em>definition</em></td>
<td>预定义名为<em>name</em>，值为<em>definition</em>的宏。</td>
</tr>
<tr>
<td>-ggdb&nbsp;-ggdb<em>level</em></td>
<td>为调试器 gdb 生成调试信息。<em>level</em>可以为1，2，3，默认值为2。</td>
</tr>
<tr>
<td>-g&nbsp;-g<em>level</em></td>
<td>生成操作系统本地格式的调试信息。-g 和 -ggdb 并不太相同， -g 会生成 gdb 之外的信息。<em>level</em>取值同上。</td>
</tr>
<tr>
<td>-s</td>
<td>去除可执行文件中的符号表和重定位信息。用于减小可执行文件的大小。</td>
</tr>
<tr>
<td>-M</td>
<td>告诉预处理器输出一个适合make的规则，用于描述各目标文件的依赖关系。对于每个 源文件，预处理器输出 一个make规则，该规则的目标项(target)是源文件对应的目标文件名，依赖项(dependency)是源文件中 #include引用的所有文件。生成的规则可 以是单行，但如果太长，就用`/'-换行符续成多行。规则 显示在标准输出，不产生预处理过的C程序。</td>
</tr>
<tr>
<td>-C</td>
<td>告诉预处理器不要丢弃注释。配合`-E'选项使用。</td>
</tr>
<tr>
<td>-P</td>
<td>告诉预处理器不要产生`#line'命令。配合`-E'选项使用。</td>
</tr>
<tr>
<td>-static</td>
<td>在支持动态链接的系统上，阻止连接共享库。该选项在其它系统上 无效。</td>
</tr>
<tr>
<td>-nostdlib</td>
<td>不连接系统标准启动文件和标准库文件，只把指定的文件传递给连接器。</td>
</tr>
<tr bgcolor="#c0c0c0">
<th>Warnings</th><th></th>
</tr>
<tr>
<td>-Wall</td>
<td>会打开一些很有用的警告选项，建议编译时加此选项。</td>
</tr>
<tr>
<td>-W&nbsp;-Wextra</td>
<td>打印一些额外的警告信息。</td>
</tr>
<tr>
<td>-w</td>
<td>禁止显示所有警告信息。</td>
</tr>
<tr>
<td>-Wshadow</td>
<td>当一个局部变量遮盖住了另一个局部变量，或者全局变量时，给出警告。很有用的选项，建议打开。 -Wall 并不会打开此项。</td>
</tr>
<tr>
<td>-Wpointer-arith</td>
<td>对函数指针或者void *类型的指针进行算术操作时给出警告。也很有用。 -Wall 并不会打开此项。</td>
</tr>
<tr>
<td>-Wcast-qual</td>
<td>当强制转化丢掉了类型修饰符时给出警告。 -Wall 并不会打开此项。</td>
</tr>
<tr>
<td>-Waggregate-return</td>
<td>如果定义或调用了返回结构体或联合体的函数，编译器就发出警告。</td>
</tr>
<tr>
<td>-Winline</td>
<td>无论是声明为 inline 或者是指定了-finline-functions 选项，如果某函数不能内联，编译器都将发出警告。如果你的代码含有很多 inline 函数的话，这是很有用的选项。</td>
</tr>
<tr>
<td>-Werror</td>
<td>把警告当作错误。出现任何警告就放弃编译。</td>
</tr>
<tr>
<td>-Wunreachable-code</td>
<td>如果编译器探测到永远不会执行到的代码，就给出警告。也是比较有用的选项。</td>
</tr>
<tr>
<td>-Wcast-align</td>
<td>一旦某个指针类型强制转换导致目标所需的地址对齐增加时，编译器就发出警告。</td>
</tr>
<tr>
<td>-Wundef</td>
<td>当一个没有定义的符号出现在 #if 中时，给出警告。</td>
</tr>
<tr>
<td>-Wredundant-decls</td>
<td>如果在同一个可见域内某定义多次声明，编译器就发出警告，即使这些重复声明有效并且毫无差别。</td>
</tr>
</table>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[gcc同时使用动态和静态链接]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/11/06/complier-static-dynamic-ld/"/>
    <updated>2014-11-06T14:51:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/11/06/complier-static-dynamic-ld</id>
    <content type="html"><![CDATA[<p>gcc &ndash;static a.c -Wl,-Bstatic -lm -Wl,-Bdynamic -lc</p>

<p>其中用到的两个选项：-Wl,-Bstatic和-Wl,-Bdynamic。这两个选项是gcc的特殊选项，它会将选项的参数传递给链接器，作为 链接器的选项。比如-Wl,-Bstatic告诉链接器使用-Bstatic选项，该选项是告诉链接器，对接下来的-l选项使用静态链 接；-Wl,-Bdynamic就是告诉链接器对接下来的-l选项使用动态链接。下面是man gcc对-Wl,option的描述，<br/>
<code>
    -Wl,option  
           Pass option as an option to the linker.  If option contains commas, it is   
           split into multiple options at the commas.  You can use this syntax to pass  
           an argument to the option.  For example, -Wl,-Map,output.map passes -Map output.map  
           to the linker.  When using the GNU linker, you can also get the same effect with   
           -Wl,-Map=output.map.  
</code>
下面是man ld分别对-Bstatic和-Bdynamic的描述，<br/>
```
    -Bdynamic<br/>
    -dy<br/>
    -call_shared<br/>
           Link against dynamic libraries. You may use this option multiple times on the<br/>
           command line: it affects library searching for -l options which follow it.</p>

<pre><code>-Bstatic  
-dn  
-non_shared  
-static  
       Do not link against shared libraries. You may use this option multiple times on   
       the command line: it affects library searching for -l options which follow it.   
       This option also implies --unresolved-symbols=report-all.  This option can be   
       used with -shared.  Doing so means that a shared library is being created but   
       that all of the library's external references must be resolved by pulling in   
       entries from static libraries.  
</code></pre>

<p>```
　　值得注意的是对-static的描述：-static和-shared可以同时存在，这样会创建共享库，但该共享库引用的其他库会静态地链接到该共享库中。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GCC制作Library--shared部分相当不错]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/11/06/compiler-gcc-lib/"/>
    <updated>2014-11-06T14:49:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/11/06/compiler-gcc-lib</id>
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/alex_ww/article/details/4544207">贴自http://blog.csdn.net/alex_ww/article/details/4544207</a></p>

<h3>Library可分成三种，static、shared与dynamically loaded。</h3>

<h4>1. Static libraries</h4>

<p>Static 链接库用于静态链接，简单讲是把一堆object檔用ar(archiver)包装集合起来，文件名以 `.a' 结尾。优点是执行效能通常会比后两者快，而且因为是静态链接，所以不易发生执行时找不到library或版本错置而无法执行的问题。缺点则是档案较大，维护度较低；例如library如果发现bug需要更新，那么就必须重新连结执行档。</p>

<h5>1.1 编译</h5>

<p>编译方式很简单，先例用 `-c' 编出 object 檔，再用 ar 包起来即可。
<code>
    ____ hello.c ____
    #include
    void hello(){ printf("Hello "); }
    ____ world.c ____
    #include
    void world(){ printf("world."); }
    ____ mylib.h ____
    void hello();
    void world();
</code>
$ gcc -c hello.c world.c /* 编出 hello.o 与 world.o */ <br/>
$ ar rcs libmylib.a hello.o world.o /* 包成 limylib.a */ <br/>
这样就可以建出一个档名为 libmylib.a 的檔。输出的档名其实没有硬性规定，但如果想要配合 gcc 的 &lsquo;-l&rsquo; 参数来连结，一定要以 &lsquo;lib&rsquo; 开头，中间是你要的library名称，然后紧接着 &lsquo;.a&rsquo; 结尾。</p>

<h5>1.2 使用</h5>

<pre><code>    ____ main.c ____
    #include "mylib.h"
    int main() {
    hello();
    world();
    }
</code></pre>

<p>使用上就像与一般的 object 档连结没有差别。<br/>
$ gcc main.c libmylib.a<br/>
也可以配合 gcc 的 `-l' 参数使用<br/>
$ gcc main.c -L. -lmylib<br/>
&lsquo;-Ldir&rsquo; 参数用来指定要搜寻链接库的目录，'.&lsquo; 表示搜寻现在所在的目录。通常默认会搜 /usr/lib 或 /lib 等目录。<br/>
&rsquo;-llibrary' 参数用来指定要连结的链接库，'mylib' 表示要与mylib进行连结，他会搜寻library名称前加'lib'后接'.a'的档案来连结。<br/>
$ ./a.out<br/>
Hello world.</p>

<h3>2. Shared libraries</h3>

<p>Shared library 会在程序执行起始时才被自动加载。因为链接库与执行档是分离的，所以维护弹性较好。有两点要注意，shared library是在程序起始时就要被加载，而不是执行中用到才加载，而且在连结阶段需要有该链接库才能进行连结。<br/>
首先有一些名词要弄懂，soname、real name与linker name。<br/>
soname 用来表示是一个特定 library 的名称，像是 libmylib.so.1 。前面以 &lsquo;lib&rsquo; 开头，接着是该 library 的名称，然后是 &lsquo;.so&rsquo; ，接着是版号，用来表名他的界面；如果接口改变时，就会增加版号来维护兼容度。<br/>
real name 是实际放有library程序的文件名，后面会再加上 minor 版号与release 版号，像是 libmylib.so.1.0.0 。<br/>
一般来说，版号的改变规则是(印象中在 APress-Difinitive Guide to GCC中有提到，但目前手边没这本书)，最后缀的release版号用于程序内容的修正，接口完全没有改变。中间的minor用于有新增加接口，但相旧接口没改变，所以与旧版本兼容。最前面的version版号用于原接口有移除或改变，与旧版不兼容时。<br/>
linker name是用于连结时的名称，是不含版号的 soname ，如: libmylib.so。<br/>
通常 linker name与 real name是用 ln 指到对应的 real name ，用来提供弹性与维护性。</p>

<h5>2.1 编译</h5>

<p>shared library的制作过程较复杂。<br/>
$ gcc -c -fPIC hello.c world.c<br/>
编译时要加上 -fPIC 用来产生 position-independent code。也可以用 -fpic参数。 (不太清楚差异，只知道 -fPIC 较通用于不同平台，但产生的code较大，而且编译速度较慢)。<br/>
$ gcc -shared -Wl,-soname,libmylib.so.1 -o libmylib.so.1.0.0 /<br/>
hello.o world.o<br/>
-shared 表示要编译成 shared library<br/>
-Wl 用于参递参数给linker，因此-soname与libmylib.so.1会被传给linker处理。<br/>
-soname用来指名 soname 为 limylib.so.1<br/>
library会被输出成libmylib.so.1.0.0 (也就是real name)<br/>
若不指定 soname 的话，在编译结连后的执行档会以连时的library档名为soname，并载入他。否则是载入soname指定的library档案。<br/>
可以利用 objdump 来看 library 的 soname。<br/>
$ objdump -p libmylib.so | grep SONAME<br/>
SONAME libmylib.so.1<br/>
若不指名-soname参数的话，则library不会有这个字段数据。<br/>
在编译后再用 ln 来建立 soname 与 linker name 两个档案。<br/>
$ ln -s libmylib.so.1.0.0 libmylib.so<br/>
$ ln -s libmylib.so.1.0.0 libmylib.so.1</p>

<h5>2.2 使用</h5>

<p>与使用 static library 同。<br/>
$ gcc main.c libmylib.so<br/>
以上直接指定与 libmylib.so 连结。<br/>
或用<br/>
$ gcc main.c -L. -lmylib<br/>
linker会搜寻 libmylib.so 来进行连结。<br/>
如果目录下同时有static与shared library的话，会以shared为主。<br/>
使用 -static 参数可以避免使用shared连结。<br/>
$ gcc main.c -static -L. -lmylib<br/>
此时可以用 ldd 看编译出的执行档与shared链接库的相依性<br/>
$ldd a.out<br/>
linux-gate.so.1 => (0xffffe000)<br/>
libmylib.so.1 => not found<br/>
libc.so.6 => /lib/libc.so.6 (0xb7dd6000)<br/>
/lib/ld-linux.so.2 (0xb7f07000)<br/>
输出结果显示出该执行文件需要 libmylib.so.1 这个shared library。<br/>
会显示 not found 因为没指定该library所在的目录，所找不到该library。<br/>
因为编译时有指定-soname参数为 libmylib.so.1 的关系，所以该执行档会加载libmylib.so.1。否则以libmylib.so连结，执行档则会变成要求加载libmylib.so
$ ./a.out<br/>
./a.out: error while loading shared libraries: libmylib.so.1:<br/>
cannot open shared object file: No such file or directory<br/>
因为找不到 libmylib.so.1 所以无法执行程序。<br/>
有几个方式可以处理。<br/>
a. 把 libmylib.so.1 安装到系统的library目录，如/usr/lib下<br/>
b. 设定 /etc/ld.so.conf ，加入一个新的library搜寻目录，并执行ldconfig<br/>
更新快取<br/>
c. 设定 LD_LIBRARY_PATH 环境变量来搜寻library<br/>
这个例子是加入当前目录来搜寻要载作的library<br/>
$ LD_LIBRARY_PATH=. ./a.out<br/>
Hello world.</p>

<h4>3. Dynamically loaded libraries</h4>

<p>Dynamicaaly loaded libraries 才是像 windows 所用的 DLL ，在使用到<br/>
时才加载，编译连结时不需要相关的library。动态载入库常被用于像plug-ins的应用。</p>

<h5>3.1 使用方式</h5>

<p>动态加载是透过一套 dl function来处理。<br/>
    #include &lt;dlfcn.h><br/>
    void *dlopen(const char *filename, int flag);<br/>
开启加载 filename 指定的 library。<br/>
    void *dlsym(void *handle, const char *symbol);<br/>
取得 symbol 指定的symbol name在library被加载的内存地址。<br/>
    int dlclose(void *handle);<br/>
关闭dlopen开启的handle。<br/>
    char *dlerror(void);<br/>
传回最近所发生的错误讯息。
<code>
    ____ dltest.c ____
    #include &lt;stdio.h&gt;
    #include &lt;stdlib.h&gt;
    #include &lt;stddef.h&gt;
    #include &lt;dlfcn.h&gt;
    int main() {
    void *handle;
    void (*f)();
    char *error;
    /* 开启之前所撰写的 libmylib.so 链接库 */
    handle = dlopen("./libmylib.so", RTLD_LAZY);
    if( !handle ) {
    fputs( dlerror(), stderr);
    exit(1);
    }
    /* 取得 hello function 的 address */
    f = dlsym(handle, "hello");
    if(( error=dlerror())!=NULL) {
    fputs(error, stderr);
    exit(1);
    }
    /* 呼叫该 function */
    f();
    dlclose(handle);
    }
</code>
编译时要加上 -ldl 参数来与 dl library 连结<br/>
$ gcc dltest.c -ldl<br/>
结果会印出 Hello 字符串<br/>
$ ./a.out<br/>
Hello<br/>
关于dl的详细内容请参阅 man dlopen</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[binutils(含as、ld等)静态编译]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/10/31/compiler-binutil-static/"/>
    <updated>2013-10-31T14:47:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/10/31/compiler-binutil-static</id>
    <content type="html"><![CDATA[<h4>静态编译</h4>

<pre><code>./configure 后加   CFLAGS=-static --enable-static LDFLAGS=-static --disable-shared
./configure 后加   CFLAGS=-static LDFLAGS=-static
</code></pre>

<h4>binutils-2.23.2 中gas、ld静态编译：</h4>

<pre><code>./configure
make
cd gas
make clean
make LDFLAGS=-all-static
</code></pre>

<p>或者
<code>
./configure
vim gas/Makefile
     搜 --mode=link，找到 LINK = $(LIBTOOL) --tag=CC ...
     在CC后面加个参数 -all-static
make
</code></p>

<h5>原因：</h5>

<p>他们链接的时候是通过 ./libtool 完成的，在libtool里有一行提示（./libtool &ndash;help没有显示这个提示)：
<code>
-all-static       do not do any dynamic linking at all
</code>
所以就是要libtool增加-all-static参数</p>
]]></content>
  </entry>
  
</feed>
