<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: kernel~sched | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/kernel~sched/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2015-01-03T23:26:57+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[中断，进程]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/01/03/kernel-sched-irq-mark/"/>
    <updated>2015-01-03T15:45:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/01/03/kernel-sched-irq-mark</id>
    <content type="html"><![CDATA[<p>blog.chinaunix.net/uid-20806345-id-3203602.html</p>

<p>  中断不是进程，不受内核调度器的管辖。在系统处理进程的过程中，对于某个cpu来说，如果有内部中断或外部中断到来，则切换到中断处理程序，切换首先要将进程由用户态要切到进程的内核态，然后再将cpu切换到中断态，待处理完中断返回进程的内核态，再返回进程的用户态，如果中断时进程刚好处于内核态中不用由用户态切到内核态了。<br/>
  中断处理时是不分优先级的，处理中断的过程中如果有任意中断到来，都会抢占当前的中断处理过程。所以对于要及时响应的中断，需要通过关中断来屏蔽其他中断。通常所说的中断优先级是指中断控制器端的优先级，当有多个中断触发时，首先选择优先级高的中断发出请求给处理器。中断优先级只是对中断控制器而言的，所有的中断对cpu来说都是一样的，没有优先级高低之分。<br/>
  关中断是关闭所有的外部可屏蔽中断，和优先级没有关系，如果在某中断处理程序中关中断，则不会被任何可屏蔽中断抢占，但是会被任意的不可屏蔽中断抢占。关中断是中断处理程序可选的。</p>

<p>bbs.chinaunix.net/thread-2306027-1-8.html</p>

<p>软中断做的是一些可延迟的费时间的事，当然不能在中断里执行了。<br/>
  <code>__do_softirq</code>代码，可以看到在执行可延迟函数第一件事就是开中断。但在开始之前，禁用了下半部中断（<code>__local_bh_disable</code>）。这样就算被中断了，返回内核时也不会被抢占，还是执行这里的代码。也不会被调度。<br/>
  那么这样的后果就是软中断上下文里的会一直执行下去，直到到达了限定次数，然后唤醒守护进程。<br/>
  因为软中断切换了栈，不再使用进程上下文，那么如果在软中断上下文直接或简洁调用了shedule，那么只有死翘翘了！！因为schedule调度回来的时候是依赖进程内核栈的thread_info。</p>

<p>  内核抢占点之一就是中断返回的时候检查是否可以抢占，检查的内容之一就是preempt_count是否等于0，因为禁用了下半部中断，那么肯定就不会等于0的，所以不会被抢占。也就是说返回的时候不会发生调度。</p>

<p>  个人理解 中断上下文 最大的特征 禁掉了某种中断（硬中断和软中断），所以导致 不能阻塞。<br/>
  softirq 有可能在两种方式下被调用，一是中断处理程序退出时，开放硬件中断之后，会去调用do_softirq()。
  do_softirq()会禁掉后半部抢占，并且现在执行流使用的是被中断的进程的栈，所以无法阻塞。<br/>
  softirq的另一种调用方式是ksoftirq内核线程，同样do_softirq()被调用，后半部中断被禁掉，同样禁止阻塞。<br/>
  工作队列，可以被任何中断或者软中断中断，运行在进程上下文，有自己的栈，可以阻塞。</p>

<p>看一下__do_softirq()的代码,新的硬中断确实可能触发更高优先级的软中断，但是这个软中断并不会在被中断的软中断之前得到执行，软中断始终是顺序执行的。从代码看来，新一批的软中断，无论优先级多高，也得等到前一批的软中断被处理完成之后才能得到处理。而优先级只能帮助软中断在对应的批次中优先得到处理。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[硬中断和软中断]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/01/03/kernel-sched-irq/"/>
    <updated>2015-01-03T15:15:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/01/03/kernel-sched-irq</id>
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/zhangskd/article/details/21992933">http://blog.csdn.net/zhangskd/article/details/21992933</a></p>

<h4>概述</h4>

<p>从本质上来讲，中断是一种电信号，当设备有某种事件发生时，它就会产生中断，通过总线把电信号发送给中断控制器。
如果中断的线是激活的，中断控制器就把电信号发送给处理器的某个特定引脚。处理器于是立即停止自己正在做的事，
跳到中断处理程序的入口点，进行中断处理。</p>

<h5>(1) 硬中断</h5>

<p>由与系统相连的外设(比如网卡、硬盘)自动产生的。主要是用来通知操作系统系统外设状态的变化。比如当网卡收到数据包的时候，就会发出一个中断。我们通常所说的中断指的是硬中断(hardirq)。</p>

<h5>(2) 软中断</h5>

<p>为了满足实时系统的要求，中断处理应该是越快越好。linux为了实现这个特点，当中断发生的时候，硬中断处理那些短时间就可以完成的工作，而将那些处理事件比较长的工作，放到中断之后来完成，也就是软中断(softirq)来完成。</p>

<h5>(3) 中断嵌套</h5>

<p>Linux下硬中断是可以嵌套的，但是没有优先级的概念，也就是说任何一个新的中断都可以打断正在执行的中断，但同种中断除外。软中断不能嵌套，但相同类型的软中断可以在不同CPU上并行执行。</p>

<h5>(4) 软中断指令</h5>

<p>int是软中断指令。<br/>
中断向量表是中断号和中断处理函数地址的对应表。<br/>
int n - 触发软中断n。相应的中断处理函数的地址为：中断向量表地址 + 4 * n。</p>

<h5>(5)硬中断和软中断的区别</h5>

<p>软中断是执行中断指令产生的，而硬中断是由外设引发的。<br/>
硬中断的中断号是由中断控制器提供的，软中断的中断号由指令直接指出，无需使用中断控制器。<br/>
硬中断是可屏蔽的，软中断不可屏蔽。<br/>
硬中断处理程序要确保它能快速地完成任务，这样程序执行时才不会等待较长时间，称为上半部。<br/>
软中断处理硬中断未完成的工作，是一种推后执行的机制，属于下半部。</p>

<h4>开关</h4>

<h5>(1) 硬中断的开关</h5>

<p>简单禁止和激活当前处理器上的本地中断：
<code>
local_irq_disable();
local_irq_enable();
</code>
保存本地中断系统状态下的禁止和激活：
<code>
unsigned long flags;
local_irq_save(flags);
local_irq_restore(flags);
</code></p>

<h5>(2) 软中断的开关</h5>

<p>禁止下半部，如softirq、tasklet和workqueue等：
<code>
local_bh_disable();
local_bh_enable();
</code>
需要注意的是，禁止下半部时仍然可以被硬中断抢占。</p>

<h5>(3) 判断中断状态</h5>

<pre><code>    #define in_interrupt() (irq_count()) // 是否处于中断状态(硬中断或软中断)
    #define in_irq() (hardirq_count()) // 是否处于硬中断
    #define in_softirq() (softirq_count()) // 是否处于软中断
</code></pre>

<h4>硬中断</h4>

<h5>(1) 注册中断处理函数</h5>

<p>注册中断处理函数：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/&lt;em&gt;&lt;em&gt;
</span><span class='line'> * irq: 要分配的中断号
</span><span class='line'> * handler: 要注册的中断处理函数
</span><span class='line'> * flags: 标志(一般为0)
</span><span class='line'> * name: 设备名(dev-&gt;name)
</span><span class='line'> * dev: 设备(struct net_device &lt;/em&gt;dev)，作为中断处理函数的参数
</span><span class='line'> * 成功返回0
</span><span class='line'> &lt;/em&gt;/&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;int request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags,   
</span><span class='line'>const char *name, void *dev);  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>中断处理函数本身：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;typedef irqreturn_t (*irq_handler_t) (int, void *);  
</span><span class='line'>
</span><span class='line'>/** 
</span><span class='line'> * enum irqreturn 
</span><span class='line'> * @IRQ_NONE: interrupt was not from this device 
</span><span class='line'> * @IRQ_HANDLED: interrupt was handled by this device 
</span><span class='line'> * @IRQ_WAKE_THREAD: handler requests to wake the handler thread 
</span><span class='line'> */  
</span><span class='line'>enum irqreturn {  
</span><span class='line'>IRQ_NONE,  
</span><span class='line'>IRQ_HANDLED,  
</span><span class='line'>IRQ_WAKE_THREAD,  
</span><span class='line'>};  
</span><span class='line'>typedef enum irqreturn irqreturn_t;  
</span><span class='line'>#define IRQ_RETVAL(x) ((x) != IRQ_NONE)  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>##### (2) 注销中断处理函数
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;/** 
</span><span class='line'> * free_irq - free an interrupt allocated with request_irq 
</span><span class='line'> * @irq: Interrupt line to free 
</span><span class='line'> * @dev_id: Device identity to free 
</span><span class='line'> * 
</span><span class='line'> * Remove an interrupt handler. The handler is removed and if the 
</span><span class='line'> * interrupt line is no longer in use by any driver it is disabled. 
</span><span class='line'> * On a shared IRQ the caller must ensure the interrupt is disabled 
</span><span class='line'> * on the card it drives before calling this function. The function does 
</span><span class='line'> * not return until any executing interrupts for this IRQ have completed. 
</span><span class='line'> * This function must not be called from interrupt context. 
</span><span class='line'> */  
</span><span class='line'>
</span><span class='line'>void free_irq(unsigned int irq, void *dev_id);  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>#### 软中断
</span><span class='line'>##### (1) 定义
</span><span class='line'>软中断是一组静态定义的下半部接口，可以在所有处理器上同时执行，即使两个类型相同也可以。  
</span><span class='line'>但一个软中断不会抢占另一个软中断，唯一可以抢占软中断的是硬中断。
</span><span class='line'>
</span><span class='line'>软中断由softirq_action结构体表示：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;struct softirq_action {  
</span><span class='line'>void (*action) (struct softirq_action *); /* 软中断的处理函数 */  
</span><span class='line'>};  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>目前已注册的软中断有10种，定义为一个全局数组：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static struct softirq_action softirq_vec[NR_SOFTIRQS];  
</span><span class='line'>
</span><span class='line'>enum {  
</span><span class='line'>HI_SOFTIRQ = 0, /* 优先级高的tasklets */  
</span><span class='line'>TIMER_SOFTIRQ, /* 定时器的下半部 */  
</span><span class='line'>NET_TX_SOFTIRQ, /* 发送网络数据包 */  
</span><span class='line'>NET_RX_SOFTIRQ, /* 接收网络数据包 */  
</span><span class='line'>BLOCK_SOFTIRQ, /* BLOCK装置 */  
</span><span class='line'>BLOCK_IOPOLL_SOFTIRQ,  
</span><span class='line'>TASKLET_SOFTIRQ, /* 正常优先级的tasklets */  
</span><span class='line'>SCHED_SOFTIRQ, /* 调度程序 */  
</span><span class='line'>HRTIMER_SOFTIRQ, /* 高分辨率定时器 */  
</span><span class='line'>RCU_SOFTIRQ, /* RCU锁定 */  
</span><span class='line'>NR_SOFTIRQS /* 10 */  
</span><span class='line'>};  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>##### (2) 注册软中断处理函数
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;/** 
</span><span class='line'> * @nr: 软中断的索引号 
</span><span class='line'> * @action: 软中断的处理函数 
</span><span class='line'> */  
</span><span class='line'>
</span><span class='line'>void open_softirq(int nr, void (*action) (struct softirq_action *))  
</span><span class='line'>{  
</span><span class='line'>softirq_vec[nr].action = action;  
</span><span class='line'>}  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;例如：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;open_softirq(NET_TX_SOFTIRQ, net_tx_action);
</span><span class='line'>open_softirq(NET_RX_SOFTIRQ, net_rx_action);</span></code></pre></td></tr></table></div></figure></p>

<h5>(3) 触发软中断</h5>

<p>调用raise_softirq()来触发软中断。
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
<span class='line-number'>206</span>
<span class='line-number'>207</span>
<span class='line-number'>208</span>
<span class='line-number'>209</span>
<span class='line-number'>210</span>
<span class='line-number'>211</span>
<span class='line-number'>212</span>
<span class='line-number'>213</span>
<span class='line-number'>214</span>
<span class='line-number'>215</span>
<span class='line-number'>216</span>
<span class='line-number'>217</span>
<span class='line-number'>218</span>
<span class='line-number'>219</span>
<span class='line-number'>220</span>
<span class='line-number'>221</span>
<span class='line-number'>222</span>
<span class='line-number'>223</span>
<span class='line-number'>224</span>
<span class='line-number'>225</span>
<span class='line-number'>226</span>
<span class='line-number'>227</span>
<span class='line-number'>228</span>
<span class='line-number'>229</span>
<span class='line-number'>230</span>
<span class='line-number'>231</span>
<span class='line-number'>232</span>
<span class='line-number'>233</span>
<span class='line-number'>234</span>
<span class='line-number'>235</span>
<span class='line-number'>236</span>
<span class='line-number'>237</span>
<span class='line-number'>238</span>
<span class='line-number'>239</span>
<span class='line-number'>240</span>
<span class='line-number'>241</span>
<span class='line-number'>242</span>
<span class='line-number'>243</span>
<span class='line-number'>244</span>
<span class='line-number'>245</span>
<span class='line-number'>246</span>
<span class='line-number'>247</span>
<span class='line-number'>248</span>
<span class='line-number'>249</span>
<span class='line-number'>250</span>
<span class='line-number'>251</span>
<span class='line-number'>252</span>
<span class='line-number'>253</span>
<span class='line-number'>254</span>
<span class='line-number'>255</span>
<span class='line-number'>256</span>
<span class='line-number'>257</span>
<span class='line-number'>258</span>
<span class='line-number'>259</span>
<span class='line-number'>260</span>
<span class='line-number'>261</span>
<span class='line-number'>262</span>
<span class='line-number'>263</span>
<span class='line-number'>264</span>
<span class='line-number'>265</span>
<span class='line-number'>266</span>
<span class='line-number'>267</span>
<span class='line-number'>268</span>
<span class='line-number'>269</span>
<span class='line-number'>270</span>
<span class='line-number'>271</span>
<span class='line-number'>272</span>
<span class='line-number'>273</span>
<span class='line-number'>274</span>
<span class='line-number'>275</span>
<span class='line-number'>276</span>
<span class='line-number'>277</span>
<span class='line-number'>278</span>
<span class='line-number'>279</span>
<span class='line-number'>280</span>
<span class='line-number'>281</span>
<span class='line-number'>282</span>
<span class='line-number'>283</span>
<span class='line-number'>284</span>
<span class='line-number'>285</span>
<span class='line-number'>286</span>
<span class='line-number'>287</span>
<span class='line-number'>288</span>
<span class='line-number'>289</span>
<span class='line-number'>290</span>
<span class='line-number'>291</span>
<span class='line-number'>292</span>
<span class='line-number'>293</span>
<span class='line-number'>294</span>
<span class='line-number'>295</span>
<span class='line-number'>296</span>
<span class='line-number'>297</span>
<span class='line-number'>298</span>
<span class='line-number'>299</span>
<span class='line-number'>300</span>
<span class='line-number'>301</span>
<span class='line-number'>302</span>
<span class='line-number'>303</span>
<span class='line-number'>304</span>
<span class='line-number'>305</span>
<span class='line-number'>306</span>
<span class='line-number'>307</span>
<span class='line-number'>308</span>
<span class='line-number'>309</span>
<span class='line-number'>310</span>
<span class='line-number'>311</span>
<span class='line-number'>312</span>
<span class='line-number'>313</span>
<span class='line-number'>314</span>
<span class='line-number'>315</span>
<span class='line-number'>316</span>
<span class='line-number'>317</span>
<span class='line-number'>318</span>
<span class='line-number'>319</span>
<span class='line-number'>320</span>
<span class='line-number'>321</span>
<span class='line-number'>322</span>
<span class='line-number'>323</span>
<span class='line-number'>324</span>
<span class='line-number'>325</span>
<span class='line-number'>326</span>
<span class='line-number'>327</span>
<span class='line-number'>328</span>
<span class='line-number'>329</span>
<span class='line-number'>330</span>
<span class='line-number'>331</span>
<span class='line-number'>332</span>
<span class='line-number'>333</span>
<span class='line-number'>334</span>
<span class='line-number'>335</span>
<span class='line-number'>336</span>
<span class='line-number'>337</span>
<span class='line-number'>338</span>
<span class='line-number'>339</span>
<span class='line-number'>340</span>
<span class='line-number'>341</span>
<span class='line-number'>342</span>
<span class='line-number'>343</span>
<span class='line-number'>344</span>
<span class='line-number'>345</span>
<span class='line-number'>346</span>
<span class='line-number'>347</span>
<span class='line-number'>348</span>
<span class='line-number'>349</span>
<span class='line-number'>350</span>
<span class='line-number'>351</span>
<span class='line-number'>352</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void raise_softirq(unsigned int nr)&lt;br/&gt;
</span><span class='line'>{&lt;br/&gt;
</span><span class='line'>    unsigned long flags;&lt;br/&gt;
</span><span class='line'>    local_irq_save(flags);&lt;br/&gt;
</span><span class='line'>    raise_softirq_irqoff(nr);&lt;br/&gt;
</span><span class='line'>    local_irq_restore(flags);&lt;br/&gt;
</span><span class='line'>}&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;/* This function must run with irqs disabled */  
</span><span class='line'>inline void rasie_softirq_irqsoff(unsigned int nr)  
</span><span class='line'>{  
</span><span class='line'>__raise_softirq_irqoff(nr);  
</span><span class='line'>
</span><span class='line'>/* If we're in an interrupt or softirq, we're done 
</span><span class='line'> * (this also catches softirq-disabled code). We will 
</span><span class='line'> * actually run the softirq once we return from the irq 
</span><span class='line'> * or softirq. 
</span><span class='line'> * Otherwise we wake up ksoftirqd to make sure we 
</span><span class='line'> * schedule the softirq soon. 
</span><span class='line'> */  
</span><span class='line'>if (! in_interrupt()) /* 如果不处于硬中断或软中断 */  
</span><span class='line'>    wakeup_softirqd(void); /* 唤醒ksoftirqd/n进程 */  
</span><span class='line'>}  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>Percpu变量irq_cpustat_t中的__softirq_pending是等待处理的软中断的位图，通过设置此变量
</span><span class='line'>
</span><span class='line'>即可告诉内核该执行哪些软中断。
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static inline void __rasie_softirq_irqoff(unsigned int nr)  
</span><span class='line'>{  
</span><span class='line'>trace_softirq_raise(nr);  
</span><span class='line'>or_softirq_pending(1UL &lt;&lt; nr);  
</span><span class='line'>}  
</span><span class='line'>
</span><span class='line'>typedef struct {  
</span><span class='line'>unsigned int __softirq_pending;  
</span><span class='line'>unsigned int __nmi_count; /* arch dependent */  
</span><span class='line'>} irq_cpustat_t;  
</span><span class='line'>
</span><span class='line'>irq_cpustat_t irq_stat[];  
</span><span class='line'>#define __IRQ_STAT(cpu, member) (irq_stat[cpu].member)  
</span><span class='line'>#define or_softirq_pending(x) percpu_or(irq_stat.__softirq_pending, (x))  
</span><span class='line'>#define local_softirq_pending() percpu_read(irq_stat.__softirq_pending)  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>唤醒ksoftirqd内核线程处理软中断。
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static void wakeup_softirqd(void)  
</span><span class='line'>{  
</span><span class='line'>/* Interrupts are disabled: no need to stop preemption */  
</span><span class='line'>struct task_struct *tsk = __get_cpu_var(ksoftirqd);  
</span><span class='line'>
</span><span class='line'>if (tsk &amp;&amp; tsk-&gt;state != TASK_RUNNING)  
</span><span class='line'>    wake_up_process(tsk);  
</span><span class='line'>}  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>在下列地方，待处理的软中断会被检查和执行：  
</span><span class='line'>1. 从一个硬件中断代码处返回时  
</span><span class='line'>2. 在ksoftirqd内核线程中  
</span><span class='line'>3. 在那些显示检查和执行待处理的软中断的代码中，如网络子系统中
</span><span class='line'>
</span><span class='line'>而不管是用什么方法唤起，软中断都要在do_softirq()中执行。如果有待处理的软中断，do_softirq()会循环遍历每一个，调用它们的相应的处理程序。在中断处理程序中触发软中断是最常见的形式。中断处理程序执行硬件设备的相关操作，然后触发相应的软中断，最后退出。内核在执行完中断处理程序以后，马上就会调用do_softirq()，于是软中断开始执行中断处理程序完成剩余的任务。
</span><span class='line'>
</span><span class='line'>下面来看下do_softirq()的具体实现。
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;asmlinkage void do_softirq(void)  
</span><span class='line'>{  
</span><span class='line'>__u32 pending;  
</span><span class='line'>unsigned long flags;  
</span><span class='line'>
</span><span class='line'>/* 如果当前已处于硬中断或软中断中，直接返回 */  
</span><span class='line'>if (in_interrupt())   
</span><span class='line'>    return;  
</span><span class='line'>
</span><span class='line'>local_irq_save(flags);  
</span><span class='line'>pending = local_softirq_pending();  
</span><span class='line'>if (pending) /* 如果有激活的软中断 */  
</span><span class='line'>    __do_softirq(); /* 处理函数 */  
</span><span class='line'>local_irq_restore(flags);  
</span><span class='line'>}  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;code&gt;
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>/&lt;em&gt; We restart softirq processing MAX_SOFTIRQ_RESTART times,
</span><span class='line'> * and we fall back to softirqd after that.
</span><span class='line'> * This number has been established via experimentation.
</span><span class='line'> * The two things to balance is latency against fairness - we want
</span><span class='line'> * to handle softirqs as soon as possible, but they should not be
</span><span class='line'> * able to lock up the box.
</span><span class='line'> &lt;/em&gt;/&lt;br/&gt;
</span><span class='line'>asmlinkage void &lt;strong&gt;do_softirq(void)&lt;br/&gt;
</span><span class='line'>{&lt;br/&gt;
</span><span class='line'>    struct softirq_action *h;&lt;br/&gt;
</span><span class='line'>    &lt;/strong&gt;u32 pending;&lt;br/&gt;
</span><span class='line'>    /&lt;em&gt; 本函数能重复触发执行的次数，防止占用过多的cpu时间 &lt;/em&gt;/&lt;br/&gt;
</span><span class='line'>    int max_restart = MAX_SOFTIRQ_RESTART;&lt;br/&gt;
</span><span class='line'>    int cpu;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    pending = local_softirq_pending(); /* 激活的软中断位图 */  
</span><span class='line'>account_system_vtime(current);  
</span><span class='line'>/* 本地禁止当前的软中断 */  
</span><span class='line'>__local_bh_disable((unsigned long)__builtin_return_address(0), SOFTIRQ_OFFSET);  
</span><span class='line'>lockdep_softirq_enter(); /* current-&gt;softirq_context++ */  
</span><span class='line'>cpu = smp_processor_id(); /* 当前cpu编号 */  
</span><span class='line'>
</span><span class='line'>restart:  
</span><span class='line'>/* Reset the pending bitmask before enabling irqs */  
</span><span class='line'>set_softirq_pending(0); /* 重置位图 */  
</span><span class='line'>local_irq_enable();  
</span><span class='line'>h = softirq_vec;  
</span><span class='line'>do {  
</span><span class='line'>    if (pending &amp; 1) {  
</span><span class='line'>        unsigned int vec_nr = h - softirq_vec; /* 软中断索引 */  
</span><span class='line'>        int prev_count = preempt_count();  
</span><span class='line'>        kstat_incr_softirqs_this_cpu(vec_nr);  
</span><span class='line'>
</span><span class='line'>        trace_softirq_entry(vec_nr);  
</span><span class='line'>        h-&gt;action(h); /* 调用软中断的处理函数 */  
</span><span class='line'>        trace_softirq_exit(vec_nr);  
</span><span class='line'>
</span><span class='line'>        if (unlikely(prev_count != preempt_count())) {  
</span><span class='line'>            printk(KERN_ERR "huh, entered softirq %u %s %p" "with preempt_count %08x,"  
</span><span class='line'>                "exited with %08x?\n", vec_nr, softirq_to_name[vec_nr], h-&gt;action, prev_count,  
</span><span class='line'>                preempt_count());  
</span><span class='line'>        }  
</span><span class='line'>        rcu_bh_qs(cpu);  
</span><span class='line'>    }  
</span><span class='line'>    h++;  
</span><span class='line'>    pending &gt;&gt;= 1;  
</span><span class='line'>} while(pending);  
</span><span class='line'>
</span><span class='line'>local_irq_disable();  
</span><span class='line'>pending = local_softirq_pending();  
</span><span class='line'>if (pending &amp; --max_restart) /* 重复触发 */  
</span><span class='line'>    goto restart;  
</span><span class='line'>
</span><span class='line'>/* 如果重复触发了10次了，接下来唤醒ksoftirqd/n内核线程来处理 */  
</span><span class='line'>if (pending)  
</span><span class='line'>    wakeup_softirqd();   
</span><span class='line'>
</span><span class='line'>lockdep_softirq_exit();  
</span><span class='line'>account_system_vtime(current);  
</span><span class='line'>__local_bh_enable(SOFTIRQ_OFFSET);  
</span><span class='line'>}  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>##### (4) ksoftirqd内核线程
</span><span class='line'>内核不会立即处理重新触发的软中断。  
</span><span class='line'>当大量软中断出现的时候，内核会唤醒一组内核线程来处理。  
</span><span class='line'>这些线程的优先级最低(nice值为19)，这能避免它们跟其它重要的任务抢夺资源。  
</span><span class='line'>但它们最终肯定会被执行，所以这个折中的方案能够保证在软中断很多时用户程序不会因为得不到处理时间而处于饥饿状态，同时也保证过量的软中断最终会得到处理。
</span><span class='line'>
</span><span class='line'>每个处理器都有一个这样的线程，名字为ksoftirqd/n，n为处理器的编号。
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static int run_ksoftirqd(void *__bind_cpu)  
</span><span class='line'>{  
</span><span class='line'>set_current_state(TASK_INTERRUPTIBLE);  
</span><span class='line'>current-&gt;flags |= PF_KSOFTIRQD; /* I am ksoftirqd */  
</span><span class='line'>
</span><span class='line'>while(! kthread_should_stop()) {  
</span><span class='line'>    preempt_disable();  
</span><span class='line'>
</span><span class='line'>    if (! local_softirq_pending()) { /* 如果没有要处理的软中断 */  
</span><span class='line'>        preempt_enable_no_resched();  
</span><span class='line'>        schedule();  
</span><span class='line'>        preempt_disable():  
</span><span class='line'>    }  
</span><span class='line'>
</span><span class='line'>    __set_current_state(TASK_RUNNING);  
</span><span class='line'>
</span><span class='line'>    while(local_softirq_pending()) {  
</span><span class='line'>        /* Preempt disable stops cpu going offline. 
</span><span class='line'>         * If already offline, we'll be on wrong CPU: don't process. 
</span><span class='line'>         */  
</span><span class='line'>         if (cpu_is_offline(long)__bind_cpu))/* 被要求释放cpu */  
</span><span class='line'>             goto wait_to_die;  
</span><span class='line'>
</span><span class='line'>        do_softirq(); /* 软中断的统一处理函数 */  
</span><span class='line'>
</span><span class='line'>        preempt_enable_no_resched();  
</span><span class='line'>        cond_resched();  
</span><span class='line'>        preempt_disable();  
</span><span class='line'>        rcu_note_context_switch((long)__bind_cpu);  
</span><span class='line'>    }  
</span><span class='line'>
</span><span class='line'>    preempt_enable();  
</span><span class='line'>    set_current_state(TASK_INTERRUPTIBLE);  
</span><span class='line'>}  
</span><span class='line'>
</span><span class='line'>__set_current_state(TASK_RUNNING);  
</span><span class='line'>return 0;  
</span><span class='line'>
</span><span class='line'>wait_to_die:  
</span><span class='line'>preempt_enable();  
</span><span class='line'>/* Wait for kthread_stop */  
</span><span class='line'>set_current_state(TASK_INTERRUPTIBLE);  
</span><span class='line'>while(! kthread_should_stop()) {  
</span><span class='line'>    schedule();  
</span><span class='line'>    set_current_state(TASK_INTERRUPTIBLE);  
</span><span class='line'>}  
</span><span class='line'>
</span><span class='line'>__set_current_state(TASK_RUNNING);  
</span><span class='line'>return 0;  
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[关于ksoftirqd进程]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2015/01/03/kernel-sched-ksoftirqd/"/&gt;
</span><span class='line'>&lt;updated&gt;2015-01-03T15:01:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2015/01/03/kernel-sched-ksoftirqd&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;p&gt;blog.chinaunix.net/uid-20737871-id-1881243.html&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;每个处理器都有一组辅助处理器软中断(和tasklet)的内核线程。当内核中出现大量软中断的时候，这些内核进程就会辅助处理它们。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;引入ksoftirq内核线程的原因：&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;对于软中断，内核会选择在几个特殊时机进行处理。而在中断处理程序返回时处理是最常见的。软中断被触发的频率有时可能很高，更不利的是，处理函数有时还会 字形重复触发，那么就会导致用户空间进程无法获得足够的处理时间，因而处于饥饿状态。单纯的对重新触发的软中断采取不立即处理的策略，也无法让人接受。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;最初的解决方案：&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;1）只要还有被触发并等待处理的软中断，本次执行就要负责处理，重新触发的软中断也在本次执行返回前被处理。这样做可以保证对内核的软中断采取即时处理的 方式，关键在于，对重新触发的软中断也会立即处理。当负载很高的时候，此时若有大量被触发的软中断，而它们本身又会重复触发。系统可能会一直处理软中断根 本不能完成其他任务。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;2）不处理重新触发的软中断。在从中断返回的时候，内核和平常一样，也会检查所有挂起的软中断并处理他们。但是，任何自行重新触发的软中断不会马上处理， 它们被放到下一个软中断执行时机去处理。而这个时机通常也就是下一次中断返回的时候。可是，在比较空闲的系统中，立即处理软中断才是比较好的做法。尽管它 能保证用户空间不处于饥饿状态，但它却让软中断忍受饥饿的痛苦，而根本没有好好利用闲置的系统资源。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;改进：&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;最终在内核中实现的方案是不会立即处理处理重新触发的软中断。而作为改进，当大量软中断出现的时候，内核会唤醒一组内核线程来处理这些负载。这些线程在最 低的优先级上运行（nice值是19），这能避免它们跟其他重要的任务抢夺资源。但它们最终肯定会被执行，所以这个折中方案能够保证在软中断负担很中的时 候用户程序不会因为得不到处理时间处于饥饿状态。相应的，也能保证”过量“的软中断终究会得到处理。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;每个处理器都有一个这样的线程。所有线程的名字都叫做ksoftirq/n，区别在于n，它对应的是处理器的编号。在一个双CPU的机器上就有两个这样的 线程，分别叫做ksoftirqd/0和ksoftirqd/1。为了保证只要有空闲的处理器，它们就会处理软中断，所以给每个处理器都分配一个这样的线 程。一旦该线程被初始化，它就会执行类似下面这样的死循环：&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;在kernel/softirq.c中
</span><span class='line'>&lt;code&gt;
</span><span class='line'>static int ksoftirqd(void * __bind_cpu)
</span><span class='line'>{
</span><span class='line'>    set_user_nice(current, 19);
</span><span class='line'>    current-&gt;flags |= PF_NOFREEZE;
</span><span class='line'>    set_current_state(TASK_INTERRUPTIBLE);
</span><span class='line'>    while (!kthread_should_stop()) {
</span><span class='line'>        preempt_disable();
</span><span class='line'>        if (!local_softirq_pending()) {
</span><span class='line'>            preempt_enable_no_resched();
</span><span class='line'>            schedule();
</span><span class='line'>            preempt_disable();
</span><span class='line'>        }
</span><span class='line'>        __set_current_state(TASK_RUNNING);
</span><span class='line'>        while (local_softirq_pending()) {
</span><span class='line'>            /* Preempt disable stops cpu going offline.
</span><span class='line'>                If already offline, we'll be on wrong CPU:
</span><span class='line'>                don't process */
</span><span class='line'>            if (cpu_is_offline((long)__bind_cpu))
</span><span class='line'>                goto wait_to_die;
</span><span class='line'>            do_softirq();
</span><span class='line'>            preempt_enable_no_resched();
</span><span class='line'>            cond_resched();
</span><span class='line'>            preempt_disable();
</span><span class='line'>        }
</span><span class='line'>        preempt_enable();
</span><span class='line'>        set_current_state(TASK_INTERRUPTIBLE);
</span><span class='line'>    }
</span><span class='line'>    __set_current_state(TASK_RUNNING);
</span><span class='line'>    return 0;
</span><span class='line'>wait_to_die:
</span><span class='line'>    preempt_enable();
</span><span class='line'>    /* Wait for kthread_stop */
</span><span class='line'>    set_current_state(TASK_INTERRUPTIBLE);
</span><span class='line'>    while (!kthread_should_stop()) {
</span><span class='line'>        schedule();
</span><span class='line'>        set_current_state(TASK_INTERRUPTIBLE);
</span><span class='line'>    }
</span><span class='line'>    __set_current_state(TASK_RUNNING);
</span><span class='line'>    return 0;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;只要有待处理的软中断(由softirq_pending()函数负责发现)，ksoftirq就会调用do_softirq去处理它们。通过重复执行这 样的操作，重新触发的软中断也会被执行。如果有必要，每次迭代后都会调用schedule()以便让更重要的进程得到处理机会。当所有需要执行的操作都完 成以后，该内核线程将自己设置为TASK_INTERRUPTIBLE状态，唤起调度程序选择其他可执行进程投入运行。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;只要do_softirq()函数发现已经执行过的内核线程重新触发了它自己，软中断内核线程就会被唤醒.&lt;/p&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[tsc时钟初始化]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2014/05/29/kernel-sched-tsc/"/&gt;
</span><span class='line'>&lt;updated&gt;2014-05-29T14:03:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2014/05/29/kernel-sched-tsc&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;h5&gt;tsc时钟源初始化&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    //    调用路径：time_init-&gt;tsc_init
</span><span class='line'>//    函数任务：
</span><span class='line'>//        1.矫正tsc，获取tsc频率，设置cpu频率等于tsc频率
</span><span class='line'>//        2.初始化基于tsc的延迟函数
</span><span class='line'>//        3.检查tsc的特性
</span><span class='line'>//            3.1 tsc之间是否同步
</span><span class='line'>//                3.1.1 如果tsc之间不同步，标记tsc不稳定，设置rating=0
</span><span class='line'>//            3.2 tsc是否稳定
</span><span class='line'>//        4.注册tsc时钟源设备
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    void __init tsc_init(void)
</span><span class='line'>{
</span><span class='line'>    u64 lpj;
</span><span class='line'>    int cpu;
</span><span class='line'>
</span><span class='line'>    //矫正tsc，获取tsc频率
</span><span class='line'>    tsc_khz = x86_platform.calibrate_tsc();
</span><span class='line'>    //cpu频率等于tsc频率
</span><span class='line'>    cpu_khz = tsc_khz;
</span><span class='line'>    //计算辅助cycle到ns转换的辅助参数scale
</span><span class='line'>    for_each_possible_cpu(cpu)
</span><span class='line'>        set_cyc2ns_scale(cpu_khz, cpu);
</span><span class='line'>    //初始化基于tsc的延迟函数，ndely，udelay，mdelay
</span><span class='line'>    use_tsc_delay();
</span><span class='line'>    //检查cpu之间tsc是否同步
</span><span class='line'>    if (unsynchronized_tsc())
</span><span class='line'>        mark_tsc_unstable("TSCs unsynchronized");
</span><span class='line'>    //检查tsc是否可靠
</span><span class='line'>    check_system_tsc_reliable();
</span><span class='line'>    //注册tsc时钟源设备
</span><span class='line'>    init_tsc_clocksource();
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;延迟函数ndelay，udelay，mdelay&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;通过tsc实现短延迟
</span><span class='line'>&lt;code&gt;
</span><span class='line'>void use_tsc_delay(void)
</span><span class='line'>{
</span><span class='line'>    //通过tsc进行短延迟
</span><span class='line'>    delay_fn = delay_tsc;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;tsc延迟函数&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;通过rep_nop实现轮询时的短延迟，查询tsc时禁止内核抢占，确保不受不同cpu间影响。</span></code></pre></td></tr></table></div></figure>
    static void delay_tsc(unsigned long loops)
    {
        unsigned long bclock, now;
        int cpu;
        //短延迟，禁止内核抢占
        preempt_disable();
        //delay_tsc当前运行的cpu
        cpu = smp_processor_id();
        rdtsc_barrier();
        rdtscl(bclock);
        for (;;) {
            rdtsc_barrier();
            rdtscl(now);
            if ((now - bclock) >= loops)
                break;
            //允许rt策略进程运行
            preempt_enable();
            //空操作
            rep_nop();
            preempt_disable();</p>

<pre><code>        //delay_tsc在运行过程中，可能会迁移到不同的cpu
        //tsc
        if (unlikely(cpu != smp_processor_id())) {
            loops -= (now - bclock);
            cpu = smp_processor_id();
            rdtsc_barrier();
            rdtscl(bclock);
        }
    }
    preempt_enable();
}
</code></pre>

<pre><code>
##### 检查tsc是否同步
</code></pre>

<pre><code>//    调用路径：tsc_init-&gt;unsynchronized_tsc
//    检查办法：
//        1.如果apic在多块板卡，则tsc不同步
//        2.如果cpuid显示具有稳定的tsc，则tsc同步
//        3.intel cpu的tsc都是同步的
//        4.默认其他品牌的多核的tsc不同步
</code></pre>

<pre><code></code></pre>

<pre><code>__cpuinit int unsynchronized_tsc(void)
{
    //如果apic分布在多块板卡上，tsc可能不同步
    if (apic_is_clustered_box())
        return 1;
    //cpu具有稳定的tsc
    if (boot_cpu_has(X86_FEATURE_CONSTANT_TSC))
        return 0;
    //intel cpu的tsc都是同步的
    if (boot_cpu_data.x86_vendor != X86_VENDOR_INTEL) {
        //非intel cpu，如果cpu个数&gt;1,则认为不同步
        if (num_possible_cpus() &gt; 1)
            tsc_unstable = 1;
    }
    return tsc_unstable;
}
</code></pre>

<pre><code>
##### 标记tsc不稳定
</code></pre>

<pre><code>//    调用路径：tsc_init-&gt;mark_tsc_unstable
//    函数任务：
//        1.如果tsc时钟已经注册，异步设置tsc的rating=0，标识其不稳定
//        2.如果tsc时钟还未注册，同步设置tsc的rating=0，标识其不稳定
</code></pre>

<pre><code></code></pre>

<pre><code>void mark_tsc_unstable(char *reason)
{
    if (!tsc_unstable) {
        tsc_unstable = 1;
        sched_clock_stable = 0;
        //tsc已经注册，
        if (clocksource_tsc.mult)
        {
            clocksource_mark_unstable(&amp;clocksource_tsc);
        }
        //如果tsc时钟源未注册，修改rating为最低，从而不会被当做最佳的时钟源
        else {
            clocksource_tsc.flags |= CLOCK_SOURCE_UNSTABLE;
            clocksource_tsc.rating = 0;
        }
    }
}
</code></pre>

<pre><code>
##### 注册tsc时钟源
</code></pre>

<pre><code>//    函数任务：
//        1.计算tsc的mult
//        2.检查tsc是否稳定
//            2.1 如果tsc不稳定，降低其rating，清除时钟源连续标志
//        3.向系统注册tsc clocksource
//    调用路径：tsc_init-&gt;init_tsc_clocksource
</code></pre>

<pre><code></code></pre>

<pre><code>static void __init init_tsc_clocksource(void)
{
    // 计算tsc的mult
    clocksource_tsc.mult = clocksource_khz2mult(tsc_khz,
            clocksource_tsc.shift);
    // 如果tsc的可靠性已经验证，则清除 必须验证 标记
    if (tsc_clocksource_reliable)
        clocksource_tsc.flags &amp;= ~CLOCK_SOURCE_MUST_VERIFY;

    // 检查tsc是否稳定
    // 在tsc_init前通过全局变量标记tsc是否稳定，可靠
    if (check_tsc_unstable()) {
        // 如果tsc不稳定，则降低rating最低，清除连续标记
        clocksource_tsc.rating = 0;
        clocksource_tsc.flags &amp;= ~CLOCK_SOURCE_IS_CONTINUOUS;
    }
    // 向系统注册tsc clocksource
    clocksource_register(&amp;clocksource_tsc);
}
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[周期性调度器scheduler_tick]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/05/22/kernel-sched-tick/"/>
    <updated>2014-05-22T16:57:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/05/22/kernel-sched-tick</id>
    <content type="html"><![CDATA[<p>周期性调度器由中断实现，系统定时产生一个中断，然后启动周期性调度器，周期性调度器执行过程中要关闭中断, 周期性调度器执行完毕后再打开中断(handle_IRQ_event,  IRQF_DISABLED)</p>

<p>周期性调度器主要做两个工作：<br/>
a)更新相关统计量<br/>
b) 检查进程执行的时间是否超过了它对应的ideal_runtime，如果超过了，则告诉系统，需要启动主调度器(schedule)进行进程切换。(注意 thread_info:preempt_count、thread_info:flags (TIF_NEED_RESCHED))</p>

<h4>周期性调度器</h4>

<pre><code>    |----&gt;do_timer()   更新jiffies_64
    |----&gt;update_process_times()
          |----&gt;scheduler_tick()
          |----&gt;update_rq_clock()  更新当前调度队列rq的clock
          |----&gt;curr-&gt;sched_class-&gt;task_tick() 
          |         对于普通进程，即task_tick_fair()
          |         task_struct: struct sched_class *sched_class

update_rq_clock()----delta = sched_clock_cpu(cpu_of(rq)) - rq-&gt;clock
         |-----两次相邻两次周期性调度器运行的时间差
         |----rq-&gt;clock += delta; 更新运行队列上的时钟
               |----&gt;update_rq_clock_task(rq, delta)
               |     即rq-&gt;clock_task += delta
</code></pre>

<h4>普通进程</h4>

<pre><code>task_tick_fair()----&gt;entity_tick()   没有考虑组调度
   |----&gt;update_curr() 更新相关统计量
   |----&gt;check_preempt_tick()   
   |        检查进程本次获得CPU使用权的执行时间是否超过了
   |        它对应的ideal_runtime值，如果超过了，则将当前进
   |        程的TIF_NEED_RESCHED标志位置位

update_curr()
   |----delta_exec = (unsigned long)(now - curr-&gt;exec_start);  
   |            exec_start当前进程开始获得
   |            cpu使用权时的时间戳;
   |            进程本次所获得的CPU执行权的时间;
   |----&gt;__update_curr(cfs_rq, curr, delta_exec);
         |----&gt;curr-&gt;sum_exec_runtime += delta_exec; 
         |     更新该进程获得CPU执行权总时间
         |
         |----&gt;curr-&gt;vruntime += delta_exec_weighted;
         |     更新该进程获得CPU执行权的虚拟时间
         |
         |----&gt;update_min_vruntime()
         |     更新cfs_rq-&gt;min_vruntime
         |
   |----&gt;curr-&gt;exec_start = now    
   |        更新进程下次运行起始时间
   |        (如果被抢占，下次被调度时将会更新)

check_preempt_tick()
   |----ideal_runtime = sched_slice(cfs_rq, curr);
   |----delta_exec = curr-&gt;sum_exec_runtime 
   |                 - curr-&gt;prev_sum_exec_runtime;
   |----if(delta_exec &gt; ideal_runtime)  
   |          resched_task(rq_of(cfs_rq)-&gt;curr);
   |          把当前进程的TIF_NEED_RESCHED标志位置位
   |----else
   |    delta = curr-&gt;vruntime - se-&gt;vruntime;  //这是什么？
   |    if (delta &gt; ideal_runtime)  
   |        resched_task(rq_of(cfs_rq)-&gt;curr);
   |        把当前进程的TIF_NEED_RESCHED标志位置位
</code></pre>

<h4>实时进程</h4>

<pre><code>task_tick_rt()
    |----&gt;update_curr_rt();
    |----&gt;if (p-&gt;policy != SCHED_RR) return;  SCHED_FIFO只有主动放弃CPU使用权
    |----&gt;rt.timeslice值减一，若没有运行完时间则直接返回，
    |     否则再次分配时间片，加入队列尾部，设置TIF_NEED_RESCHED

update_curr_rt()
    |----delta_exec = rq-&gt;clock - curr-&gt;se.exec_start; //本次运行时间
    |----curr-&gt;se.sum_exec_runtime += delta_exec; //更新总得运行时间
    |----curr-&gt;se.exec_start = rq-&gt;clock; //更新下次进程运行的起始时间
    |----if (sched_rt_runtime(rt_rq) != RUNTIME_INF)
    |-------{
    |           rt_rq-&gt;rt_time += delta_exec;
    |                if (sched_rt_runtime_exceeded(rt_rq))
    |                   resched_task(curr);
    |       }
</code></pre>
]]></content>
  </entry>
  
</feed>
