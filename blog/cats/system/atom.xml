<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: system | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/system/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2015-01-21T10:01:52+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[修改、重新生成和安装src.rpm源码包]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/10/30/tools-src-rpm/"/>
    <updated>2014-10-30T09:50:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/10/30/tools-src-rpm</id>
    <content type="html"><![CDATA[<p>RHEL/CentOS/Fedora/Suse等Linux发行版都使用rpm包作为软件包格式。另外还有一个相关的格式srpm包（后缀是.src.rpm），它包含了源代码，可以用它重新生成rpm包。<br/>
当前最新发行的RHEL/CentOS是6.X版本。目前最新版是RHEL6.5/CentOS6.5。（CentOS是RHEL的免费版本，与RHEL对应版本完全等价，除了去掉了Redhat的LOGO。）<br/>
在如下地址，可以找到RHEL6的所有rpm包的源码包：<em>.src.rpm。<br/>
    <a href="http://ftp.redhat.com/redhat/linux/enterprise/6Server/en/os/SRPMS/  ">http://ftp.redhat.com/redhat/linux/enterprise/6Server/en/os/SRPMS/  </a>
CentOS就是使用这些</em>src.rpm源码包构建出所有RPM包，生成CentOS操作系统的。<br/>
*src.rpm源码包解压出来后，可以看到有该软件的源代码压缩包和一些patch文件。<br/>
如果rpm包有问题，我们可以去<code>http://ftp.redhat.com/redhat/linux/enterprise/6Server/en/os/SRPMS/</code>下载对应的src.rpm包，然后把它解开后修改源代码，重新编译和生成rpm包，进行分发和安装。</p>

<h4>直接安装*src.rpm源码包</h4>

<p>有时，我们没有找到可用的rpm包，但找到了其对应的<em>src.rpm源码包，此时我们可以安装这个</em>src.rpm源码包。步骤与直接安装rpm包很不相同。
<code>
rpm -i /tmp/mypackage-1.0.0-1.src.rpm
</code>
此时还没有安装完成。只是在~/rpmbuild/ 目录下准备了该src.rpm源码包的资源，可用于进一步生成rpm包。
<code>
[user@host ~]$ cd ~/rpmbuild/SPECS
[user@host SPECS]$ rpmbuild -ba mypackage.spec
</code></p>

<h4>你也可以直接使用如下命令：</h4>

<pre><code>rpmbuild --rebuild /tmp/mypackage-1.0.0-1.src.rpm
</code></pre>

<p>这个命令一步即可在～/rpmbuild/RPMS/目录下重新生成rpm包。<br/>
基于*src.rpm源码包修改代码后生成rpm包并安装<br/>
rpmbuild命令基于.spec文件和源码tar.gz及patch文件生成src.rpm和rpm包。<br/>
因此，我们只需要修改.spec文件，或者对应的源码和patch文件，然后再执行<br/>
<code>
rpmbuild -ba mypackage.spec
</code>
命令，就可以生成更新后的src.rpm包和rpm包。rpm包在~/rpmbuild/RPMS目录下，<br/>
src.rpm包在~/rpmbuild/SRPMS目录下。注意,要修改~/rpmbuild/SOURCES/目录下的文件:<br/>
1. 你可以重新打包~/rpmbuild/SOURCES/目录下的tar.gz源文件。<br/>
2. 你可以修改.spec文件，增加或者减少对patch的应用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[grubby edit centos grub args]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/10/24/system-grubby/"/>
    <updated>2014-10-24T15:57:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/10/24/system-grubby</id>
    <content type="html"><![CDATA[<p>In Debian/Ubuntu, grub.cfg is fully generated by scripts and any manual changes made to it will be clobbered. In RHEL/CentOS however, grub.cfg is modified by scripts but manual changes are persisted, and is actually the canonical location for certain settings.</p>

<p>The tool which manages grub.cfg is grubby, which is called by /sbin/new-kernel-pkg when kernels are installed or removed. The &ndash;copy-default parameter is passed to grubby when a new kernel is installed, which causes it to copy the kernel parameters from the current default kernel. Setting the default kernel parameters for future-installed kernels is therefore done by editing the entry for the default kernel in grub.cfg.</p>

<p>If you weren&rsquo;t automating this you could simply edit grub.cfg manually and change all the current kernel entries. However, you can use grubby to modify grub.cfg in order to avoid parsing it or writing regular expressions. For example, this will remove the rhgb and quiet parameters from the specified kernel version.</p>

<pre><code>$ grubby --update-kernel=/boot/vmlinuz-2.6.32-220.13.1.el6.x86_64 --remove-args="rhgb quiet"
</code></pre>

<p>There doesn&rsquo;t seem to be an option to list the currently configured kernels however, so you&rsquo;ll have to discover these another way. One option is to just look for vmlinuz files in /boot/:</p>

<pre><code>#!/bin/sh
for KERNEL in /boot/vmlinuz-*; do
    grubby --update-kernel="$KERNEL" --remove-args="rhgb quiet"
done
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[grub]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/10/24/system-grub/"/>
    <updated>2014-10-24T15:53:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/10/24/system-grub</id>
    <content type="html"><![CDATA[<p>在命令行状态，可以根据需要加载或移除相应模块，也可用来启动在菜单没有显现的的系统。
比如，在第一硬盘的第一分区上装有windows xp系统，但在菜单上没显示出来，我们可以命令行状态下输入命令启动：
<code>
    grub&gt;set root=(hd0,1)
    grub&gt;chainloader +1
    grub&gt;boot
</code>
又比如启动第二硬盘第一逻辑分区上的ubuntu系统：
<code>
    grub&gt;set root=(hd1,5)
    grub&gt;linux /boot/vmlinuz-xxx-xxx root=/dev/sdb5
    grub&gt;initrd /boot/initrd.img-xxx-xxx
    grub&gt;boot
</code>
其中内核vmlinuz和initrd.img的版本号可用按Tab键自动查看。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[\r\n,\n,\r简介]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/10/21/system-enter-newline/"/>
    <updated>2014-10-21T10:06:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/10/21/system-enter-newline</id>
    <content type="html"><![CDATA[<p>&lsquo;\r'是回车，前者使光标到行首，（carriage return）<br/>
&rsquo;\n'是换行，后者使光标下移一格，（line feed）</p>

<p>\r 是回车，return<br/>
\n 是换行，newline</p>

<p>^M 是ascii中的'\r', 回车符，是16进制的0x0D，八进制的015，十进制的13<br/>
^M在vi编辑器中可以使用Ctrl+ v + m三个键打出来</p>

<p>对于换行这个动作，unix下一般只有一个0x0A表示换行(&ldquo;\n&rdquo;)，windows下一般都是0x0D和0x0A两个字符(&ldquo;\r\n&rdquo;)，苹果机(MAC OS系统)则采用回车符CR表示下一行(\r)</p>

<blockquote><p>  Unix系统里，每行结尾只有“&lt;换行>”，即“\n”；<br/>
  Windows系统里面，每行结尾是“&lt;回车>&lt;换行>”，即“\r\n”；<br/>
  Mac系统里，每行结尾是“&lt;回车>”,即“\r”。</p></blockquote>

<p>一个直接后果是，Unix/Mac系统下的文件在Windows里打开的话，所有文字会变成一行；而Windows里的文件在Unix下打开的话，在每行的结尾会多车一个<sup>M</sup>字符。
Dos和windows采用回车+换行CR/LF表示下一行,即<sup>M</sup>$（$不是换行符的表示，换行符没有表示出来，$是文本结束EOF的表示）
而UNIX/Linux采用换行符LF表示下一行，即\n<br/>
苹果机(MAC OS系统)则采用回车符CR表示下一行，即\r</p>

<p>CR用符号'\r'表示, 十进制ASCII代码是13, 十六进制代码为0x0D;<br/>
LF使用'\n'符号表示, ASCII代码是10, 十六制为0x0A. 所以Windows平台上换行在文本文件中是使用 0d 0a 两个字节表示, 而UNIX和苹果平台上换行则是使用0a或0d一个字节表示.</p>

<p>由于dos风格的换行使用\r\n，把这样的文件上传到unix，有些版本的vi不能识别\r，所以vi显示时在行尾会出现<sup>M</sup>出来，但是有些就能识别\r\n，正常显示回车换行。</p>

<p>dos to unix，去掉<sup>M</sup>
<code>
tr -d "\015" &lt;myfile.txt &gt; myfile_new.txt
tr -d "\r" &lt;myfile.txt &gt; myfile_new.txt
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Win7下硬盘安装Ubuntu系统]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/10/15/ubuntu-win7-install/"/>
    <updated>2014-10-15T10:52:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/10/15/ubuntu-win7-install</id>
    <content type="html"><![CDATA[<h5>1.下载Linux镜像：</h5>

<p>  以Ubuntu为例：<a href="http://www.ubuntu.com/desktop/get-ubuntu/download">http://www.ubuntu.com/desktop/get-ubuntu/download</a></p>

<h5>2.下载并安装EasyBCD：</h5>

<p>  系统引导软件EasyBCD：<a href="http://neosmart.net/EasyBCD/%E3%80%80">http://neosmart.net/EasyBCD/%E3%80%80</a></p>

<h5>3.设置启动项</h5>

<p>　　1) 把ubuntu镜像文件放在C盘根目录，并将镜像中的casper目录下的vmlinuz和initrd.lz解压到C盘根目录下<br/>
　　2) 在打开的EasyBCD界面选择 Add New Entry -> NeoGrub -> Install -> Configure -> 将如下代码粘贴到自动打开的记事本中
<code>
title Install Ubuntu
root (hd0,2)
kernel (hd0,2)/vmlinuz boot=casper iso-scan/filename=/ubuntu-12.10-desktop-i386.iso ro quiet splash locale=zh_CN.UTF-8
initrd (hd0,2)/initrd.lz
</code>
  注：这段代码中的 untu-12.10-desktop-i386.iso要和下载的镜像名字一致。配置文件的几行命令意思是在你硬盘的各分区根目录下（“/”）扫描文件 名为“ untu-11.10-desktop-i386”的镜像并引导启动该镜像文件。当然，如果你把镜像放到了其他目录下，则相应地修改 “filename=/×××”（原教程的镜像存放文件目录为system，其配置文件为filename=/system）。(hd0,2)代表你的放 镜像的盘符所在位置，我放在了C盘，又因为我的是笔记本，有两个隐藏的主分区，所有我的C盘就是第三个，盘符为hd(0,2)。如果不懂，最好查百度，很 多安装出错不成功都是因为这个没有设置正确。</p>

<h5>4.开始安装ubuntu</h5>

<p>　　1) 重启电脑选择NeoGrub Bootloader启动项进入Ubuntu live cd桌面<br/>
　　2) 打开终端执行如下命令：<br/>
<code>
　　sudo umount -l /isodevice （该命令是挂载ISO镜像所在的C盘分区）
</code>
　　3) 点击桌面上的安装ubuntu，然后一步步按照提示选择安装</p>
]]></content>
  </entry>
  
</feed>
