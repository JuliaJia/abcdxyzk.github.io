<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: kernel | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/kernel/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2015-01-03T23:26:57+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[中断，进程]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/01/03/kernel-sched-irq-mark/"/>
    <updated>2015-01-03T15:45:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/01/03/kernel-sched-irq-mark</id>
    <content type="html"><![CDATA[<p>blog.chinaunix.net/uid-20806345-id-3203602.html</p>

<p>  中断不是进程，不受内核调度器的管辖。在系统处理进程的过程中，对于某个cpu来说，如果有内部中断或外部中断到来，则切换到中断处理程序，切换首先要将进程由用户态要切到进程的内核态，然后再将cpu切换到中断态，待处理完中断返回进程的内核态，再返回进程的用户态，如果中断时进程刚好处于内核态中不用由用户态切到内核态了。<br/>
  中断处理时是不分优先级的，处理中断的过程中如果有任意中断到来，都会抢占当前的中断处理过程。所以对于要及时响应的中断，需要通过关中断来屏蔽其他中断。通常所说的中断优先级是指中断控制器端的优先级，当有多个中断触发时，首先选择优先级高的中断发出请求给处理器。中断优先级只是对中断控制器而言的，所有的中断对cpu来说都是一样的，没有优先级高低之分。<br/>
  关中断是关闭所有的外部可屏蔽中断，和优先级没有关系，如果在某中断处理程序中关中断，则不会被任何可屏蔽中断抢占，但是会被任意的不可屏蔽中断抢占。关中断是中断处理程序可选的。</p>

<p>bbs.chinaunix.net/thread-2306027-1-8.html</p>

<p>软中断做的是一些可延迟的费时间的事，当然不能在中断里执行了。<br/>
  <code>__do_softirq</code>代码，可以看到在执行可延迟函数第一件事就是开中断。但在开始之前，禁用了下半部中断（<code>__local_bh_disable</code>）。这样就算被中断了，返回内核时也不会被抢占，还是执行这里的代码。也不会被调度。<br/>
  那么这样的后果就是软中断上下文里的会一直执行下去，直到到达了限定次数，然后唤醒守护进程。<br/>
  因为软中断切换了栈，不再使用进程上下文，那么如果在软中断上下文直接或简洁调用了shedule，那么只有死翘翘了！！因为schedule调度回来的时候是依赖进程内核栈的thread_info。</p>

<p>  内核抢占点之一就是中断返回的时候检查是否可以抢占，检查的内容之一就是preempt_count是否等于0，因为禁用了下半部中断，那么肯定就不会等于0的，所以不会被抢占。也就是说返回的时候不会发生调度。</p>

<p>  个人理解 中断上下文 最大的特征 禁掉了某种中断（硬中断和软中断），所以导致 不能阻塞。<br/>
  softirq 有可能在两种方式下被调用，一是中断处理程序退出时，开放硬件中断之后，会去调用do_softirq()。
  do_softirq()会禁掉后半部抢占，并且现在执行流使用的是被中断的进程的栈，所以无法阻塞。<br/>
  softirq的另一种调用方式是ksoftirq内核线程，同样do_softirq()被调用，后半部中断被禁掉，同样禁止阻塞。<br/>
  工作队列，可以被任何中断或者软中断中断，运行在进程上下文，有自己的栈，可以阻塞。</p>

<p>看一下__do_softirq()的代码,新的硬中断确实可能触发更高优先级的软中断，但是这个软中断并不会在被中断的软中断之前得到执行，软中断始终是顺序执行的。从代码看来，新一批的软中断，无论优先级多高，也得等到前一批的软中断被处理完成之后才能得到处理。而优先级只能帮助软中断在对应的批次中优先得到处理。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[硬中断和软中断]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/01/03/kernel-sched-irq/"/>
    <updated>2015-01-03T15:15:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/01/03/kernel-sched-irq</id>
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/zhangskd/article/details/21992933">http://blog.csdn.net/zhangskd/article/details/21992933</a></p>

<h4>概述</h4>

<p>从本质上来讲，中断是一种电信号，当设备有某种事件发生时，它就会产生中断，通过总线把电信号发送给中断控制器。
如果中断的线是激活的，中断控制器就把电信号发送给处理器的某个特定引脚。处理器于是立即停止自己正在做的事，
跳到中断处理程序的入口点，进行中断处理。</p>

<h5>(1) 硬中断</h5>

<p>由与系统相连的外设(比如网卡、硬盘)自动产生的。主要是用来通知操作系统系统外设状态的变化。比如当网卡收到数据包的时候，就会发出一个中断。我们通常所说的中断指的是硬中断(hardirq)。</p>

<h5>(2) 软中断</h5>

<p>为了满足实时系统的要求，中断处理应该是越快越好。linux为了实现这个特点，当中断发生的时候，硬中断处理那些短时间就可以完成的工作，而将那些处理事件比较长的工作，放到中断之后来完成，也就是软中断(softirq)来完成。</p>

<h5>(3) 中断嵌套</h5>

<p>Linux下硬中断是可以嵌套的，但是没有优先级的概念，也就是说任何一个新的中断都可以打断正在执行的中断，但同种中断除外。软中断不能嵌套，但相同类型的软中断可以在不同CPU上并行执行。</p>

<h5>(4) 软中断指令</h5>

<p>int是软中断指令。<br/>
中断向量表是中断号和中断处理函数地址的对应表。<br/>
int n - 触发软中断n。相应的中断处理函数的地址为：中断向量表地址 + 4 * n。</p>

<h5>(5)硬中断和软中断的区别</h5>

<p>软中断是执行中断指令产生的，而硬中断是由外设引发的。<br/>
硬中断的中断号是由中断控制器提供的，软中断的中断号由指令直接指出，无需使用中断控制器。<br/>
硬中断是可屏蔽的，软中断不可屏蔽。<br/>
硬中断处理程序要确保它能快速地完成任务，这样程序执行时才不会等待较长时间，称为上半部。<br/>
软中断处理硬中断未完成的工作，是一种推后执行的机制，属于下半部。</p>

<h4>开关</h4>

<h5>(1) 硬中断的开关</h5>

<p>简单禁止和激活当前处理器上的本地中断：
<code>
local_irq_disable();
local_irq_enable();
</code>
保存本地中断系统状态下的禁止和激活：
<code>
unsigned long flags;
local_irq_save(flags);
local_irq_restore(flags);
</code></p>

<h5>(2) 软中断的开关</h5>

<p>禁止下半部，如softirq、tasklet和workqueue等：
<code>
local_bh_disable();
local_bh_enable();
</code>
需要注意的是，禁止下半部时仍然可以被硬中断抢占。</p>

<h5>(3) 判断中断状态</h5>

<pre><code>    #define in_interrupt() (irq_count()) // 是否处于中断状态(硬中断或软中断)
    #define in_irq() (hardirq_count()) // 是否处于硬中断
    #define in_softirq() (softirq_count()) // 是否处于软中断
</code></pre>

<h4>硬中断</h4>

<h5>(1) 注册中断处理函数</h5>

<p>注册中断处理函数：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/&lt;em&gt;&lt;em&gt;
</span><span class='line'> * irq: 要分配的中断号
</span><span class='line'> * handler: 要注册的中断处理函数
</span><span class='line'> * flags: 标志(一般为0)
</span><span class='line'> * name: 设备名(dev-&gt;name)
</span><span class='line'> * dev: 设备(struct net_device &lt;/em&gt;dev)，作为中断处理函数的参数
</span><span class='line'> * 成功返回0
</span><span class='line'> &lt;/em&gt;/&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;int request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags,   
</span><span class='line'>const char *name, void *dev);  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>中断处理函数本身：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;typedef irqreturn_t (*irq_handler_t) (int, void *);  
</span><span class='line'>
</span><span class='line'>/** 
</span><span class='line'> * enum irqreturn 
</span><span class='line'> * @IRQ_NONE: interrupt was not from this device 
</span><span class='line'> * @IRQ_HANDLED: interrupt was handled by this device 
</span><span class='line'> * @IRQ_WAKE_THREAD: handler requests to wake the handler thread 
</span><span class='line'> */  
</span><span class='line'>enum irqreturn {  
</span><span class='line'>IRQ_NONE,  
</span><span class='line'>IRQ_HANDLED,  
</span><span class='line'>IRQ_WAKE_THREAD,  
</span><span class='line'>};  
</span><span class='line'>typedef enum irqreturn irqreturn_t;  
</span><span class='line'>#define IRQ_RETVAL(x) ((x) != IRQ_NONE)  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>##### (2) 注销中断处理函数
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;/** 
</span><span class='line'> * free_irq - free an interrupt allocated with request_irq 
</span><span class='line'> * @irq: Interrupt line to free 
</span><span class='line'> * @dev_id: Device identity to free 
</span><span class='line'> * 
</span><span class='line'> * Remove an interrupt handler. The handler is removed and if the 
</span><span class='line'> * interrupt line is no longer in use by any driver it is disabled. 
</span><span class='line'> * On a shared IRQ the caller must ensure the interrupt is disabled 
</span><span class='line'> * on the card it drives before calling this function. The function does 
</span><span class='line'> * not return until any executing interrupts for this IRQ have completed. 
</span><span class='line'> * This function must not be called from interrupt context. 
</span><span class='line'> */  
</span><span class='line'>
</span><span class='line'>void free_irq(unsigned int irq, void *dev_id);  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>#### 软中断
</span><span class='line'>##### (1) 定义
</span><span class='line'>软中断是一组静态定义的下半部接口，可以在所有处理器上同时执行，即使两个类型相同也可以。  
</span><span class='line'>但一个软中断不会抢占另一个软中断，唯一可以抢占软中断的是硬中断。
</span><span class='line'>
</span><span class='line'>软中断由softirq_action结构体表示：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;struct softirq_action {  
</span><span class='line'>void (*action) (struct softirq_action *); /* 软中断的处理函数 */  
</span><span class='line'>};  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>目前已注册的软中断有10种，定义为一个全局数组：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static struct softirq_action softirq_vec[NR_SOFTIRQS];  
</span><span class='line'>
</span><span class='line'>enum {  
</span><span class='line'>HI_SOFTIRQ = 0, /* 优先级高的tasklets */  
</span><span class='line'>TIMER_SOFTIRQ, /* 定时器的下半部 */  
</span><span class='line'>NET_TX_SOFTIRQ, /* 发送网络数据包 */  
</span><span class='line'>NET_RX_SOFTIRQ, /* 接收网络数据包 */  
</span><span class='line'>BLOCK_SOFTIRQ, /* BLOCK装置 */  
</span><span class='line'>BLOCK_IOPOLL_SOFTIRQ,  
</span><span class='line'>TASKLET_SOFTIRQ, /* 正常优先级的tasklets */  
</span><span class='line'>SCHED_SOFTIRQ, /* 调度程序 */  
</span><span class='line'>HRTIMER_SOFTIRQ, /* 高分辨率定时器 */  
</span><span class='line'>RCU_SOFTIRQ, /* RCU锁定 */  
</span><span class='line'>NR_SOFTIRQS /* 10 */  
</span><span class='line'>};  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>##### (2) 注册软中断处理函数
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;/** 
</span><span class='line'> * @nr: 软中断的索引号 
</span><span class='line'> * @action: 软中断的处理函数 
</span><span class='line'> */  
</span><span class='line'>
</span><span class='line'>void open_softirq(int nr, void (*action) (struct softirq_action *))  
</span><span class='line'>{  
</span><span class='line'>softirq_vec[nr].action = action;  
</span><span class='line'>}  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;例如：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;open_softirq(NET_TX_SOFTIRQ, net_tx_action);
</span><span class='line'>open_softirq(NET_RX_SOFTIRQ, net_rx_action);</span></code></pre></td></tr></table></div></figure></p>

<h5>(3) 触发软中断</h5>

<p>调用raise_softirq()来触发软中断。
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
<span class='line-number'>206</span>
<span class='line-number'>207</span>
<span class='line-number'>208</span>
<span class='line-number'>209</span>
<span class='line-number'>210</span>
<span class='line-number'>211</span>
<span class='line-number'>212</span>
<span class='line-number'>213</span>
<span class='line-number'>214</span>
<span class='line-number'>215</span>
<span class='line-number'>216</span>
<span class='line-number'>217</span>
<span class='line-number'>218</span>
<span class='line-number'>219</span>
<span class='line-number'>220</span>
<span class='line-number'>221</span>
<span class='line-number'>222</span>
<span class='line-number'>223</span>
<span class='line-number'>224</span>
<span class='line-number'>225</span>
<span class='line-number'>226</span>
<span class='line-number'>227</span>
<span class='line-number'>228</span>
<span class='line-number'>229</span>
<span class='line-number'>230</span>
<span class='line-number'>231</span>
<span class='line-number'>232</span>
<span class='line-number'>233</span>
<span class='line-number'>234</span>
<span class='line-number'>235</span>
<span class='line-number'>236</span>
<span class='line-number'>237</span>
<span class='line-number'>238</span>
<span class='line-number'>239</span>
<span class='line-number'>240</span>
<span class='line-number'>241</span>
<span class='line-number'>242</span>
<span class='line-number'>243</span>
<span class='line-number'>244</span>
<span class='line-number'>245</span>
<span class='line-number'>246</span>
<span class='line-number'>247</span>
<span class='line-number'>248</span>
<span class='line-number'>249</span>
<span class='line-number'>250</span>
<span class='line-number'>251</span>
<span class='line-number'>252</span>
<span class='line-number'>253</span>
<span class='line-number'>254</span>
<span class='line-number'>255</span>
<span class='line-number'>256</span>
<span class='line-number'>257</span>
<span class='line-number'>258</span>
<span class='line-number'>259</span>
<span class='line-number'>260</span>
<span class='line-number'>261</span>
<span class='line-number'>262</span>
<span class='line-number'>263</span>
<span class='line-number'>264</span>
<span class='line-number'>265</span>
<span class='line-number'>266</span>
<span class='line-number'>267</span>
<span class='line-number'>268</span>
<span class='line-number'>269</span>
<span class='line-number'>270</span>
<span class='line-number'>271</span>
<span class='line-number'>272</span>
<span class='line-number'>273</span>
<span class='line-number'>274</span>
<span class='line-number'>275</span>
<span class='line-number'>276</span>
<span class='line-number'>277</span>
<span class='line-number'>278</span>
<span class='line-number'>279</span>
<span class='line-number'>280</span>
<span class='line-number'>281</span>
<span class='line-number'>282</span>
<span class='line-number'>283</span>
<span class='line-number'>284</span>
<span class='line-number'>285</span>
<span class='line-number'>286</span>
<span class='line-number'>287</span>
<span class='line-number'>288</span>
<span class='line-number'>289</span>
<span class='line-number'>290</span>
<span class='line-number'>291</span>
<span class='line-number'>292</span>
<span class='line-number'>293</span>
<span class='line-number'>294</span>
<span class='line-number'>295</span>
<span class='line-number'>296</span>
<span class='line-number'>297</span>
<span class='line-number'>298</span>
<span class='line-number'>299</span>
<span class='line-number'>300</span>
<span class='line-number'>301</span>
<span class='line-number'>302</span>
<span class='line-number'>303</span>
<span class='line-number'>304</span>
<span class='line-number'>305</span>
<span class='line-number'>306</span>
<span class='line-number'>307</span>
<span class='line-number'>308</span>
<span class='line-number'>309</span>
<span class='line-number'>310</span>
<span class='line-number'>311</span>
<span class='line-number'>312</span>
<span class='line-number'>313</span>
<span class='line-number'>314</span>
<span class='line-number'>315</span>
<span class='line-number'>316</span>
<span class='line-number'>317</span>
<span class='line-number'>318</span>
<span class='line-number'>319</span>
<span class='line-number'>320</span>
<span class='line-number'>321</span>
<span class='line-number'>322</span>
<span class='line-number'>323</span>
<span class='line-number'>324</span>
<span class='line-number'>325</span>
<span class='line-number'>326</span>
<span class='line-number'>327</span>
<span class='line-number'>328</span>
<span class='line-number'>329</span>
<span class='line-number'>330</span>
<span class='line-number'>331</span>
<span class='line-number'>332</span>
<span class='line-number'>333</span>
<span class='line-number'>334</span>
<span class='line-number'>335</span>
<span class='line-number'>336</span>
<span class='line-number'>337</span>
<span class='line-number'>338</span>
<span class='line-number'>339</span>
<span class='line-number'>340</span>
<span class='line-number'>341</span>
<span class='line-number'>342</span>
<span class='line-number'>343</span>
<span class='line-number'>344</span>
<span class='line-number'>345</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void raise_softirq(unsigned int nr)&lt;br/&gt;
</span><span class='line'>{&lt;br/&gt;
</span><span class='line'>    unsigned long flags;&lt;br/&gt;
</span><span class='line'>    local_irq_save(flags);&lt;br/&gt;
</span><span class='line'>    raise_softirq_irqoff(nr);&lt;br/&gt;
</span><span class='line'>    local_irq_restore(flags);&lt;br/&gt;
</span><span class='line'>}&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;/* This function must run with irqs disabled */  
</span><span class='line'>inline void rasie_softirq_irqsoff(unsigned int nr)  
</span><span class='line'>{  
</span><span class='line'>__raise_softirq_irqoff(nr);  
</span><span class='line'>
</span><span class='line'>/* If we're in an interrupt or softirq, we're done 
</span><span class='line'> * (this also catches softirq-disabled code). We will 
</span><span class='line'> * actually run the softirq once we return from the irq 
</span><span class='line'> * or softirq. 
</span><span class='line'> * Otherwise we wake up ksoftirqd to make sure we 
</span><span class='line'> * schedule the softirq soon. 
</span><span class='line'> */  
</span><span class='line'>if (! in_interrupt()) /* 如果不处于硬中断或软中断 */  
</span><span class='line'>    wakeup_softirqd(void); /* 唤醒ksoftirqd/n进程 */  
</span><span class='line'>}  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>Percpu变量irq_cpustat_t中的__softirq_pending是等待处理的软中断的位图，通过设置此变量
</span><span class='line'>
</span><span class='line'>即可告诉内核该执行哪些软中断。
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static inline void __rasie_softirq_irqoff(unsigned int nr)  
</span><span class='line'>{  
</span><span class='line'>trace_softirq_raise(nr);  
</span><span class='line'>or_softirq_pending(1UL &lt;&lt; nr);  
</span><span class='line'>}  
</span><span class='line'>
</span><span class='line'>typedef struct {  
</span><span class='line'>unsigned int __softirq_pending;  
</span><span class='line'>unsigned int __nmi_count; /* arch dependent */  
</span><span class='line'>} irq_cpustat_t;  
</span><span class='line'>
</span><span class='line'>irq_cpustat_t irq_stat[];  
</span><span class='line'>#define __IRQ_STAT(cpu, member) (irq_stat[cpu].member)  
</span><span class='line'>#define or_softirq_pending(x) percpu_or(irq_stat.__softirq_pending, (x))  
</span><span class='line'>#define local_softirq_pending() percpu_read(irq_stat.__softirq_pending)  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>唤醒ksoftirqd内核线程处理软中断。
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static void wakeup_softirqd(void)  
</span><span class='line'>{  
</span><span class='line'>/* Interrupts are disabled: no need to stop preemption */  
</span><span class='line'>struct task_struct *tsk = __get_cpu_var(ksoftirqd);  
</span><span class='line'>
</span><span class='line'>if (tsk &amp;&amp; tsk-&gt;state != TASK_RUNNING)  
</span><span class='line'>    wake_up_process(tsk);  
</span><span class='line'>}  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>在下列地方，待处理的软中断会被检查和执行：  
</span><span class='line'>1. 从一个硬件中断代码处返回时  
</span><span class='line'>2. 在ksoftirqd内核线程中  
</span><span class='line'>3. 在那些显示检查和执行待处理的软中断的代码中，如网络子系统中
</span><span class='line'>
</span><span class='line'>而不管是用什么方法唤起，软中断都要在do_softirq()中执行。如果有待处理的软中断，do_softirq()会循环遍历每一个，调用它们的相应的处理程序。在中断处理程序中触发软中断是最常见的形式。中断处理程序执行硬件设备的相关操作，然后触发相应的软中断，最后退出。内核在执行完中断处理程序以后，马上就会调用do_softirq()，于是软中断开始执行中断处理程序完成剩余的任务。
</span><span class='line'>
</span><span class='line'>下面来看下do_softirq()的具体实现。
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;asmlinkage void do_softirq(void)  
</span><span class='line'>{  
</span><span class='line'>__u32 pending;  
</span><span class='line'>unsigned long flags;  
</span><span class='line'>
</span><span class='line'>/* 如果当前已处于硬中断或软中断中，直接返回 */  
</span><span class='line'>if (in_interrupt())   
</span><span class='line'>    return;  
</span><span class='line'>
</span><span class='line'>local_irq_save(flags);  
</span><span class='line'>pending = local_softirq_pending();  
</span><span class='line'>if (pending) /* 如果有激活的软中断 */  
</span><span class='line'>    __do_softirq(); /* 处理函数 */  
</span><span class='line'>local_irq_restore(flags);  
</span><span class='line'>}  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;code&gt;
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>/&lt;em&gt; We restart softirq processing MAX_SOFTIRQ_RESTART times,
</span><span class='line'> * and we fall back to softirqd after that.
</span><span class='line'> * This number has been established via experimentation.
</span><span class='line'> * The two things to balance is latency against fairness - we want
</span><span class='line'> * to handle softirqs as soon as possible, but they should not be
</span><span class='line'> * able to lock up the box.
</span><span class='line'> &lt;/em&gt;/&lt;br/&gt;
</span><span class='line'>asmlinkage void &lt;strong&gt;do_softirq(void)&lt;br/&gt;
</span><span class='line'>{&lt;br/&gt;
</span><span class='line'>    struct softirq_action *h;&lt;br/&gt;
</span><span class='line'>    &lt;/strong&gt;u32 pending;&lt;br/&gt;
</span><span class='line'>    /&lt;em&gt; 本函数能重复触发执行的次数，防止占用过多的cpu时间 &lt;/em&gt;/&lt;br/&gt;
</span><span class='line'>    int max_restart = MAX_SOFTIRQ_RESTART;&lt;br/&gt;
</span><span class='line'>    int cpu;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    pending = local_softirq_pending(); /* 激活的软中断位图 */  
</span><span class='line'>account_system_vtime(current);  
</span><span class='line'>/* 本地禁止当前的软中断 */  
</span><span class='line'>__local_bh_disable((unsigned long)__builtin_return_address(0), SOFTIRQ_OFFSET);  
</span><span class='line'>lockdep_softirq_enter(); /* current-&gt;softirq_context++ */  
</span><span class='line'>cpu = smp_processor_id(); /* 当前cpu编号 */  
</span><span class='line'>
</span><span class='line'>restart:  
</span><span class='line'>/* Reset the pending bitmask before enabling irqs */  
</span><span class='line'>set_softirq_pending(0); /* 重置位图 */  
</span><span class='line'>local_irq_enable();  
</span><span class='line'>h = softirq_vec;  
</span><span class='line'>do {  
</span><span class='line'>    if (pending &amp; 1) {  
</span><span class='line'>        unsigned int vec_nr = h - softirq_vec; /* 软中断索引 */  
</span><span class='line'>        int prev_count = preempt_count();  
</span><span class='line'>        kstat_incr_softirqs_this_cpu(vec_nr);  
</span><span class='line'>
</span><span class='line'>        trace_softirq_entry(vec_nr);  
</span><span class='line'>        h-&gt;action(h); /* 调用软中断的处理函数 */  
</span><span class='line'>        trace_softirq_exit(vec_nr);  
</span><span class='line'>
</span><span class='line'>        if (unlikely(prev_count != preempt_count())) {  
</span><span class='line'>            printk(KERN_ERR "huh, entered softirq %u %s %p" "with preempt_count %08x,"  
</span><span class='line'>                "exited with %08x?\n", vec_nr, softirq_to_name[vec_nr], h-&gt;action, prev_count,  
</span><span class='line'>                preempt_count());  
</span><span class='line'>        }  
</span><span class='line'>        rcu_bh_qs(cpu);  
</span><span class='line'>    }  
</span><span class='line'>    h++;  
</span><span class='line'>    pending &gt;&gt;= 1;  
</span><span class='line'>} while(pending);  
</span><span class='line'>
</span><span class='line'>local_irq_disable();  
</span><span class='line'>pending = local_softirq_pending();  
</span><span class='line'>if (pending &amp; --max_restart) /* 重复触发 */  
</span><span class='line'>    goto restart;  
</span><span class='line'>
</span><span class='line'>/* 如果重复触发了10次了，接下来唤醒ksoftirqd/n内核线程来处理 */  
</span><span class='line'>if (pending)  
</span><span class='line'>    wakeup_softirqd();   
</span><span class='line'>
</span><span class='line'>lockdep_softirq_exit();  
</span><span class='line'>account_system_vtime(current);  
</span><span class='line'>__local_bh_enable(SOFTIRQ_OFFSET);  
</span><span class='line'>}  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>##### (4) ksoftirqd内核线程
</span><span class='line'>内核不会立即处理重新触发的软中断。  
</span><span class='line'>当大量软中断出现的时候，内核会唤醒一组内核线程来处理。  
</span><span class='line'>这些线程的优先级最低(nice值为19)，这能避免它们跟其它重要的任务抢夺资源。  
</span><span class='line'>但它们最终肯定会被执行，所以这个折中的方案能够保证在软中断很多时用户程序不会因为得不到处理时间而处于饥饿状态，同时也保证过量的软中断最终会得到处理。
</span><span class='line'>
</span><span class='line'>每个处理器都有一个这样的线程，名字为ksoftirqd/n，n为处理器的编号。
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static int run_ksoftirqd(void *__bind_cpu)  
</span><span class='line'>{  
</span><span class='line'>set_current_state(TASK_INTERRUPTIBLE);  
</span><span class='line'>current-&gt;flags |= PF_KSOFTIRQD; /* I am ksoftirqd */  
</span><span class='line'>
</span><span class='line'>while(! kthread_should_stop()) {  
</span><span class='line'>    preempt_disable();  
</span><span class='line'>
</span><span class='line'>    if (! local_softirq_pending()) { /* 如果没有要处理的软中断 */  
</span><span class='line'>        preempt_enable_no_resched();  
</span><span class='line'>        schedule();  
</span><span class='line'>        preempt_disable():  
</span><span class='line'>    }  
</span><span class='line'>
</span><span class='line'>    __set_current_state(TASK_RUNNING);  
</span><span class='line'>
</span><span class='line'>    while(local_softirq_pending()) {  
</span><span class='line'>        /* Preempt disable stops cpu going offline. 
</span><span class='line'>         * If already offline, we'll be on wrong CPU: don't process. 
</span><span class='line'>         */  
</span><span class='line'>         if (cpu_is_offline(long)__bind_cpu))/* 被要求释放cpu */  
</span><span class='line'>             goto wait_to_die;  
</span><span class='line'>
</span><span class='line'>        do_softirq(); /* 软中断的统一处理函数 */  
</span><span class='line'>
</span><span class='line'>        preempt_enable_no_resched();  
</span><span class='line'>        cond_resched();  
</span><span class='line'>        preempt_disable();  
</span><span class='line'>        rcu_note_context_switch((long)__bind_cpu);  
</span><span class='line'>    }  
</span><span class='line'>
</span><span class='line'>    preempt_enable();  
</span><span class='line'>    set_current_state(TASK_INTERRUPTIBLE);  
</span><span class='line'>}  
</span><span class='line'>
</span><span class='line'>__set_current_state(TASK_RUNNING);  
</span><span class='line'>return 0;  
</span><span class='line'>
</span><span class='line'>wait_to_die:  
</span><span class='line'>preempt_enable();  
</span><span class='line'>/* Wait for kthread_stop */  
</span><span class='line'>set_current_state(TASK_INTERRUPTIBLE);  
</span><span class='line'>while(! kthread_should_stop()) {  
</span><span class='line'>    schedule();  
</span><span class='line'>    set_current_state(TASK_INTERRUPTIBLE);  
</span><span class='line'>}  
</span><span class='line'>
</span><span class='line'>__set_current_state(TASK_RUNNING);  
</span><span class='line'>return 0;  
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[关于ksoftirqd进程]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2015/01/03/kernel-sched-ksoftirqd/"/&gt;
</span><span class='line'>&lt;updated&gt;2015-01-03T15:01:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2015/01/03/kernel-sched-ksoftirqd&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;p&gt;blog.chinaunix.net/uid-20737871-id-1881243.html&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;每个处理器都有一组辅助处理器软中断(和tasklet)的内核线程。当内核中出现大量软中断的时候，这些内核进程就会辅助处理它们。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;引入ksoftirq内核线程的原因：&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;对于软中断，内核会选择在几个特殊时机进行处理。而在中断处理程序返回时处理是最常见的。软中断被触发的频率有时可能很高，更不利的是，处理函数有时还会 字形重复触发，那么就会导致用户空间进程无法获得足够的处理时间，因而处于饥饿状态。单纯的对重新触发的软中断采取不立即处理的策略，也无法让人接受。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;最初的解决方案：&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;1）只要还有被触发并等待处理的软中断，本次执行就要负责处理，重新触发的软中断也在本次执行返回前被处理。这样做可以保证对内核的软中断采取即时处理的 方式，关键在于，对重新触发的软中断也会立即处理。当负载很高的时候，此时若有大量被触发的软中断，而它们本身又会重复触发。系统可能会一直处理软中断根 本不能完成其他任务。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;2）不处理重新触发的软中断。在从中断返回的时候，内核和平常一样，也会检查所有挂起的软中断并处理他们。但是，任何自行重新触发的软中断不会马上处理， 它们被放到下一个软中断执行时机去处理。而这个时机通常也就是下一次中断返回的时候。可是，在比较空闲的系统中，立即处理软中断才是比较好的做法。尽管它 能保证用户空间不处于饥饿状态，但它却让软中断忍受饥饿的痛苦，而根本没有好好利用闲置的系统资源。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;改进：&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;最终在内核中实现的方案是不会立即处理处理重新触发的软中断。而作为改进，当大量软中断出现的时候，内核会唤醒一组内核线程来处理这些负载。这些线程在最 低的优先级上运行（nice值是19），这能避免它们跟其他重要的任务抢夺资源。但它们最终肯定会被执行，所以这个折中方案能够保证在软中断负担很中的时 候用户程序不会因为得不到处理时间处于饥饿状态。相应的，也能保证”过量“的软中断终究会得到处理。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;每个处理器都有一个这样的线程。所有线程的名字都叫做ksoftirq/n，区别在于n，它对应的是处理器的编号。在一个双CPU的机器上就有两个这样的 线程，分别叫做ksoftirqd/0和ksoftirqd/1。为了保证只要有空闲的处理器，它们就会处理软中断，所以给每个处理器都分配一个这样的线 程。一旦该线程被初始化，它就会执行类似下面这样的死循环：&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;在kernel/softirq.c中
</span><span class='line'>&lt;code&gt;
</span><span class='line'>static int ksoftirqd(void * __bind_cpu)
</span><span class='line'>{
</span><span class='line'>    set_user_nice(current, 19);
</span><span class='line'>    current-&gt;flags |= PF_NOFREEZE;
</span><span class='line'>    set_current_state(TASK_INTERRUPTIBLE);
</span><span class='line'>    while (!kthread_should_stop()) {
</span><span class='line'>        preempt_disable();
</span><span class='line'>        if (!local_softirq_pending()) {
</span><span class='line'>            preempt_enable_no_resched();
</span><span class='line'>            schedule();
</span><span class='line'>            preempt_disable();
</span><span class='line'>        }
</span><span class='line'>        __set_current_state(TASK_RUNNING);
</span><span class='line'>        while (local_softirq_pending()) {
</span><span class='line'>            /* Preempt disable stops cpu going offline.
</span><span class='line'>                If already offline, we'll be on wrong CPU:
</span><span class='line'>                don't process */
</span><span class='line'>            if (cpu_is_offline((long)__bind_cpu))
</span><span class='line'>                goto wait_to_die;
</span><span class='line'>            do_softirq();
</span><span class='line'>            preempt_enable_no_resched();
</span><span class='line'>            cond_resched();
</span><span class='line'>            preempt_disable();
</span><span class='line'>        }
</span><span class='line'>        preempt_enable();
</span><span class='line'>        set_current_state(TASK_INTERRUPTIBLE);
</span><span class='line'>    }
</span><span class='line'>    __set_current_state(TASK_RUNNING);
</span><span class='line'>    return 0;
</span><span class='line'>wait_to_die:
</span><span class='line'>    preempt_enable();
</span><span class='line'>    /* Wait for kthread_stop */
</span><span class='line'>    set_current_state(TASK_INTERRUPTIBLE);
</span><span class='line'>    while (!kthread_should_stop()) {
</span><span class='line'>        schedule();
</span><span class='line'>        set_current_state(TASK_INTERRUPTIBLE);
</span><span class='line'>    }
</span><span class='line'>    __set_current_state(TASK_RUNNING);
</span><span class='line'>    return 0;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;只要有待处理的软中断(由softirq_pending()函数负责发现)，ksoftirq就会调用do_softirq去处理它们。通过重复执行这 样的操作，重新触发的软中断也会被执行。如果有必要，每次迭代后都会调用schedule()以便让更重要的进程得到处理机会。当所有需要执行的操作都完 成以后，该内核线程将自己设置为TASK_INTERRUPTIBLE状态，唤起调度程序选择其他可执行进程投入运行。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;只要do_softirq()函数发现已经执行过的内核线程重新触发了它自己，软中断内核线程就会被唤醒.&lt;/p&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[内核模块编译怎样绕过insmod时的版本检查]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2014/12/22/kernel-vermagic/"/&gt;
</span><span class='line'>&lt;updated&gt;2014-12-22T22:15:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2014/12/22/kernel-vermagic&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;p&gt;&lt;a href="http://blog.sina.com.cn/s/blog_53931eca01015uky.html"&gt;http://blog.sina.com.cn/s/blog_53931eca01015uky.html&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;在開發kernel driver時，總是會遇到討人厭的vermagic檢查，只要目前在run的kernel版本跟driver編譯時用的kernel版本不一致，就沒辦法insmod。
</span><span class='line'>&lt;code&gt;
</span><span class='line'>bash-3.2# insmod sdio.ko
</span><span class='line'>sdio: version magic '2.6.28-271-gec75a15 preempt mod_unload modversions ARMv7 '
</span><span class='line'>should be '2.6.28 preempt mod_unload ARMv7 '
</span><span class='line'>insmod: init_module 'sdio.ko' failed (Exec format error)
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>這大大降低了開發速度，尤其是當你拿不到客戶在用的kernel時，又要開發driver給他用，真的是很麻煩……&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;那麼要怎麼利用噁心的方式繞過去呢???&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;一、先把 Moudle version 檢查關掉。&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;user@host # ARCH=arm make menuconfig
</span><span class='line'>--- Enable loadable module support                                             │ │
</span><span class='line'>│ │         [ ]   Forced module loading                                      │ │
</span><span class='line'>│ │         [*]   Module unloading                                           │ │
</span><span class='line'>│ │         [*]     Forced module unloading                                  │ │
</span><span class='line'>│ │         [ ]   Module versioning support                                  │ │
</span><span class='line'>│ │         [ ]   Source checksum for all modules
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;二、 使用modinfo時，可以看到目前這driver的vermagic&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    filename: external_drivers/omap3530/Linux/sdio/sdio.ko
</span><span class='line'>author: Texas Instruments Inc
</span><span class='line'>alias: TIWLAN_SDIO
</span><span class='line'>license: GPL
</span><span class='line'>description: TI WLAN SDIO driver
</span><span class='line'>depends:
</span><span class='line'>vermagic: 2.6.28-271-gec75a15 preempt mod_unload ARMv7
</span><span class='line'>parm: g_sdio_debug_level:debug level (int)
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;三、 修改 kernel 的 vermagic，再重新編譯driver&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;vermagic 的第一個值 2.6.28-noneed 是由這 include/linux/utsrelease.h裡的 UTS_RELEASE 所定義。
</span><span class='line'>&lt;code&gt;
</span><span class='line'>#define UTS_RELEASE "2.6.28-271-gec75a15"
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>之後再由 include/linux/vermagic.h 裡的 macro&lt;br/&gt;
</span><span class='line'>去組合出 VERMAGIC_STRING ， 也就是 kernel 的vermagic。</span></code></pre></td></tr></table></div></figure>
    #include &lt;generated/utsrelease.h></p>

<pre><code>#ifdef CONFIG_SMP
#define MODULE_VERMAGIC_SMP "SMP "
#else
#define MODULE_VERMAGIC_SMP ""
#endif
#ifdef CONFIG_PREEMPT
#define MODULE_VERMAGIC_PREEMPT "preempt "
#else
#define MODULE_VERMAGIC_PREEMPT ""
#endif完成編譯後，你就可以得
#ifdef CONFIG_MODULE_UNLOAD
#define MODULE_VERMAGIC_MODULE_UNLOAD "mod_unload "
#else
#define MODULE_VERMAGIC_MODULE_UNLOAD ""
#endif
#ifndef CONFIG_MODVERSIONS
#define MODULE_VERMAGIC_MODVERSIONS "modversions "
#else
#define MODULE_VERMAGIC_MODVERSIONS ""
#endif
#ifndef MODULE_ARCH_VERMAGIC
#define MODULE_ARCH_VERMAGIC ""
#endif

#define VERMAGIC_STRING \
UTS_RELEASE " " \
MODULE_VERMAGIC_SMP MODULE_VERMAGIC_PREEMPT \
MODULE_VERMAGIC_MODULE_UNLOAD MODULE_VERMAGIC_MODVERSIONS \
MODULE_ARCH_VERMAGIC
</code></pre>

<pre><code>所以， 我們只要把 UTS_RELEASE 改成我們的數字即可，當然若是懶得去try組合後的字串，也可以直接將VERMAGIC_STRING改成你要的字串

建議修改完 vermagic.h, utsrelease.h後，還是把kernel重編完再編kernel，比較保險。

以下是修改後，用modinfo看的結果
</code></pre>

<pre><code>filename: external_drivers/omap3530/Linux/sdio/sdio.ko
author: Texas Instruments Inc
alias: TIWLAN_SDIO
license: GPL
description: TI WLAN SDIO driver
depends:
vermagic: 2.6.28 preempt mod_unload ARMv7
parm: g_sdio_debug_level:debug level (int)
</code></pre>

<pre><code>
-------------
-------------

另外若你是用git 做版本控制 , 那就會出現git的版本號在kernel 編號上  
所以要把他關掉
</code></pre>

<pre><code>General setup  ---&gt;
 [ ] Automatically append version information to the version strin

解釋;
CONFIG_LOCALVERSION_AUTO:                                                   │ 
  │                                                                         │ 
  │ This will try to automatically determine if the current tree is a       │ 
  │ release tree by looking for git tags that belong to the current         │ 
  │ top of tree revision.                                                   │ 
  │                                                                         │ 
  │ A string of the format -gxxxxxxxx will be added to the localversion     │ 
  │ if a git-based tree is found.  The string generated by this will be     │ 
  │ appended after any matching localversion* files, and after the value    │ 
  │ set in CONFIG_LOCALVERSION.                                             │ 
  │                                                                         │ 
  │ (The actual string used here is the first eight characters produced     │ 
  │ by running the command:                                                 │ 
  │                                                                         │ 
  │ which is done within the script "scripts/setlocalversion".)             │ 
  │                                                                         │ 
  │ Symbol: LOCALVERSION_AUTO [=y]                                          │ 
  │ Prompt: Automatically append version information to the version string  │ 
  │   Defined at init/Kconfig:84                                            │ 
  │   Location:                                                             │ 
  │ ingT
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[收包软中断和netif_rx]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/12/16/kernel-net-softirq-rx/"/>
    <updated>2014-12-16T15:30:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/12/16/kernel-net-softirq-rx</id>
    <content type="html"><![CDATA[<h5>初始化报文接收软中断</h5>

<pre><code>static int __init net_dev_init(void)
{
    ......
    open_softirq(NET_RX_SOFTIRQ, net_rx_action);
    ......
}
</code></pre>

<h5>报文接收软中断的处理函数net_rx_action详解：</h5>

<pre><code>static void net_rx_action(struct softirq_action *h)
{
    /*取得本地cpu 的softnet_data 的poll_list  链表*/
    struct list_head *list = &amp;__get_cpu_var(softnet_data).poll_list;
    /*设置软中断处理程序一次允许的最大执行时间为2个jiffies*/
    unsigned long time_limit = jiffies + 2;
　　
    /*设置软中断接收函数一次最多处理的报文个数为 300 */
    int budget = netdev_budget;
    /*关闭本地cpu的中断，下面判断list是否为空时防止硬中断抢占*/
    local_irq_disable();
    /*循环处理pool_list 链表上的等待处理的napi*/
    while (!list_empty(list))
    {
        struct napi_struct *n;
        int work, weight;

        /*如果处理报文超出一次处理最大的个数
          或允许时间超过最大时间就停止执行，
          跳到softnet_break 处*/
        if (unlikely(budget &lt;= 0 || time_after(jiffies, time_limit)))
        {
            goto softnet_break;
        }
        /*使能本地中断，上面判断list为空已完成，下面调用NAPI
          的轮询函数是在硬中断开启的情况下执行*/
        local_irq_enable();

        /* 取得softnet_data pool_list 链表上的一个napi,
           即使现在硬中断抢占软中断，会把一个napi挂到pool_list的尾端
           软中断只会从pool_list 头部移除一个pool_list，这样不存在临界区*/
        n = list_entry(list-&gt;next, struct napi_struct, poll_list);
        /*用weighe 记录napi 一次轮询允许处理的最大报文数*/
        weight = n-&gt;weight;
        /* work 记录一个napi总共处理的报文数*/
        work = 0;
　　
        /*如果取得的napi状态是被调度的，就执行napi的轮询处理函数*/
        if (test_bit(NAPI_STATE_SCHED, &amp;n-&gt;state))
        {
            work = n-&gt;poll(n, weight);
        }
        WARN_ON_ONCE(work &gt; weight);
        /*预算减去已经处理的报文数*/
        budget -= work;
        /*禁止本地CPU 的中断，下面会有把没执行完的NAPI挂到softnet_data
          尾部的操作，和硬中断存在临界区。同时while循环时判断list是否
          为空时也要禁止硬中断抢占*/
        local_irq_disable();
　　
        /*如果napi 一次轮询处理的报文数正好等于允许处理的最大数,
          说明一次轮询没处理完全部需要处理的报文*/
        if (unlikely(work == weight))
        {
            /*如果napi已经被禁用，就把napi 从 softnet_data 的pool_list 上移除*/
            if (unlikely(napi_disable_pending(n)))
            {
                local_irq_enable();
                napi_complete(n);
                local_irq_disable();
            }
            else
            {
                /*否则，把napi 移到 pool_list 的尾端*/
                list_move_tail(&amp;n-&gt;poll_list, list);
            }
        }
    }
out:
    local_irq_enable();
    return;
　　
    /*如果处理时间超时，或处理的报文数到了最多允许处理的个数，
      说明还有napi 上有报文需要处理，调度软中断。
      否则，说明这次软中断处理完全部的napi上的需要处理的报文，不再需要
      调度软中断了*/
softnet_break:
    __get_cpu_var(netdev_rx_stat).time_squeeze++;
    __raise_softirq_irqoff(NET_RX_SOFTIRQ);
    goto out;
}
</code></pre>

<h5>虚拟NAPI backlog 的轮询函数process_backlog（）:</h5>

<p>参数：<br/>
napi : 本地cpu上softnet_data 的backlog .<br/>
quota :  一次轮询可以处理的最多报文数。</p>

<h6>函数详解：</h6>

<pre><code class="">static int process_backlog(struct napi_struct *napi, int quota)
{
    int work = 0;

    /*取得本地CPU上的softnet_data  数据*/
    struct softnet_data *queue = &amp;__get_cpu_var(softnet_data);
　　
    /*开始计时，一旦允许时间到，就退出轮询*/
    unsigned long start_time = jiffies;
    napi-&gt;weight = weight_p;
　　
    /*循环从softnet_data 的输入队列取报文并处理，直到队列中没有报文了,
     或处理的报文数大于了允许的上限值了，
     或轮询函数执行时间大于一个jiffies 了
　　*/
    do
    {
        struct sk_buff *skb;
        /*禁用本地中断，要存队列中取skb,防止抢占*/
        local_irq_disable();
　　
        /*从softnet_data 的输入队列中取得一个skb*/
        skb = __skb_dequeue(&amp;queue-&gt;input_pkt_queue);
　　
        /*如果队列中没有skb,则使能中断并退出轮询*/
        if (!skb)
        {
            /*把napi 从 softnet_data 的 pool_list 链表上摘除*/
            __napi_complete(napi);
            /*使能本地CPU的中断*/
            local_irq_enable();
            break;
        }
        /*skb 已经摘下来了，使能中断*/
        local_irq_enable();
　　
        /*把skb送到协议栈相关协议模块进行处理,详细处理见后续章节*/
        netif_receive_skb(skb);
    } while (++work &lt; quota &amp;&amp; jiffies == start_time);
    /*返回处理报文个数*/
    return work;
}
</code></pre>

<h5>linux旧的收包方式提供给驱动的接口netif_rx():</h5>

<pre><code class="">int netif_rx(struct sk_buff *skb)
{
    struct softnet_data *queue;
    unsigned long flags;
　
    /*如果接收skb的时间戳没设定，设定接收时间戳*/
    if (!skb-&gt;tstamp.tv64)
    {
        net_timestamp(skb);
    }
　　
    /*禁止本地cpu的中断*/
    local_irq_save(flags);
　　
    /*取得本地cpu的softnet_data*/
    queue = &amp;__get_cpu_var(softnet_data);

    /*每个CPU都有一个统计数据，增加统计数据*/
    __get_cpu_var(netdev_rx_stat).total++;
　　
    /*如果本地CPU的输入队列中的skb 个数小于允许的最多的个数*/
    if (queue-&gt;input_pkt_queue.qlen &lt;= netdev_max_backlog)
    {
        /*如果本地cpu的输入队列长度不为0,表示输入队列已经有skb了，
        并且特殊的napi backlog 已经挂入了softnet_data  的
        pool_list上了*/
        if (queue-&gt;input_pkt_queue.qlen)
        {
enqueue:
            /*把skb 放入CPU的输入队列 input_pkt_queue*/
            __skb_queue_tail(&amp;queue-&gt;input_pkt_queue, skb);

            /*使能中断 并 返回*/
            local_irq_restore(flags);
            return NET_RX_SUCCESS;
        }
        /*如果输入队列为空，则把 特殊的napi backlog 挂到softnet_data
        的 pool_list 上 并返回把skb放入输入队列并返回*/
        napi_schedule(&amp;queue-&gt;backlog);
        goto enqueue;
    }
    /*如果本地cpu的输入队列已经满了，则丢弃报文，
      并增加丢包计数并返回*/
    __get_cpu_var(netdev_rx_stat).dropped++;
    local_irq_restore(flags);
　　
    kfree_skb(skb);
    return NET_RX_DROP;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
