<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: kernel | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/kernel/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2014-12-24T23:53:30+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[内核模块编译怎样绕过insmod时的版本检查]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/12/22/kernel-vermagic/"/>
    <updated>2014-12-22T22:15:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/12/22/kernel-vermagic</id>
    <content type="html"><![CDATA[<p><a href="http://blog.sina.com.cn/s/blog_53931eca01015uky.html">http://blog.sina.com.cn/s/blog_53931eca01015uky.html</a></p>

<p>在開發kernel driver時，總是會遇到討人厭的vermagic檢查，只要目前在run的kernel版本跟driver編譯時用的kernel版本不一致，就沒辦法insmod。
<code>
    bash-3.2# insmod sdio.ko
    sdio: version magic '2.6.28-271-gec75a15 preempt mod_unload modversions ARMv7 '
    should be '2.6.28 preempt mod_unload ARMv7 '
    insmod: init_module 'sdio.ko' failed (Exec format error)
</code>
這大大降低了開發速度，尤其是當你拿不到客戶在用的kernel時，又要開發driver給他用，真的是很麻煩……</p>

<p>那麼要怎麼利用噁心的方式繞過去呢???</p>

<h5>一、先把 Moudle version 檢查關掉。</h5>

<pre><code>user@host # ARCH=arm make menuconfig
    --- Enable loadable module support                                             │ │
    │ │         [ ]   Forced module loading                                      │ │
    │ │         [*]   Module unloading                                           │ │
    │ │         [*]     Forced module unloading                                  │ │
    │ │         [ ]   Module versioning support                                  │ │
    │ │         [ ]   Source checksum for all modules
</code></pre>

<h5>二、 使用modinfo時，可以看到目前這driver的vermagic</h5>

<pre><code>    filename: external_drivers/omap3530/Linux/sdio/sdio.ko
    author: Texas Instruments Inc
    alias: TIWLAN_SDIO
    license: GPL
    description: TI WLAN SDIO driver
    depends:
    vermagic: 2.6.28-271-gec75a15 preempt mod_unload ARMv7
    parm: g_sdio_debug_level:debug level (int)
</code></pre>

<h5>三、 修改 kernel 的 vermagic，再重新編譯driver</h5>

<p>vermagic 的第一個值 2.6.28-noneed 是由這 include/linux/utsrelease.h裡的 UTS_RELEASE 所定義。
<code>
    #define UTS_RELEASE "2.6.28-271-gec75a15"
</code>
之後再由 include/linux/vermagic.h 裡的 macro<br/>
去組合出 VERMAGIC_STRING ， 也就是 kernel 的vermagic。
```
    #include &lt;generated/utsrelease.h></p>

<pre><code>#ifdef CONFIG_SMP
#define MODULE_VERMAGIC_SMP "SMP "
#else
#define MODULE_VERMAGIC_SMP ""
#endif
#ifdef CONFIG_PREEMPT
#define MODULE_VERMAGIC_PREEMPT "preempt "
#else
#define MODULE_VERMAGIC_PREEMPT ""
#endif完成編譯後，你就可以得
#ifdef CONFIG_MODULE_UNLOAD
#define MODULE_VERMAGIC_MODULE_UNLOAD "mod_unload "
#else
#define MODULE_VERMAGIC_MODULE_UNLOAD ""
#endif
#ifndef CONFIG_MODVERSIONS
#define MODULE_VERMAGIC_MODVERSIONS "modversions "
#else
#define MODULE_VERMAGIC_MODVERSIONS ""
#endif
#ifndef MODULE_ARCH_VERMAGIC
#define MODULE_ARCH_VERMAGIC ""
#endif

#define VERMAGIC_STRING \
UTS_RELEASE " " \
MODULE_VERMAGIC_SMP MODULE_VERMAGIC_PREEMPT \
MODULE_VERMAGIC_MODULE_UNLOAD MODULE_VERMAGIC_MODVERSIONS \
MODULE_ARCH_VERMAGIC
</code></pre>

<pre><code>所以， 我們只要把 UTS_RELEASE 改成我們的數字即可，當然若是懶得去try組合後的字串，也可以直接將VERMAGIC_STRING改成你要的字串

建議修改完 vermagic.h, utsrelease.h後，還是把kernel重編完再編kernel，比較保險。

以下是修改後，用modinfo看的結果
</code></pre>

<pre><code>filename: external_drivers/omap3530/Linux/sdio/sdio.ko
author: Texas Instruments Inc
alias: TIWLAN_SDIO
license: GPL
description: TI WLAN SDIO driver
depends:
vermagic: 2.6.28 preempt mod_unload ARMv7
parm: g_sdio_debug_level:debug level (int)
</code></pre>

<pre><code>
-------------
-------------

另外若你是用git 做版本控制 , 那就會出現git的版本號在kernel 編號上  
所以要把他關掉
</code></pre>

<pre><code>General setup  ---&gt;
 [ ] Automatically append version information to the version strin

解釋;
CONFIG_LOCALVERSION_AUTO:                                                   │ 
  │                                                                         │ 
  │ This will try to automatically determine if the current tree is a       │ 
  │ release tree by looking for git tags that belong to the current         │ 
  │ top of tree revision.                                                   │ 
  │                                                                         │ 
  │ A string of the format -gxxxxxxxx will be added to the localversion     │ 
  │ if a git-based tree is found.  The string generated by this will be     │ 
  │ appended after any matching localversion* files, and after the value    │ 
  │ set in CONFIG_LOCALVERSION.                                             │ 
  │                                                                         │ 
  │ (The actual string used here is the first eight characters produced     │ 
  │ by running the command:                                                 │ 
  │                                                                         │ 
  │ which is done within the script "scripts/setlocalversion".)             │ 
  │                                                                         │ 
  │ Symbol: LOCALVERSION_AUTO [=y]                                          │ 
  │ Prompt: Automatically append version information to the version string  │ 
  │   Defined at init/Kconfig:84                                            │ 
  │   Location:                                                             │ 
  │ ingT
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[收包软中断和netif_rx]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/12/16/kernel-net-softirq-rx/"/>
    <updated>2014-12-16T15:30:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/12/16/kernel-net-softirq-rx</id>
    <content type="html"><![CDATA[<h5>初始化报文接收软中断</h5>

<pre><code>static int __init net_dev_init(void)
{
    ......
    open_softirq(NET_RX_SOFTIRQ, net_rx_action);
    ......
}
</code></pre>

<h5>报文接收软中断的处理函数net_rx_action详解：</h5>

<pre><code>static void net_rx_action(struct softirq_action *h)
{
    /*取得本地cpu 的softnet_data 的poll_list  链表*/
    struct list_head *list = &amp;__get_cpu_var(softnet_data).poll_list;
    /*设置软中断处理程序一次允许的最大执行时间为2个jiffies*/
    unsigned long time_limit = jiffies + 2;
　　
    /*设置软中断接收函数一次最多处理的报文个数为 300 */
    int budget = netdev_budget;
    /*关闭本地cpu的中断，下面判断list是否为空时防止硬中断抢占*/
    local_irq_disable();
    /*循环处理pool_list 链表上的等待处理的napi*/
    while (!list_empty(list))
    {
        struct napi_struct *n;
        int work, weight;

        /*如果处理报文超出一次处理最大的个数
          或允许时间超过最大时间就停止执行，
          跳到softnet_break 处*/
        if (unlikely(budget &lt;= 0 || time_after(jiffies, time_limit)))
        {
            goto softnet_break;
        }
        /*使能本地中断，上面判断list为空已完成，下面调用NAPI
          的轮询函数是在硬中断开启的情况下执行*/
        local_irq_enable();

        /* 取得softnet_data pool_list 链表上的一个napi,
           即使现在硬中断抢占软中断，会把一个napi挂到pool_list的尾端
           软中断只会从pool_list 头部移除一个pool_list，这样不存在临界区*/
        n = list_entry(list-&gt;next, struct napi_struct, poll_list);
        /*用weighe 记录napi 一次轮询允许处理的最大报文数*/
        weight = n-&gt;weight;
        /* work 记录一个napi总共处理的报文数*/
        work = 0;
　　
        /*如果取得的napi状态是被调度的，就执行napi的轮询处理函数*/
        if (test_bit(NAPI_STATE_SCHED, &amp;n-&gt;state))
        {
            work = n-&gt;poll(n, weight);
        }
        WARN_ON_ONCE(work &gt; weight);
        /*预算减去已经处理的报文数*/
        budget -= work;
        /*禁止本地CPU 的中断，下面会有把没执行完的NAPI挂到softnet_data
          尾部的操作，和硬中断存在临界区。同时while循环时判断list是否
          为空时也要禁止硬中断抢占*/
        local_irq_disable();
　　
        /*如果napi 一次轮询处理的报文数正好等于允许处理的最大数,
          说明一次轮询没处理完全部需要处理的报文*/
        if (unlikely(work == weight))
        {
            /*如果napi已经被禁用，就把napi 从 softnet_data 的pool_list 上移除*/
            if (unlikely(napi_disable_pending(n)))
            {
                local_irq_enable();
                napi_complete(n);
                local_irq_disable();
            }
            else
            {
                /*否则，把napi 移到 pool_list 的尾端*/
                list_move_tail(&amp;n-&gt;poll_list, list);
            }
        }
    }
out:
    local_irq_enable();
    return;
　　
    /*如果处理时间超时，或处理的报文数到了最多允许处理的个数，
      说明还有napi 上有报文需要处理，调度软中断。
      否则，说明这次软中断处理完全部的napi上的需要处理的报文，不再需要
      调度软中断了*/
softnet_break:
    __get_cpu_var(netdev_rx_stat).time_squeeze++;
    __raise_softirq_irqoff(NET_RX_SOFTIRQ);
    goto out;
}
</code></pre>

<h5>虚拟NAPI backlog 的轮询函数process_backlog（）:</h5>

<p>参数：<br/>
napi : 本地cpu上softnet_data 的backlog .<br/>
quota :  一次轮询可以处理的最多报文数。</p>

<h6>函数详解：</h6>

<pre><code class="">static int process_backlog(struct napi_struct *napi, int quota)
{
    int work = 0;

    /*取得本地CPU上的softnet_data  数据*/
    struct softnet_data *queue = &amp;__get_cpu_var(softnet_data);
　　
    /*开始计时，一旦允许时间到，就退出轮询*/
    unsigned long start_time = jiffies;
    napi-&gt;weight = weight_p;
　　
    /*循环从softnet_data 的输入队列取报文并处理，直到队列中没有报文了,
     或处理的报文数大于了允许的上限值了，
     或轮询函数执行时间大于一个jiffies 了
　　*/
    do
    {
        struct sk_buff *skb;
        /*禁用本地中断，要存队列中取skb,防止抢占*/
        local_irq_disable();
　　
        /*从softnet_data 的输入队列中取得一个skb*/
        skb = __skb_dequeue(&amp;queue-&gt;input_pkt_queue);
　　
        /*如果队列中没有skb,则使能中断并退出轮询*/
        if (!skb)
        {
            /*把napi 从 softnet_data 的 pool_list 链表上摘除*/
            __napi_complete(napi);
            /*使能本地CPU的中断*/
            local_irq_enable();
            break;
        }
        /*skb 已经摘下来了，使能中断*/
        local_irq_enable();
　　
        /*把skb送到协议栈相关协议模块进行处理,详细处理见后续章节*/
        netif_receive_skb(skb);
    } while (++work &lt; quota &amp;&amp; jiffies == start_time);
    /*返回处理报文个数*/
    return work;
}
</code></pre>

<h5>linux旧的收包方式提供给驱动的接口netif_rx():</h5>

<pre><code class="">int netif_rx(struct sk_buff *skb)
{
    struct softnet_data *queue;
    unsigned long flags;
　
    /*如果接收skb的时间戳没设定，设定接收时间戳*/
    if (!skb-&gt;tstamp.tv64)
    {
        net_timestamp(skb);
    }
　　
    /*禁止本地cpu的中断*/
    local_irq_save(flags);
　　
    /*取得本地cpu的softnet_data*/
    queue = &amp;__get_cpu_var(softnet_data);

    /*每个CPU都有一个统计数据，增加统计数据*/
    __get_cpu_var(netdev_rx_stat).total++;
　　
    /*如果本地CPU的输入队列中的skb 个数小于允许的最多的个数*/
    if (queue-&gt;input_pkt_queue.qlen &lt;= netdev_max_backlog)
    {
        /*如果本地cpu的输入队列长度不为0,表示输入队列已经有skb了，
        并且特殊的napi backlog 已经挂入了softnet_data  的
        pool_list上了*/
        if (queue-&gt;input_pkt_queue.qlen)
        {
enqueue:
            /*把skb 放入CPU的输入队列 input_pkt_queue*/
            __skb_queue_tail(&amp;queue-&gt;input_pkt_queue, skb);

            /*使能中断 并 返回*/
            local_irq_restore(flags);
            return NET_RX_SUCCESS;
        }
        /*如果输入队列为空，则把 特殊的napi backlog 挂到softnet_data
        的 pool_list 上 并返回把skb放入输入队列并返回*/
        napi_schedule(&amp;queue-&gt;backlog);
        goto enqueue;
    }
    /*如果本地cpu的输入队列已经满了，则丢弃报文，
      并增加丢包计数并返回*/
    __get_cpu_var(netdev_rx_stat).dropped++;
    local_irq_restore(flags);
　　
    kfree_skb(skb);
    return NET_RX_DROP;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[offsetof宏 container_of宏]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/09/15/kernel-offset-container_of/"/>
    <updated>2014-09-15T15:57:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/09/15/kernel-offset-container_of</id>
    <content type="html"><![CDATA[<p>Linux内核中，用两个非常巧妙地宏实现了，一个是offsetof宏，另一个是container_of宏，下面讲解一下这两个宏。</p>

<h4>1.  offsetof宏</h4>

<h5>【定义】：</h5>

<pre><code>#define offsetof(TYPE, MEMBER) ((size_t) &amp; ((TYPE *)0)-&gt;MEMBER )
</code></pre>

<h5>【功能】： 获得一个结构体变量成员在此结构体中的偏移量。</h5>

<h5>【例子】：</h5>

<pre><code class="">    struct A 
        { 
        int x ; 
        int y; 
        int z; 
    }; 

    void main() 
    { 
        printf("the offset of z is %d",offsetof( struct A, z )  ); 
    } 
</code></pre>

<p>// 输出结果为 8</p>

<h5>【分析】：</h5>

<p>该宏，TYPE为结构体类型，MEMBER 为结构体内的变量名。<br/>
(TYPE <em>)0) 是欺骗编译器说有一个指向结构TYPE 的指针，其地址值0 <br/>
(TYPE </em>)0)->MEMBER 是要取得结构体TYPE中成员变量MEMBER的地址. 因为基址为0，所以，这时MEMBER的地址当然就是MEMBER在TYPE中的偏移了。</p>

<h4>2. container_of宏（即实现了题目中的功能）</h4>

<h5>【定义】：</h5>

<pre><code>#define container_of(ptr, type, member)   ({const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr); (type *)( (char *)__mptr - offsetof(type,member) );})
</code></pre>

<h5>【功能】：</h5>

<p>从结构体（type）某成员变量（member）指针（ptr）来求出该结构体（type）的首指针。</p>

<h5>【例子】：</h5>

<pre><code>    struct A 
    { 
        int x ; 
        int y; 
        int z; 
    }; 

    struct A myTest; 

    int *pz = &amp;myTest.z; 

    struct A* getHeaderPtr( int *pz ) 
    { 
        return container_of( pz , struct A, z ); 
    } 
</code></pre>

<h5>【分析】：</h5>

<p>（1） typeof( ( (type <em>)0)->member )为取出member成员的变量类型。<br/>
（2） 定义__mptr指针ptr为指向该成员变量的指针(即指向ptr所指向的变量处)<br/>
（3） (char </em>)__mptr - offsetof(type,member)) 用该成员变量的实际地址减去该变量在结构体中的偏移，来求出结构体起始地址。<br/>
（4） ({ })这个扩展返回程序块中最后一个表达式的值。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux内核模块签名]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/08/21/kernel-module-signed/"/>
    <updated>2014-08-21T18:23:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/08/21/kernel-module-signed</id>
    <content type="html"><![CDATA[<h4>linux内核模块签名 Documentation/module_signing.txt</h4>

<p>内核在模块模块加载时使用加密签名验证，校验签名是否与已编译的内核公钥匹配。目前只支持RSA X.509验证。<br/>
签名验证在通过CONFIG_MODULE_SIG使能。打开签名同时还会强制做模块ELF元数据检查，然后再做签名验证。</p>

<h4>公钥生成</h4>

<p>内核编译时可以指定一系列的公钥。x509.genkey文件用来生成X509密钥。如果没有该文件，系统会自动提供一个默认的配置。Makefile会根据x509.genkey规则在内核编译根目录生成默认配置，用户可以手动更改该文件。</p>

<p>由此在内核编译过程中分别生成私钥和公钥文件分别为./signing_key.priv和./signing_key.x509。</p>

<p>默认配置是使用/dev/random生成的。如果/dev/random没有足够数据，在后台运行以下命令可以生成更多的数据：rngd -r /dev/urandom。</p>

<h4>模块签名</h4>

<p>设置了CONFIG_MODULE_SIG_ALL，所有模块将会自动添加签名。如果没有设置，需要手动添加：<br/>
scripts/sign-file <hash algo> $(MODSECKEY) $(MODPUBKEY) modules.ko<br/>
哈希算法必须为sha1, sha224, sha256, sha384, sha512。对应的加密算法必须是使能的。CONFIG_MODULE_SIG_HASH设置sign-file使用的默认算法。</p>

<p><code>MODSECKEY=&lt;secret-key-ring-path&gt;</code><br/>
加密私钥文件，默认是./signing_key.priv</p>

<p><code>MODPUBKEY=&lt;public-key-ring-path&gt;</code><br/>
加密公钥文件，默认为./signing_key.x509</p>

<h6>签名模块裁减</h6>

<p>签名模块裁减就是去除签名部分，在重新签名之前需要先裁减之前的签名。在打包内核模块发布时，并没有自动裁减。</p>

<h6>加载签名模块</h6>

<p>模块是通过insmod来加载的，模块加载时通过检查模块的签名部分来验证。</p>

<h6>不合法签名和没有签名的模块</h6>

<p>如果设 置了CONFIG_MODULE_SIG_FORCE或者在内核启动命令行设置了module.sig_enforce，内核将只加载带有公钥的合法签名 模块。如果都没有设置则会加载没有签名的模块。如果内核有密钥，但模块没有提供合法的签名就会被拒绝加载。下表说明了各种情况：</p>

<pre><code>模块状态        许可模式    强制检查
未签名           通过      EKEYREJECTED
签名，没有公钥       ENOKEY      ENOKEY
签名，公钥     通过      通过
非法签名，公钥       EKEYREJECTED    EKEYREJECTED
签名，过期密钥       EKEYEXPIRED EKEYEXPIRED
破坏的签名     EBADMSG     EBADMSG
破坏的ELF        ENOEXEC     ENOEXEC
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux 即时修改 启动级别 启动参数 磁盘满无法进系统 忘记密码]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/08/14/kernel-init-edit-args/"/>
    <updated>2014-08-14T17:20:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/08/14/kernel-init-edit-args</id>
    <content type="html"><![CDATA[<h4>1、修改启动级别错误配置的方法</h4>

<p>如果你不小心把级别设成0或6，用下边的方法补救：<br/>
1. 启动系统后，在倒计时结束前按任意键，进入grub引导界面 <br/>
2. 在grub引导界面的输入‘e’，进入下一级，高亮第二行，再输入‘e’<br/>
3. 在最后输入 1[单用户模式] 按回车回到上一级（单用户模式启动不会去读取/etc/inittab）
4. 输入‘b’重启系统</p>

<p>也可以改其他启动参数
进行紧急引导最简单的方法是：<br/>
把 init=/bin/bash 或 init=/bin/sh 选项传递给内核</p>

<h5>2、磁盘满导致无法进入系统</h5>

<p>删除一些文件后重启<br/>
没法删除 说文件系统是只读的 ，重新mount 你的磁盘系统为可读写的。<br/>
<code>
mount -o remount,rw  /
</code></p>

<h5>3、忘记密码</h5>

<p>passwd user</p>
]]></content>
  </entry>
  
</feed>
