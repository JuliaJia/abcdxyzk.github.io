<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: kernel | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/kernel/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2014-11-29T16:26:34+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[offsetof宏 container_of宏]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/09/15/kernel-offset-container_of/"/>
    <updated>2014-09-15T15:57:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/09/15/kernel-offset-container_of</id>
    <content type="html"><![CDATA[<p>Linux内核中，用两个非常巧妙地宏实现了，一个是offsetof宏，另一个是container_of宏，下面讲解一下这两个宏。</p>

<h4>1.  offsetof宏</h4>

<h5>【定义】：</h5>

<pre><code>#define offsetof(TYPE, MEMBER) ((size_t) &amp; ((TYPE *)0)-&gt;MEMBER )
</code></pre>

<h5>【功能】： 获得一个结构体变量成员在此结构体中的偏移量。</h5>

<h5>【例子】：</h5>

<pre><code class="">    struct A 
        { 
        int x ; 
        int y; 
        int z; 
    }; 

    void main() 
    { 
        printf("the offset of z is %d",offsetof( struct A, z )  ); 
    } 
</code></pre>

<p>// 输出结果为 8</p>

<h5>【分析】：</h5>

<p>该宏，TYPE为结构体类型，MEMBER 为结构体内的变量名。<br/>
(TYPE <em>)0) 是欺骗编译器说有一个指向结构TYPE 的指针，其地址值0 <br/>
(TYPE </em>)0)->MEMBER 是要取得结构体TYPE中成员变量MEMBER的地址. 因为基址为0，所以，这时MEMBER的地址当然就是MEMBER在TYPE中的偏移了。</p>

<h4>2. container_of宏（即实现了题目中的功能）</h4>

<h5>【定义】：</h5>

<pre><code>#define container_of(ptr, type, member)   ({const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr); (type *)( (char *)__mptr - offsetof(type,member) );})
</code></pre>

<h5>【功能】：</h5>

<p>从结构体（type）某成员变量（member）指针（ptr）来求出该结构体（type）的首指针。</p>

<h5>【例子】：</h5>

<pre><code>    struct A 
    { 
        int x ; 
        int y; 
        int z; 
    }; 

    struct A myTest; 

    int *pz = &amp;myTest.z; 

    struct A* getHeaderPtr( int *pz ) 
    { 
        return container_of( pz , struct A, z ); 
    } 
</code></pre>

<h5>【分析】：</h5>

<p>（1） typeof( ( (type <em>)0)->member )为取出member成员的变量类型。<br/>
（2） 定义__mptr指针ptr为指向该成员变量的指针(即指向ptr所指向的变量处)<br/>
（3） (char </em>)__mptr - offsetof(type,member)) 用该成员变量的实际地址减去该变量在结构体中的偏移，来求出结构体起始地址。<br/>
（4） ({ })这个扩展返回程序块中最后一个表达式的值。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux内核模块签名]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/08/21/kernel-module-signed/"/>
    <updated>2014-08-21T18:23:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/08/21/kernel-module-signed</id>
    <content type="html"><![CDATA[<h4>linux内核模块签名 Documentation/module_signing.txt</h4>

<p>内核在模块模块加载时使用加密签名验证，校验签名是否与已编译的内核公钥匹配。目前只支持RSA X.509验证。<br/>
签名验证在通过CONFIG_MODULE_SIG使能。打开签名同时还会强制做模块ELF元数据检查，然后再做签名验证。</p>

<h4>公钥生成</h4>

<p>内核编译时可以指定一系列的公钥。x509.genkey文件用来生成X509密钥。如果没有该文件，系统会自动提供一个默认的配置。Makefile会根据x509.genkey规则在内核编译根目录生成默认配置，用户可以手动更改该文件。</p>

<p>由此在内核编译过程中分别生成私钥和公钥文件分别为./signing_key.priv和./signing_key.x509。</p>

<p>默认配置是使用/dev/random生成的。如果/dev/random没有足够数据，在后台运行以下命令可以生成更多的数据：rngd -r /dev/urandom。</p>

<h4>模块签名</h4>

<p>设置了CONFIG_MODULE_SIG_ALL，所有模块将会自动添加签名。如果没有设置，需要手动添加：<br/>
scripts/sign-file <hash algo> $(MODSECKEY) $(MODPUBKEY) modules.ko<br/>
哈希算法必须为sha1, sha224, sha256, sha384, sha512。对应的加密算法必须是使能的。CONFIG_MODULE_SIG_HASH设置sign-file使用的默认算法。</p>

<p><code>MODSECKEY=&lt;secret-key-ring-path&gt;</code><br/>
加密私钥文件，默认是./signing_key.priv</p>

<p><code>MODPUBKEY=&lt;public-key-ring-path&gt;</code><br/>
加密公钥文件，默认为./signing_key.x509</p>

<h6>签名模块裁减</h6>

<p>签名模块裁减就是去除签名部分，在重新签名之前需要先裁减之前的签名。在打包内核模块发布时，并没有自动裁减。</p>

<h6>加载签名模块</h6>

<p>模块是通过insmod来加载的，模块加载时通过检查模块的签名部分来验证。</p>

<h6>不合法签名和没有签名的模块</h6>

<p>如果设 置了CONFIG_MODULE_SIG_FORCE或者在内核启动命令行设置了module.sig_enforce，内核将只加载带有公钥的合法签名 模块。如果都没有设置则会加载没有签名的模块。如果内核有密钥，但模块没有提供合法的签名就会被拒绝加载。下表说明了各种情况：</p>

<pre><code>模块状态        许可模式    强制检查
未签名           通过      EKEYREJECTED
签名，没有公钥       ENOKEY      ENOKEY
签名，公钥     通过      通过
非法签名，公钥       EKEYREJECTED    EKEYREJECTED
签名，过期密钥       EKEYEXPIRED EKEYEXPIRED
破坏的签名     EBADMSG     EBADMSG
破坏的ELF        ENOEXEC     ENOEXEC
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux 即时修改 启动级别 启动参数 磁盘满无法进系统 忘记密码]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/08/14/kernel-init-edit-args/"/>
    <updated>2014-08-14T17:20:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/08/14/kernel-init-edit-args</id>
    <content type="html"><![CDATA[<h4>1、修改启动级别错误配置的方法</h4>

<p>如果你不小心把级别设成0或6，用下边的方法补救：<br/>
1. 启动系统后，在倒计时结束前按任意键，进入grub引导界面 <br/>
2. 在grub引导界面的输入‘e’，进入下一级，高亮第二行，再输入‘e’<br/>
3. 在最后输入 1[单用户模式] 按回车回到上一级（单用户模式启动不会去读取/etc/inittab）
4. 输入‘b’重启系统</p>

<p>也可以改其他启动参数
进行紧急引导最简单的方法是：<br/>
把 init=/bin/bash 或 init=/bin/sh 选项传递给内核</p>

<h5>2、磁盘满导致无法进入系统</h5>

<p>删除一些文件后重启<br/>
没法删除 说文件系统是只读的 ，重新mount 你的磁盘系统为可读写的。<br/>
<code>
mount -o remount,rw  /
</code></p>

<h5>3、忘记密码</h5>

<p>passwd user</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[log_buf(ring buffer)(syslog)(printk)]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/08/08/kernel-syslog/"/>
    <updated>2014-08-08T09:43:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/08/08/kernel-syslog</id>
    <content type="html"><![CDATA[<h5>printk 的输出都是保存在log_buf里的</h5>

<p>How to read it the ring buffer? Here is a beautiful illustration from IBM Developerworks
dmesg would be your first resort! How does dmesg accomplish its task? By a call to syslog()! How does syslog do its job? Through the system call interface which in turn call do_syslog(). do_syslog() does the finishing act like this</p>

<p><img src="/images/kernel/2014-08-08.gif" alt="alt" /></p>

<p>// 模仿kernel/printk.c中do_syslog，在module 中读printk输出的最后4k
```
        char <em><em>log_buf;
        int </em>log_buf_len, </em>log_start, *log_end;</p>

<pre><code>    int MASK;
    int end, len;
    unsigned i, j, limit, count;
    char c;
    int ret;


    log_buf = (char**) 0xffffffff803270e0;
    log_buf_len = (int*)0xffffffff803270d8;
    log_start = (int*) 0xffffffff804eabd0;
    log_end = (int*) 0xffffffff804eabe0;

    i = 0;
    end = *log_end;
    len = *log_buf_len;
    MASK = len - 1;

    count = L;
    if (count &gt; len) count = len;
    limit = end;

    for (i=0;i&lt;count;i++) {
            j = limit-1-i;
            c = *(*log_buf + (j&amp;MASK));
            if (c == '\0') c = '\n';
            buf[count-1-i] = c;
    }
</code></pre>

<p>// 输出</p>

<pre><code>    file = filp_open(file_path, O_RDWR|O_CREAT|O_APPEND, 0777);
    if(IS_ERR(file)) {
            printk("Open file %s failed..\n", file_path);
            return 0;
    }
    old_fs = get_fs();
    set_fs(get_ds());
    ret = file-&gt;f_op-&gt;write(file, buf, i, &amp;file-&gt;f_pos);
    file-&gt;f_op-&gt;fsync(file, file-&gt;f_dentry, 0);
    set_fs(old_fs);
    filp_close(file, NULL);
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux内核网络分层结构]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/08/01/net-struct/"/>
    <updated>2014-08-01T16:52:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/08/01/net-struct</id>
    <content type="html"><![CDATA[<p><a href="http://liucw.blog.51cto.com/6751239/1221140">http://liucw.blog.51cto.com/6751239/1221140</a></p>

<h4>内核网络结构</h4>

<p>  在Linux内核中，对网络部分按照网络协议层、网络设备层、设备驱动功能层和网络媒介层的分层体系设计。</p>

<p>  网络驱动功能层主要通过网络驱动程序实现。</p>

<p>  在Linux内核，所有的网络设备都被抽象为一个接口处理，该接口提供了所有的网络操作。</p>

<p>  net_device结构表示网络设备在内核中的情况，也就是网络设备接口。网络设备接口既包括软件虚拟的网络设备接口，如环路设备，也包括了网络硬件设备，如以太网卡。</p>

<p>  Linux内核有一个dev_base的全局指针，指向一个设备链表，包括了系统内的所有网络设备。该设备链表每个节点是一个网络设备。</p>

<p>  在net_device结构中提供了许多供系统访问和协议层调用的设备方法，包括初始化、打开关闭设备、数据包发送和接收等。</p>

<h4>与网络有关的数据结构</h4>

<p>  内核对网络数据包的处理都是基于sk_buff结构的，该结构是内核网络部分最重要的数据结构。</p>

<p>  网络协议栈中各层协议都可以通过对该结构的操作实现本层协议数据的添加或者删除。使用sk_buff结构避免了网络协议栈各层来回复制数据导致的效率低下。</p>

<p><img src="/images/kernel/20140801-1.png" alt="" /></p>

<p>  sk_buff结构可以分为两个部分，一部分是存储数据包缓存，在图中表示为PackertData，另一部分是由一组用于内核管理的指针组成。<br/>
  sk_buff管理的指针最主要的是下面4个：</p>

<blockquote><p>head指向数据缓冲(PackertData)的内核首地址；<br/>
data指向当前数据包的首地址；<br/>
tail指向当前数据包的尾地址；<br/>
end 指向数据缓冲的内核尾地址。<br/>
  数据包的大小在内核网络协议栈的处理过程中会发生改变，因此data和tail指针也会不断变化，而head和tail指针是不会发生改变的。</p></blockquote>

<p>  对于一个TCP数据包为例，sk_buff还提供了几个指针直接指向各层协议头。mac指针指向数据的mac头；nh指针指向网络协议头，一般是IP协议头；h指向传输层协议头，在本例中是TCP协议头。</p>

<p>  对各层设置指针的是方便了协议栈对数据包的处理。</p>

<h4>net_device结构</h4>

<p>  Linux内核中网络设备最重要的数据结构就是net_device结构了，它是网络驱动程序最重要的部分。<br/>
  net_device结构保存在include/linux/netdevices.h头文件，理解该结构对理解网络设备驱动有很大帮助。<br/>
  内核中所有网络设备的信息和操作都在net_device设备中，无论是注册网络设备，还是设置网络设备参数，都用到该结构。<br/>
  下面是主要数据成员。</p>

<blockquote><p>设备名称<br/>
总线参数<br/>
协议参数<br/>
链接层变量<br/>
接口标志</p></blockquote>

<h4>数据包接收流程</h4>

<p>  在Linux内核中，一个网络数据包从网卡接收到用户空间需要经过链路层、传输层和socket的处理，最终到达用户空间。<br/>
<img src="/images/kernel/20140801-2.png" alt="" /><br/>
  以DM9000网卡为例，当网卡收到数据包以后，调用中断处理函数 dm9000_interrupt()，该函数检查中断处理类型，如果是接收数据包中断，则调用 dm9000_rx()函数接收数据包到内核空间。</p>

<p>  dm9000_rx()函数收到数据包完成后，内核会继续调用 netif_rx()函数，函数的作用是把网卡接收到数据提交给协议栈处理。</p>

<p>  协议栈使用 net_rx_action()函数处理接收数据包队列，该函数处理数据包后如果是 IP数据包则提交给 ip_recv()函数处理。ip_recv()函数主要是检查一个数据包IP头的合法性，检查通过后交给 ip_local_deliver()和 ip_local_deliver_finish()函数处理，之所以分开处理是因为内核中有防火墙相关的代码需要动态加载到此处。</p>

<p>  IP头处理完毕后，以UDP数据包为例将交由 udp_recv()函数处理，与 ip_recv()函数类亿，该函数检查 UDP头的合法性，然后交给 udp_queue_recv()函数处理，最后提交给 sock_queue_recv()函数处理。</p>

<p>  数据包进入 socket部分的第一个函数是 skb_recv_datagram()，该函数从内核的 socket队列取出数据包，交给 socket部分的 udp_recvmsg()函数，该函数负责处理UDP的数据，sock_recvmsg()处理提交给 sock_read()函数。</p>

<p>  sock_read()函数读取接收到的数据缓冲，把数据返回给 sys_read()系统调用。sys_read()函数调用最终把数据复制到用户空间，供用户使得。</p>

<h4>数据包发送流程</h4>

<p>  以UDP数据包发送流程为例，在DM9000网卡上如何发送一个数据包。</p>

<p><img src="/images/kernel/20140801-3.png" alt="" /></p>

<p>  当用户空间的应用程序通过 socket函数 sento()发送一个UDP数据后，会调用内核空间的 sock_writev()函数，然后通过 sock_sendmsg()函数处理。sock_sendmsg()函数调用 inet_sendmsg()函数处理，inet_sendmsg()函数会把要发送的数据交给传输层的 udp_sendmsg()函数处理。</p>

<p>  udp_sendmsg()函数在数据前加入UDP头，然后把数据交给 ip_build_xmit()函数处理，该函数根据 socket提供的目的 IP和端口信息构造IP头，然后调用 output_maybe_reroute()函数处理。out_maybe_reroute()函数检查数据包是否需要经过路由，最后交给 ip_output()函数写入到发送队列，写入完成后由 ip_finish_output()函数处理后续工作。</p>

<p>  链路层的 dev_queue_xmit()函数处理发送队列，调用 DM9000网卡的发送数据包函数 dm9000_xmit()发送数据包，发送完毕后，调用 dm9000_xmit_done函数处理发送结果。</p>
]]></content>
  </entry>
  
</feed>
