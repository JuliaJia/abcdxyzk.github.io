<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: kernel | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/kernel/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2015-05-20T16:25:14+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ipv6初始化和处理流程分析]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/05/15/kernel-net-ipv6/"/>
    <updated>2015-05-15T15:57:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/05/15/kernel-net-ipv6</id>
    <content type="html"><![CDATA[<p><a href="/download/kernel/ipv6%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90.pdf">ipv6初始化和处理流程分析.pdf</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TCP的URG标志和内核实现]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/05/15/kernel-net-tcp_urg/"/>
    <updated>2015-05-15T13:51:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/05/15/kernel-net-tcp_urg</id>
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/phenix_lord/article/details/42012931">TCP的URG标志和内核实现之一：协议</a><br/>
<a href="http://blog.csdn.net/phenix_lord/article/details/42046125">TCP的URG标志和内核实现之二：发送的实现</a><br/>
<a href="http://blog.csdn.net/phenix_lord/article/details/42065897">TCP的URG标志和内核实现之三：接收的实现</a></p>

<hr />

<h3>TCP的URG标志和内核实现之一：协议</h3>

<p>定义urgent数据的目的：<br/>
urgent机制，是用于通知应用层需要接收urgent data，在urgent data接收完成后，通知应用层urgent data数据接收完毕。相关协议文本RFC793 RFC1122 RFC6093</p>

<h4>哪些数据是urgent data？</h4>

<h5>协议规定</h5>

<p>在TCP报头的URG位有效的时候，通过TCP报头中的urgent pointer来标识urgent data的位置，但是在urgent pointer的解析方式上各个协议文本的描述有差异：</p>

<p>解读一：RFC793  P17，描述是“The urgent pointer points to the sequence number of the octet following the urgent data.”，在P41有描述“This mechanism permits a point in the data stream to be designated as the end of urgent information. Whenever this point is in advance of the receive sequence number (RCV.NXT) at the receiving TCP, that TCP must tell the user to go into &ldquo;urgent mode&rdquo;; when the receive sequence number catches up to the urgent pointer, the TCP must tell user to go”，可以认为是：当前接收的报文中SEQ在SEG.SEQ+Urgent Pointer之前的都是,而urgent pointer是第一个非urgent data（ TCP已经接受，但是还没有提交给应用的数据是不是呢？）</p>

<p>解读二：在P56的描述是“If the urgent flag is set, then SND.UP &lt;-SND.NXT-1 and set the urgent pointer in the outgoing segments”，也就是urgent pointer是最后一个urgent data字节。而在RFC1122中消除了这一歧义：在P84中说明“the urgent pointer points to the sequence number of the LAST octet (not LAST+1) in a sequence of urgent data”</p>

<h5>linux实现</h5>

<p>虽然在RFC1122中消除了这一歧义，linux仍然使用了解读一的解析方式，如果要使用解读二定义的方式，需要使用tcp_stdurg这个配置项。</p>

<h4>urgent data数据能有多长？</h4>

<h5>协议规定</h5>

<p>按照RFC793 P41的描述，长度不受限，RFC1122 P84中，更是明确了“A TCP MUST support a sequence of urgent data of any length”</p>

<h5>linux实现</h5>

<p>其实，linux只支持1BYTE的urgent data</p>

<h4>urgent data与OOB数据</h4>

<p>OOB数据说的是带外数据，也就是这些数据不是放到TCP流供读取的，而是通过额外的接口来获取，linux默认把urgent data实现为OOB数据；而按照协议的规定，urgent data不是out of band data</p>

<p>由于OOB数据的协议和实现上存在很多不确定因素，因此现在已经不建议使用了</p>

<hr />

<h3>TCP的URG标志和内核实现之二：发送的实现</h3>

<p>Linxu内核在默认情况下，把urgent data实现为OOB数据</p>

<h4>发送URG数据的接口</h4>

<p>在内核态，使用kernel_sendmsg/kernel_sendpage完成发送，只不过需要加上MSG_OOB标志，表示要发送的URG数据。</p>

<h4>URG数据发送接口的实现</h4>

<p>分片主要在kernel_sendmsg中完成，在OOB数据的处理上，它和kernel_sendpage是一致
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
<span class='line-number'>206</span>
<span class='line-number'>207</span>
<span class='line-number'>208</span>
<span class='line-number'>209</span>
<span class='line-number'>210</span>
<span class='line-number'>211</span>
<span class='line-number'>212</span>
<span class='line-number'>213</span>
<span class='line-number'>214</span>
<span class='line-number'>215</span>
<span class='line-number'>216</span>
<span class='line-number'>217</span>
<span class='line-number'>218</span>
<span class='line-number'>219</span>
<span class='line-number'>220</span>
<span class='line-number'>221</span>
<span class='line-number'>222</span>
<span class='line-number'>223</span>
<span class='line-number'>224</span>
<span class='line-number'>225</span>
<span class='line-number'>226</span>
<span class='line-number'>227</span>
<span class='line-number'>228</span>
<span class='line-number'>229</span>
<span class='line-number'>230</span>
<span class='line-number'>231</span>
<span class='line-number'>232</span>
<span class='line-number'>233</span>
<span class='line-number'>234</span>
<span class='line-number'>235</span>
<span class='line-number'>236</span>
<span class='line-number'>237</span>
<span class='line-number'>238</span>
<span class='line-number'>239</span>
<span class='line-number'>240</span>
<span class='line-number'>241</span>
<span class='line-number'>242</span>
<span class='line-number'>243</span>
<span class='line-number'>244</span>
<span class='line-number'>245</span>
<span class='line-number'>246</span>
<span class='line-number'>247</span>
<span class='line-number'>248</span>
<span class='line-number'>249</span>
<span class='line-number'>250</span>
<span class='line-number'>251</span>
<span class='line-number'>252</span>
<span class='line-number'>253</span>
<span class='line-number'>254</span>
<span class='line-number'>255</span>
<span class='line-number'>256</span>
<span class='line-number'>257</span>
<span class='line-number'>258</span>
<span class='line-number'>259</span>
<span class='line-number'>260</span>
<span class='line-number'>261</span>
<span class='line-number'>262</span>
<span class='line-number'>263</span>
<span class='line-number'>264</span>
<span class='line-number'>265</span>
<span class='line-number'>266</span>
<span class='line-number'>267</span>
<span class='line-number'>268</span>
<span class='line-number'>269</span>
<span class='line-number'>270</span>
<span class='line-number'>271</span>
<span class='line-number'>272</span>
<span class='line-number'>273</span>
<span class='line-number'>274</span>
<span class='line-number'>275</span>
<span class='line-number'>276</span>
<span class='line-number'>277</span>
<span class='line-number'>278</span>
<span class='line-number'>279</span>
<span class='line-number'>280</span>
<span class='line-number'>281</span>
<span class='line-number'>282</span>
<span class='line-number'>283</span>
<span class='line-number'>284</span>
<span class='line-number'>285</span>
<span class='line-number'>286</span>
<span class='line-number'>287</span>
<span class='line-number'>288</span>
<span class='line-number'>289</span>
<span class='line-number'>290</span>
<span class='line-number'>291</span>
<span class='line-number'>292</span>
<span class='line-number'>293</span>
<span class='line-number'>294</span>
<span class='line-number'>295</span>
<span class='line-number'>296</span>
<span class='line-number'>297</span>
<span class='line-number'>298</span>
<span class='line-number'>299</span>
<span class='line-number'>300</span>
<span class='line-number'>301</span>
<span class='line-number'>302</span>
<span class='line-number'>303</span>
<span class='line-number'>304</span>
<span class='line-number'>305</span>
<span class='line-number'>306</span>
<span class='line-number'>307</span>
<span class='line-number'>308</span>
<span class='line-number'>309</span>
<span class='line-number'>310</span>
<span class='line-number'>311</span>
<span class='line-number'>312</span>
<span class='line-number'>313</span>
<span class='line-number'>314</span>
<span class='line-number'>315</span>
<span class='line-number'>316</span>
<span class='line-number'>317</span>
<span class='line-number'>318</span>
<span class='line-number'>319</span>
<span class='line-number'>320</span>
<span class='line-number'>321</span>
<span class='line-number'>322</span>
<span class='line-number'>323</span>
<span class='line-number'>324</span>
<span class='line-number'>325</span>
<span class='line-number'>326</span>
<span class='line-number'>327</span>
<span class='line-number'>328</span>
<span class='line-number'>329</span>
<span class='line-number'>330</span>
<span class='line-number'>331</span>
<span class='line-number'>332</span>
<span class='line-number'>333</span>
<span class='line-number'>334</span>
<span class='line-number'>335</span>
<span class='line-number'>336</span>
<span class='line-number'>337</span>
<span class='line-number'>338</span>
<span class='line-number'>339</span>
<span class='line-number'>340</span>
<span class='line-number'>341</span>
<span class='line-number'>342</span>
<span class='line-number'>343</span>
<span class='line-number'>344</span>
<span class='line-number'>345</span>
<span class='line-number'>346</span>
<span class='line-number'>347</span>
<span class='line-number'>348</span>
<span class='line-number'>349</span>
<span class='line-number'>350</span>
<span class='line-number'>351</span>
<span class='line-number'>352</span>
<span class='line-number'>353</span>
<span class='line-number'>354</span>
<span class='line-number'>355</span>
<span class='line-number'>356</span>
<span class='line-number'>357</span>
<span class='line-number'>358</span>
<span class='line-number'>359</span>
<span class='line-number'>360</span>
<span class='line-number'>361</span>
<span class='line-number'>362</span>
<span class='line-number'>363</span>
<span class='line-number'>364</span>
<span class='line-number'>365</span>
<span class='line-number'>366</span>
<span class='line-number'>367</span>
<span class='line-number'>368</span>
<span class='line-number'>369</span>
<span class='line-number'>370</span>
<span class='line-number'>371</span>
<span class='line-number'>372</span>
<span class='line-number'>373</span>
<span class='line-number'>374</span>
<span class='line-number'>375</span>
<span class='line-number'>376</span>
<span class='line-number'>377</span>
<span class='line-number'>378</span>
<span class='line-number'>379</span>
<span class='line-number'>380</span>
<span class='line-number'>381</span>
<span class='line-number'>382</span>
<span class='line-number'>383</span>
<span class='line-number'>384</span>
<span class='line-number'>385</span>
<span class='line-number'>386</span>
<span class='line-number'>387</span>
<span class='line-number'>388</span>
<span class='line-number'>389</span>
<span class='line-number'>390</span>
<span class='line-number'>391</span>
<span class='line-number'>392</span>
<span class='line-number'>393</span>
<span class='line-number'>394</span>
<span class='line-number'>395</span>
<span class='line-number'>396</span>
<span class='line-number'>397</span>
<span class='line-number'>398</span>
<span class='line-number'>399</span>
<span class='line-number'>400</span>
<span class='line-number'>401</span>
<span class='line-number'>402</span>
<span class='line-number'>403</span>
<span class='line-number'>404</span>
<span class='line-number'>405</span>
<span class='line-number'>406</span>
<span class='line-number'>407</span>
<span class='line-number'>408</span>
<span class='line-number'>409</span>
<span class='line-number'>410</span>
<span class='line-number'>411</span>
<span class='line-number'>412</span>
<span class='line-number'>413</span>
<span class='line-number'>414</span>
<span class='line-number'>415</span>
<span class='line-number'>416</span>
<span class='line-number'>417</span>
<span class='line-number'>418</span>
<span class='line-number'>419</span>
<span class='line-number'>420</span>
<span class='line-number'>421</span>
<span class='line-number'>422</span>
<span class='line-number'>423</span>
<span class='line-number'>424</span>
<span class='line-number'>425</span>
<span class='line-number'>426</span>
<span class='line-number'>427</span>
<span class='line-number'>428</span>
<span class='line-number'>429</span>
<span class='line-number'>430</span>
<span class='line-number'>431</span>
<span class='line-number'>432</span>
<span class='line-number'>433</span>
<span class='line-number'>434</span>
<span class='line-number'>435</span>
<span class='line-number'>436</span>
<span class='line-number'>437</span>
<span class='line-number'>438</span>
<span class='line-number'>439</span>
<span class='line-number'>440</span>
<span class='line-number'>441</span>
<span class='line-number'>442</span>
<span class='line-number'>443</span>
<span class='line-number'>444</span>
<span class='line-number'>445</span>
<span class='line-number'>446</span>
<span class='line-number'>447</span>
<span class='line-number'>448</span>
<span class='line-number'>449</span>
<span class='line-number'>450</span>
<span class='line-number'>451</span>
<span class='line-number'>452</span>
<span class='line-number'>453</span>
<span class='line-number'>454</span>
<span class='line-number'>455</span>
<span class='line-number'>456</span>
<span class='line-number'>457</span>
<span class='line-number'>458</span>
<span class='line-number'>459</span>
<span class='line-number'>460</span>
<span class='line-number'>461</span>
<span class='line-number'>462</span>
<span class='line-number'>463</span>
<span class='line-number'>464</span>
<span class='line-number'>465</span>
<span class='line-number'>466</span>
<span class='line-number'>467</span>
<span class='line-number'>468</span>
<span class='line-number'>469</span>
<span class='line-number'>470</span>
<span class='line-number'>471</span>
<span class='line-number'>472</span>
<span class='line-number'>473</span>
<span class='line-number'>474</span>
<span class='line-number'>475</span>
<span class='line-number'>476</span>
<span class='line-number'>477</span>
<span class='line-number'>478</span>
<span class='line-number'>479</span>
<span class='line-number'>480</span>
<span class='line-number'>481</span>
<span class='line-number'>482</span>
<span class='line-number'>483</span>
<span class='line-number'>484</span>
<span class='line-number'>485</span>
<span class='line-number'>486</span>
<span class='line-number'>487</span>
<span class='line-number'>488</span>
<span class='line-number'>489</span>
<span class='line-number'>490</span>
<span class='line-number'>491</span>
<span class='line-number'>492</span>
<span class='line-number'>493</span>
<span class='line-number'>494</span>
<span class='line-number'>495</span>
<span class='line-number'>496</span>
<span class='line-number'>497</span>
<span class='line-number'>498</span>
<span class='line-number'>499</span>
<span class='line-number'>500</span>
<span class='line-number'>501</span>
<span class='line-number'>502</span>
<span class='line-number'>503</span>
<span class='line-number'>504</span>
<span class='line-number'>505</span>
<span class='line-number'>506</span>
<span class='line-number'>507</span>
<span class='line-number'>508</span>
<span class='line-number'>509</span>
<span class='line-number'>510</span>
<span class='line-number'>511</span>
<span class='line-number'>512</span>
<span class='line-number'>513</span>
<span class='line-number'>514</span>
<span class='line-number'>515</span>
<span class='line-number'>516</span>
<span class='line-number'>517</span>
<span class='line-number'>518</span>
<span class='line-number'>519</span>
<span class='line-number'>520</span>
<span class='line-number'>521</span>
<span class='line-number'>522</span>
<span class='line-number'>523</span>
<span class='line-number'>524</span>
<span class='line-number'>525</span>
<span class='line-number'>526</span>
<span class='line-number'>527</span>
<span class='line-number'>528</span>
<span class='line-number'>529</span>
<span class='line-number'>530</span>
<span class='line-number'>531</span>
<span class='line-number'>532</span>
<span class='line-number'>533</span>
<span class='line-number'>534</span>
<span class='line-number'>535</span>
<span class='line-number'>536</span>
<span class='line-number'>537</span>
<span class='line-number'>538</span>
<span class='line-number'>539</span>
<span class='line-number'>540</span>
<span class='line-number'>541</span>
<span class='line-number'>542</span>
<span class='line-number'>543</span>
<span class='line-number'>544</span>
<span class='line-number'>545</span>
<span class='line-number'>546</span>
<span class='line-number'>547</span>
<span class='line-number'>548</span>
<span class='line-number'>549</span>
<span class='line-number'>550</span>
<span class='line-number'>551</span>
<span class='line-number'>552</span>
<span class='line-number'>553</span>
<span class='line-number'>554</span>
<span class='line-number'>555</span>
<span class='line-number'>556</span>
<span class='line-number'>557</span>
<span class='line-number'>558</span>
<span class='line-number'>559</span>
<span class='line-number'>560</span>
<span class='line-number'>561</span>
<span class='line-number'>562</span>
<span class='line-number'>563</span>
<span class='line-number'>564</span>
<span class='line-number'>565</span>
<span class='line-number'>566</span>
<span class='line-number'>567</span>
<span class='line-number'>568</span>
<span class='line-number'>569</span>
<span class='line-number'>570</span>
<span class='line-number'>571</span>
<span class='line-number'>572</span>
<span class='line-number'>573</span>
<span class='line-number'>574</span>
<span class='line-number'>575</span>
<span class='line-number'>576</span>
<span class='line-number'>577</span>
<span class='line-number'>578</span>
<span class='line-number'>579</span>
<span class='line-number'>580</span>
<span class='line-number'>581</span>
<span class='line-number'>582</span>
<span class='line-number'>583</span>
<span class='line-number'>584</span>
<span class='line-number'>585</span>
<span class='line-number'>586</span>
<span class='line-number'>587</span>
<span class='line-number'>588</span>
<span class='line-number'>589</span>
<span class='line-number'>590</span>
<span class='line-number'>591</span>
<span class='line-number'>592</span>
<span class='line-number'>593</span>
<span class='line-number'>594</span>
<span class='line-number'>595</span>
<span class='line-number'>596</span>
<span class='line-number'>597</span>
<span class='line-number'>598</span>
<span class='line-number'>599</span>
<span class='line-number'>600</span>
<span class='line-number'>601</span>
<span class='line-number'>602</span>
<span class='line-number'>603</span>
<span class='line-number'>604</span>
<span class='line-number'>605</span>
<span class='line-number'>606</span>
<span class='line-number'>607</span>
<span class='line-number'>608</span>
<span class='line-number'>609</span>
<span class='line-number'>610</span>
<span class='line-number'>611</span>
<span class='line-number'>612</span>
<span class='line-number'>613</span>
<span class='line-number'>614</span>
<span class='line-number'>615</span>
<span class='line-number'>616</span>
<span class='line-number'>617</span>
<span class='line-number'>618</span>
<span class='line-number'>619</span>
<span class='line-number'>620</span>
<span class='line-number'>621</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int tcp_sendmsg(struct kiocb &lt;em&gt;iocb, struct sock &lt;/em&gt;sk, struct msghdr &lt;em&gt;msg,&lt;br/&gt;
</span><span class='line'>        size_t size)&lt;br/&gt;
</span><span class='line'>{&lt;br/&gt;
</span><span class='line'>    。。。。。。。。。。。。。。&lt;br/&gt;
</span><span class='line'>    /&lt;/em&gt;如果flags设置了MSG_OOB该接口其实返回的mss_now关闭了TSO功能&lt;em&gt;/&lt;br/&gt;
</span><span class='line'>    mss_now = tcp_send_mss(sk, &amp;size_goal, flags);&lt;br/&gt;
</span><span class='line'>    。。。。。。。。。。。。。。&lt;br/&gt;
</span><span class='line'>    while (&ndash;iovlen &gt;= 0) {&lt;br/&gt;
</span><span class='line'>        size_t seglen = iov-&gt;iov_len;&lt;br/&gt;
</span><span class='line'>        unsigned char __user &lt;/em&gt;from = iov-&gt;iov_base;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;        iov++;  
</span><span class='line'>
</span><span class='line'>    while (seglen &gt; 0) {  
</span><span class='line'>        int copy = 0;  
</span><span class='line'>        int max = size_goal;  
</span><span class='line'>
</span><span class='line'>        skb = tcp_write_queue_tail(sk);  
</span><span class='line'>        if (tcp_send_head(sk)) {  
</span><span class='line'>            if (skb-&gt;ip_summed == CHECKSUM_NONE)  
</span><span class='line'>                max = mss_now;  
</span><span class='line'>            copy = max - skb-&gt;len;  
</span><span class='line'>        }  
</span><span class='line'>
</span><span class='line'>        if (copy &lt;= 0) {  
</span><span class='line'>new_segment:  
</span><span class='line'>            /* Allocate new segment. If the interface is SG, 
</span><span class='line'>             * allocate skb fitting to single page. 
</span><span class='line'>             */  
</span><span class='line'>            if (!sk_stream_memory_free(sk))  
</span><span class='line'>                goto wait_for_sndbuf;  
</span><span class='line'>
</span><span class='line'>            skb = sk_stream_alloc_skb(sk,  
</span><span class='line'>                          select_size(sk, sg),  
</span><span class='line'>                          sk-&gt;sk_allocation);  
</span><span class='line'>            if (!skb)  
</span><span class='line'>                goto wait_for_memory;  
</span><span class='line'>
</span><span class='line'>            /* 
</span><span class='line'>             * Check whether we can use HW checksum. 
</span><span class='line'>             */  
</span><span class='line'>            if (sk-&gt;sk_route_caps &amp; NETIF_F_ALL_CSUM)  
</span><span class='line'>                skb-&gt;ip_summed = CHECKSUM_PARTIAL;  
</span><span class='line'>
</span><span class='line'>            skb_entail(sk, skb);  
</span><span class='line'>            copy = size_goal;  
</span><span class='line'>            max = size_goal;  
</span><span class='line'>        }  
</span><span class='line'>
</span><span class='line'>        /* Try to append data to the end of skb. */  
</span><span class='line'>        if (copy &gt; seglen)  
</span><span class='line'>            copy = seglen;  
</span><span class='line'>
</span><span class='line'>        /* Where to copy to? */  
</span><span class='line'>        if (skb_availroom(skb) &gt; 0) {  
</span><span class='line'>            /* We have some space in skb head. Superb! */  
</span><span class='line'>            copy = min_t(int, copy, skb_availroom(skb));  
</span><span class='line'>            err = skb_add_data_nocache(sk, skb, from, copy);  
</span><span class='line'>            if (err)  
</span><span class='line'>                goto do_fault;  
</span><span class='line'>        } else {  
</span><span class='line'>            int merge = 0;  
</span><span class='line'>            int i = skb_shinfo(skb)-&gt;nr_frags;  
</span><span class='line'>            struct page *page = sk-&gt;sk_sndmsg_page;  
</span><span class='line'>            int off;  
</span><span class='line'>
</span><span class='line'>            if (page &amp;&amp; page_count(page) == 1)  
</span><span class='line'>                sk-&gt;sk_sndmsg_off = 0;  
</span><span class='line'>
</span><span class='line'>            off = sk-&gt;sk_sndmsg_off;  
</span><span class='line'>
</span><span class='line'>            if (skb_can_coalesce(skb, i, page, off) &amp;&amp;  
</span><span class='line'>                off != PAGE_SIZE) {  
</span><span class='line'>                /* We can extend the last page 
</span><span class='line'>                 * fragment. */  
</span><span class='line'>                merge = 1;  
</span><span class='line'>            } else if (i == MAX_SKB_FRAGS || !sg) {  
</span><span class='line'>                /* Need to add new fragment and cannot 
</span><span class='line'>                 * do this because interface is non-SG, 
</span><span class='line'>                 * or because all the page slots are 
</span><span class='line'>                 * busy. */  
</span><span class='line'>                tcp_mark_push(tp, skb);  
</span><span class='line'>                goto new_segment;  
</span><span class='line'>            } else if (page) {  
</span><span class='line'>                if (off == PAGE_SIZE) {  
</span><span class='line'>                    put_page(page);  
</span><span class='line'>                    sk-&gt;sk_sndmsg_page = page = NULL;  
</span><span class='line'>                    off = 0;  
</span><span class='line'>                }  
</span><span class='line'>            } else  
</span><span class='line'>                off = 0;  
</span><span class='line'>
</span><span class='line'>            if (copy &gt; PAGE_SIZE - off)  
</span><span class='line'>                copy = PAGE_SIZE - off;  
</span><span class='line'>            if (!sk_wmem_schedule(sk, copy))  
</span><span class='line'>                goto wait_for_memory;  
</span><span class='line'>
</span><span class='line'>            if (!page) {  
</span><span class='line'>                /* Allocate new cache page. */  
</span><span class='line'>                if (!(page = sk_stream_alloc_page(sk)))  
</span><span class='line'>                    goto wait_for_memory;  
</span><span class='line'>            }  
</span><span class='line'>
</span><span class='line'>            /* Time to copy data. We are close to 
</span><span class='line'>             * the end! */  
</span><span class='line'>            err = skb_copy_to_page_nocache(sk, from, skb,  
</span><span class='line'>                               page, off, copy);  
</span><span class='line'>            if (err) {  
</span><span class='line'>                /* If this page was new, give it to the 
</span><span class='line'>                 * socket so it does not get leaked. 
</span><span class='line'>                 */  
</span><span class='line'>                if (!sk-&gt;sk_sndmsg_page) {  
</span><span class='line'>                    sk-&gt;sk_sndmsg_page = page;  
</span><span class='line'>                    sk-&gt;sk_sndmsg_off = 0;  
</span><span class='line'>                }  
</span><span class='line'>                goto do_error;  
</span><span class='line'>            }  
</span><span class='line'>
</span><span class='line'>            /* Update the skb. */  
</span><span class='line'>            if (merge) {  
</span><span class='line'>                skb_frag_size_add(&amp;skb_shinfo(skb)-&gt;frags[i - 1], copy);  
</span><span class='line'>            } else {  
</span><span class='line'>                skb_fill_page_desc(skb, i, page, off, copy);  
</span><span class='line'>                if (sk-&gt;sk_sndmsg_page) {  
</span><span class='line'>                    get_page(page);  
</span><span class='line'>                } else if (off + copy &lt; PAGE_SIZE) {  
</span><span class='line'>                    get_page(page);  
</span><span class='line'>                    sk-&gt;sk_sndmsg_page = page;  
</span><span class='line'>                }  
</span><span class='line'>            }  
</span><span class='line'>
</span><span class='line'>            sk-&gt;sk_sndmsg_off = off + copy;  
</span><span class='line'>        }  
</span><span class='line'>
</span><span class='line'>        if (!copied)  
</span><span class='line'>            TCP_SKB_CB(skb)-&gt;tcp_flags &amp;= ~TCPHDR_PSH;  
</span><span class='line'>
</span><span class='line'>        tp-&gt;write_seq += copy;  
</span><span class='line'>        TCP_SKB_CB(skb)-&gt;end_seq += copy;  
</span><span class='line'>        skb_shinfo(skb)-&gt;gso_segs = 0;  
</span><span class='line'>
</span><span class='line'>        from += copy;  
</span><span class='line'>        copied += copy;  
</span><span class='line'>        if ((seglen -= copy) == 0 &amp;&amp; iovlen == 0)  
</span><span class='line'>            goto out;  
</span><span class='line'>        /*对于OOB数据，即使一个分片用光，如果还有 
</span><span class='line'>        send_buff和OOB数据，就继续积累分片*/  
</span><span class='line'>        if (skb-&gt;len &lt; max || (flags &amp; MSG_OOB))  
</span><span class='line'>            continue;  
</span><span class='line'>
</span><span class='line'>        if (forced_push(tp)) {  
</span><span class='line'>            tcp_mark_push(tp, skb);  
</span><span class='line'>            __tcp_push_pending_frames(sk, mss_now, TCP_NAGLE_PUSH);  
</span><span class='line'>        } else if (skb == tcp_send_head(sk))  
</span><span class='line'>            tcp_push_one(sk, mss_now);  
</span><span class='line'>        continue;  
</span><span class='line'>
</span><span class='line'>wait_for_sndbuf:  
</span><span class='line'>        set_bit(SOCK_NOSPACE, &amp;sk-&gt;sk_socket-&gt;flags);  
</span><span class='line'>wait_for_memory:  
</span><span class='line'>        if (copied)  
</span><span class='line'>            tcp_push(sk, flags &amp; ~MSG_MORE, mss_now, TCP_NAGLE_PUSH);  
</span><span class='line'>
</span><span class='line'>        if ((err = sk_stream_wait_memory(sk, &amp;timeo)) != 0)  
</span><span class='line'>            goto do_error;  
</span><span class='line'>
</span><span class='line'>        mss_now = tcp_send_mss(sk, &amp;size_goal, flags);  
</span><span class='line'>    }  
</span><span class='line'>}  
</span><span class='line'>
</span><span class='line'>out:  
</span><span class='line'>if (copied)  
</span><span class='line'>    tcp_push(sk, flags, mss_now, tp-&gt;nonagle);  
</span><span class='line'>release_sock(sk);  
</span><span class='line'>return copied;  
</span><span class='line'>
</span><span class='line'>do_fault:  
</span><span class='line'>if (!skb-&gt;len) {  
</span><span class='line'>    tcp_unlink_write_queue(skb, sk);  
</span><span class='line'>    /* It is the one place in all of TCP, except connection 
</span><span class='line'>     * reset, where we can be unlinking the send_head. 
</span><span class='line'>     */  
</span><span class='line'>    tcp_check_send_head(sk, skb);  
</span><span class='line'>    sk_wmem_free_skb(sk, skb);  
</span><span class='line'>}  
</span><span class='line'>
</span><span class='line'>do_error:  
</span><span class='line'>if (copied)  
</span><span class='line'>    goto out;  
</span><span class='line'>out_err:  
</span><span class='line'>err = sk_stream_error(sk, flags, err);  
</span><span class='line'>release_sock(sk);  
</span><span class='line'>return err;  
</span><span class='line'>}  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>tcp_sendmsg中，涉及对OOB数据的处理主要有：
</span><span class='line'>
</span><span class='line'>##### 1、在调用tcp_send_mss确定分片大小的时候：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static int tcp_send_mss(struct sock *sk,int *size_goal, int flags)
</span><span class='line'>{
</span><span class='line'>intmss_now;
</span><span class='line'>mss_now= tcp_current_mss(sk);
</span><span class='line'>
</span><span class='line'>/*如果是OOB数据，large_allowed=0，关闭TSO*/
</span><span class='line'>*size_goal= tcp_xmit_size_goal(sk, mss_now, !(flags &amp; MSG_OOB));
</span><span class='line'>returnmss_now;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;如果是OOB数据，其实是关闭了TSO功能，这样做的原因是：天知道各个网卡芯片在执行分片的时候咋个处理TCP报头中的URG标志和urgent point
</span><span class='line'>
</span><span class='line'>##### 2、在确定何时开始执行分片的发送的时候：
</span><span class='line'>
</span><span class='line'>如果是OOB数据，即使当前已经积累了一整个分片，也不会想普通的数据一样执行发送(tcp_push)，而是继续积累直到用户下发的数据全部分片或者snd_buf/内存用尽。
</span><span class='line'>
</span><span class='line'>##### 3、执行tcp_push的时候：
</span><span class='line'>
</span><span class='line'>在用户下发的数据全部分片或者snd_buf/内存用尽后，进入tcp_push执行发送操作(所有的OOB数据，都会通过这个接口来执行发送)
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static inline void tcp_push(struct sock*sk, int flags, int mss_now,
</span><span class='line'>                     int nonagle)
</span><span class='line'>{
</span><span class='line'>if(tcp_send_head(sk)) {
</span><span class='line'>    structtcp_sock *tp = tcp_sk(sk);
</span><span class='line'>    if(!(flags &amp; MSG_MORE) || forced_push(tp))
</span><span class='line'>        tcp_mark_push(tp,tcp_write_queue_tail(sk));    
</span><span class='line'>          /*tcp_mark_urg设置tp-&gt;snd_up，标识进入OOB数据发送模式，设置urgent point
</span><span class='line'>          指向urgentdata接受后的第一个字符*/
</span><span class='line'>    tcp_mark_urg(tp,flags);
</span><span class='line'>    __tcp_push_pending_frames(sk,mss_now,
</span><span class='line'>                  (flags &amp; MSG_MORE) ? TCP_NAGLE_CORK :nonagle);
</span><span class='line'>}
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>#### 发送处理
</span><span class='line'>
</span><span class='line'>使用struct tcp_sock中的snd_up来标识当前的urgent point，同时也使用该数据来判断当前是否处于urgent data发送模式，在普通数据的发送模式中tcp_sock::snd_up总是和tcp_sock::snd_una相等，只有在有urgent data发送的时候，才在tcp_push---&gt;tcp_mark_urg中设置为urgentpoint，进入到urgent data的处理模式
</span><span class='line'>
</span><span class='line'>在tcp_transmit_skb中的以下代码段负责urgent data相关的处理：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;if (unlikely(tcp_urg_mode(tp) &amp;&amp; before(tcb-&gt;seq, tp-&gt;snd_up))) {  
</span><span class='line'>if (before(tp-&gt;snd_up, tcb-&gt;seq + 0x10000)) {  
</span><span class='line'>    th-&gt;urg_ptr = htons(tp-&gt;snd_up - tcb-&gt;seq);  
</span><span class='line'>    th-&gt;urg = 1;  
</span><span class='line'>} else if (after(tcb-&gt;seq + 0xFFFF, tp-&gt;snd_nxt)) {  
</span><span class='line'>    th-&gt;urg_ptr = htons(0xFFFF);  
</span><span class='line'>    th-&gt;urg = 1;  
</span><span class='line'>}  
</span><span class='line'>}  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>只要当前待发送的skb的seq在tcp_sock记录的urgent point前面，就需要在报头中对URG标志置位，同时如果tcp_sock记录的urgent point。如果该报文的seq距离大于16为能表示的最大值，就置TCP报头中的urgent point为65535。
</span><span class='line'>
</span><span class='line'>#### 切换回普通模式：
</span><span class='line'>
</span><span class='line'>在收到对方ACK的处理流程tcp_ack---&gt;tcp_clean_rtx_queue中：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;if (likely(between(tp-&gt;snd_up, prior_snd_una, tp-&gt;snd_una)))  
</span><span class='line'>tp-&gt;snd_up = tp-&gt;snd_una;  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>#### 报文体现
</span><span class='line'>根据对发送代码的分析，可以看到：如果用户使用MSG_OOB数据发送一段比较长(若干个MSS)的数据，那么线路上的报文应该是分成了若干组，每组由若干个长度为MSS的报文构成，组内的每个报文有一样的urgent pointer，指向下一组报文的起始seq，每一组的长度最长为65535。
</span><span class='line'>
</span><span class='line'>----------
</span><span class='line'>### TCP的URG标志和内核实现之三：接收的实现
</span><span class='line'>
</span><span class='line'>大致的处理过程
</span><span class='line'>
</span><span class='line'>TCP的接收流程：在tcp_v4_do_rcv中的相关处理(网卡收到报文触发)中，会首先通过tcp_check_urg设置tcp_sock的urg_data为TCP_URG_NOTYET(urgent point指向的可能不是本报文，而是后续报文或者前面收到的乱序报文)，并保存最新的urgent data的sequence和对于的1 BYTE urgent data到tcp_sock的urg_data (如果之前的urgent data没有读取，就会被覆盖)。
</span><span class='line'>
</span><span class='line'>用户接收流程：在tcp_recvmsg流程中，如果发现当前的skb的数据中有urgent data，首先拷贝urgent data之前的数据，然后tcp_recvmsg退出，提示用户来接收OOB数据；在用户下一次调用tcp_recvmsg来接收数据的时候，会跳过urgent data，并设置urgent data数据接收完成。
</span><span class='line'>相关的数据结构和定义
</span><span class='line'>
</span><span class='line'>tcp_sock结构：
</span><span class='line'>
</span><span class='line'>1、 urg_data成员，其高8bit为urgent data的接收状态；其低8位为保存的1BYTE urgent数据。urgent data的接收状态对应的宏的含义描述：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;#defineTCP_URG_VALID    0x0100  /*urgent data已经读到了tcp_sock::urg_data*/
</span><span class='line'>
</span><span class='line'>#defineTCP_URG_NOTYET   0x0200  /*已经发现有urgent data，还没有读取到tcp_sock::urg_data*/
</span><span class='line'>
</span><span class='line'>#defineTCP_URG_READ     0x0400  /*urgent data已经被用户通过MSG_OOB读取了*/
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>2、 urg_seq成员，为当前的urgent data的sequence
</span><span class='line'>
</span><span class='line'>流程详情
</span><span class='line'>
</span><span class='line'>#### TCP的接收过程
</span><span class='line'>
</span><span class='line'>在tcp_rcv_established的slow_path中
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;slow_path:  
</span><span class='line'>if (len &lt; (th-&gt;doff &lt;&lt; 2) || tcp_checksum_complete_user(sk, skb))  
</span><span class='line'>    goto csum_error;  
</span><span class='line'>/* 
</span><span class='line'> *  Standard slow path. 
</span><span class='line'> */  
</span><span class='line'>if (!tcp_validate_incoming(sk, skb, th, 1))  
</span><span class='line'>    return 0;  
</span><span class='line'>step5:  
</span><span class='line'>if (th-&gt;ack &amp;&amp;  
</span><span class='line'>    tcp_ack(sk, skb, FLAG_SLOWPATH | FLAG_UPDATE_TS_RECENT) &lt; 0)  
</span><span class='line'>    goto discard;  
</span><span class='line'>tcp_rcv_rtt_measure_ts(sk, skb);  
</span><span class='line'>/* 处理紧急数据. */  
</span><span class='line'>tcp_urg(sk, skb, th);  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>也就是在报文的CRC验证和sequence验证完成后，就会通过tcp_urg来处理接收到的urgent data ：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static void tcp_urg(struct sock *sk, struct sk_buff *skb, const struct tcphdr *th)  
</span><span class='line'>{  
</span><span class='line'>struct tcp_sock *tp = tcp_sk(sk);  
</span><span class='line'>
</span><span class='line'>/*收到了urgent data,则检查和设置urg_data和urg_seq成员*/  
</span><span class='line'>if (th-&gt;urg)  
</span><span class='line'>    tcp_check_urg(sk, th);  
</span><span class='line'>
</span><span class='line'>/* Do we wait for any urgent data? - normally not... 
</span><span class='line'>发现了有urgent data，但是还没有保存到tp-&gt;urg_data*/  
</span><span class='line'>if (tp-&gt;urg_data == TCP_URG_NOTYET) {  
</span><span class='line'>    u32 ptr = tp-&gt;urg_seq - ntohl(th-&gt;seq) + (th-&gt;doff * 4) -  
</span><span class='line'>          th-&gt;syn;  
</span><span class='line'>
</span><span class='line'>    /* Is the urgent pointer pointing into this packet? */  
</span><span class='line'>    if (ptr &lt; skb-&gt;len) {  
</span><span class='line'>        u8 tmp;  
</span><span class='line'>        if (skb_copy_bits(skb, ptr, &amp;tmp, 1))  
</span><span class='line'>            BUG();  
</span><span class='line'>        tp-&gt;urg_data = TCP_URG_VALID | tmp;  
</span><span class='line'>        if (!sock_flag(sk, SOCK_DEAD))  
</span><span class='line'>            sk-&gt;sk_data_ready(sk, 0);  
</span><span class='line'>    }  
</span><span class='line'>}  
</span><span class='line'>}  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>检查和设置urg_data和urg_seq成员的处理函数tcp_check_urg的具体流程
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static void tcp_check_urg(struct sock *sk, const struct tcphdr *th)  
</span><span class='line'>{  
</span><span class='line'>struct tcp_sock *tp = tcp_sk(sk);  
</span><span class='line'>u32 ptr = ntohs(th-&gt;urg_ptr);  
</span><span class='line'>/*两种urgent point的解析方式: 
</span><span class='line'>一是指向urgent data之后的第一个字节 
</span><span class='line'>二是执行urgent data的结束字节(RFC1122) 
</span><span class='line'>sysctl_tcp_stdurg被设置表示当前采用的是第二种模式 
</span><span class='line'>不需要把urgent point -1来指向urgent data的结束字节*/  
</span><span class='line'>if (ptr &amp;&amp; !sysctl_tcp_stdurg)  
</span><span class='line'>    ptr--;  
</span><span class='line'>ptr += ntohl(th-&gt;seq);  
</span><span class='line'>
</span><span class='line'>/* Ignore urgent data that we've already seen and read.  
</span><span class='line'>如果copied_seq已经大于urgent point，那么对于从tcp_rcv_established 
</span><span class='line'>来执行的，前面的tcp_validate_incoming已经拒绝了这种报文( 
</span><span class='line'>接收窗口外)，这里要处理的是哪种情形?*/  
</span><span class='line'>if (after(tp-&gt;copied_seq, ptr))  
</span><span class='line'>    return;  
</span><span class='line'>
</span><span class='line'>/* Do not replay urg ptr. 
</span><span class='line'> * 
</span><span class='line'> * NOTE: interesting situation not covered by specs. 
</span><span class='line'> * Misbehaving sender may send urg ptr, pointing to segment, 
</span><span class='line'> * which we already have in ofo queue. We are not able to fetch 
</span><span class='line'> * such data and will stay in TCP_URG_NOTYET until will be eaten 
</span><span class='line'> * by recvmsg(). Seems, we are not obliged to handle such wicked 
</span><span class='line'> * situations. But it is worth to think about possibility of some 
</span><span class='line'> * DoSes using some hypothetical application level deadlock. 
</span><span class='line'> */  
</span><span class='line'>/*  这种情况什么时候发生?没搞明白*/  
</span><span class='line'>if (before(ptr, tp-&gt;rcv_nxt))  
</span><span class='line'>    return;  
</span><span class='line'>
</span><span class='line'>/* Do we already have a newer (or duplicate) urgent pointer?  
</span><span class='line'>如果当前已经进入urg数据读取模式，且urgent point不大于当前 
</span><span class='line'>保存的值，那么之前已经开始了读取tp-&gt;urg_seq对应的 
</span><span class='line'>urgent 数据，无需重复处理了*/  
</span><span class='line'>if (tp-&gt;urg_data &amp;&amp; !after(ptr, tp-&gt;urg_seq))  
</span><span class='line'>    return;  
</span><span class='line'>
</span><span class='line'>/* Tell the world about our new urgent pointer.*/  
</span><span class='line'>sk_send_sigurg(sk);  
</span><span class='line'>
</span><span class='line'>/* We may be adding urgent data when the last byte read was 
</span><span class='line'> * urgent. To do this requires some care. We cannot just ignore 
</span><span class='line'> * tp-&gt;copied_seq since we would read the last urgent byte again 
</span><span class='line'> * as data, nor can we alter copied_seq until this data arrives 
</span><span class='line'> * or we break the semantics of SIOCATMARK (and thus sockatmark()) 
</span><span class='line'> * 
</span><span class='line'> * NOTE. Double Dutch. Rendering to plain English: author of comment 
</span><span class='line'> * above did something sort of  send("A", MSG_OOB); send("B", MSG_OOB); 
</span><span class='line'> * and expect that both A and B disappear from stream. This is _wrong_. 
</span><span class='line'> * Though this happens in BSD with high probability, this is occasional. 
</span><span class='line'> * Any application relying on this is buggy. Note also, that fix "works" 
</span><span class='line'> * only in this artificial test. Insert some normal data between A and B and we will 
</span><span class='line'> * decline of BSD again. Verdict: it is better to remove to trap 
</span><span class='line'> * buggy users. 
</span><span class='line'> */  
</span><span class='line'> /*用户下一次要读取的数据就是用户还没有读取的urgent数据 
</span><span class='line'>且当前存在新的用户未读取数据*/  
</span><span class='line'>if (tp-&gt;urg_seq == tp-&gt;copied_seq &amp;&amp; tp-&gt;urg_data &amp;&amp;  
</span><span class='line'>    !sock_flag(sk, SOCK_URGINLINE) &amp;&amp; tp-&gt;copied_seq != tp-&gt;rcv_nxt) {  
</span><span class='line'>    struct sk_buff *skb = skb_peek(&amp;sk-&gt;sk_receive_queue);  
</span><span class='line'>    tp-&gt;copied_seq++;  
</span><span class='line'>    if (skb &amp;&amp; !before(tp-&gt;copied_seq, TCP_SKB_CB(skb)-&gt;end_seq)) {  
</span><span class='line'>        __skb_unlink(skb, &amp;sk-&gt;sk_receive_queue);  
</span><span class='line'>        __kfree_skb(skb);  
</span><span class='line'>    }  
</span><span class='line'>}  
</span><span class='line'>
</span><span class='line'>tp-&gt;urg_data = TCP_URG_NOTYET;  
</span><span class='line'>tp-&gt;urg_seq = ptr;  
</span><span class='line'>
</span><span class='line'>/* Disable header prediction. */  
</span><span class='line'>tp-&gt;pred_flags = 0;  
</span><span class='line'>}  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>#### 用户接收数据接口
</span><span class='line'>##### 用户接收URG数据的接口
</span><span class='line'>在用户接收数据的tcp_recvmsg函数中，如果用户通过MSG_OOB来接收数据，会进入tcp_recv_urg处理
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static int tcp_recv_urg(struct sock *sk, struct msghdr *msg, int len, int flags)  
</span><span class='line'>{  
</span><span class='line'>struct tcp_sock *tp = tcp_sk(sk);  
</span><span class='line'>
</span><span class='line'>/* No URG data to read.  
</span><span class='line'>用户已经读取过了*/  
</span><span class='line'>if (sock_flag(sk, SOCK_URGINLINE) || !tp-&gt;urg_data ||  
</span><span class='line'>    tp-&gt;urg_data == TCP_URG_READ)  
</span><span class='line'>    return -EINVAL; /* Yes this is right ! */  
</span><span class='line'>
</span><span class='line'>if (sk-&gt;sk_state == TCP_CLOSE &amp;&amp; !sock_flag(sk, SOCK_DONE))  
</span><span class='line'>    return -ENOTCONN;  
</span><span class='line'>/*当前的tp-&gt;urg_data为合法的数据，可以读取*/  
</span><span class='line'>if (tp-&gt;urg_data &amp; TCP_URG_VALID) {  
</span><span class='line'>    int err = 0;  
</span><span class='line'>    char c = tp-&gt;urg_data;  
</span><span class='line'>    /*标识urgent data已读*/  
</span><span class='line'>    if (!(flags &amp; MSG_PEEK))  
</span><span class='line'>        tp-&gt;urg_data = TCP_URG_READ;  
</span><span class='line'>
</span><span class='line'>    /* Read urgent data. */  
</span><span class='line'>    msg-&gt;msg_flags |= MSG_OOB;  
</span><span class='line'>
</span><span class='line'>    if (len &gt; 0) {  
</span><span class='line'>        if (!(flags &amp; MSG_TRUNC))  
</span><span class='line'>            err = memcpy_toiovec(msg-&gt;msg_iov, &amp;c, 1);  
</span><span class='line'>        len = 1;  
</span><span class='line'>    } else  
</span><span class='line'>        msg-&gt;msg_flags |= MSG_TRUNC;  
</span><span class='line'>
</span><span class='line'>    return err ? -EFAULT : len;  
</span><span class='line'>}  
</span><span class='line'>
</span><span class='line'>if (sk-&gt;sk_state == TCP_CLOSE || (sk-&gt;sk_shutdown &amp; RCV_SHUTDOWN))  
</span><span class='line'>    return 0;  
</span><span class='line'>
</span><span class='line'>/* Fixed the recv(..., MSG_OOB) behaviour.  BSD docs and 
</span><span class='line'> * the available implementations agree in this case: 
</span><span class='line'> * this call should never block, independent of the 
</span><span class='line'> * blocking state of the socket. 
</span><span class='line'> * Mike &lt;pall@rz.uni-karlsruhe.de&gt; 
</span><span class='line'> */  
</span><span class='line'>return -EAGAIN;  
</span><span class='line'>}  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>##### 用户接收普通数据的接口中的相关处理
</span><span class='line'>
</span><span class='line'>在用户接收数据的tcp_recvmsg函数中，在查找到待拷贝的skb后，首先拷贝urgent data数据前的数据，然后退出接收过程，在用户下一次执行tcp_recvmsg的时候跳过urgent data，设置urgent data读取结束
</span><span class='line'>
</span><span class='line'>查找到准备拷贝的skb后的处理：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;found_ok_skb:  
</span><span class='line'>/* Ok so how much can we use? */  
</span><span class='line'>used = skb-&gt;len - offset;  
</span><span class='line'>if (len &lt; used)  
</span><span class='line'>used = len;  
</span><span class='line'>
</span><span class='line'>/* 当前有urg_data数据*/  
</span><span class='line'>if (tp-&gt;urg_data) {  
</span><span class='line'>u32 urg_offset = tp-&gt;urg_seq - *seq;  
</span><span class='line'>/*urgent data在当前待拷贝的数据范围内*/  
</span><span class='line'>if (urg_offset &lt; used) {  
</span><span class='line'>    if (!urg_offset) {/*待拷贝的数据就是urgent data，跨过该urgent data， 
</span><span class='line'>    只给用户读取后面的数据*/  
</span><span class='line'>        if (!sock_flag(sk, SOCK_URGINLINE)) {  
</span><span class='line'>            ++*seq;  
</span><span class='line'>            urg_hole++;  
</span><span class='line'>            offset++;  
</span><span class='line'>            used--;  
</span><span class='line'>            if (!used)  
</span><span class='line'>                goto skip_copy;  
</span><span class='line'>        }  
</span><span class='line'>    }   
</span><span class='line'>    } else/*指定只拷贝urgent data数据之前的，完成后在下一次循环 
</span><span class='line'>    开始的位置，会退出循环，返回用户；下一次用户调用tcp_recvmsg 
</span><span class='line'>    就进入到上面的分支了*/  
</span><span class='line'>        used = urg_offset;  
</span><span class='line'>}  
</span><span class='line'>}   
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;skip_copy:  
</span><span class='line'>    /*用户读取的数据跨过了urgent point，设置读取结束 
</span><span class='line'>    开启fast path*/  
</span><span class='line'>    if (tp-&gt;urg_data &amp;&amp; after(tp-&gt;copied_seq, tp-&gt;urg_seq)) {  
</span><span class='line'>        tp-&gt;urg_data = 0;  
</span><span class='line'>        tcp_fast_path_check(sk);  
</span><span class='line'>    }  
</span><span class='line'>    if (used + offset &lt; skb-&gt;len)  
</span><span class='line'>        continue;  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>在接收完urgent data数据前的所有数据之后， tcp_recvmsg的以下代码片段得到执行，这段代码退出当前接收过程，提示用户有urgent data数据到来，需要用MSG_OOB来接收
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;if (tp-&gt;urg_data &amp;&amp; tp-&gt;urg_seq == *seq) {  
</span><span class='line'>if (copied)  
</span><span class='line'>    break;  
</span><span class='line'>if (signal_pending(current)) {  
</span><span class='line'>    copied = timeo ? sock_intr_errno(timeo) : -EAGAIN;  
</span><span class='line'>    break;  
</span><span class='line'>}  
</span><span class='line'>}  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h3&gt;后记&lt;/h3&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;TCP的urg数据，由于定义和实现上的混乱，当前已经不建议使用，但是为了兼容之前已经已经存在的实现，该机制会长期在内核中存在，如果不了解该机制及其内核行为，有可能就很难解释一些奇怪的问题：比如某段代码不小心地造成send接口事实上设置了MSG_OOB，就会造成接收端少了一个BYTE。&lt;/p&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[tcp三个接收队列]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2015/05/11/kernel-net-tcp_queue/"/&gt;
</span><span class='line'>&lt;updated&gt;2015-05-11T15:46:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2015/05/11/kernel-net-tcp_queue&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;p&gt;&lt;a href="http://www.cnblogs.com/alreadyskb/p/4386565.html"&gt;http://www.cnblogs.com/alreadyskb/p/4386565.html&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;三个接收队列&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;ul&gt;
</span><span class='line'>&lt;li&gt;tcp协议栈数据接收实现了三个接收缓存分别是prequeue、sk_write_queue、sk_backlog。&lt;/li&gt;
</span><span class='line'>&lt;/ul&gt;
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>&lt;p&gt;之所以需要三个接收缓存的原因如下：&lt;br/&gt;
</span><span class='line'>tcp协议栈接收到数据包时struct sock *sk 可能被进程下上文或者中断上下文占用：&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  1、如果处于进程上下文sk_lock.owned=1，软中断因为sk_lock.owned=1，所以数据只能暂存在后备队列中（backlog），当进程上下文逻辑处理完成后会回调tcp_v4_do_rcv处理backlog队列作为补偿，具体看tcp_sendmsg 函数 release_sock的实现。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  2、如果当前处于中断上下文，sk_lock.owned=0，那么数据可能被放置到receive_queue或者prequeue，数据优先放置到prequeue中，如果prequeue满了则会放置到receive_queue中，理论上这里有一个队列就行了，但是TCP协议栈为什么要设计两个呢？其实是为了快点结束软中断数据处理流程，软中断处理函数中禁止了进程抢占和其他软中断发生，效率应该是很低下的，如果数据被放置到prequeue中，那么软中断流程很快就结束了，如果放置到receive_queue那么会有很复杂的逻辑需要处理。receive_queue队列的处理在软中断中，prequeue队列的处理则是在进程上下文中。总的来说就是为了提高TCP协议栈的效率。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;后备队列的处理逻辑&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;1、什么时候使用后备队列&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;tcp协议栈对struct sock &lt;em&gt;sk有两把锁，第一把是sk_lock.slock，第二把则是sk_lock.owned。sk_lock.slock用于获取struct sock &lt;/em&gt;sk对象的成员的修改权限；sk_lock.owned用于区分当前是进程上下文或是软中断上下文，为进程上下文时sk_lock.owned会被置1，中断上下文为0。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;如果是要对sk修改，首先是必须拿锁sk_lock.slock，其后是判断当前是软中断或是进程上下文，如果是进程上下文，那么接收到的skb则只能先放置到后备队列中sk_backlog中。如果是软中断上下文则可以放置到prequeue和sk_write_queue中。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;代码片段如下：
</span><span class='line'>&lt;code&gt;
</span><span class='line'>    bh_lock_sock_nested(sk);               // 获取第一把锁。
</span><span class='line'>    ret = 0;
</span><span class='line'>    if (!sock_owned_by_user(sk)) {         // 判断第二把锁，区分是处于进程上下文还是软中断上下文。
</span><span class='line'>#ifdef CONFIG_NET_DMA
</span><span class='line'>        struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>        if (!tp-&gt;ucopy.dma_chan &amp;&amp; tp-&gt;ucopy.pinned_list)
</span><span class='line'>            tp-&gt;ucopy.dma_chan = dma_find_channel(DMA_MEMCPY);
</span><span class='line'>        if (tp-&gt;ucopy.dma_chan)
</span><span class='line'>            ret = tcp_v4_do_rcv(sk, skb);
</span><span class='line'>        else
</span><span class='line'>#endif
</span><span class='line'>        {
</span><span class='line'>            if (!tcp_prequeue(sk, skb))    // 如果处于中断上下文，则优先放置到prequeue中，如果prequeue满则放置到sk_write_queue中。
</span><span class='line'>                ret = tcp_v4_do_rcv(sk, skb);
</span><span class='line'>        }
</span><span class='line'>    } else if (unlikely(sk_add_backlog(sk, skb,  // 如果是处于进程上下文则直接放置到后备队列中(sk_backlog中)。
</span><span class='line'>                        sk-&gt;sk_rcvbuf + sk-&gt;sk_sndbuf))) {
</span><span class='line'>        bh_unlock_sock(sk);
</span><span class='line'>        NET_INC_STATS_BH(net, LINUX_MIB_TCPBACKLOGDROP);
</span><span class='line'>        goto discard_and_relse;
</span><span class='line'>    }
</span><span class='line'>    bh_unlock_sock(sk);
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;2、skb怎么add到sk_backlog中&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;sk_add_backlog函数用于add sbk到sk_backlog中，所以下面我们分析次函数。</span></code></pre></td></tr></table></div></figure>
    /<em> The per-socket spinlock must be held here. </em>/
    static inline __must_check int sk_add_backlog(struct sock <em>sk, struct sk_buff </em>skb,
                               unsigned int limit)
    {
        if (sk_rcvqueues_full(sk, skb, limit))  // 判断接收缓存是否已经用完了，很明显sk_backlog的缓存大小也算在了总接收缓存中。
            return -ENOBUFS;</p>

<pre><code>    __sk_add_backlog(sk, skb);              // 将skb添加到sk_backlog队列中。
    sk_extended(sk)-&gt;sk_backlog.len += skb-&gt;truesize;  // 更新sk_backlog中已经挂载的数据量。
    return 0;
}
</code></pre>

<pre><code></code></pre>

<pre><code>/* OOB backlog add */
static inline void __sk_add_backlog(struct sock *sk, struct sk_buff *skb)
{
    if (!sk-&gt;sk_backlog.tail) {   // 如果当前sk_backlog为NULL，此时head和tail都指向skb。
        sk-&gt;sk_backlog.head = sk-&gt;sk_backlog.tail = skb;
    } else {                      // 分支表示sk_backlog中已经有数据了，那么skb直接挂在tail的尾部，之后tail指针后移到skb。
        sk-&gt;sk_backlog.tail-&gt;next = skb;
        sk-&gt;sk_backlog.tail = skb;
    }
    skb-&gt;next = NULL;             // 这种很重要，在sk_backlog处理时会用来判断skb是否处理完毕。
}
</code></pre>

<pre><code>
##### 3、sk_backlog中skb的处理

很明显sk_backlog的处理必然中进程上下文进行，对于数据接收，进程上下文的接口是tcp_recvmmsg，所以sk_backlog肯定要在tcp_recvmmsg中处理。

tcp_recvmmsg sk_backlog的代码处理片段如下：
</code></pre>

<pre><code>tcp_cleanup_rbuf(sk, copied);
TCP_CHECK_TIMER(sk);
release_sock(sk);
</code></pre>

<pre><code>
release_sock(sk)涉及到sk_backlog处理。
</code></pre>

<pre><code>void release_sock(struct sock *sk)
{
    /*
    * The sk_lock has mutex_unlock() semantics:
    */
    mutex_release(&amp;sk-&gt;sk_lock.dep_map, 1, _RET_IP_);

    spin_lock_bh(&amp;sk-&gt;sk_lock.slock);   // 获取第一把锁。
    if (sk-&gt;sk_backlog.tail)            // 如果后备队列不为NULL，则开始处理。
        __release_sock(sk);

    if (proto_has_rhel_ext(sk-&gt;sk_prot, RHEL_PROTO_HAS_RELEASE_CB) &amp;&amp;
            sk-&gt;sk_prot-&gt;release_cb)
        sk-&gt;sk_prot-&gt;release_cb(sk);

    sk-&gt;sk_lock.owned = 0;              // 进成上下文skb处理完了，释放第二把锁。
    if (waitqueue_active(&amp;sk-&gt;sk_lock.wq))
        wake_up(&amp;sk-&gt;sk_lock.wq);
    spin_unlock_bh(&amp;sk-&gt;sk_lock.slock); // 释放第一把锁。
}
</code></pre>

<pre><code>
`__release_sock(sk)`是后备队列的真正处理函数。
</code></pre>

<pre><code>static void __release_sock(struct sock *sk)
{
    struct sk_buff *skb = sk-&gt;sk_backlog.head;

    do {
        sk-&gt;sk_backlog.head = sk-&gt;sk_backlog.tail = NULL;
        bh_unlock_sock(sk);

        do {
            struct sk_buff *next = skb-&gt;next;

            skb-&gt;next = NULL;
            sk_backlog_rcv(sk, skb);    // skb的处理函数，其实调用的是tcp_v4_do_rcv函数。

            /*
             * We are in process context here with softirqs
             * disabled, use cond_resched_softirq() to preempt.
             * This is safe to do because we've taken the backlog
             * queue private:
             */
            cond_resched_softirq();

            skb = next;
        } while (skb != NULL);          // 如果skb=NULL，那么说明之前的sk_backlog已经处理完了。

        bh_lock_sock(sk);
    } while ((skb = sk-&gt;sk_backlog.head) != NULL); // 在处理上一个sk_backlog时，可能被软中断中断了，建立了新的sk_backlog，新建立的sk_backlog也将一并被处理。

    /*
    * Doing the zeroing here guarantee we can not loop forever
    * while a wild producer attempts to flood us.
    */
    sk_extended(sk)-&gt;sk_backlog.len = 0;
}
</code></pre>

<p><code>``
  一开始重置sk-&gt;sk_backlog.head ，sk-&gt;sk_backlog.tail为NULL。sk_backlog是一个双链表，head指向了链表头部的skb，而tail则指向了链表尾部的skb。这里之所以置NULL head 和tail，是因为struct sk_buff *skb = sk-&gt;sk_backlog.head 提前取到了head指向的skb，之后就可以通过skb-&gt;next来获取下一个skb处理，结束的条件是skb-&gt;next=NULL，这个是在</code>__sk_add_backlog`函数中置位的，也就说对于sk_backlog的处理head和tail指针已经没有用了。</p>

<p>  为什么要置NULLsk->sk_backlog.head ，sk->sk_backlog.tail呢？第一想法是它可能要被重新使用了。那么在什么情况下会被重新使用呢？试想一下当前是在进程上下文，并且sk->sk_lock.slock没有被锁住，那是不是可能被软中断打断呢？如果被软中断打断了是不是要接收数据呢，tcp协议栈为了效率考虑肯定是要接收数据的，前面分析道这种情况的数据必须放置到后备队列中(sk_backlog)，所以可以肯定置NULL sk->sk_backlog.head ，sk->sk_backlog.tail是为了在处理上一个sk_backlog时，能重用sk_backlog，建立一条新的sk_backlog，或许有人会问为什么不直接添加到原先的sk_backlog tail末尾呢？这个问题我也没有想太清楚，或许是同步不好做吧。</p>

<h5>4、skb被处理到哪去了</h5>

<p>  很明显接收的数据最终都将被传递到应用层，在传递到应用层前必须要保证三个接收队列中的数据有序，那么这三个队列是怎么保证数据字节流有序的被递交给应用层呢？三个队列都会调用tcp_v4_do_rcv函数，prequeue和sk_backlog是在tcp_recvmsg中调用tcp_v4_do_rcv函数，也就是进程上下文中调用tcp_v4_do_rcv函数，但会local_bh_disable禁止软中断。如果在tcp_rcv_established, tcp_data_queue中如果刚好数据可以直接copy到用户空间，又会短暂开始软中断local_bh_enable。</p>

<p>  但在tcp_checksum_complete_user、tcp_rcv_established、tcp_data_queue函数中开启软中断将来容易出问题，进入软中断:softirq()+=1; local_bh_enable:softirq()-=2; 所以现在只是软中断中softirq()统计不准，进程中还是准的。但如果以后在软中断中在local_bh_enable之前给softirq()+=1了，那么就会导致软中断被打断，导致软中断执行途中被切走而且永远切不回来。tcp_checksum_complete_user被切走导致收包不成功，tcp_rcv_established、tcp_data_queue函数中如果在tp->copied_seq+=chunk后被切走就会导致tp->copied_seq>tp->rcv_nxt，那么下次收包后就有可能出现tp->copied_seq > sk_write_queue.first.end_seq, 等异常。</p>

<p>  如果仔细分析tcp_v4_do_rcv函数能发现，这个函数能保证数据有序的排列在一起，所以无论是在处理sk_backlog还是prequeue，最终都会调用tcp_v4_do_rcv函数将数据有效地插入到sk_write_queue中，最后被应用层取走。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[中断子系统之（八）：softirq]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/05/07/kernel-irq-softirq/"/>
    <updated>2015-05-07T16:04:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/05/07/kernel-irq-softirq</id>
    <content type="html"><![CDATA[<p><a href="http://www.wowotech.net/linux_kenrel/soft-irq.html">http://www.wowotech.net/linux_kenrel/soft-irq.html</a></p>

<h3>一、前言</h3>

<p>对于中断处理而言，linux将其分成了两个部分，一个叫做中断handler（top half），是全程关闭中断的，另外一部分是deferable task（bottom half），属于不那么紧急需要处理的事情。在执行bottom half的时候，是开中断的。有多种bottom half的机制，例如：softirq、tasklet、workqueue或是直接创建一个kernel thread来执行bottom half（这在旧的kernel驱动中常见，现在，一个理智的driver厂商是不会这么做的）。本文主要讨论softirq机制。由于tasklet是基于softirq的，因此本文也会提及tasklet，但主要是从需求层面考虑，不会涉及其具体的代码实现。</p>

<p>在普通的驱动中一般是不会用到softirq，但是由于驱动经常使用的tasklet是基于softirq的，因此，了解softirq机制有助于撰写更优雅的driver。softirq不能动态分配，都是静态定义的。内核已经定义了若干种softirq number，例如网络数据的收发、block设备的数据访问（数据量大，通信带宽高），timer的deferable task（时间方面要求高）。本文的第二章讨论了softirq和tasklet这两种机制有何不同，分别适用于什么样的场景。第三章描述了一些context的概念，这是要理解后续内容的基础。第四章是进入softirq的实现，对比hard irq来解析soft irq的注册、触发，调度的过程。</p>

<ul>
<li>注：本文中的linux kernel的版本是3.14</li>
</ul>


<h3>二、为何有softirq和tasklet</h3>

<h4>1、为何有top half和bottom half</h4>

<p>中断处理模块是任何OS中最重要的一个模块，对系统的性能会有直接的影响。想像一下：如果在通过U盘进行大量数据拷贝的时候，你按下一个key，需要半秒的时间才显示出来，这个场景是否让你崩溃？因此，对于那些复杂的、需要大量数据处理的硬件中断，我们不能让handler中处理完一切再恢复现场（handler是全程关闭中断的），而是仅仅在handler中处理一部分，具体包括：<br/>
（1）有实时性要求的<br/>
（2）和硬件相关的。例如ack中断，read HW FIFO to ram等<br/>
（3）如果是共享中断，那么获取硬件中断状态以便判断是否是本中断发生</p>

<p>除此之外，其他的内容都是放到bottom half中处理。在把中断处理过程划分成top half和bottom half之后，关中断的top half被瘦身，可以非常快速的执行完毕，大大减少了系统关中断的时间，提高了系统的性能。</p>

<p>我们可以基于下面的系统进一步的进行讨论：</p>

<p><img src="/images/kernel/2015-05-07-11.gif" alt="" /></p>

<p>当网卡控制器的FIFO收到的来自以太网的数据的时候（例如半满的时候，可以软件设定），可以将该事件通过irq signal送达Interrupt Controller。Interrupt Controller可以把中断分发给系统中的Processor A or B。</p>

<p>NIC的中断处理过程大概包括：
<code>
    mask and ack interrupt controller---&gt;ack NIC---&gt;copy FIFO to ram---&gt;handle Data in the ram---&gt;unmask interrupt controller
</code>
我们先假设Processor A处理了这个网卡中断事件，于是NIC的中断handler在Processor A上欢快的执行，这时候，Processor A的本地中断是disable的。NIC的中断handler在执行的过程中，网络数据仍然源源不断的到来，但是，如果NIC的中断handler不操作NIC的寄存器来ack这个中断的话，NIC是不会触发下一次中断的。还好，我们的NIC interrupt handler总是在最开始就会ack，因此，这不会导致性能问题。ack之后，NIC已经具体再次trigger中断的能力。当Processor A上的handler 在处理接收来自网络的数据的时候，NIC的FIFO很可能又收到新的数据，并trigger了中断，这时候，Interrupt controller还没有umask，因此，即便还有Processor B（也就是说有处理器资源），中断控制器也无法把这个中断送达处理器系统。因此，只能眼睁睁的看着NIC FIFO填满数据，数据溢出，或者向对端发出拥塞信号，无论如何，整体的系统性能是受到严重的影响。</p>

<p>注意：对于新的interrupt controller，可能没有mask和umask操作，但是原理是一样的，只不过NIC的handler执行完毕要发生EOI而已。</p>

<p>要解决上面的问题，最重要的是尽快的执行完中断handler，打开中断，unmask IRQ（或者发送EOI），方法就是把耗时的handle Data in the ram这个步骤踢出handler，让其在bottom half中执行。</p>

<h4>2、为何有softirq和tasklet</h4>

<p>OK，linux kernel已经把中断处理分成了top half和bottom half，看起来已经不错了，那为何还要提供softirq、tasklet和workqueue这些bottom half机制，linux kernel本来就够复杂了，bottom half还来添乱。实际上，在早期的linux kernel还真是只有一个bottom half机制，简称BH，简单好用，但是性能不佳。后来，linux kernel的开发者开发了task queue机制，试图来替代BH，当然，最后task queue也消失在内核代码中了。现在的linux kernel提供了三种bottom half的机制，来应对不同的需求。</p>

<p>workqueue和softirq、tasklet有本质的区别：workqueue运行在process context，而softirq和tasklet运行在interrupt context。因此，出现workqueue是不奇怪的，在有sleep需求的场景中，defering task必须延迟到kernel thread中执行，也就是说必须使用workqueue机制。softirq和tasklet是怎么回事呢？从本质上将，bottom half机制的设计有两方面的需求，一个是性能，一个是易用性。设计一个通用的bottom half机制来满足这两个需求非常的困难，因此，内核提供了softirq和tasklet两种机制。softirq更倾向于性能，而tasklet更倾向于易用性。</p>

<p>我们还是进入实际的例子吧，还是使用上一节的系统图。在引入softirq之后，网络数据的处理如下：</p>

<p>关中断：
<code>
    mask and ack interrupt controller---&gt;ack NIC---&gt;copy FIFO to ram---&gt;raise softirq---&gt;unmask interrupt controller
</code>
开中断：在softirq上下文中进行handle Data in the ram的动作</p>

<p>同样的，我们先假设Processor A处理了这个网卡中断事件，很快的完成了基本的HW操作后，raise softirq。在返回中断现场前，会检查softirq的触发情况，因此，后续网络数据处理的softirq在processor A上执行。在执行过程中，NIC硬件再次触发中断，Interrupt controller将该中断分发给processor B，执行动作和Processor A是类似的，因此，最后，网络数据处理的softirq在processor B上执行。</p>

<p>为了性能，同一类型的softirq有可能在不同的CPU上并发执行，这给使用者带来了极大的痛苦，因为驱动工程师在撰写softirq的回调函数的时候要考虑重入，考虑并发，要引入同步机制。但是，为了性能，我们必须如此。</p>

<p>当网络数据处理的softirq同时在Processor A和B上运行的时候，网卡中断又来了（可能是10G的网卡吧）。这时候，中断分发给processor A，这时候，processor A上的handler仍然会raise softirq，但是并不会调度该softirq。也就是说，softirq在一个CPU上是串行执行的。这种情况下，系统性能瓶颈是CPU资源，需要增加更多的CPU来解决该问题。</p>

<p>如果是tasklet的情况会如何呢？为何tasklet性能不如softirq呢？如果一个tasklet在processor A上被调度执行，那么它永远也不会同时在processor B上执行，也就是说，tasklet是串行执行的（注：不同的tasklet还是会并发的），不需要考虑重入的问题。我们还是用网卡这个例子吧（注意：这个例子仅仅是用来对比，实际上，网络数据是使用softirq机制的），同样是上面的系统结构图。假设使用tasklet，网络数据的处理如下：</p>

<p>关中断：
<code>
    mask and ack interrupt controller---&gt;ack NIC---&gt;copy FIFO to ram---&gt;schedule tasklet---&gt;unmask interrupt controller
</code>
开中断：在softirq上下文中（一般使用TASKLET_SOFTIRQ这个softirq）进行handle Data in the ram的动作</p>

<p>同样的，我们先假设Processor A处理了这个网卡中断事件，很快的完成了基本的HW操作后，schedule tasklet（同时也就raise TASKLET_SOFTIRQ softirq）。在返回中断现场前，会检查softirq的触发情况，因此，在TASKLET_SOFTIRQ softirq的handler中，获取tasklet相关信息并在processor A上执行该tasklet的handler。在执行过程中，NIC硬件再次触发中断，Interrupt controller将该中断分发给processor B，执行动作和Processor A是类似的，虽然TASKLET_SOFTIRQ softirq在processor B上可以执行，但是，在检查tasklet的状态的时候，如果发现该tasklet在其他processor上已经正在运行，那么该tasklet不会被处理，一直等到在processor A上的tasklet处理完，在processor B上的这个tasklet才能被执行。这样的串行化操作虽然对驱动工程师是一个福利，但是对性能而言是极大的损伤。</p>

<h3>三、理解softirq需要的基础知识（各种context）</h3>

<h4>1、preempt_count</h4>

<p>为了更好的理解下面的内容，我们需要先看看一些基础知识：一个task的thread info数据结构定义如下（只保留和本场景相关的内容）：
<code>
    struct thread_info {
        ......
        int preempt_count;    /* 0 =&gt; preemptable, &lt;0 =&gt; bug */
        ......
    };
</code>
preempt_count这个成员被用来判断当前进程是否可以被抢占。如果preempt_count不等于0（可能是代码调用preempt_disable显式的禁止了抢占，也可能是处于中断上下文等），说明当前不能进行抢占，如果preempt_count等于0，说明已经具备了抢占的条件（当然具体是否要抢占当前进程还是要看看thread info中的flag成员是否设定了_TIF_NEED_RESCHED这个标记，可能是当前的进程的时间片用完了，也可能是由于中断唤醒了优先级更高的进程）。 具体preempt_count的数据格式可以参考下图：</p>

<p><img src="/images/kernel/2015-05-07-12.gif" alt="" /></p>

<p>preemption count用来记录当前被显式的禁止抢占的次数，也就是说，每调用一次preempt_disable，preemption count就会加一，调用preempt_enable，该区域的数值会减去一。preempt_disable和preempt_enable必须成对出现，可以嵌套，最大嵌套的深度是255。</p>

<p>hardirq count描述当前中断handler嵌套的深度。对于ARM平台的linux kernel，其中断部分的代码如下：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
<span class='line-number'>206</span>
<span class='line-number'>207</span>
<span class='line-number'>208</span>
<span class='line-number'>209</span>
<span class='line-number'>210</span>
<span class='line-number'>211</span>
<span class='line-number'>212</span>
<span class='line-number'>213</span>
<span class='line-number'>214</span>
<span class='line-number'>215</span>
<span class='line-number'>216</span>
<span class='line-number'>217</span>
<span class='line-number'>218</span>
<span class='line-number'>219</span>
<span class='line-number'>220</span>
<span class='line-number'>221</span>
<span class='line-number'>222</span>
<span class='line-number'>223</span>
<span class='line-number'>224</span>
<span class='line-number'>225</span>
<span class='line-number'>226</span>
<span class='line-number'>227</span>
<span class='line-number'>228</span>
<span class='line-number'>229</span>
<span class='line-number'>230</span>
<span class='line-number'>231</span>
<span class='line-number'>232</span>
<span class='line-number'>233</span>
<span class='line-number'>234</span>
<span class='line-number'>235</span>
<span class='line-number'>236</span>
<span class='line-number'>237</span>
<span class='line-number'>238</span>
<span class='line-number'>239</span>
<span class='line-number'>240</span>
<span class='line-number'>241</span>
<span class='line-number'>242</span>
<span class='line-number'>243</span>
<span class='line-number'>244</span>
<span class='line-number'>245</span>
<span class='line-number'>246</span>
<span class='line-number'>247</span>
<span class='line-number'>248</span>
<span class='line-number'>249</span>
<span class='line-number'>250</span>
<span class='line-number'>251</span>
<span class='line-number'>252</span>
<span class='line-number'>253</span>
<span class='line-number'>254</span>
<span class='line-number'>255</span>
<span class='line-number'>256</span>
<span class='line-number'>257</span>
<span class='line-number'>258</span>
<span class='line-number'>259</span>
<span class='line-number'>260</span>
<span class='line-number'>261</span>
<span class='line-number'>262</span>
<span class='line-number'>263</span>
<span class='line-number'>264</span>
<span class='line-number'>265</span>
<span class='line-number'>266</span>
<span class='line-number'>267</span>
<span class='line-number'>268</span>
<span class='line-number'>269</span>
<span class='line-number'>270</span>
<span class='line-number'>271</span>
<span class='line-number'>272</span>
<span class='line-number'>273</span>
<span class='line-number'>274</span>
<span class='line-number'>275</span>
<span class='line-number'>276</span>
<span class='line-number'>277</span>
<span class='line-number'>278</span>
<span class='line-number'>279</span>
<span class='line-number'>280</span>
<span class='line-number'>281</span>
<span class='line-number'>282</span>
<span class='line-number'>283</span>
<span class='line-number'>284</span>
<span class='line-number'>285</span>
<span class='line-number'>286</span>
<span class='line-number'>287</span>
<span class='line-number'>288</span>
<span class='line-number'>289</span>
<span class='line-number'>290</span>
<span class='line-number'>291</span>
<span class='line-number'>292</span>
<span class='line-number'>293</span>
<span class='line-number'>294</span>
<span class='line-number'>295</span>
<span class='line-number'>296</span>
<span class='line-number'>297</span>
<span class='line-number'>298</span>
<span class='line-number'>299</span>
<span class='line-number'>300</span>
<span class='line-number'>301</span>
<span class='line-number'>302</span>
<span class='line-number'>303</span>
<span class='line-number'>304</span>
<span class='line-number'>305</span>
<span class='line-number'>306</span>
<span class='line-number'>307</span>
<span class='line-number'>308</span>
<span class='line-number'>309</span>
<span class='line-number'>310</span>
<span class='line-number'>311</span>
<span class='line-number'>312</span>
<span class='line-number'>313</span>
<span class='line-number'>314</span>
<span class='line-number'>315</span>
<span class='line-number'>316</span>
<span class='line-number'>317</span>
<span class='line-number'>318</span>
<span class='line-number'>319</span>
<span class='line-number'>320</span>
<span class='line-number'>321</span>
<span class='line-number'>322</span>
<span class='line-number'>323</span>
<span class='line-number'>324</span>
<span class='line-number'>325</span>
<span class='line-number'>326</span>
<span class='line-number'>327</span>
<span class='line-number'>328</span>
<span class='line-number'>329</span>
<span class='line-number'>330</span>
<span class='line-number'>331</span>
<span class='line-number'>332</span>
<span class='line-number'>333</span>
<span class='line-number'>334</span>
<span class='line-number'>335</span>
<span class='line-number'>336</span>
<span class='line-number'>337</span>
<span class='line-number'>338</span>
<span class='line-number'>339</span>
<span class='line-number'>340</span>
<span class='line-number'>341</span>
<span class='line-number'>342</span>
<span class='line-number'>343</span>
<span class='line-number'>344</span>
<span class='line-number'>345</span>
<span class='line-number'>346</span>
<span class='line-number'>347</span>
<span class='line-number'>348</span>
<span class='line-number'>349</span>
<span class='line-number'>350</span>
<span class='line-number'>351</span>
<span class='line-number'>352</span>
<span class='line-number'>353</span>
<span class='line-number'>354</span>
<span class='line-number'>355</span>
<span class='line-number'>356</span>
<span class='line-number'>357</span>
<span class='line-number'>358</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void handle_IRQ(unsigned int irq, struct pt_regs &lt;em&gt;regs)
</span><span class='line'>{
</span><span class='line'>    struct pt_regs &lt;/em&gt;old_regs = set_irq_regs(regs);&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    irq_enter(); 
</span><span class='line'>generic_handle_irq(irq);
</span><span class='line'>
</span><span class='line'>irq_exit();
</span><span class='line'>set_irq_regs(old_regs);
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;通用的IRQ handler被irq_enter和irq_exit这两个函数包围。irq_enter说明进入到IRQ context，而irq_exit则说明退出IRQ context。在irq_enter函数中会调用preempt_count_add(HARDIRQ_OFFSET)，为hardirq count的bit field增加1。在irq_exit函数中，会调用preempt_count_sub(HARDIRQ_OFFSET)，为hardirq count的bit field减去1。hardirq count占用了4个bit，说明硬件中断handler最大可以嵌套15层。在旧的内核中，hardirq count占用了12个bit，支持4096个嵌套。当然，在旧的kernel中还区分fast interrupt handler和slow interrupt handler，中断handler最大可以嵌套的次数理论上等于系统IRQ的个数。在实际中，这个数目不可能那么大（内核栈就受不了），因此，即使系统支持了非常大的中断个数，也不可能各个中断依次嵌套，达到理论的上限。基于这样的考虑，后来内核减少了hardirq count占用bit数目，改成了10个bit（在general arch的代码中修改为10，实际上，各个arch可以redefine自己的hardirq count的bit数）。但是，当内核大佬们决定废弃slow interrupt handler的时候，实际上，中断的嵌套已经不会发生了。因此，理论上，hardirq count要么是0，要么是1。不过呢，不能总拿理论说事，实际上，万一有写奇葩或者老古董driver在handler中打开中断，那么这时候中断嵌套还是会发生的，但是，应该不会太多（一个系统中怎么可能有那么多奇葩呢？呵呵），因此，目前hardirq count占用了4个bit，应付15个奇葩driver是妥妥的。
</span><span class='line'>
</span><span class='line'>对softirq count进行操作有两个场景：
</span><span class='line'>
</span><span class='line'>（1）也是在进入soft irq handler之前给 softirq count加一，退出soft irq handler之后给 softirq count减去一。由于soft irq handler在一个CPU上是不会并发的，总是串行执行，因此，这个场景下只需要一个bit就够了，也就是上图中的bit 8。通过该bit可以知道当前task是否在sofirq context。
</span><span class='line'>
</span><span class='line'>（2）由于内核同步的需求，进程上下文需要禁止softirq。这时候，kernel提供了local_bf_enable和local_bf_disable这样的接口函数。这部分的概念是和preempt disable/enable类似的，占用了bit9～15，最大可以支持127次嵌套。
</span><span class='line'>
</span><span class='line'>#### 2、一个task的各种上下文
</span><span class='line'>
</span><span class='line'>看完了preempt_count之后，我们来介绍各种context：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;#define in_irq()        (hardirq_count())
</span><span class='line'>#define in_softirq()        (softirq_count())
</span><span class='line'>#define in_interrupt()        (irq_count())
</span><span class='line'>
</span><span class='line'>#define in_serving_softirq()    (softirq_count() &amp; SOFTIRQ_OFFSET)
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;这里首先要介绍的是一个叫做IRQ context的术语。这里的IRQ context其实就是hard irq context，也就是说明当前正在执行中断handler（top half），只要preempt_count中的hardirq count大于0（＝1是没有中断嵌套，如果大于1，说明有中断嵌套），那么就是IRQ context。
</span><span class='line'>
</span><span class='line'>softirq context并没有那么的直接，一般人会认为当sofirq handler正在执行的时候就是softirq context。这样说当然没有错，sofirq handler正在执行的时候，会增加softirq count，当然是softirq context。不过，在其他context的情况下，例如进程上下文中，有有可能因为同步的要求而调用local_bh_disable，这时候，通过local_bh_disable/enable保护起来的代码也是执行在softirq context中。当然，这时候其实并没有正在执行softirq handler。如果你确实想知道当前是否正在执行softirq handler，in_serving_softirq可以完成这个使命，这是通过操作preempt_count的bit 8来完成的。
</span><span class='line'>
</span><span class='line'>所谓中断上下文，就是IRQ context ＋ softirq context＋NMI context。
</span><span class='line'>
</span><span class='line'>### 四、softirq机制
</span><span class='line'>
</span><span class='line'>softirq和hardirq（就是硬件中断啦）是对应的，因此softirq的机制可以参考hardirq对应理解，当然softirq是纯软件的，不需要硬件参与。
</span><span class='line'>
</span><span class='line'>#### 1、softirq number
</span><span class='line'>
</span><span class='line'>和IRQ number一样，对于软中断，linux kernel也是用一个softirq number唯一标识一个softirq，具体定义如下：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;enum
</span><span class='line'>{
</span><span class='line'>HI_SOFTIRQ=0,
</span><span class='line'>TIMER_SOFTIRQ,
</span><span class='line'>NET_TX_SOFTIRQ,
</span><span class='line'>NET_RX_SOFTIRQ,
</span><span class='line'>BLOCK_SOFTIRQ,
</span><span class='line'>BLOCK_IOPOLL_SOFTIRQ,
</span><span class='line'>TASKLET_SOFTIRQ,
</span><span class='line'>SCHED_SOFTIRQ,
</span><span class='line'>HRTIMER_SOFTIRQ,
</span><span class='line'>RCU_SOFTIRQ,    /* Preferable RCU should always be the last softirq */
</span><span class='line'>
</span><span class='line'>NR_SOFTIRQS
</span><span class='line'>};
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;HI_SOFTIRQ用于高优先级的tasklet，TASKLET_SOFTIRQ用于普通的tasklet。TIMER_SOFTIRQ是for software timer的（所谓software timer就是说该timer是基于系统tick的）。NET_TX_SOFTIRQ和NET_RX_SOFTIRQ是用于网卡数据收发的。BLOCK_SOFTIRQ和BLOCK_IOPOLL_SOFTIRQ是用于block device的。SCHED_SOFTIRQ用于多CPU之间的负载均衡的。HRTIMER_SOFTIRQ用于高精度timer的。RCU_SOFTIRQ是处理RCU的。这些具体使用情景分析会在各自的子系统中分析，本文只是描述softirq的工作原理。
</span><span class='line'>
</span><span class='line'>#### 2、softirq描述符
</span><span class='line'>
</span><span class='line'>我们前面已经说了，softirq是静态定义的，也就是说系统中有一个定义softirq描述符的数组，而softirq number就是这个数组的index。这个概念和早期的静态分配的中断描述符概念是类似的。具体定义如下：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;struct softirq_action
</span><span class='line'>{
</span><span class='line'>void    (*action)(struct softirq_action *);
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>static struct softirq_action softirq_vec[NR_SOFTIRQS] __cacheline_aligned_in_smp;
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;系统支持多少个软中断，静态定义的数组就会有多少个entry。`____cacheline_aligned`保证了在SMP的情况下，softirq_vec是对齐到cache line的。softirq描述符非常简单，只有一个action成员，表示如果触发了该softirq，那么应该调用action回调函数来处理这个soft irq。对于硬件中断而言，其mask、ack等都是和硬件寄存器相关并封装在irq chip函数中，对于softirq，没有硬件寄存器，只有“软件寄存器”，定义如下：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;typedef struct {
</span><span class='line'>unsigned int __softirq_pending;
</span><span class='line'>#ifdef CONFIG_SMP
</span><span class='line'>unsigned int ipi_irqs[NR_IPI];
</span><span class='line'>#endif
</span><span class='line'>} ____cacheline_aligned irq_cpustat_t;
</span><span class='line'>
</span><span class='line'>irq_cpustat_t irq_stat[NR_CPUS] ____cacheline_aligned;
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;ipi_irqs这个成员用于处理器之间的中断，我们留到下一个专题来描述。`__softirq_pending`就是这个“软件寄存器”。softirq采用谁触发，谁负责处理的。例如：当一个驱动的硬件中断被分发给了指定的CPU，并且在该中断handler中触发了一个softirq，那么该CPU负责调用该softirq number对应的action callback来处理该软中断。因此，这个“软件寄存器”应该是每个CPU拥有一个（专业术语叫做banked register）。为了性能，irq_stat中的每一个entry被定义对齐到cache line。
</span><span class='line'>
</span><span class='line'>#### 3、如何注册一个softirq
</span><span class='line'>
</span><span class='line'>通过调用open_softirq接口函数可以注册softirq的action callback函数，具体如下：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;void open_softirq(int nr, void (*action)(struct softirq_action *))
</span><span class='line'>{
</span><span class='line'>softirq_vec[nr].action = action;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;softirq_vec是一个多CPU之间共享的数据，不过，由于所有的注册都是在系统初始化的时候完成的，那时候，系统是串行执行的。此外，softirq是静态定义的，每个entry（或者说每个softirq number）都是固定分配的，因此，不需要保护。
</span><span class='line'>
</span><span class='line'>#### 4、如何触发softirq？
</span><span class='line'>
</span><span class='line'>在linux kernel中，可以调用raise_softirq这个接口函数来触发本地CPU上的softirq，具体如下：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;void raise_softirq(unsigned int nr)
</span><span class='line'>{
</span><span class='line'>unsigned long flags;
</span><span class='line'>
</span><span class='line'>local_irq_save(flags);
</span><span class='line'>raise_softirq_irqoff(nr);
</span><span class='line'>local_irq_restore(flags);
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;虽然大部分的使用场景都是在中断handler中（也就是说关闭本地CPU中断）来执行softirq的触发动作，但是，这不是全部，在其他的上下文中也可以调用raise_softirq。因此，触发softirq的接口函数有两个版本，一个是raise_softirq，有关中断的保护，另外一个是raise_softirq_irqoff，调用者已经关闭了中断，不需要关中断来保护“soft irq status register”。
</span><span class='line'>
</span><span class='line'>所谓trigger softirq，就是在`__softirq_pending`（也就是上面说的soft irq status register）的某个bit置一。从上面的定义可知，`__softirq_pending`是per cpu的，因此不需要考虑多个CPU的并发，只要disable本地中断，就可以确保对，`__softirq_pending`操作的原子性。
</span><span class='line'>
</span><span class='line'>具体raise_softirq_irqoff的代码如下：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;inline void raise_softirq_irqoff(unsigned int nr)
</span><span class='line'>{
</span><span class='line'>__raise_softirq_irqoff(nr); ---------- （1）
</span><span class='line'>
</span><span class='line'>if (!in_interrupt())
</span><span class='line'>    wakeup_softirqd();      ---------- （2）
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;（1）`__raise_softirq_irqoff`函数设定本CPU上的`__softirq_pending`的某个bit等于1，具体的bit是由soft irq number（nr参数）指定的。
</span><span class='line'>
</span><span class='line'>（2）如果在中断上下文，我们只要set `__softirq_pending`的某个bit就OK了，在中断返回的时候自然会进行软中断的处理。但是，如果在context上下文调用这个函数的时候，我们必须要调用wakeup_softirqd函数用来唤醒本CPU上的softirqd这个内核线程。具体softirqd的内容请参考下一个章节。
</span><span class='line'>
</span><span class='line'>#### 5、disable/enable softirq
</span><span class='line'>
</span><span class='line'>在linux kernel中，可以使用local_irq_disable和local_irq_enable来disable和enable本CPU中断。和硬件中断一样，软中断也可以disable，接口函数是local_bh_disable和local_bh_enable。虽然和想像的local_softirq_enable/disable有些出入，不过bh这个名字更准确反应了该接口函数的意涵，因为local_bh_disable/enable函数就是用来disable/enable bottom half的，这里就包括softirq和tasklet。
</span><span class='line'>
</span><span class='line'>先看disable吧，毕竟禁止bottom half比较简单：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static inline void local_bh_disable(void)
</span><span class='line'>{
</span><span class='line'>__local_bh_disable_ip(_THIS_IP_, SOFTIRQ_DISABLE_OFFSET);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>static __always_inline void __local_bh_disable_ip(unsigned long ip, unsigned int cnt)
</span><span class='line'>{
</span><span class='line'>preempt_count_add(cnt);
</span><span class='line'>barrier();
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;看起来disable bottom half比较简单，就是讲current thread info上的preempt_count成员中的softirq count的bit field9～15加上一就OK了。barrier是优化屏障（Optimization barrier），会在内核同步系列文章中描述。
</span><span class='line'>
</span><span class='line'>enable函数比较复杂，如下：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static inline void local_bh_enable(void)
</span><span class='line'>{
</span><span class='line'>__local_bh_enable_ip(_THIS_IP_, SOFTIRQ_DISABLE_OFFSET);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void __local_bh_enable_ip(unsigned long ip, unsigned int cnt)
</span><span class='line'>{
</span><span class='line'>WARN_ON_ONCE(in_irq() || irqs_disabled()); --------- （1）
</span><span class='line'>
</span><span class='line'>preempt_count_sub(cnt - 1);                --------- （2）
</span><span class='line'>
</span><span class='line'>if (unlikely(!in_interrupt() &amp;&amp; local_softirq_pending())) {  ------- （3）
</span><span class='line'>    do_softirq();
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>preempt_count_dec();                       --------- （4）
</span><span class='line'>preempt_check_resched();
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;（1）disable/enable bottom half是一种内核同步机制。在硬件中断的handler（top half）中，不应该调用disable/enable bottom half函数来保护共享数据，因为bottom half其实是不可能抢占top half的。同样的，soft irq也不会抢占另外一个soft irq的执行，也就是说，一旦一个softirq handler被调度执行（无论在哪一个processor上），那么，本地的softirq handler都无法抢占其运行，要等到当前的softirq handler运行完毕后，才能执行下一个soft irq handler。注意：上面我们说的是本地，是local，softirq handler是可以在多个CPU上同时运行的，但是，linux kernel中没有disable all softirq的接口函数（就好像没有disable all CPU interrupt的接口一样，注意体会local_bh_enable/disable中的local的含义）。
</span><span class='line'>
</span><span class='line'>说了这么多，一言以蔽之，local_bh_enable/disable是给进程上下文使用的，用于防止softirq handler抢占local_bh_enable/disable之间的临界区的。
</span><span class='line'>
</span><span class='line'>irqs_disabled接口函数可以获知当前本地CPU中断是否是disable的，如果返回1，那么当前是disable 本地CPU的中断的。如果irqs_disabled返回1，有可能是下面这样的代码造成的：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;local_irq_disable();
</span><span class='line'>......
</span><span class='line'>local_bh_disable();
</span><span class='line'>
</span><span class='line'>......
</span><span class='line'>
</span><span class='line'>local_bh_enable();
</span><span class='line'>......
</span><span class='line'>local_irq_enable();
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;本质上，关本地中断是一种比关本地bottom half更强劲的锁，关本地中断实际上是禁止了top half和bottom half抢占当前进程上下文的运行。也许你会说：这也没有什么，就是有些浪费，至少代码逻辑没有问题。但事情没有这么简单，在`local_bh_enable---&gt;do_softirq---&gt;__do_softirq`中，有一条无条件打开当前中断的操作，也就是说，原本想通过local_irq_disable/local_irq_enable保护的临界区被破坏了，其他的中断handler可以插入执行，从而无法保证local_irq_disable/local_irq_enable保护的临界区的原子性，从而破坏了代码逻辑。
</span><span class='line'>
</span><span class='line'>in_irq()这个函数如果不等于0的话，说明local_bh_enable被irq_enter和irq_exit包围，也就是说在中断handler中调用了local_bh_enable/disable。这道理是和上面类似的，这里就不再详细描述了。
</span><span class='line'>
</span><span class='line'>（2）在local_bh_disable中我们为preempt_count增加了SOFTIRQ_DISABLE_OFFSET，在local_bh_enable函数中应该减掉同样的数值。这一步，我们首先减去了（SOFTIRQ_DISABLE_OFFSET-1），为何不一次性的减去SOFTIRQ_DISABLE_OFFSET呢？考虑下面运行在进程上下文的代码场景：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;......
</span><span class='line'>
</span><span class='line'>local_bh_disable
</span><span class='line'>
</span><span class='line'>...需要被保护的临界区...
</span><span class='line'>
</span><span class='line'>local_bh_enable
</span><span class='line'>......
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;在临界区内，有进程context 和softirq共享的数据，因此，在进程上下文中使用local_bh_enable/disable进行保护。假设在临界区代码执行的时候，发生了中断，由于代码并没有阻止top half的抢占，因此中断handler会抢占当前正在执行的thread。在中断handler中，我们raise了softirq，在返回中断现场的时候，由于disable了bottom half，因此虽然触发了softirq，但是不会调度执行。因此，代码返回临界区继续执行，直到local_bh_enable。一旦enable了bottom half，那么之前raise的softirq就需要调度执行了，因此，这也是为什么在local_bh_enable会调用do_softirq函数。
</span><span class='line'>
</span><span class='line'>调用do_softirq函数来处理pending的softirq的时候，当前的task是不能被抢占的，因为一旦被抢占，下一次该task被调度运行的时候很可能在其他的CPU上去了（还记得吗？softirq的pending 寄存器是per cpu的）。因此，我们不能一次性的全部减掉，那样的话有可能preempt_count等于0，那样就允许抢占了。因此，这里减去了（SOFTIRQ_DISABLE_OFFSET-1），既保证了softirq count的bit field9~15被减去了1，又保持了preempt disable的状态。
</span><span class='line'>
</span><span class='line'>（3）如果当前不是interrupt context的话，并且有pending的softirq，那么调用do_softirq函数来处理软中断。
</span><span class='line'>
</span><span class='line'>（4）该来的总会来，在step 2中我们少减了1，这里补上，其实也就是preempt count-1。
</span><span class='line'>
</span><span class='line'>（5）在softirq handler中很可能wakeup了高优先级的任务，这里最好要检查一下，看看是否需要进行调度，确保高优先级的任务得以调度执行。
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>#### 5、如何处理一个被触发的soft irq
</span><span class='line'>
</span><span class='line'>我们说softirq是一种defering task的机制，也就是说top half没有做的事情，需要延迟到bottom half中来执行。那么具体延迟到什么时候呢？这是本节需要讲述的内容，也就是说soft irq是如何调度执行的。
</span><span class='line'>
</span><span class='line'>在上一节已经描述一个softirq被调度执行的场景，本节主要关注在中断返回现场时候调度softirq的场景。我们来看中断退出的代码，具体如下：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;void irq_exit(void)
</span><span class='line'>{
</span><span class='line'>......
</span><span class='line'>if (!in_interrupt() &amp;&amp; local_softirq_pending())
</span><span class='line'>    invoke_softirq();
</span><span class='line'>
</span><span class='line'>......
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;代码中“!in_interrupt()”这个条件可以确保下面的场景不会触发sotfirq的调度：
</span><span class='line'>
</span><span class='line'>（1）中断handler是嵌套的。也就是说本次irq_exit是退出到上一个中断handler。当然，在新的内核中，这种情况一般不会发生，因为中断handler都是关中断执行的。
</span><span class='line'>
</span><span class='line'>（2）本次中断是中断了softirq handler的执行。也就是说本次irq_exit是不是退出到进程上下文，而是退出到上一个softirq context。这一点也保证了在一个CPU上的softirq是串行执行的（注意：多个CPU上还是有可能并发的）
</span><span class='line'>
</span><span class='line'>我们继续看invoke_softirq的代码：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static inline void invoke_softirq(void)
</span><span class='line'>{
</span><span class='line'>if (!force_irqthreads) {
</span><span class='line'>#ifdef CONFIG_HAVE_IRQ_EXIT_ON_IRQ_STACK
</span><span class='line'>    __do_softirq();
</span><span class='line'>#else
</span><span class='line'>    do_softirq_own_stack();
</span><span class='line'>#endif
</span><span class='line'>} else {
</span><span class='line'>    wakeup_softirqd();
</span><span class='line'>}
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;force_irqthreads是和强制线程化相关的，主要用于interrupt handler的调试（一般而言，在线程环境下比在中断上下文中更容易收集调试数据）。如果系统选择了对所有的interrupt handler进行线程化处理，那么softirq也没有理由在中断上下文中处理（中断handler都在线程中执行了，softirq怎么可能在中断上下文中执行）。本身invoke_softirq这个函数是在中断上下文中被调用的，如果强制线程化，那么系统中所有的软中断都在sofirq的daemon进程中被调度执行。
</span><span class='line'>
</span><span class='line'>如果没有强制线程化，softirq的处理也分成两种情况，主要是和softirq执行的时候使用的stack相关。如果arch支持单独的IRQ STACK，这时候，由于要退出中断，因此irq stack已经接近全空了（不考虑中断栈嵌套的情况，因此新内核下，中断不会嵌套），因此直接调用`__do_softirq()`处理软中断就OK了，否则就调用do_softirq_own_stack函数在softirq自己的stack上执行。当然对ARM而言，softirq的处理就是在当前的内核栈上执行的，因此do_softirq_own_stack的调用就是调用`__do_softirq()`，代码如下（删除了部分无关代码）：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;asmlinkage void __do_softirq(void)
</span><span class='line'>{
</span><span class='line'>......
</span><span class='line'>pending = local_softirq_pending();  ----------- 获取softirq pending的状态
</span><span class='line'>__local_bh_disable_ip(_RET_IP_, SOFTIRQ_OFFSET); ---- 标识下面的代码是正在处理softirq
</span><span class='line'>cpu = smp_processor_id();
</span><span class='line'>restart:
</span><span class='line'>set_softirq_pending(0);  ------------- 清除pending标志
</span><span class='line'>local_irq_enable();      ------------- 打开中断，softirq handler是开中断执行的
</span><span class='line'>h = softirq_vec;         ------------- 获取软中断描述符指针
</span><span class='line'>
</span><span class='line'>while ((softirq_bit = ffs(pending))) { --------- 寻找pending中第一个被设定为1的bit
</span><span class='line'>    unsigned int vec_nr;
</span><span class='line'>    int prev_count;
</span><span class='line'>
</span><span class='line'>    h += softirq_bit - 1; ----------- 指向pending的那个软中断描述符
</span><span class='line'>    vec_nr = h - softirq_vec; ------- 获取soft irq number
</span><span class='line'>    h-&gt;action(h);         ----------- 指向softirq handler
</span><span class='line'>    h++;
</span><span class='line'>    pending &gt;&gt;= softirq_bit;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>local_irq_disable();      ----------- 打开中断
</span><span class='line'>
</span><span class='line'>pending = local_softirq_pending(); ------ （注1）
</span><span class='line'>if (pending) {
</span><span class='line'>    if (time_before(jiffies, end) &amp;&amp; !need_resched() &amp;&amp;
</span><span class='line'>        --max_restart)
</span><span class='line'>        goto restart;
</span><span class='line'>
</span><span class='line'>    wakeup_softirqd();
</span><span class='line'>}
</span><span class='line'>__local_bh_enable(SOFTIRQ_OFFSET); ----------- 标识softirq处理完毕
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```
</span><span class='line'>（注1）再次检查softirq pending，有可能上面的softirq handler在执行过程中，发生了中断，又raise了softirq。如果的确如此，那么我们需要跳转到restart那里重新处理soft irq。当然，也不能总是在这里不断的loop，因此linux kernel设定了下面的条件：&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;（1）softirq的处理时间没有超过2个ms&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;（2）上次的softirq中没有设定TIF_NEED_RESCHED，也就是说没有有高优先级任务需要调度&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;（3）loop的次数小于 10次&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;因此，只有同时满足上面三个条件，程序才会跳转到restart那里重新处理soft irq。否则wakeup_softirqd就OK了。这样的设计也是一个平衡的方案。一方面照顾了调度延迟：本来，发生一个中断，系统期望在限定的时间内调度某个进程来处理这个中断，如果softirq handler不断触发，其实linux kernel是无法保证调度延迟时间的。另外一方面，也照顾了硬件的thoughput：已经预留了一定的时间来处理softirq。&lt;/p&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[内核源码分析之linux内核栈]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2015/05/07/kernel-irq-stack2/"/&gt;
</span><span class='line'>&lt;updated&gt;2015-05-07T15:54:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2015/05/07/kernel-irq-stack2&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;p&gt;&lt;a href="http://www.cnblogs.com/liangning/p/3879177.html"&gt;http://www.cnblogs.com/liangning/p/3879177.html&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;基于3.16-rc4&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;在3.16-rc4内核源码中，内核给每个进程分配的内核栈大小为8KB。这个内核栈被称为异常栈，在进程的内核空间运行时或者执行异常处理程序时，使用的都是异常栈，看下异常栈的代码（include/linux/sched.h）：
</span><span class='line'>&lt;code&gt;
</span><span class='line'>union thread_union {
</span><span class='line'>    struct thread_info thread_info;
</span><span class='line'>    unsigned long stack[THREAD_SIZE/sizeof(long)];
</span><span class='line'>};
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>THREAD_SIZE值为8KB，因此内核为进程的异常栈（内核栈）分配了两个页框大小（页框大小4KB）。另外，进程的thread_info结构体保存在栈顶部。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;此外，内核为每个cpu分配一个硬中断栈和一个软中断栈（这两个栈也是内核栈），用来执行中断服务例程和下半部（软中断），看看代码（arch/x86/kernel/irq_32.c）。这两个栈属于cpu，不属于进程，这和异常栈是有区别的。
</span><span class='line'>&lt;code&gt;
</span><span class='line'>DEFINE_PER_CPU(struct irq_stack *, hardirq_stack);
</span><span class='line'>DEFINE_PER_CPU(struct irq_stack *, softirq_stack);
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>定义了两个数组hardirq_stack和softirq_stack，每个数组元素对应一个cpu，指向了该cpu的硬中断栈或者软中断栈。再来看下struct irq_stack结构体（arch/x86/include/asm/processor.h）：
</span><span class='line'>&lt;code&gt;
</span><span class='line'>struct irq_stack {
</span><span class='line'>    u32                     stack[THREAD_SIZE/sizeof(u32)];
</span><span class='line'>} __aligned(THREAD_SIZE);
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>可见，硬中断栈和软中断栈的大小均为8KB。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;内核在执行中断处理程序时，在do_IRQ函数中会调用handle_irq函数，在handle_irq函数中要进行堆栈切换，代码如下（arch/x86/kernel/irq_32.c）：</span></code></pre></td></tr></table></div></figure>
    bool handle_irq(unsigned irq, struct pt_regs <em>regs)
    {
        struct irq_desc </em>desc;
        int overflow;</p>

<pre><code>    overflow = check_stack_overflow();

    desc = irq_to_desc(irq);
    if (unlikely(!desc))
    return false;

    if (user_mode_vm(regs) || !execute_on_irq_stack(overflow, desc, irq)) {
        if (unlikely(overflow))
            print_stack_overflow();
        desc-&gt;handle_irq(irq, desc);
    }

    return true;
}
</code></pre>

<pre><code>
第12行中执行execute_on_irq_stack函数来判断是否需要堆栈切换，如果不需要，则执行if体的中断服务例程，即在当前堆栈中执行中断服务例程，如果需要切换堆栈，则在execute_on_irq_stack函数中切换堆栈并在该函数中（新堆栈中）执行中断服务例程。下面看下execute_on_irq_stack代码（arch/x86/kernel/irq_32.c）：
</code></pre>

<pre><code>static inline int
execute_on_irq_stack(int overflow, struct irq_desc *desc, int irq)
{
    struct irq_stack *curstk, *irqstk;
    u32 *isp, *prev_esp, arg1, arg2;

    curstk = (struct irq_stack *) current_stack();
    irqstk = __this_cpu_read(hardirq_stack);

    /*
     * this is where we switch to the IRQ stack. However, if we are
     * already using the IRQ stack (because we interrupted a hardirq
     * handler) we can't do that and just have to keep using the
     * current stack (which is the irq stack already after all)
     */
    if (unlikely(curstk == irqstk))
        return 0;

    isp = (u32 *) ((char *)irqstk + sizeof(*irqstk));

    /* Save the next esp at the bottom of the stack */
    prev_esp = (u32 *)irqstk;
    *prev_esp = current_stack_pointer;

    if (unlikely(overflow))
        call_on_stack(print_stack_overflow, isp);

    asm volatile("xchgl    %%ebx,%%esp    \n"
             "call    *%%edi        \n"
             "movl    %%ebx,%%esp    \n"
             : "=a" (arg1), "=d" (arg2), "=b" (isp)
             :  "0" (irq),   "1" (desc),  "2" (isp),
            "D" (desc-&gt;handle_irq)
             : "memory", "cc", "ecx");
    return 1;
}
</code></pre>

<p>```</p>

<p>第7行获取当前堆栈的指针，第8行获取本地cpu的硬中断栈指针，第16行对二者进行比较，如果相等，则不需要切换堆栈（说明当前堆栈就是硬中断栈，也说明是在中断处理程序中时又发生了中断）。如果不相等，就要进行堆栈切换，第22-23行将当前堆栈指针保存在将要切换到的堆栈中（用于返回）。第28行，交换ebx和esp寄存器的值（实现了堆栈切换，将中断栈指针给了esp），第29行跳转到相应的中断服务例程，第30行从中断服务例程返回后，又将原来的堆栈指针赋给esp，切换到原先堆栈。第33行将中断服务例程函数名存放在%edi中。</p>
]]></content>
  </entry>
  
</feed>
