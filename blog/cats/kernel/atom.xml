<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: kernel | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/kernel/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2015-04-15T15:35:54+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[TCP校验和的原理和实现]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/04/15/kernel-net-sum/"/>
    <updated>2015-04-15T14:07:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/04/15/kernel-net-sum</id>
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/zhangskd/article/details/11770647">http://blog.csdn.net/zhangskd/article/details/11770647</a></p>

<h4>概述</h4>

<p>TCP校验和是一个端到端的校验和，由发送端计算，然后由接收端验证。其目的是为了发现TCP首部和数据在发送端到接收端之间发生的任何改动。如果接收方检测到校验和有差错，则TCP段会被直接丢弃。</p>

<p>TCP校验和覆盖TCP首部和TCP数据，而IP首部中的校验和只覆盖IP的首部，不覆盖IP数据报中的任何数据。</p>

<p>TCP的校验和是必需的，而UDP的校验和是可选的。</p>

<p>TCP和UDP计算校验和时，都要加上一个12字节的伪首部。</p>

<h4>伪首部</h4>

<p><img src="/images/kernel/2015-04-15-1.jpeg" alt="" /></p>

<p>伪首部共有12字节，包含如下信息：源IP地址、目的IP地址、保留字节(置0)、传输层协议号(TCP是6)、TCP报文长度(报头+数据)。</p>

<p>伪首部是为了增加TCP校验和的检错能力：如检查TCP报文是否收错了(目的IP地址)、传输层协议是否选对了(传输层协议号)等。</p>

<h4>定义</h4>

<h5>(1) RFC 793的TCP校验和定义</h5>

<p>The checksum field is the 16 bit one&rsquo;s complement of the one&rsquo;s complement sum of all 16-bit words in the header and text. If a segment contains an odd number of header and text octets to be checksummed, the last octet is padded on the right with zeros to form a 16-bit word for checksum purposes. The pad is not transmitted as part of the segment. While computing the checksum, the checksum field itself is replaced with zeros.</p>

<p>上述的定义说得很明确：<br/>
首先，把伪首部、TCP报头、TCP数据分为16位的字，如果总长度为奇数个字节，则在最后增添一个位都为0的字节。把TCP报头中的校验和字段置为0（否则就陷入鸡生蛋还是蛋生鸡的问题）。</p>

<p>其次，用反码相加法累加所有的16位字（进位也要累加）。</p>

<p>最后，对计算结果取反，作为TCP的校验和。</p>

<h5>(2) RFC 1071的IP校验和定义</h5>

<p>1.Adjacent octets to be checksummed are paired to form 16-bit integers, and the 1&rsquo;s complement sum of these 16-bit integers is formed.</p>

<p>2.To generate a checksum, the checksum field itself is cleared, the 16-bit 1&rsquo;s complement sum is computed over the octets concerned, and the 1&rsquo;s complement of this sum is placed in the checksum field.</p>

<p>3.To check a checksum, the 1&rsquo;s complement sum is computed over the same set of octets, including the checksum field. If the result is all 1 bits (-0 in 1&rsquo;s complement arithmetic), the check succeeds.</p>

<p>可以看到，TCP校验和、IP校验和的计算方法是基本一致的，除了计算的范围不同。</p>

<h4>实现</h4>

<p>基于2.6.18、x86_64。</p>

<p>csum_tcpudp_nofold()按4字节累加伪首部到sum中。
<code>
    static inline unsigned long csum_tcpudp_nofold (unsigned long saddr, unsigned long daddr,  
                                                    unsigned short len, unsigned short proto,  
                                                    unsigned int sum)  
    {  
        asm("addl %1, %0\n"    /* 累加daddr */  
            "adcl %2, %0\n"    /* 累加saddr */  
            "adcl %3, %0\n"    /* 累加len(2字节), proto, 0*/  
            "adcl $0, %0\n"    /*加上进位 */  
            : "=r" (sum)  
            : "g" (daddr), "g" (saddr), "g" ((ntohs(len) &lt;&lt; 16) + proto*256), "0" (sum));  
        return sum;  
    }   
</code></p>

<p>csum_tcpudp_magic()产生最终的校验和。</p>

<p>首先，按4字节累加伪首部到sum中。</p>

<p>其次，累加sum的低16位、sum的高16位，并且对累加的结果取反。</p>

<p>最后，截取sum的高16位，作为校验和。
```
    static inline unsigned short int csum_tcpudp_magic(unsigned long saddr, unsigned long daddr,<br/>
                                                       unsigned short len, unsigned short proto,<br/>
                                                       unsigned int sum)<br/>
    {<br/>
        return csum_fold(csum_tcpudp_nofold(saddr, daddr, len, proto, sum));<br/>
    }</p>

<pre><code>static inline unsigned int csum_fold(unsigned int sum)  
{  
    __asm__(  
        "addl %1, %0\n"  
        "adcl 0xffff, %0"  
        : "=r" (sum)  
        : "r" (sum &lt;&lt; 16), "0" (sum &amp; 0xffff0000)   

        /* 将sum的低16位，作为寄存器1的高16位，寄存器1的低16位补0。 
          * 将sum的高16位，作为寄存器0的高16位，寄存器0的低16位补0。 
          * 这样，addl %1, %0就累加了sum的高16位和低16位。 
          * 
         * 还要考虑进位。如果有进位，adcl 0xfff, %0为：0x1 + 0xffff + %0，寄存器0的高16位加1。 
          * 如果没有进位，adcl 0xffff, %0为：0xffff + %0，对寄存器0的高16位无影响。 
          */  

    );  

    return (~sum) &gt;&gt; 16; /* 对sum取反，返回它的高16位，作为最终的校验和 */  
}  
</code></pre>

<pre><code>
#### 发送校验
</code></pre>

<pre><code>#define CHECKSUM_NONE 0 /* 不使用校验和，UDP可选 */  
#define CHECKSUM_HW 1 /* 由硬件计算报头和首部的校验和 */  
#define CHECKSUM_UNNECESSARY 2 /* 表示不需要校验，或者已经成功校验了 */  
#define CHECKSUM_PARTIAL CHECKSUM_HW  
#define CHECKSUM_COMPLETE CHECKSUM_HW  
</code></pre>

<pre><code>
##### @tcp_transmit_skb()
    icsk-&gt;icsk_af_ops-&gt;send_check(sk, skb-&gt;len, skb); /* 计算校验和 */
</code></pre>

<pre><code>void tcp_v4_send_check(struct sock *sk, int len, struct sk_buff *skb)  
{  
    struct inet_sock *inet = inet_sk(sk);  
    struct tcphdr *th = skb-&gt;h.th;  

    if (skb-&gt;ip_summed == CHECKSUM_HW) {  
        /* 只计算伪首部，TCP报头和TCP数据的累加由硬件完成 */  
        th-&gt;check = ~tcp_v4_check(th, len, inet-&gt;saddr, inet-&gt;daddr, 0);  
        skb-&gt;csum = offsetof(struct tcphdr, check); /* 校验和值在TCP首部的偏移 */  

    } else {  
        /* tcp_v4_check累加伪首部，获取最终的校验和。 
         * csum_partial累加TCP报头。 
         * 那么skb-&gt;csum应该是TCP数据部分的累加，这是在从用户空间复制时顺便累加的。 
         */  
        th-&gt;check = tcp_v4_check(th, len, inet-&gt;saddr, inet-&gt;daddr,  
                                 csum_partial((char *)th, th-&gt;doff &lt;&lt; 2, skb-&gt;csum));  
    }  
}  
</code></pre>

<p><code>
</code>
    unsigned csum_partial(const unsigned char *buff, unsigned len, unsigned sum)<br/>
    {<br/>
        return add32_with_carry(do_csum(buff, len), sum);<br/>
    }</p>

<pre><code>static inline unsigned add32_with_carry(unsigned a, unsigned b)  
{  
    asm("addl %2, %0\n\t"  
             "adcl $0, %0"  
             : "=r" (a)  
             : "0" (a), "r" (b));  
    return a;  
}   
</code></pre>

<pre><code>
do_csum()用于计算一段内存的校验和，这里用于累加TCP报头。

具体计算时用到一些技巧：  
1.反码累加时，按16位、32位、64位来累加的效果是一样的。  
2.使用内存对齐，减少内存操作的次数。
</code></pre>

<pre><code>static __force_inline unsigned do_csum(const unsigned char *buff, unsigned len)  
{  
    unsigned odd, count;  
    unsigned long result = 0;  

    if (unlikely(len == 0))  
        return result;  

    /* 使起始地址为XXX0，接下来可按2字节对齐 */  
    odd = 1 &amp; (unsigned long) buff;  
    if (unlikely(odd)) {  
        result = *buff &lt;&lt; 8; /* 因为机器是小端的 */  
        len--;  
        buff++;  
    }  
    count = len &gt;&gt; 1; /* nr of 16-bit words，这里可能余下1字节未算，最后会处理*/  

    if (count) {  
        /* 使起始地址为XX00，接下来可按4字节对齐 */  
        if (2 &amp; (unsigned long) buff) {  
            result += *(unsigned short *)buff;  
            count--;  
            len -= 2;  
            buff += 2;  
        }  
        count &gt;&gt;= 1; /* nr of 32-bit words，这里可能余下2字节未算，最后会处理 */  

        if (count) {  
            unsigned long zero;  
            unsigned count64;  
            /* 使起始地址为X000，接下来可按8字节对齐 */  
            if (4 &amp; (unsigned long)buff) {  
                result += *(unsigned int *)buff;  
                count--;  
                len -= 4;  
                buff += 4;  
            }  
            count &gt;&gt;= 1; /* nr of 64-bit words，这里可能余下4字节未算，最后会处理*/  

            /* main loop using 64byte blocks */  
            zero = 0;  
            count64 = count &gt;&gt; 3; /* 64字节的块数，这里可能余下56字节未算，最后会处理 */  
            while (count64) { /* 反码累加所有的64字节块 */  
                asm ("addq 0*8(%[src]), %[res]\n\t"    /* b、w、l、q分别对应8、16、32、64位操作 */  
                          "addq 1*8(%[src]), %[res]\n\t"    /* [src]为指定寄存器的别名，效果应该等同于0、1等 */  
                          "adcq 2*8(%[src]), %[res]\n\t"  
                          "adcq 3*8(%[src]), %[res]\n\t"  
                          "adcq 4*8(%[src]), %[res]\n\t"  
                          "adcq 5*8(%[src]), %[res]\n\t"  
                          "adcq 6*8(%[src]), %[res]\n\t"  
                          "adcq 7*8(%[src]), %[res]\n\t"  
                          "adcq %[zero], %[res]"  
                          : [res] "=r" (result)  
                          : [src] "r" (buff), [zero] "r" (zero), "[res]" (result));  
                buff += 64;  
                count64--;  
            }  

            /* 从这里开始，反序处理之前可能漏算的字节 */  

            /* last upto 7 8byte blocks，前面按8个8字节做计算单位，所以最多可能剩下7个8字节 */  
            count %= 8;  
            while (count) {  
                asm ("addq %1, %0\n\t"  
                     "adcq %2, %0\n"  
                     : "=r" (result)  
                     : "m" (*(unsigned long *)buff), "r" (zero), "0" (result));  
                --count;  
                buff += 8;  
            }  

            /* 带进位累加result的高32位和低32位 */  
            result = add32_with_carry(result&gt;&gt;32, result&amp;0xffffffff);  

            /* 之前始按8字节对齐，可能有4字节剩下 */  
            if (len &amp; 4) {  
                result += *(unsigned int *) buff;  
                buff += 4;  
            }  
        }  

       /* 更早前按4字节对齐，可能有2字节剩下 */  
        if (len &amp; 2) {  
            result += *(unsigned short *) buff;  
            buff += 2;  
        }  
    }  

    /* 最早之前按2字节对齐，可能有1字节剩下 */  
    if (len &amp; 1)  
        result += *buff;  

    /* 再次带进位累加result的高32位和低32位 */  
    result = add32_with_carry(result&gt;&gt;32, result &amp; 0xffffffff);   

    /* 这里涉及到一个技巧，用于处理初始地址为奇数的情况 */  
    if (unlikely(odd)) {  
        result = from32to16(result); /* 累加到result的低16位 */  
        /* result为：0 0 a b 
         * 然后交换a和b，result变为：0 0 b a 
         */  
        result = ((result &gt;&gt; 8) &amp; 0xff) | ((result &amp; oxff) &lt;&lt; 8);  
    }  

    return result; /* 返回result的低32位 */  
}  
</code></pre>

<pre><code></code></pre>

<pre><code>static inline unsigned short from32to16(unsigned a)  
{  
    unsigned short b = a &gt;&gt; 16;  
    asm ("addw %w2, %w0\n\t"  
              "adcw $0, %w0\n"  
              : "=r" (b)  
              : "0" (b), "r" (a));  
    return b;  
}  
</code></pre>

<pre><code>
csum_partial_copy_from_user()用于拷贝用户空间数据到内核空间，同时计算用户数据的校验和，结果保存到skb-&gt;csum中（X86_64）。
</code></pre>

<pre><code>/** 
 * csum_partial_copy_from_user - Copy and checksum from user space. 
 * @src: source address (user space) 
 * @dst: destination address 
 * @len: number of bytes to be copied. 
 * @isum: initial sum that is added into the result (32bit unfolded) 
 * @errp: set to -EFAULT for an bad source address. 
 * 
 * Returns an 32bit unfolded checksum of the buffer. 
 * src and dst are best aligned to 64bits. 
 */  

unsigned int csum_partial_copy_from_user(const unsigned char __user *src,  
                                  unsigned char *dst, int len, unsigned int isum, int *errp)  
{  
    might_sleep();  
    *errp = 0;  

    if (likely(access_ok(VERIFY_READ, src, len))) {  

        /* Why 6, not 7? To handle odd addresses aligned we would need to do considerable 
         * complications to fix the checksum which is defined as an 16bit accumulator. The fix 
         * alignment code is primarily for performance compatibility with 32bit and that will handle 
         * odd addresses slowly too. 
         * 处理X010、X100、X110的起始地址。不处理X001，因为这会使复杂度大增加。 
         */  
        if (unlikely((unsigned long)src &amp; 6)) {  
            while (((unsigned long)src &amp; 6) &amp;&amp; len &gt;= 2) {  
                __u16 val16;  
                *errp = __get_user(val16, (__u16 __user *)src);  
                if (*errp)  
                    return isum;  
                *(__u16 *)dst = val16;  
                isum = add32_with_carry(isum, val16);  
                src += 2;  
                dst += 2;  
                len -= 2;  
            }  
        }  

        /* 计算函数是用纯汇编实现的，应该是因为效率吧 */  
        isum = csum_parial_copy_generic((__force void *)src, dst, len, isum, errp, NULL);  

        if (likely(*errp == 0))  
            return isum; /* 成功 */  
    }  

    *errp = -EFAULT;  
    memset(dst, 0, len);  
    return isum;  
}  
</code></pre>

<pre><code>
上述的实现比较复杂，来看下最简单的csum_partial_copy_from_user()实现（um）。
</code></pre>

<pre><code>unsigned int csum_partial_copy_from_user(const unsigned char *src,  
                                         unsigned char *dst, int len, int sum,  
                                         int *err_ptr)  
{  
    if (copy_from_user(dst, src, len)) { /* 拷贝用户空间数据到内核空间 */  
        *err_ptr = -EFAULT; /* bad address */  
        return (-1);  
    }  

    return csum_partial(dst, len, sum); /* 计算用户数据的校验和，会存到skb-&gt;csum中 */  
}  
</code></pre>

<pre><code>
#### 接收校验

##### @tcp_v4_rcv
    /* 检查校验和 */
    if (skb-&gt;ip_summed != CHECKSUM_UNNECESSARY &amp;&amp; tcp_v4_checksum_init(skb))  
        goto bad_packet;   


接收校验的第一部分，主要是计算伪首部。
</code></pre>

<pre><code>static int tcp_v4_checksum_init(struct sk_buff *skb)  
{  
    /* 如果TCP报头、TCP数据的反码累加已经由硬件完成 */  
    if (skb-&gt;ip_summed == CHECKSUM_HW) {  

        /* 现在只需要再累加上伪首部，取反获取最终的校验和。 
         * 校验和为0时，表示TCP数据报正确。 
         */  
        if (! tcp_v4_check(skb-&gt;h.th, skb-&gt;len, skb-&gt;nh.iph-&gt;saddr, skb-&gt;nh.iph-&gt;daddr, skb-&gt;csum)) {  
            skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;  
            return 0; /* 校验成功 */  

        } /* 没有else失败退出吗？*/  
    }  

    /* 对伪首部进行反码累加，主要用于软件方法 */  
    skb-&gt;csum = csum_tcpudp_nofold(skb-&gt;nh.iph-&gt;saddr, skb-&gt;nh.iph-&gt;daddr, skb-&gt;len, IPPROTO_TCP, 0);  


    /* 对于长度小于76字节的小包，接着累加TCP报头和报文，完成校验；否则，以后再完成检验。*/  
    if (skb-&gt;len &lt;= 76) {  
        return __skb_checksum_complete(skb);  
    }  
}  
</code></pre>

<pre><code>
接收校验的第二部分，计算报头和报文。
</code></pre>

<p>tcp_v4_rcv、tcp_v4_do_rcv()</p>

<pre><code>| --&gt; tcp_checksum_complete()

            | --&gt; __tcp_checksum_complete()

                        | --&gt; __skb_checksum_complete()
</code></pre>

<p>tcp_rcv_established()</p>

<pre><code>| --&gt; tcp_checksum_complete_user()

            | --&gt; __tcp_checksum_complete_user()

                        | --&gt; __tcp_checksum_complete()

                                    | --&gt; __skb_checksum_complete()
</code></pre>

<pre><code></code></pre>

<pre><code>unsigned int __skb_checksum_complete(struct sk_buff *skb)  
{  
    unsigned int sum;  

    sum = (u16) csum_fold(skb_checksum(skb, 0, skb-&gt;len, skb-&gt;csum));  

    if (likely(!sum)) { /* sum为0表示成功了 */  
        /* 硬件检测失败，软件检测成功了，说明硬件检测有误 */  
        if (unlikely(skb-&gt;ip_summed == CHECKSUM_HW))  
            netdev_rx_csum_fault(skb-&gt;dev);  
        skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;  
    }  
    return sum;  
}  
</code></pre>

<pre><code>
计算skb包的校验和时，可以指定相对于skb-&gt;data的偏移量offset。由于skb包可能由分页和分段，所以需要考虑skb-&gt;data + offset是位于此skb段的线性区中、还是此skb的分页中，或者位于其它分段中。这个函数逻辑比较复杂。
</code></pre>

<pre><code>/* Checksum skb data. */  
unsigned int skb_checksum(const struct sk_buff *skb, int offset, int len, unsigned int csum)  
{  
    int start = skb_headlen(skb); /* 线性区域长度 */  
    /* copy &gt; 0，说明offset在线性区域中。 
     * copy &lt; 0，说明offset在此skb的分页数据中，或者在其它分段skb中。 
     */  
    int i, copy = start - offset;  
    int pos = 0; /* 表示校验了多少数据 */  

    /* Checksum header. */  
    if (copy &gt; 0) { /* 说明offset在本skb的线性区域中 */  
        if (copy &gt; len)  
            copy = len; /* 不能超过指定的校验长度 */  

        /* 累加copy长度的线性区校验 */  
        csum = csum_partial(skb-&gt;data + offset, copy, csum);  

        if ((len -= copy) == 0)  
            return csum;  

        offset += copy; /* 接下来从这里继续处理 */  
        pos = copy; /* 已处理数据长 */  
    }  

    /* 累加本skb分页数据的校验和 */  
    for (i = 0; i &lt; skb_shinfo(skb)-&gt;nr_frags; i++) {  
        int end;  
        BUG_TRAP(start &lt;= offset + len);  

        end = start + skb_shinfo(skb)-&gt;frags[i].size;  

        if ((copy = end - offset) &gt; 0) { /* 如果offset位于本页中，或者线性区中 */  
            unsigned int csum2;  
            u8 *vaddr; /* 8位够吗？*/  
            skb_frag_t *frag = &amp;skb_shinfo(skb)-&gt;frags[i];  

            if (copy &gt; len)  
                copy = len;  

            vaddr = kmap_skb_frag(frag); /* 把物理页映射到内核空间 */  
            csum2 = csum_partial(vaddr + frag-&gt;page_offset + offset - start, copy, 0);  
            kunmap_skb_frag(vaddr); /* 解除映射 */  

            /* 如果pos为奇数，需要对csum2进行处理。 
             * csum2：a, b, c, d =&gt; b, a, d, c 
             */  
            csum = csum_block_add(csum, csum2, pos);  

            if (! (len -= copy))  
                return csum;  

            offset += copy;  
            pos += copy;  
        }  
        start = end; /* 接下来从这里处理 */  
    }  

    /* 如果此skb是个大包，还有其它分段 */  
    if (skb_shinfo(skb)-&gt;frag_list) {  
        struct sk_buff *list = skb_shinfo(skb)-&gt;frag_list;  

        for (; list; list = list-&gt;next) {  
            int end;  
            BUG_TRAP(start &lt;= offset + len);  

            end = start + list-&gt;len;  

            if ((copy = end - offset) &gt; 0) { /* 如果offset位于此skb分段中，或者分页，或者线性区 */  
                unsigned int csum2;  
                if (copy &gt; len)  
                    copy = len;  

                csum2 = skb_checksum(list, offset - start, copy, 0); /* 递归调用 */  
                csum = csum_block_add(csum, csum2, pos);  
                if ((len -= copy) == 0)  
                    return csum;  

                offset += copy;  
                pos += copy;  
            }  
            start = end;  
        }  
    }  

    BUG_ON(len);  
    return csum;  
}
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux网络编程：原始套接字 SOCK_RAW]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/04/14/kernel-net-sock-raw/"/>
    <updated>2015-04-14T21:27:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/04/14/kernel-net-sock-raw</id>
    <content type="html"><![CDATA[<p><a href="http://blog.chinaunix.net/uid-23069658-id-3280895.html">http://blog.chinaunix.net/uid-23069658-id-3280895.html</a></p>

<h4>一、修改iphdr+tcphdr</h4>

<p>对于TCP或UDP的程序开发，焦点在Data字段，我们没法直接对TCP或UDP头部字段进行赤裸裸的修改，当然还有IP头。换句话说，我们对它们头部操作的空间非常受限，只能使用它们已经开放给我们的诸如源、目的IP，源、目的端口等等。</p>

<p>原始套接字的创建方法：
<code>
    socket(AF_INET, SOCK_RAW, protocol);
</code>
  重点在protocol字段，这里就不能简单的将其值为0了。在头文件netinet/in.h中定义了系统中该字段目前能取的值，注意：有些系统中不一定实现了netinet/in.h中的所有协议。源代码的linux/in.h中和netinet/in.h中的内容一样。我们常见的有IPPROTO_TCP，IPPROTO_UDP和IPPROTO_ICMP。</p>

<p>用这种方式我就可以得到原始的IP包了，然后就可以自定义IP所承载的具体协议类型，如TCP，UDP或ICMP，并手动对每种承载在IP协议之上的报文进行填充。</p>

<p>先简单复习一下TCP报文的格式</p>

<p><img src="/images/kernel/2015-04-14-1.jpg" alt="" /></p>

<p><img src="/images/kernel/2015-04-14-2.jpg" alt="" /></p>

<p>原始套接字还提供了一个非常有用的参数IP_HDRINCL：</p>

<p>1、当开启该参数时：我们可以从IP报文首部第一个字节开始依次构造整个IP报文的所有选项，但是IP报文头部中的标识字段(设置为0时)和IP首部校验和字段总是由内核自己维护的，不需要我们关心。</p>

<p>2、如果不开启该参数：我们所构造的报文是从IP首部之后的第一个字节开始，IP首部由内核自己维护，首部中的协议字段被设置成调用socket()函数时我们所传递给它的第三个参数。</p>

<p> 开启IP_HDRINCL特性的模板代码一般为：
<code>
    const int on =1;
    if (setsockopt (sockfd, IPPROTO_IP, IP_HDRINCL, &amp;on, sizeof(on)) &lt; 0) {
        printf("setsockopt error!\n");
    }
</code></p>

<p>所以，我们还得复习一下IP报文的首部格式：</p>

<p><img src="/images/kernel/2015-04-14-3.jpg" alt="" /></p>

<p>同样，我们重点关注IP首部中的着色部分区段的填充情况。</p>

<pre><code>    #include &lt;stdlib.h&gt;
    #include &lt;stdio.h&gt;
    #include &lt;errno.h&gt;
    #include &lt;string.h&gt;
    #include &lt;unistd.h&gt;
    #include &lt;netdb.h&gt;
    #include &lt;sys/socket.h&gt;
    #include &lt;sys/types.h&gt;
    #include &lt;netinet/in.h&gt;
    #include &lt;netinet/ip.h&gt;
    #include &lt;arpa/inet.h&gt;
    #include &lt;linux/tcp.h&gt;

    #include &lt;linux/if_ether.h&gt;
    #include &lt;linux/if_arp.h&gt;
    #include &lt;linux/sockios.h&gt;

    unsigned csum_tcpudp_nofold(unsigned saddr, unsigned daddr,
                unsigned len, unsigned proto, unsigned sum)
    {
        unsigned long long s = (unsigned)sum;
        s += (unsigned)saddr;
        s += (unsigned)daddr;
        s += (proto + len) &lt;&lt; 8;
        s += (s &gt;&gt; 32);
        return (unsigned)s;
    }

    unsigned short check_sum(unsigned short *addr, int len, unsigned sum)
    {
        int nleft = len;
        unsigned short *w = addr;
        unsigned short ret = 0;
        while (nleft &gt; 1) {
            sum += *w++;
            nleft -= 2;
        }
        if (nleft == 1) {
            *(unsigned char *)(&amp;ret) = *(unsigned char *)w;
            sum += ret;
        }

        sum = (sum&gt;&gt;16) + (sum&amp;0xffff);
        sum += (sum&gt;&gt;16);
        ret = ~sum;
        return ret;
    }

    //在该函数中构造整个IP报文，最后调用sendto函数将报文发送出去
    void attack(int skfd, struct sockaddr_in *target, unsigned short srcport)
    {
        char buf[256] = {0};
        struct ip *ip;
        struct tcphdr *tcp;
        int ip_len;
        int op_len = 12;

        //在我们TCP的报文中Data没有字段，所以整个IP报文的长度
        ip_len = sizeof(struct ip) + sizeof(struct tcphdr) + op_len;

        //开始填充IP首部
        ip=(struct ip*)buf;
        ip-&gt;ip_v = IPVERSION;
        ip-&gt;ip_hl = sizeof(struct ip)&gt;&gt;2;
        ip-&gt;ip_tos = 0;
        ip-&gt;ip_len = htons(ip_len);
        ip-&gt;ip_id = 0;
        ip-&gt;ip_off = 0;
        ip-&gt;ip_ttl = MAXTTL;
        ip-&gt;ip_p = IPPROTO_TCP;
        ip-&gt;ip_sum = 0;
        ip-&gt;ip_dst = target-&gt;sin_addr;

        //开始填充TCP首部
        tcp = (struct tcphdr*)(buf+sizeof(struct ip));
        tcp-&gt;source = htons(srcport);
        tcp-&gt;dest = target-&gt;sin_port;
        srand(time(NULL));
        tcp-&gt;doff = (sizeof(struct tcphdr) + op_len) &gt;&gt; 2; // tcphdr + option
        tcp-&gt;syn = 1;
        tcp-&gt;check = 0;
        tcp-&gt;window = ntohs(14600);

        int i = ip_len - op_len;
        // mss = 1460
        buf[i++] = 0x02;
        buf[i++] = 0x04;
        buf[i++] = 0x05;
        buf[i++] = 0xb4;
        // sack
        buf[i++] = 0x01;
        buf[i++] = 0x01;
        buf[i++] = 0x04;
        buf[i++] = 0x02;
        // wsscale = 7
        buf[i++] = 0x01;
        buf[i++] = 0x03;
        buf[i++] = 0x03;
        buf[i++] = 0x07;

        int T = 1;
        while(1) {
            if (T == 0) break;
            T--;
            tcp-&gt;seq = random();
            //源地址伪造，我们随便任意生成个地址，让服务器一直等待下去
            //ip-&gt;ip_src.s_addr = random();
            //自定义源地址192.168.204.136 = 0xc0a8cc88; 反转赋值
            ip-&gt;ip_src.s_addr = 0x88cca8c0;
            unsigned sum = csum_tcpudp_nofold(ip-&gt;ip_src.s_addr, ip-&gt;ip_dst.s_addr, sizeof(struct tcphdr)+op_len, IPPROTO_TCP, 0);
            tcp-&gt;check = check_sum((unsigned short*)tcp, sizeof(struct tcphdr)+op_len, sum);
    //      ip-&gt;ip_sum = check_sum((unsigned short*)ip, sizeof(struct ip), 0);
            sendto(skfd, buf, ip_len, 0, (struct sockaddr*)target, sizeof(struct sockaddr_in));
        }
    }

    int main(int argc, char** argv)
    {
        int skfd;
        struct sockaddr_in target;
        struct hostent *host;
        const int on = 1;
        unsigned short srcport;

        if (argc != 4) {
            printf("Usage:%s dstip dstport srcport\n", argv[0]);
            exit(1);
        }

        bzero(&amp;target, sizeof(struct sockaddr_in));
        target.sin_family = AF_INET;
        target.sin_port = htons(atoi(argv[2]));

        if (inet_aton(argv[1], &amp;target.sin_addr) == 0) {
            host = gethostbyname(argv[1]);
            if(host == NULL) {
                printf("TargetName Error:%s\n", hstrerror(h_errno));
                exit(1);
            }
            target.sin_addr = *(struct in_addr *)(host-&gt;h_addr_list[0]);
        }

        //将协议字段置为IPPROTO_TCP，来创建一个TCP的原始套接字
        if (0 &gt; (skfd = socket(AF_INET, SOCK_RAW, IPPROTO_TCP))) {
            perror("Create Error");
            exit(1);
        }

        //用模板代码来开启IP_HDRINCL特性，我们完全自己手动构造IP报文
        if (0 &gt; setsockopt(skfd, IPPROTO_IP, IP_HDRINCL, &amp;on, sizeof(on))) {
            perror("IP_HDRINCL failed");
            exit(1);
        }

        //因为只有root用户才可以play with raw socket :)
        setuid(getpid());
        srcport = atoi(argv[3]);
        attack(skfd, &amp;target, srcport);
    }
</code></pre>

<ul>
<li>原始套接字上也可以调用connet、bind之类的函数</li>
</ul>


<hr />

<h4>修改mac+iphdr+tcphdr</h4>

<p>blog.chinaunix.net/uid-23069658-id-3283534.html</p>

<p>在Linux系统中要从链路层(MAC)直接收发数帧，比较普遍的做法就是用libpcap和libnet两个动态库来实现。但今天我们就要用原始套接字来实现这个功能。</p>

<p><img src="/images/kernel/2015-04-14-4.jpg" alt="" /></p>

<p>这里的2字节帧类型用来指示该数据帧所承载的上层协议是IP、ARP或其他。</p>

<p>为了实现直接从链路层收发数据帧，我们要用到原始套接字的如下形式：
<code>
    socket(PF_PACKET, type, protocol)
</code>
1、其中type字段可取SOCK_RAW或SOCK_DGRAM。它们两个都使用一种与设备无关的标准物理层地址结构struct sockaddr_ll{}，但具体操作的报文格式不同：</p>

<p>SOCK_RAW：直接向网络硬件驱动程序发送(或从网络硬件驱动程序接收)没有任何处理的完整数据报文(包括物理帧的帧头)，这就要求我们必须了解对应设备的物理帧帧头结构，才能正确地装载和分析报文。也就是说我们用这种套接字从网卡驱动上收上来的报文包含了MAC头部，如果我们要用这种形式的套接字直接向网卡发送数据帧，那么我们必须自己组装我们MAC头部。这正符合我们的需求。</p>

<p>SOCK_DGRAM：这种类型的套接字对于收到的数据报文的物理帧帧头会被系统自动去掉，然后再将其往协议栈上层传递；同样地，在发送时数据时，系统将会根据sockaddr_ll结构中的目的地址信息为数据报文添加一个合适的MAC帧头。</p>

<p>2、protocol字段，常见的，一般情况下该字段取ETH_P_IP，ETH_P_ARP，ETH_P_RARP或ETH_P_ALL，当然链路层协议很多，肯定不止我们说的这几个，但我们一般只关心这几个就够我们用了。这里简单提一下网络数据收发的一点基础。协议栈在组织数据收发流程时需要处理好两个方面的问题：“从上倒下”，即数据发送的任务；“从下到上”，即数据接收的任务。数据发送相对接收来说要容易些，因为对于数据接收而言，网卡驱动还要明确什么样的数据该接收、什么样的不该接收等问题。protocol字段可选的四个值及其意义如下：</p>

<p>protocol        值        作用<br/>
ETH_P_IP      0X0800   只接收发往目的MAC是本机的IP类型的数据帧<br/>
ETH_P_ARP     0X0806   只接收发往目的MAC是本机的ARP类型的数据帧<br/>
ETH_P_RARP    0X8035   只接受发往目的MAC是本机的RARP类型的数据帧<br/>
ETH_P_ALL     0X0003   接收发往目的MAC是本机的所有类型(ip,arp,rarp)的数据帧，同时还可以接收从本机发出去的所有数据帧。在混杂模式打开的情况下，还会接收到发往目的MAC为非本地硬件地址的数据帧。</p>

<p>protocol字段可取的所有协议参见/usr/include/linux/if_ether.h头文件里的定义。</p>

<p>最后，格外需要留心一点的就是，发送数据的时候需要自己组织整个以太网数据帧。和地址相关的结构体就不能再用前面的struct sockaddr_in{}了，而是struct sockaddr_ll{}，如下：</p>

<pre><code>    struct sockaddr_ll{
        unsigned short sll_family; /* 总是 AF_PACKET */
        unsigned short sll_protocol; /* 物理层的协议 */
        int sll_ifindex; /* 接口号 */
        unsigned short sll_hatype; /* 报头类型 */
        unsigned char sll_pkttype; /* 分组类型 */
        unsigned char sll_halen; /* 地址长度 */
        unsigned char sll_addr[8]; /* 物理层地址 */
    };
</code></pre>

<p>  sll_protocoll：取值在linux/if_ether.h中，可以指定我们所感兴趣的二层协议；</p>

<p>  sll_ifindex：置为0表示处理所有接口，对于单网卡的机器就不存在“所有”的概念了。如果你有多网卡，该字段的值一般通过ioctl来搞定，模板代码如下，如果我们要获取eth0接口的序号，可以使用如下代码来获取：</p>

<pre><code>    struct  sockaddr_ll  sll;
    struct ifreq ifr;

    strcpy(ifr.ifr_name, "eth0");
    ioctl(sockfd, SIOCGIFINDEX, &amp;ifr);
    sll.sll_ifindex = ifr.ifr_ifindex;
</code></pre>

<p>  sll_hatype：ARP硬件地址类型，定义在 linux/if_arp.h 中。 取ARPHRD_ETHER时表示为以太网。</p>

<p>  sll_pkttype：包含分组类型。目前，有效的分组类型有：目标地址是本地主机的分组用的 PACKET_HOST，物理层广播分组用的 PACKET_BROADCAST ，发送到一个物理层多路广播地址的分组用的 PACKET_MULTICAST，在混杂(promiscuous)模式下的设备驱动器发向其他主机的分组用的 PACKET_OTHERHOST，源于本地主机的分组被环回到分组套接口用的 PACKET_OUTGOING。这些类型只对接收到的分组有意义。</p>

<p>  sll_addr和sll_halen指示物理层(如以太网，802.3，802.4或802.5等)地址及其长度，严格依赖于具体的硬件设备。类似于获取接口索引sll_ifindex，要获取接口的物理地址，可以采用如下代码：</p>

<pre><code>    struct ifreq ifr;

    strcpy(ifr.ifr_name, "eth0");
    ioctl(sockfd, SIOCGIFHWADDR, &amp;ifr);
</code></pre>

<p> 缺省情况下，从任何接口收到的符合指定协议的所有数据报文都会被传送到原始PACKET套接字口，而使用bind系统调用并以一个sochddr_ll结构体对象将PACKET套接字与某个网络接口相绑定，就可使我们的PACKET原始套接字只接收指定接口的数据报文。</p>

<p> 接下来我们简单介绍一下网卡是怎么收报的，如果你对这部分已经很了解可以跳过这部分内容。网卡从线路上收到信号流，网卡的驱动程序会去检查数据帧开始的前6个字节，即目的主机的MAC地址，如果和自己的网卡地址一致它才会接收这个帧，不符合的一般都是直接无视。然后该数据帧会被网络驱动程序分解，IP报文将通过网络协议栈，最后传送到应用程序那里。往上层传递的过程就是一个校验和“剥头”的过程，由协议栈各层去实现。</p>

<p>接下来我们来写个简单的抓包程序，将那些发给本机的IPv4报文全打印出来：</p>

<pre><code>    #include &lt;stdio.h&gt;
    #include &lt;stdlib.h&gt;
    #include &lt;errno.h&gt;
    #include &lt;unistd.h&gt;
    #include &lt;sys/socket.h&gt;
    #include &lt;sys/types.h&gt;
    #include &lt;netinet/in.h&gt;
    #include &lt;netinet/ip.h&gt;
    #include &lt;netinet/if_ether.h&gt;

    int main(int argc, char **argv)
    {
        int sock, n;
        char buffer[2048];
        struct ethhdr *eth;
        struct iphdr *iph;

        if (0 &gt; (sock = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_IP)))) {
            perror("socket");
            exit(1);
        }

        while (1) {
            printf("=====================================\n");
            //注意：在这之前我没有调用bind函数，原因是什么呢？
            n = recvfrom(sock, buffer, 2048, 0, NULL, NULL);
            printf("%d bytes read\n", n);

            //接收到的数据帧头6字节是目的MAC地址，紧接着6字节是源MAC地址。
            eth = (struct ethhdr*)buffer;
            printf("Dest MAC addr:%02x:%02x:%02x:%02x:%02x:%02x\n",eth-&gt;h_dest[0],eth-&gt;h_dest[1],eth-&gt;h_dest[2],eth-&gt;h_dest[3],eth-&gt;h_dest[4],eth-&gt;h_dest[5]);
            printf("Source MAC addr:%02x:%02x:%02x:%02x:%02x:%02x\n",eth-&gt;h_source[0],eth-&gt;h_source[1],eth-&gt;h_source[2],eth-&gt;h_source[3],eth-&gt;h_source[4],eth-&gt;h_source[5]);

            iph = (struct iphdr*)(buffer + sizeof(struct ethhdr));
            //我们只对IPV4且没有选项字段的IPv4报文感兴趣
            if(iph-&gt;version == 4 &amp;&amp; iph-&gt;ihl == 5){
                unsigned char *sd, *dd;
                sd = (unsigned char*)&amp;iph-&gt;saddr;
                dd = (unsigned char*)&amp;iph-&gt;daddr;
                printf("Source Host: %d.%d.%d.%d Dest host: %d.%d.%d.%d\n", sd[0], sd[1], sd[2], sd[3], dd[0], dd[1], dd[2], dd[3]);
            //  printf("Source host:%s\n", inet_ntoa(iph-&gt;saddr));
            //  printf("Dest host:%s\n", inet_ntoa(iph-&gt;daddr));
            }
        }
        return 0;
    }
</code></pre>

<p>构造mac源地址包，注意目标mac地址要正确，可以本机先抓包看看是什么</p>

<pre><code>    #include &lt;stdlib.h&gt;
    #include &lt;stdio.h&gt;
    #include &lt;errno.h&gt;
    #include &lt;string.h&gt;
    #include &lt;unistd.h&gt;
    #include &lt;netdb.h&gt;
    #include &lt;sys/socket.h&gt;
    #include &lt;sys/types.h&gt;
    #include &lt;netinet/in.h&gt;
    #include &lt;netinet/ip.h&gt;
    #include &lt;arpa/inet.h&gt;
    #include &lt;linux/tcp.h&gt;

    #include &lt;linux/if_ether.h&gt;
    #include &lt;linux/if_arp.h&gt;
    #include &lt;linux/sockios.h&gt;

    unsigned csum_tcpudp_nofold(unsigned saddr, unsigned daddr,
                unsigned len, unsigned proto, unsigned sum)
    {
        unsigned long long s = (unsigned)sum;
        s += (unsigned)saddr;
        s += (unsigned)daddr;
        s += (proto + len) &lt;&lt; 8;
        s += (s &gt;&gt; 32);
        return (unsigned)s;
    }

    unsigned short check_sum(unsigned short *addr, int len, unsigned sum)
    {
        int nleft = len;
        unsigned short *w = addr;
        unsigned short ret = 0;
        while (nleft &gt; 1) {
            sum += *w++;
            nleft -= 2;
        }
        if (nleft == 1) {
            *(unsigned char *)(&amp;ret) = *(unsigned char *)w;
            sum += ret;
        }

        sum = (sum&gt;&gt;16) + (sum&amp;0xffff);
        sum += (sum&gt;&gt;16);
        ret = ~sum;
        return ret;
    }

    int change(char c)
    {
        if (c &gt;= 'a') return c-'a'+10;
        if (c &gt;= 'A') return c-'A'+10;
        return c-'0';
    }

    //在该函数中构造整个IP报文，最后调用sendto函数将报文发送出去
    void attack(int skfd, struct sockaddr_ll *target, char **argv)
    {
        char buf[512]={0};
        struct ethhdr *eth;
        struct ip *ip;
        struct tcphdr *tcp;
        int pks_len;
        int i;
        int op_len = 12;
        unsigned short dstport;
        dstport = atoi(argv[3]);

        //在我们TCP的报文中Data没有字段，所以整个IP报文的长度
        pks_len = sizeof(struct ethhdr) + sizeof(struct ip) + sizeof(struct tcphdr) + op_len;
        eth = (struct ethhdr *) buf;
        /*
        eth-&gt;h_dest[0] = 0x00;
        eth-&gt;h_dest[1] = 0x50;
        eth-&gt;h_dest[2] = 0x56;
        eth-&gt;h_dest[3] = 0xee;
        eth-&gt;h_dest[4] = 0x14;
        eth-&gt;h_dest[5] = 0xa6;
        */

        for (i=0;i&lt;6;i++)
            eth-&gt;h_dest[i] = change(argv[1][i*3])*16 + change(argv[1][i*3+1]);

        /*
        eth-&gt;h_source[0] = 0x00;
        eth-&gt;h_source[1] = 0x0b;
        eth-&gt;h_source[2] = 0x28;
        eth-&gt;h_source[3] = 0xd7;
        eth-&gt;h_source[4] = 0x26;
        eth-&gt;h_source[5] = 0xa6;
        */
        eth-&gt;h_proto = ntohs(ETH_P_IP);

        //开始填充IP首部
        ip=(struct ip*)(buf + sizeof(struct ethhdr));
        ip-&gt;ip_v = IPVERSION;
        ip-&gt;ip_hl = sizeof(struct ip) &gt;&gt; 2;
        ip-&gt;ip_tos = 0;
        ip-&gt;ip_len = htons(pks_len - sizeof(struct ethhdr));
        ip-&gt;ip_id = 0;
        ip-&gt;ip_off = 0;
        ip-&gt;ip_ttl = MAXTTL;
        ip-&gt;ip_p = IPPROTO_TCP;
        ip-&gt;ip_sum = 0;
        ip-&gt;ip_dst.s_addr = inet_addr(argv[2]);

        //开始填充TCP首部
        srand(time(NULL));
        tcp = (struct tcphdr*)(buf + sizeof(struct ethhdr) + sizeof(struct ip));
        tcp-&gt;source = random()%50000+10000;
        tcp-&gt;dest = ntohs(dstport);
        tcp-&gt;seq = random();
        tcp-&gt;doff = (sizeof(struct tcphdr) + op_len) &gt;&gt; 2;
        tcp-&gt;syn = 1;
        tcp-&gt;check = 0;
        tcp-&gt;window = ntohs(14600);

        i = pks_len - op_len;
        // mss = 1460
        buf[i++] = 0x02;
        buf[i++] = 0x04;
        buf[i++] = 0x05;
        buf[i++] = 0xb4;
        // sack
        buf[i++] = 0x01;
        buf[i++] = 0x01;
        buf[i++] = 0x04;
        buf[i++] = 0x02;
        // wsscale = 7
        buf[i++] = 0x01;
        buf[i++] = 0x03;
        buf[i++] = 0x03;
        buf[i++] = 0x07;

        int T = 1;
        while(1) {
            if (T == 0) break;
            T--;
            //源地址伪造，我们随便任意生成个地址，让服务器一直等待下去
            ip-&gt;ip_src.s_addr = random();
            //自定义源地址192.168.204.136 =&gt; 0xc0a8cc88
            //ip-&gt;ip_src.s_addr = 0x8fcca8c0;
            unsigned sum = csum_tcpudp_nofold(ip-&gt;ip_src.s_addr, ip-&gt;ip_dst.s_addr, sizeof(struct tcphdr)+op_len, IPPROTO_TCP, 0);
            tcp-&gt;check = check_sum((unsigned short*)tcp, sizeof(struct tcphdr)+op_len, sum);
            ip-&gt;ip_sum = check_sum((unsigned short*)ip, sizeof(struct ip), 0);
            sendto(skfd, buf, pks_len, 0, (struct sockaddr*)target, sizeof(struct sockaddr_ll));
        }
    }

    int main(int argc, char** argv)
    {
        int skfd;
        struct sockaddr_ll target;
        struct hostent *host;
        const int on=1;

        if (argc != 4) {
            printf("Usage:%s dstmac dstip dstport\n", argv[0]);
            exit(1);
        }
        if (strlen(argv[1]) != 17) {
            printf("Usage: dstmac must be xx:xx:xx:xx:xx:xx\n");
            exit(1);
        }

        //将协议字段置为IPPROTO_TCP，来创建一个TCP的原始套接字
        if (0 &gt; (skfd = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_IP)))) {
            perror("Create Error");
            exit(1);
        }

        // mac
        bzero(&amp;target, sizeof(struct sockaddr_ll));

        struct ifreq ifr;
        strncpy(ifr.ifr_name, "eth0", IFNAMSIZ);
        ioctl(skfd, SIOCGIFINDEX, &amp;ifr);
        target.sll_ifindex = ifr.ifr_ifindex;
        /*
        target.sll_family = AF_PACKET;
        target.sll_protocol = ntohs(80);
        target.sll_hatype = ARPHRD_ETHER;
        target.sll_pkttype = PACKET_OTHERHOST;
        target.sll_halen = ETH_ALEN;
        memset(target.sll_addr,0,8);
        target.sll_addr[0] = 0x00;
        target.sll_addr[1] = 0x0C;
        target.sll_addr[2] = 0x29;
        target.sll_addr[3] = 0x61;
        target.sll_addr[4] = 0xB6;
        target.sll_addr[5] = 0x43;
        */


        /*
        //http://blog.chinaunix.net/uid-305141-id-2133781.html
        struct sockaddr_ll sll;
        struct ifreq ifstruct;
        memset (&amp;sll, 0, sizeof (sll));
        sll.sll_family = PF_PACKET;
        sll.sll_protocol = htons (ETH_P_IP);

        strcpy (ifstruct.ifr_name, "eth0");
        ioctl (skfd, SIOCGIFINDEX, &amp;ifstruct);
        sll.sll_ifindex = ifstruct.ifr_ifindex;

        strcpy (ifstruct.ifr_name, "eth0");
        ioctl (skfd, SIOCGIFHWADDR, &amp;ifstruct);
        memcpy (sll.sll_addr, ifstruct.ifr_ifru.ifru_hwaddr.sa_data, ETH_ALEN);
        sll.sll_halen = ETH_ALEN;

        if (bind (skfd, (struct sockaddr *) &amp;sll, sizeof (sll)) == -1) {
            printf ("bind:   ERROR\n");
            return -1;
        }

        memset(&amp;ifstruct, 0, sizeof(ifstruct));
        strcpy (ifstruct.ifr_name, "eth0");
        if (ioctl (skfd, SIOCGIFFLAGS, &amp;ifstruct) == -1) {
            perror ("iotcl()\n");
            printf ("Fun:%s Line:%d\n", __func__, __LINE__);
            return -1;
        }

        ifstruct.ifr_flags |= IFF_PROMISC;

        if(ioctl(skfd, SIOCSIFFLAGS, &amp;ifstruct) == -1) {
            perror("iotcl()\n");
            printf ("Fun:%s Line:%d\n", __func__, __LINE__);
            return -1;
        } 
    */
        //因为只有root用户才可以play with raw socket :)
        setuid(getpid());
    //  attack(skfd, &amp;sll, srcport);
        attack(skfd, &amp;target, argv);
    }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[sk_buff详解]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/04/10/kernel-net-skbuff/"/>
    <updated>2015-04-10T15:46:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/04/10/kernel-net-skbuff</id>
    <content type="html"><![CDATA[<p><a href="/download/kernel/sk_buff%E8%AF%A6%E8%A7%A3.pdf">sk_buff详解</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux TCP数据包接收处理 tcp_recvmsg]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/04/10/kernel-net-rcvmsg/"/>
    <updated>2015-04-10T15:29:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/04/10/kernel-net-rcvmsg</id>
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/mrpre/article/details/33347221">http://blog.csdn.net/mrpre/article/details/33347221</a></p>

<pre><code>    /* 
     *  This routine copies from a sock struct into the user buffer.
     *
     *  Technical note: in 2.3 we work on _locked_ socket, so that
     *  tricks with *seq access order and skb-&gt;users are not required.
     *  Probably, code can be easily improved even more.
     */

    int tcp_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
            size_t len, int nonblock, int flags, int *addr_len)
    {
        struct tcp_sock *tp = tcp_sk(sk);
        int copied = 0;
        u32 peek_seq;
        u32 *seq;
        unsigned long used;
        int err;
        int target;  /* Read at least this many bytes */
        long timeo;
        struct task_struct *user_recv = NULL;
        int copied_early = 0;
        struct sk_buff *skb;
        u32 urg_hole = 0;

        //功能：“锁住sk”，并非真正的加锁，而是执行sk-&gt;sk_lock.owned = 1 
        //目的：这样软中断上下文能够通过owned ，判断该sk是否处于进程上下文。
        //提供一种同步机制。
        lock_sock(sk);

        TCP_CHECK_TIMER(sk);

        err = -ENOTCONN;
        if (sk-&gt;sk_state == TCP_LISTEN)
            goto out;

        //获取延迟，如果用户设置为非阻塞，那么timeo ==0000 0000 0000 0000
        //如果用户使用默认recv系统调用
        //则为阻塞，此时timeo ==0111 1111 1111 1111
        //timeo 就2个值
        timeo = sock_rcvtimeo(sk, nonblock);

        /* Urgent data needs to be handled specially. */
        if (flags &amp; MSG_OOB)
            goto recv_urg;

        //待拷贝的下一个序列号
        seq = &amp;tp-&gt;copied_seq;

        //设置了MSG_PEEK，表示不让数据从缓冲区移除，目的是下一次调用recv函数
        //仍然能够读到相同数据
        if (flags &amp; MSG_PEEK) {
            peek_seq = tp-&gt;copied_seq;
            seq = &amp;peek_seq;
        }

        //如果设置了MSG_WAITALL，则target  ==len，即recv函数中的参数len
        //如果没设置MSG_WAITALL，则target  == 1
        target = sock_rcvlowat(sk, flags &amp; MSG_WAITALL, len);

        //大循环
        do {
            u32 offset;

            /* Are we at urgent data? Stop if we have read anything or have SIGURG pending. */
            if (tp-&gt;urg_data &amp;&amp; tp-&gt;urg_seq == *seq) {
                if (copied)
                    break;
                if (signal_pending(current)) {
                    copied = timeo ? sock_intr_errno(timeo) : -EAGAIN;
                    break;
                }
            }

            /* Next get a buffer. */

            //小循环
            skb_queue_walk(&amp;sk-&gt;sk_receive_queue, skb) {
                /* Now that we have two receive queues this
                    * shouldn't happen.
                    */
                if (WARN(before(*seq, TCP_SKB_CB(skb)-&gt;seq),
                                    KERN_INFO "recvmsg bug: copied %X "
                                                "seq %X rcvnxt %X fl %X\n", *seq,
                                                TCP_SKB_CB(skb)-&gt;seq, tp-&gt;rcv_nxt,
                                                flags))
                    break;

                //如果用户的缓冲区(即用户malloc的buf)长度够大，offset一般是0。
                //即 “下次准备拷贝数据的序列号”==此时获取报文的起始序列号
                //什么情况下offset &gt;0呢？很简答，如果用户缓冲区12字节，而这个skb有120字节
                //那么一次recv系统调用，只能获取skb中的前12个字节，下一次执行recv系统调用
                //offset就是12了，offset表示从第12个字节开始读取数据，前12个字节已经读取了。
                //那这个"已经读取12字节"这个消息，存在哪呢？
                //在*seq = &amp;tp-&gt;copied_seq;中
                offset = *seq - TCP_SKB_CB(skb)-&gt;seq;
                if (tcp_hdr(skb)-&gt;syn)
                    offset--;
                if (offset &lt; skb-&gt;len)
                    goto found_ok_skb;
                if (tcp_hdr(skb)-&gt;fin)
                    goto found_fin_ok;
                WARN(!(flags &amp; MSG_PEEK), KERN_INFO "recvmsg bug 2: "
                        "copied %X seq %X rcvnxt %X fl %X\n",
                        *seq, TCP_SKB_CB(skb)-&gt;seq,
                        tp-&gt;rcv_nxt, flags);
            }

            //执行到了这里，表明小循环中break了，既然break了，说明sk_receive_queue中
            //已经没有skb可以读取了
            //如果没有执行到这里说明前面的小循环中执行了goto，读到有用的skb，或者读到fin都会goto。
            //没有skb可以读取，说明什么？
            //可能性1：当用户第一次调用recv时，压根没有数据到来
            //可能性2：skb-&gt;len一共20字节，假设用户调用一次 recv，读取12字节，再调用recv，
            //读取12字节，此时skb由于上次已经被读取了12字节，只剩下8字节。
            //于是代码的逻辑上，再会要求获取skb，来读取剩下的8字节。

            //可能性1的情况下，copied == 0，肯定不会进这个if。后续将执行休眠
            //可能性2的情况下，情况比较复杂。可能性2表明数据没有读够用户想要的len长度
            //虽然进程上下文中，没有读够数据，但是可能我们在读数据的时候
            //软中断把数据放到backlog队列中了，而backlog对队列中的数据或许恰好让我们读够数
            //据。

            //copied了数据的，copied肯定&gt;=1，而target 是1或者len
            //copied只能取0(可能性1)，或者0~len(可能性2)
            //copied &gt;= target 表示我们取得我们想要的数据了，何必进行休眠，直接return
            //如果copied 没有达到我们想要的数据，则看看sk_backlog是否为空
            //空的话，尽力了，只能尝试休眠
            //非空的话，还有一线希望，我们去sk_backlog找找数据，看看是否能够达到我们想要的
            //数据大小

            //我觉得copied == target是会出现的，但是出现的话，也不会进现在这个流程
            //，如有不对，请各位大神指正，告诉我
            //说明情况下copied == target

            /* Well, if we have backlog, try to process it now yet. */
            if (copied &gt;= target &amp;&amp; !sk-&gt;sk_backlog.tail)
                break;


            if (copied) {
                //可能性2，拷贝了数据，但是没有拷贝到指定大小
                if (sk-&gt;sk_err ||
                                sk-&gt;sk_state == TCP_CLOSE ||
                                (sk-&gt;sk_shutdown &amp; RCV_SHUTDOWN) ||
                                !timeo ||
                                signal_pending(current))
                    break;
            } else {
                //可能性1
                if (sock_flag(sk, SOCK_DONE))
                    break;

                if (sk-&gt;sk_err) {
                    copied = sock_error(sk);
                    break;
                }

                if (sk-&gt;sk_shutdown &amp; RCV_SHUTDOWN)
                    break;

                if (sk-&gt;sk_state == TCP_CLOSE) {
                    if (!sock_flag(sk, SOCK_DONE)) {
                        /* This occurs when user tries to read
                            * from never connected socket.
                            */
                        copied = -ENOTCONN;
                        break;
                    }
                    break;
                }

                //是否是阻塞的，不是，就return了。
                if (!timeo) {
                    copied = -EAGAIN;
                    break;
                }

                if (signal_pending(current)) {
                    copied = sock_intr_errno(timeo);
                    break;
                }
            }

            tcp_cleanup_rbuf(sk, copied);

            //sysctl_tcp_low_latency 默认0tp-&gt;ucopy.task == user_recv肯定也成立

            if (!sysctl_tcp_low_latency &amp;&amp; tp-&gt;ucopy.task == user_recv) {
                /* Install new reader */
                if (!user_recv &amp;&amp; !(flags &amp; (MSG_TRUNC | MSG_PEEK))) {
                    user_recv = current;
                    tp-&gt;ucopy.task = user_recv;
                    tp-&gt;ucopy.iov = msg-&gt;msg_iov;
                }

                tp-&gt;ucopy.len = len;

                WARN_ON(tp-&gt;copied_seq != tp-&gt;rcv_nxt &amp;&amp;
                    !(flags &amp; (MSG_PEEK | MSG_TRUNC)));

                /* Ugly... If prequeue is not empty, we have to
                    * process it before releasing socket, otherwise
                    * order will be broken at second iteration.
                    * More elegant solution is required!!!
                    *
                    * Look: we have the following (pseudo)queues:
                    *
                    * 1. packets in flight
                    * 2. backlog
                    * 3. prequeue
                    * 4. receive_queue
                    *
                    * Each queue can be processed only if the next ones
                    * are empty. At this point we have empty receive_queue.
                    * But prequeue _can_ be not empty after 2nd iteration,
                    * when we jumped to start of loop because backlog
                    * processing added something to receive_queue.
                    * We cannot release_sock(), because backlog contains
                    * packets arrived _after_ prequeued ones.
                    *
                    * Shortly, algorithm is clear --- to process all
                    * the queues in order. We could make it more directly,
                    * requeueing packets from backlog to prequeue, if
                    * is not empty. It is more elegant, but eats cycles,
                    * unfortunately.
                    */

                if (!skb_queue_empty(&amp;tp-&gt;ucopy.prequeue))
                    goto do_prequeue;

                /* __ Set realtime policy in scheduler __ */
            }

            if (copied &gt;= target) {
                /* Do not sleep, just process backlog. */
                release_sock(sk);
                lock_sock(sk);
            } else
                        sk_wait_data(sk, &amp;timeo); 
            //在此处睡眠了，将在tcp_prequeue函数中调用wake_up_interruptible_poll唤醒

            //软中断会判断用户是正在读取检查并且睡眠了，如果是的话，就直接把数据拷贝
            //到prequeue队列，然后唤醒睡眠的进程。因为进程睡眠，表示没有读到想要的字节数
            //此时，软中断有数据到来，直接给进程，这样进程就能以最快的速度被唤醒。


            if (user_recv) {
                int chunk;

                /* __ Restore normal policy in scheduler __ */

                if ((chunk = len - tp-&gt;ucopy.len) != 0) {
                    NET_ADD_STATS_USER(sock_net(sk), LINUX_MIB_TCPDIRECTCOPYFROMBACKLOG, chunk);
                    len -= chunk;
                    copied += chunk;
                }

                if (tp-&gt;rcv_nxt == tp-&gt;copied_seq &amp;&amp;
                                !skb_queue_empty(&amp;tp-&gt;ucopy.prequeue)) {
    do_prequeue:
                    tcp_prequeue_process(sk);

                    if ((chunk = len - tp-&gt;ucopy.len) != 0) {
                        NET_ADD_STATS_USER(sock_net(sk), LINUX_MIB_TCPDIRECTCOPYFROMPREQUEUE, chunk);
                        len -= chunk;
                        copied += chunk;
                    }
                }
            }
            if ((flags &amp; MSG_PEEK) &amp;&amp;
                            (peek_seq - copied - urg_hole != tp-&gt;copied_seq)) {
                if (net_ratelimit())
                    printk(KERN_DEBUG "TCP(%s:%d): Application bug, race in MSG_PEEK.\n",
                                                current-&gt;comm, task_pid_nr(current));
                peek_seq = tp-&gt;copied_seq;
            }
            continue;

        found_ok_skb:
            /* Ok so how much can we use? */
            //skb中还有多少聚聚没有拷贝。
            //正如前面所说的，offset是上次已经拷贝了的，这次从offset开始接下去拷贝
                    used = skb-&gt;len - offset;
            //很有可能used的大小，即skb剩余长度，依然大于用户的缓冲区大小(len)。所以依然
            //只能拷贝len长度。一般来说，用户还得执行一次recv系统调用。直到skb中的数据读完
            if (len &lt; used)
                used = len;

            /* Do we have urgent data here? */
            if (tp-&gt;urg_data) {
                u32 urg_offset = tp-&gt;urg_seq - *seq;
                if (urg_offset &lt; used) {
                    if (!urg_offset) {
                        if (!sock_flag(sk, SOCK_URGINLINE)) {
                            ++*seq;
                            urg_hole++;
                            offset++;
                            used--;
                            if (!used)
                                goto skip_copy;
                        }
                    } else
                        used = urg_offset;
                }
            }

            if (!(flags &amp; MSG_TRUNC)) {
                {
                    //一般都会进这个if，进行数据的拷贝，把能够读到的数据，放到用户的缓冲区
                    err = skb_copy_datagram_iovec(skb, offset,
                            msg-&gt;msg_iov, used);
                    if (err) {
                        /* Exception. Bailout! */
                        if (!copied)
                            copied = -EFAULT;
                        break;
                    }
                }
            }

            //更新标志位，seq 是指针，指向了tp-&gt;copied_seq
            //used是我们有能力拷贝的数据大小，即已经拷贝到用户缓冲区的大小
            //正如前面所说，如果用户的缓冲区很小，一次recv拷贝不玩skb中的数据，
            //我们需要保存已经拷贝了的大小，下次recv时，从这个大小处继续拷贝。
            //所以需要更新copied_seq。
            *seq += used;
            copied += used;
            len -= used;

            tcp_rcv_space_adjust(sk);

    skip_copy:
            if (tp-&gt;urg_data &amp;&amp; after(tp-&gt;copied_seq, tp-&gt;urg_seq)) {
                tp-&gt;urg_data = 0;
                tcp_fast_path_check(sk);
            }

            //这个就是判断我们是否拷贝完了skb中的数据，如果没有continue
            //这种情况下，len经过 len -= used; ，已经变成0，所以continue的效果相当于
            //退出了这个大循环。可以理解，你只能拷贝len长度，拷贝完之后，那就return了。

            //还有一种情况used + offset ==  skb-&gt;len，表示skb拷贝完了。这时我们只需要释放skb
            //下面会讲到
            if (used + offset &lt; skb-&gt;len)
                continue;

            //看看这个数据报文是否含有fin，含有fin，则goto到found_fin_ok
            if (tcp_hdr(skb)-&gt;fin)
                goto found_fin_ok;

            //执行到这里，标明used + offset ==  skb-&gt;len，报文也拷贝完了，那就把skb摘链释放
            if (!(flags &amp; MSG_PEEK)) {
                sk_eat_skb(sk, skb, copied_early);
                copied_early = 0;
            }
            //这个cintinue不一定是退出大循环，可能还会执行循环。
            //假设用户设置缓冲区12字节，你skb-&gt;len长度20字节。
            //第一次recv读取了12字节，skb剩下8，下一次调用recv再想读取12，
            //但是只能读取到这8字节了。
            //此时len 变量长度为4，那么这个continue依旧在这个循环中，
            //函数还是再次从do开始，使用skb_queue_walk，找skb
            //如果sk_receive_queue中skb仍旧有，那么继续读，直到len == 0
            //如果没有skb了，我们怎么办？我们的len还有4字节怎么办？
            //这得看用户设置的recv函数阻塞与否，即和timeo变量相关了。
            continue;

        found_fin_ok:
            /* Process the FIN. */
            ++*seq;
            if (!(flags &amp; MSG_PEEK)) {
                //把skb从sk_receive_queue中摘链
                sk_eat_skb(sk, skb, copied_early);
                copied_early = 0;
            }
            break;
        } while (len &gt; 0);

        //到这里是大循环退出
        //休眠过的进程，然后退出大循环 ，才满足 if (user_recv) 条件
        if (user_recv) {
            if (!skb_queue_empty(&amp;tp-&gt;ucopy.prequeue)) {
                int chunk;

                tp-&gt;ucopy.len = copied &gt; 0 ? len : 0;

                tcp_prequeue_process(sk);

                if (copied &gt; 0 &amp;&amp; (chunk = len - tp-&gt;ucopy.len) != 0) {
                    NET_ADD_STATS_USER(sock_net(sk), LINUX_MIB_TCPDIRECTCOPYFROMPREQUEUE, chunk);
                    len -= chunk;
                    copied += chunk;
                }
            }

            //数据读取完毕，清零
            tp-&gt;ucopy.task = NULL;
            tp-&gt;ucopy.len = 0;
        }

        /* According to UNIX98, msg_name/msg_namelen are ignored
            * on connected socket. I was just happy when found this 8) --ANK
            */

        /* Clean up data we have read: This will do ACK frames. */
        //很重要，将更新缓存，并且适当的时候发送ack
        tcp_cleanup_rbuf(sk, copied);

        TCP_CHECK_TIMER(sk);
        release_sock(sk);
        return copied;

    out:
        TCP_CHECK_TIMER(sk);
        release_sock(sk);
        return err;

    recv_urg:
        err = tcp_recv_urg(sk, msg, len, flags);
        goto out;
    }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux TCP数据包接收处理 tcp_v4_rcv]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/04/10/kernel-net-v4rcv/"/>
    <updated>2015-04-10T15:23:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/04/10/kernel-net-v4rcv</id>
    <content type="html"><![CDATA[<p><a href="http://blog.sina.com.cn/s/blog_52355d840100b6sd.html">http://blog.sina.com.cn/s/blog_52355d840100b6sd.html</a></p>

<h4>tcp_v4_rcv函数</h4>

<pre><code class="">    int tcp_v4_rcv(struct sk_buff *skb)
    {
        const struct iphdr *iph;
        struct tcphdr *th;
        struct sock *sk;
        int ret;

        //如果不是发往本地的数据包，则直接丢弃
        if (skb-&gt;pkt_type != PACKET_HOST)
            goto discard_it;

        TCP_INC_STATS_BH(TCP_MIB_INSEGS);

        //包长是否大于TCP头的长度
        if (!pskb_may_pull(skb, sizeof(struct tcphdr)))
            goto discard_it;

        //取得TCP首部
        th = tcp_hdr(skb);

        //检查TCP首部的长度和TCP首部中的doff字段是否匹配
        if (th-&gt;doff &lt; sizeof(struct tcphdr) / 4)
            goto bad_packet;

        //检查TCP首部到TCP数据之间的偏移是否越界
        if (!pskb_may_pull(skb, th-&gt;doff * 4))
            goto discard_it;

        if (!skb_csum_unnecessary(skb) &amp;&amp; tcp_v4_checksum_init(skb))
            goto bad_packet;

         th = tcp_hdr(skb);
        iph = ip_hdr(skb);
        TCP_SKB_CB(skb)-&gt;seq = ntohl(th-&gt;seq);

        //计算end_seq,实际上，end_seq是数据包的结束序列号，实际上是期待TCP确认
        //包中ACK的数值，在数据传输过程中，确认包ACK的数值等于本次数据包SEQ
        //号加上本数据包的有效载荷，即skb-&gt;len - th-&gt;doff * 4,但是在处理SYN报文或者
        //FIN报文的时候，确认包的ACK等于本次处理数据包的SEQ+1,考虑到这种情况，
        //期待下一个数据包的ACK就变成了TCP_SKB_CB(skb)-&gt;seq + th-&gt;syn + th-&gt;fin +
        //skb-&gt;len - th-&gt;doff * 4

        // TCP_SKB_CB宏会返回skb-&gt;cb[0],一个类型为tcp_skb_cb的结构指针，这个结
        //构保存了TCP首部选项和其他的一些状态信息

        TCP_SKB_CB(skb)-&gt;end_seq = (TCP_SKB_CB(skb)-&gt;seq + th-&gt;syn + th-&gt;fin +
                        skb-&gt;len - th-&gt;doff * 4);
        TCP_SKB_CB(skb)-&gt;ack_seq = ntohl(th-&gt;ack_seq);
        TCP_SKB_CB(skb)-&gt;when   = 0;
        TCP_SKB_CB(skb)-&gt;flags    = iph-&gt;tos;
        TCP_SKB_CB(skb)-&gt;sacked = 0;

        //根据四元组查找相应连接的sock结构，大体有两个步骤，
        //首先用__inet_lookup_established函数查找已经处于establish状态的连接，
        //如果查找不到的话，就调用__inet_lookup_listener函数查找是否存在四元组相
        //匹配的处于listen状态的sock,这个时候实际上是被动的接收来自其他主机的连接
        //请求

        //如果查找不到匹配的sock,则直接丢弃数据包
        sk = __inet_lookup(&amp;tcp_hashinfo, iph-&gt;saddr, th-&gt;source,
                   iph-&gt;daddr, th-&gt;dest, inet_iif(skb));
        if (!sk)
            goto no_tcp_socket;

        //检查sock是否处于半关闭状态
        process:
        if (sk-&gt;sk_state == TCP_TIME_WAIT)
            goto do_time_wait;

        //检查IPSEC规则
        if (!xfrm4_policy_check(sk, XFRM_POLICY_IN, skb))
            goto discard_and_relse;
        nf_reset(skb);

        //检查BPF规则
        if (sk_filter(sk, skb))
            goto discard_and_relse;

        skb-&gt;dev = NULL;

        //这里主要是和release_sock函数实现互斥，release_sock中调用了
        // spin_lock_bh(&amp;sk-&gt;sk_lock.slock);
        bh_lock_sock_nested(sk);
        ret = 0;

        //查看是否有用户态进程对该sock进行了锁定
        //如果sock_owned_by_user为真，则sock的状态不能进行更改
        if (!sock_owned_by_user(sk)) {

    #ifdef CONFIG_NET_DMA
            struct tcp_sock *tp = tcp_sk(sk);
            if (!tp-&gt;ucopy.dma_chan &amp;&amp; tp-&gt;ucopy.pinned_list)
                tp-&gt;ucopy.dma_chan = get_softnet_dma();
            if (tp-&gt;ucopy.dma_chan)
                ret = tcp_v4_do_rcv(sk, skb);
            else
    #endif
            {
                //进入预备处理队列
                if (!tcp_prequeue(sk, skb))
                    ret = tcp_v4_do_rcv(sk, skb);
            }
        } else
            //如果数据包被用户进程锁定，则数据包进入后备处理队列，并且该进程进入
            //套接字的后备处理等待队列sk-&gt;lock.wq
            sk_add_backlog(sk, skb);
        bh_unlock_sock(sk);

        sock_put(sk);
        return ret;

    no_tcp_socket:
        if (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb))
            goto discard_it;

        if (skb-&gt;len &lt; (th-&gt;doff &lt;&lt; 2) || tcp_checksum_complete(skb)) {
    bad_packet:
            TCP_INC_STATS_BH(TCP_MIB_INERRS);
        } else {
            tcp_v4_send_reset(NULL, skb);
        }

    discard_it:
        kfree_skb(skb);
        return 0;

    discard_and_relse:
        sock_put(sk);
        goto discard_it;

    do_time_wait:
        if (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb)) {
            inet_twsk_put(inet_twsk(sk));
            goto discard_it;
        }

        if (skb-&gt;len &lt; (th-&gt;doff &lt;&lt; 2) || tcp_checksum_complete(skb)) {
            TCP_INC_STATS_BH(TCP_MIB_INERRS);
            inet_twsk_put(inet_twsk(sk));
            goto discard_it;
        }
        switch (tcp_timewait_state_process(inet_twsk(sk), skb, th)) {
        case TCP_TW_SYN: {
            struct sock *sk2 = inet_lookup_listener(&amp;tcp_hashinfo,
                                iph-&gt;daddr, th-&gt;dest,
                                inet_iif(skb));
            if (sk2) {
                inet_twsk_deschedule(inet_twsk(sk), &amp;tcp_death_row);
                inet_twsk_put(inet_twsk(sk));
                sk = sk2;
                goto process;
            }
        }
        case TCP_TW_ACK:
            tcp_v4_timewait_ack(sk, skb);
            break;
        case TCP_TW_RST:
            goto no_tcp_socket;
        case TCP_TW_SUCCESS:;
        }
        goto discard_it;
    }
</code></pre>
]]></content>
  </entry>
  
</feed>
