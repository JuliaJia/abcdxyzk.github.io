<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: debug~systemtap | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/debug~systemtap/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2015-05-11T11:08:27+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ubuntu安装systemtap]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/04/28/debug-ubuntu-stap/"/>
    <updated>2015-04-28T14:42:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/04/28/debug-ubuntu-stap</id>
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/ustc_dylan/article/details/7079876">http://blog.csdn.net/ustc_dylan/article/details/7079876</a></p>

<h4>1. 从源安装systemtap</h4>

<pre><code>    $ sudo apt-get install systemtap
</code></pre>

<h4>2. 安装kernel-debug-info</h4>

<p>由于ubuntu 桌面版默认没有安装kernel-debug-info，所以安装了systemtap后仍然不能够追踪内核信息，因此需要手动安装kernel-debug-info包。</p>

<h5>（1）查看当前内核版本</h5>

<pre><code>    $ uname -a
    Linux kk-desktop 2.6.32-73-generic #141-Ubuntu SMP Tue Mar 10 17:15:10 UTC 2015 x86_64 GNU/Linux
</code></pre>

<h5>（2）下载对应内核版本的debug-info package</h5>

<p><a href="http://ddebs.ubuntu.com/pool/main/l/linux/">http://ddebs.ubuntu.com/pool/main/l/linux/</a></p>

<p><a href="http://ddebs.ubuntu.com/pool/main/l/linux/linux-image-2.6.32-73-generic-dbgsym_2.6.32-73.141_amd64.ddeb">http://ddebs.ubuntu.com/pool/main/l/linux/linux-image-2.6.32-73-generic-dbgsym_2.6.32-73.141_amd64.ddeb</a></p>

<h4>3. 安装kernel-debug-info</h4>

<pre><code>    $ sudo dpkg -i linux-image-2.6.32-73-generic-dbgsym_2.6.32-73.141_amd64.ddeb
</code></pre>

<p>经过以上安装配置后，就可以跟踪监控内核信息了，但是现在还不能跟踪linux内核模块的信息，因为，systemtap对linux内核模块的跟踪是通过libelf库来查找
/usr/lib/debug目录下以.ko.dedug结尾的模块，但是linux发行版通常将linux模块的扩展名修改为.ko。</p>

<h4>4. 安装elfutils并进行相应配置</h4>

<pre><code>    $ sudo apt-get install elfutils
</code></pre>

<pre><code>    # 这些似乎不用
    for file in `find /usr/lib/debug-name'*.ko' -print`
        do
        buildid=`eu-readelf-n $file| grep Build.ID:| awk '{print $3}'`
        dir=`echo $buildid| cut-c1-2`
        fn=`echo $buildid| cut-c3-`
        rm -fr /usr/lib/debug/.build-id
        mkdir -p/usr/lib/debug/.build-id/$dir
        ln -s $file/usr/lib/debug/.build-id/$dir/$fn
        ln -s $file/usr/lib/debug/.build-id/$dir/${fn}.debug
        done
</code></pre>

<h4>5. 写个例子测试下</h4>

<pre><code>    $ sudo stap -ve 'probe begin { log("hello world") exit() }'
</code></pre>

<p>如果能够打印出hello world，说明安装配置成功!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[systemtap article]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/10/28/debug-stap-article/"/>
    <updated>2013-10-28T16:15:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/10/28/debug-stap-article</id>
    <content type="html"><![CDATA[<p><a href="https://sourceware.org/systemtap/wiki/WarStories">https://sourceware.org/systemtap/wiki/WarStories</a></p>

<p><a href="http://wenku.baidu.com/view/9045426048d7c1c708a1452d.html">http://wenku.baidu.com/view/9045426048d7c1c708a1452d.html</a></p>

<p><a href="http://www.cnblogs.com/hazir/p/systemtap_introduction.html">http://www.cnblogs.com/hazir/p/systemtap_introduction.html</a></p>

<p><a href="https://sourceware.org/systemtap/wiki/WarStories">https://sourceware.org/systemtap/wiki/WarStories</a></p>

<p><a href="http://www.cnblogs.com/wangkangluo1/archive/2012/06/26/2562971.html">http://www.cnblogs.com/wangkangluo1/archive/2012/06/26/2562971.html</a></p>

<p><a href="http://www.ibm.com/developerworks/cn/linux/l-systemtap/index.html">http://www.ibm.com/developerworks/cn/linux/l-systemtap/index.html</a></p>

<p><a href="http://blog.yufeng.info/archives/855">http://blog.yufeng.info/archives/855</a></p>

<p><a href="http://www.360doc.com/content/12/0523/15/7982302_213133871.shtml">http://www.360doc.com/content/12/0523/15/7982302_213133871.shtml</a></p>

<p><a href="https://sourceware.org/systemtap/wiki/AddingUserSpaceProbingToApps">https://sourceware.org/systemtap/wiki/AddingUserSpaceProbingToApps</a></p>

<p><a href="http://www.docin.com/p-610001474.html">http://www.docin.com/p-610001474.html</a></p>

<p><a href="http://blog.chinaunix.net/uid-7585066-id-2048719.html">http://blog.chinaunix.net/uid-7585066-id-2048719.html</a></p>

<p><a href="http://blog.chinaunix.net/uid-20568790-id-1632313.html">http://blog.chinaunix.net/uid-20568790-id-1632313.html</a></p>

<p>wiki翻译</p>

<p><a href="http://blog.csdn.net/linyt/article/details/5204841">http://blog.csdn.net/linyt/article/details/5204841</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何知道文件被那个进程写]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/10/10/debug-stap-inodewatch/"/>
    <updated>2013-10-10T16:27:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/10/10/debug-stap-inodewatch</id>
    <content type="html"><![CDATA[<p>一个文件正在被进程写 我想查看这个进程 文件一直在增大 找不到谁在写 使用lsof也没找到</p>

<p>这个问题挺有普遍性的，解决方法应该很多，这里我给大家提个比较直观的方法。</p>

<p>linux下每个文件都会在某个块设备上存放，当然也都有相应的inode, 那么透过vfs.write我们就可以知道谁在不停的写入特定的设备上的inode。</p>

<p>幸运的是systemtap的安装包里带了inodewatch.stp，位于/usr/local/share/doc/systemtap/examples/io目录下，就是用来这个用途的。</p>

<p>我们来看下代码：</p>

<p>$ cat inodewatch.stp
```
    #! /usr/bin/env stap</p>

<pre><code>probe vfs.write, vfs.read
{
    # dev and ino are defined by vfs.write and vfs.read
    if (dev == MKDEV($1,$2) # major/minor device
        &amp;&amp; ino == $3)
    printf ("%s(%d) %s 0x%x/%u\n",
        execname(), pid(), probefunc(), dev, ino)
}
</code></pre>

<pre><code>这个脚本的使用方法如下： stap  inodewatch.stp major minor ino

下面我们构造个场景： dd不停的写入一个文件，查出这个文件的ino, 以及它所在设备的major, minor, 运行stap脚本就可以得到答案。

场景交代好了，我们来演示下：
</code></pre>

<pre><code>$ pwd
/home/chuba
$ df
Filesystem           1K-blocks      Used Available Use% Mounted on
...
/dev/sdb1            1621245336 825209568 713681236  54% /home
...
$ ls -al /dev/sdb1
brw-rw---- 1 root disk 8, 17 Oct 24 11:22 /dev/sdb1 
$ rm -f test.dat &amp;&amp; dd if=/dev/zero of=test.dat
^C9912890+0 records in
9912890+0 records out
5075399680 bytes (5.1 GB) copied, 26.8189 s, 189 MB/s
</code></pre>

<pre><code>这个终端模拟文件的不停写入，同时在另外一个终端查验谁干的。这里我们已经知道设备的major/minor为8/17
</code></pre>

<pre><code>$ stat -c '%i' test.dat
25337884
$ sudo stap /usr/local/share/doc/systemtap/examples/io/inodewatch.stp 8 17 25337884
dd(740) vfs_write 0x800011/25337884
dd(740) vfs_write 0x800011/25337884
dd(740) vfs_write 0x800011/25337884
dd(740) vfs_write 0x800011/25337884
dd(740) vfs_write 0x800011/25337884
dd(740) vfs_write 0x800011/25337884
...
</code></pre>

<p>```
看到了吧，dd是罪魁祸首，pid是740</p>
]]></content>
  </entry>
  
</feed>
