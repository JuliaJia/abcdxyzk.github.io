<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 2013~11 | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/2013~11/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2014-12-07T17:07:47+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[BFD or dwarf? article]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/11/29/debug-dwarf-article/"/>
    <updated>2013-11-29T17:54:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/11/29/debug-dwarf-article</id>
    <content type="html"><![CDATA[<p><a href="http://blog.techveda.org/howsourcedebuggerswork/">http://blog.techveda.org/howsourcedebuggerswork/</a></p>

<p><a href="http://bbs.sjtu.edu.cn/bbscon,board,Security,file,M.1134227822.A.html">http://bbs.sjtu.edu.cn/bbscon,board,Security,file,M.1134227822.A.html</a></p>

<p><a href="http://blog.csdn.net/warriorpaw/article/details/8660704">http://blog.csdn.net/warriorpaw/article/details/8660704</a></p>

<p><a href="http://blog.csdn.net/rrerre/article/details/6843539">http://blog.csdn.net/rrerre/article/details/6843539</a></p>

<p><a href="http://blog.csdn.net/rrerre/article/details/6639484">http://blog.csdn.net/rrerre/article/details/6639484</a></p>

<p><a href="http://dwarfstd.org/doc/Dwarf3.pdf">http://dwarfstd.org/doc/Dwarf3.pdf</a></p>

<p>dwarf2解析 <a href="http://hi.baidu.com/tag/dwarf2%E8%A7%A3%E6%9E%90/feeds">http://hi.baidu.com/tag/dwarf2%E8%A7%A3%E6%9E%90/feeds</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[freeBSD9.2 安装 && 允许root用户用SSH登录]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/11/21/freebsd/"/>
    <updated>2013-11-21T16:15:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/11/21/freebsd</id>
    <content type="html"><![CDATA[<h4>一</h4>

<p><a href="http://forums.freebsd.org/showthread.php?t=36579">http://forums.freebsd.org/showthread.php?t=36579</a></p>

<p>Issue:<br/>
Here is the error message that I&rsquo;ve got:
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Code:&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;cd0 at umass-sim0 bus 0 scbus3 target 0 lun 0
</span><span class='line'>cd0: &lt;ASUS SDRW-08D2S-U B302&gt; Removable CD-ROM SCSI-0 device
</span><span class='line'>cd0: 40.000MB/s transfers
</span><span class='line'>cd0: cd present [1166275 x 2048 byte records]Mounting from cd9660:/dev/iso9660/FREEBSD_INSTALL failed with error 19.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Loader variables:
</span><span class='line'>    vfs.root.mountfrom=cd9660:/dev/iso9660/FREEBSD_INSTALL
</span><span class='line'>    vfs.root.mountfrom.option=ro&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Manual root filesystem specification:
</span><span class='line'>    &lt;fstype&gt;:&lt;device&gt; [option]
</span><span class='line'>        Mount &lt;device&gt; using filesystem &lt;fstype&gt;
</span><span class='line'>        and with the specified (optional) option list.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;eg. ufs:/dev/da0s1a
</span><span class='line'>    zf:tank
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;The system seems to recognize the DVD drive but is unable to mount the media correctly.
</span><span class='line'>
</span><span class='line'>You need to get a boot prompt and disable ACPI support before booting:  
</span><span class='line'>这两句好像没效果  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;h1&gt;set debug.acpi.disabled =&ldquo;hostres&rdquo;&lt;/h1&gt;
</span><span class='line'>
</span><span class='line'>&lt;h1&gt;boot&lt;/h1&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;The solution is actually in the FreeBSD 9 errata (section 3)  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;mountroot&gt; cd9660:/dev/cd0  用这句通过
</span><span class='line'>&lt;code&gt;
</span><span class='line'>这句不只道可不可以：
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>mountroot&gt; cd9660:/iso9660/FREEBSD_INSTALL</span></code></pre></td></tr></table></div></figure></p>

<h4>二 FreeBSD 允许root用户用SSH登录</h4>

<p>修改freebsd可以用sshd权限用户登录ssh<br/>
在/etc/ssh/sshd_config最后中加入<br/>
<code>
PermitRootLogin yes #允许root登录
PermitEmptyPasswords no #不允许空密码登录
PasswordAuthentication yes # 设置是否使用口令验证。
</code></p>

<hr />

<p>FreeBSD SSH配置详解
首先vi编辑/etc/inetd.conf,去掉ssh前的#，保存退出 (开启监听ssh服务)<br/>
编辑/etc/rc.conf<br/>
最后加入:sshd_enable=&ldquo;yes"即可</p>

<p>激活sshd服务：<br/>
    #/etc/rc.d/sshd start</p>

<p>用下面命令检查服务是否启动，在22端口应该有监听。<br/>
    #netstat -an ## check port number 22<br/>
最后<br/>
vi /etc/ssh/sshd_config
<code>
...
Subsystem sftp /usr/libexec/sftp-server
IgnoreRhosts yes
IgnoreUserKnownHosts yes
PrintMotd yes
StrictModes no
RSAAuthentication yes
PermitRootLogin yes #允许root登录
PermitEmptyPasswords no #不允许空密码登录
PasswordAuthentication yes # 设置是否使用口令验证。
</code></p>

<hr />

<p>记得修改完配置文件后，重新启动sshd服务器(/etc/rc.d/sshd restart)即可。<br/>
几点补充说明<br/>
<code>
1,如果重启后还是不行请重新载入sshd_config 文件
/etc/rc.d/sshd reload
2,如果出现using keyboard-interactive authentication
password:
请确认PasswordAuthentication是否已经改成yes
另外如果客户端是putty那么请确认"尝试'智能键盘'认证（SSH-2）"的勾是否有去掉
3,如果是使用root帐号登陆
请确认密码是否为空
空密码无法登陆
4请确认是否有安装SSH
sysinstall&gt;&gt;&gt;configure&gt;&gt;&gt;networking&gt;&gt;&gt;sshd是否的勾是否有打上
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[__builtin_return_address获得程序运行栈]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/11/20/lang-c-buildin-addr/"/>
    <updated>2013-11-20T18:34:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/11/20/lang-c-buildin-addr</id>
    <content type="html"><![CDATA[<p>  gcc的编译特性使用<code>__builtin_return_address(level)</code>打印出一个函数的堆栈地址。其中 level代表是堆栈中第几层调用地址，<code>__builtin_return_address(0)</code>表示第一层调用地址，即当前函数，<code>__builtin_return_address(1)</code>表示第二层。如代码
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdio.h&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;void f()
</span><span class='line'>{
</span><span class='line'>printf("%p,%p" , __builtin_return_address(0), __builtin_return_address(1));
</span><span class='line'>//printk("Caller is %pS\n", __builtin_return_address(0));
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void g()
</span><span class='line'>{
</span><span class='line'>f();
</span><span class='line'>}
</span><span class='line'>int main()
</span><span class='line'>{
</span><span class='line'>g();
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```
</span><span class='line'>分别打印出函数f()和g() 的函数地址，我们通过objdump 出来的文件去查找打印出来的函数地址，这样就能看到调用的函数名了。&lt;/p&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[编译期间求值]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2013/11/05/compiler-cal/"/&gt;
</span><span class='line'>&lt;updated&gt;2013-11-05T14:26:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2013/11/05/compiler-cal&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;p&gt;编译期求阶乘&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;c++ 中的模板可以用来计算一些值，在编译的时候就是实现计算，而不是运行的时候。&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;求阶乘 n!，一般 me 们会写个这样的程序：</span></code></pre></td></tr></table></div></figure>
    #include <iostream>
    long Factorial(long n)
    {
        return n == 0 ? 1 : n*Factorial(n-1);
    }</p>

<pre><code>int main()
{
    long fac=1, n=20;
    for(int i=1; i&lt;=n; ++i)fac *= i;
    std::cout &lt;&lt; "20! = " &lt;&lt; fac &lt;&lt; " " &lt;&lt; Factorial(20) &lt;&lt; std::endl;
    return 0;
}
</code></pre>

<pre><code>现在使用模板技术，类似于递归的方法求 20 !。
</code></pre>

<pre><code>#include &lt;iostream&gt;

template&lt;int N&gt;
class Factorial{
public:
    static const long value = N*Factorial&lt;N-1&gt;::value;
};

template&lt;&gt;
class Factorial&lt;0&gt;{
public:
    static const long value = 1;
};

int main()
{
    std::cout &lt;&lt; "20! = " &lt;&lt; Factorial&lt;20&gt;::value &lt;&lt; std::endl;
    return 0;
}
</code></pre>

<pre><code>说明：  
  template 通常用来参数化类型，通常 class T 或是 typename T(T 用来代替一个类型的名字)，不过也可以带一个整型参数 N (貌似规定只能是整型)。  
  template &lt;&gt; 是用来特殊指定一些情形，比如上面给的 Factorial&lt;0&gt; 指定 N = 0 时的情形，这有点像递归中的 if(n==0) return 1;  
  class 类中可以带有 static const 变量，这种变量可以在类内初始化(只能是整型)；当然既是 const 变量，又是 static 变量；  
  Factorila&lt;20&gt; 实际是一个类，而 ::value 是其 static 变量；在生成Factorila&lt;20&gt; 的时候同时生成了众多的Factorila&lt;N&gt; ( N &gt;0 &amp;&amp; N &lt; 20)类；  

更多例子  
模板类，或是模版函数，或是模板成员函数，都是编译器根据程序的实际情况而生成的，需要什么就生成什么，不需要就不生成。上面的例子中， 程序中使用 Factorial&lt;20&gt; 这个类，就生成这个类，因为 Factorial&lt;20&gt; 依赖 Factorial&lt;19&gt; 所以又生成 Factorial&lt;19&gt; ，这样一直依赖下去，直到 Factorial&lt;0&gt;( me 们已经指定了)。因为是编译期生成，也是编译器求值，所以实际程序中只能使用 static const 类似的 —— 常量，而不能使用普通的 int n。所以，模板元编程中，么发使用循环，只能类似递归的技术。  
通常 me 们会将递归程序转换为循环程序，实际上循环程序基本也都可以递归解决。(是不是一定呢？O__O"…)  
求斐波那契数
</code></pre>

<pre><code>#include &lt;iostream&gt;

template &lt;long N&gt;
struct Fibonacci{
    static const long value = Fibonacci&lt;N-1&gt;::value + Fibonacci&lt;N-2&gt;::value;
};

template&lt;&gt;
struct Fibonacci&lt;0&gt;{
    static const long value = 0;
};

template&lt;&gt;
struct Fibonacci&lt;1&gt;{
    static const long value = 1;
};

int main()
{
    std::cout &lt;&lt; Fibonacci&lt;12&gt;::value &lt;&lt; std::endl;
    return 0;
}
</code></pre>

<pre><code>第 12 个斐波那契数是 144，这是唯一一个 Fib(n) = n*n 的数。
求 1+2+3+...+n
</code></pre>

<pre><code>#include &lt;iostream&gt;

template &lt;long N&gt;
struct Sum{
    static const long value = N+Sum&lt;N-1&gt;::value;
};

template&lt;&gt;
struct Sum&lt;1&gt;{
    static const long value = 1;
};

int main()
{
    std::cout &lt;&lt; Sum&lt;100&gt;::value &lt;&lt; std::endl;
    return 0;
}
</code></pre>

<pre><code>这个和 n! 的用法基本一样。

#### constexpr编译期求值
  模板只是在编译的时候完成工作的一种方法，实际上上面的模板元编程也只是在编译期求了一些常量而已；为了简化使用模板进行元编程的难度，c++11 引入了 constexpr 关键字 —— 声明常量或是函数，实现在编译期求值。上面的三个程序都可以大大简化：
</code></pre>

<pre><code>#include &lt;iostream&gt;

constexpr long factorial(long n)
{
    return n&lt;=1 ? 1 : n*factorial(n-1);
}
constexpr long fibonacci(long n)
{
    return n&lt;=1 ? n : fibonacci(n-1)+fibonacci(n-2);
}
constexpr long sum(long n)
{
    return n&lt;=1 ? n : n+sum(n-1);
}

int main()
{
    std::cout &lt;&lt; "10! F(12) 1+2+...+100 =&gt; " &lt;&lt; factorial(10) &lt;&lt; " " &lt;&lt; fibonacci(12) &lt;&lt; " " &lt;&lt; sum(100) &lt;&lt; std::endl;
    return 0;
}
</code></pre>

<p>```
不用多数，看应该看得懂神马意思，要提的就是 constexpr 都是编译的时候求值。</p>
]]></content>
  </entry>
  
</feed>
