<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 2013~08 | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/2013~08/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2014-12-04T18:13:16+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[git-svn]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/08/29/tools-git-svn-base/"/>
    <updated>2013-08-29T14:37:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/08/29/tools-git-svn-base</id>
    <content type="html"><![CDATA[<h4>常用</h4>

<pre><code>1、git-svn clone your_svn_repository
2、git add/commit
3、git-svn rebase  获取中心svn repository的更新；
4、git-svn dcommit 将本地git库的修改同步到中心svn库。
</code></pre>

<hr />

<p>git-svn默认包含在Git的安装包中，不过在Ubuntu中，git-svn是作为一个独立的Package需要额外安装的(sudo apt-get install git-svn)。安装后你就可以使用git svn xxx命令来操作中心SVN代码库了。当然如果你要使用与git svn等价的git-svn命令的话，你还需要将/usr/lib/git-core配置到你的PATH环境变量中，否则Shell会提示你无法找到 git-svn这个命令。</p>

<ul>
<li><p>检出一个已存在svn repository(类似于svn checkout)<br/>
我们可以通过git-svn clone命令完成这个操作： git-svn clone your_svn_repository_url</p></li>
<li><p>从中心服务器的svn repository获取最新更新<br/>
这个操作可以通过"git-svn rebase"完成。注意这里用的是rebase，而不是update。update命令对于通过git-svn检出的svn repostory的git版本库是不可用的。</p></li>
<li><p>查看提交历史日志<br/>
这个简单，使用"git-svn log"，加上-v选项，还可以提供每次commit操作涉及的相关文件的详细信息。</p></li>
<li><p>将本地代码同步到Svn服务器<br/>
完成这一操作需要通过"git-svn dcommit"命令。这个命令会将你在本地使用git commit提交到本地代码库的所有更改逐一提交到svn库中。加上-n选项，则该命令不会真正执行commit到svn的操作，而是会显示会有哪些本地 变动将被commit到svn服务器。git-svn dcommit似乎不能单独提交某个本地版本的修改，而是一次批量提交所有与svn中心版本库的差异。</p></li>
</ul>


<h5>下面是一个git-svn的一般使用流程：</h5>

<p>1、git-svn clone your_svn_repository；<br/>
2、修改本地代码，使用git add/commit将修改提交到本地git库；<br/>
3、定期使用git-svn rebase获取中心svn repository的更新；<br/>
4、使用git-svn dcommit命令将本地git库的修改同步到中心svn库。</p>

<h5>冲突</h5>

<p>使用git-svn处理代码冲突的步骤有些繁琐，不过瑕不掩瑜吧。这里用一个小例子来说明一下。</p>

<p>假设某svn中心库上的某个项目foo中只有一个源码文件foo.c：<br/>
* 我在使用git-svn clone检出版本时，foo.c当时只有一个commit版本信息："svn v1"；<br/>
* clone出来后，我在本地git库中修改foo.c，并通过git commit提交到本地git库中，版本为"git v1"；<br/>
* 不过与此同时另外一个同事也在修改foo.c这个文件，并已经将他的修改提交到了svn库中，版本为"svn v2"；<br/>
* 此时我使用git-svn dcommit尝试提交我的改动，git-svn提示我：<br/>
  Committing to svn://10.10.1.1:80/foo &hellip;<br/>
  M foo.c<br/>
  事务过时: 过期: ”foo/foo.c“在事务“260-1” at /usr/lib/git-core/git-svn line 570<br/>
* 使用git-svn rebase获取svn服务器上的最新foo.c，导致与foo.c冲突，不过此时svn版本信息已经添加到本地git库中(通过git log可以查看)，git-svn rebase提示你在解决foo.c的冲突后，运行git rebase &ndash;continue完成rebase操作；<br/>
* 打开foo.c，修改代码，解决冲突；<br/>
* 执行git rebase &ndash;continue，git提示我：<br/>
    You must edit all merge conflicts and then<br/>
    mark them as resolved using git add<br/>
* 执行git add foo.c，告知git已完成冲突解决；<br/>
* 再次执行git rebase &ndash;continue，提示"Applying: git v1"，此时"git v1"版本又一次成功加入本地版本库，你可通过git log查看；<br/>
* 执行git-svn dcommit将foo.c的改动同步到svn中心库，到此算是完成一次冲突解决。</p>

<ul>
<li>设置忽略文件<br/>
要忽略某些文件, 需要首先执行如下命令:<br/>
git config &ndash;global core.excludesfile ~/.gitignore<br/>
然后编辑 vi ~/.gitignore.<br/>
例如: 需要忽略vim的临时文件，就写:<br/>
.*.swp</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux内核调试转储工具kdump crash]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/08/21/debug-kdump-base/"/>
    <updated>2013-08-21T17:21:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/08/21/debug-kdump-base</id>
    <content type="html"><![CDATA[<p><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-kdump4/index.html">http://www.ibm.com/developerworks/cn/linux/l-cn-kdump4/index.html</a></p>

<pre><code>$ crash vmlinux vmcore 
crash&gt; bt
crash&gt; dis -l ffffffff80081000
crash&gt; gdb x/8ub ffffffff90091000
......
</code></pre>

<p>如果是未完成文件可以尝试以最小方式调试
<code>
$ crash --minimal vmlinux vmcore
crash&gt; log
</code>
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>crash_H_args_xbt&gt; mod -S
</span><span class='line'> MODULE   NAME       SIZE  OBJECT FILE
</span><span class='line'>c8019000  soundcore 2788  /lib/modules/2.2.5-15/misc/soundcore.o
</span><span class='line'>。。。
</span><span class='line'>crash_H_args_xbt&gt; mod -s soundcore
</span><span class='line'> MODULE   NAME       SIZE  OBJECT FILE
</span><span class='line'>c8019000  soundcore 2788  /lib/modules/2.2.5-15/misc/soundcore.o
</span><span class='line'>crash_H_args_xbt&gt; mod -d soundcore
</span><span class='line'>crash_H_args_xbt&gt; mod -s soundcore /tmp/soundcore.o
</span><span class='line'> MODULE   NAME       SIZE  OBJECT FILE
</span><span class='line'>c8019000  soundcore 2788  /tmp/soundcore.o&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;-------------------
</span><span class='line'>
</span><span class='line'>#### 1、kdump介绍与设置
</span><span class='line'>##### 1）介绍：
</span><span class='line'>Kdump 是一种基于 kexec 的内存转储工具，目前它已经被内核主线接收，成为了内核的一部分，它也由此获得了绝大多数 Linux 发行版的支持。与传统的内存转储机制不同不同，基于 Kdump 的系统工作的时候需要两个内核，一个称为系统内核，即系统正常工作时运行的内核；另外一个称为捕获内核，即正常内核崩溃时，用来进行内存转储的内核。
</span><span class='line'>
</span><span class='line'>安装crash，kexec-tools
</span><span class='line'>
</span><span class='line'>##### 2）设置
</span><span class='line'>查看/boot/grub/grub.conf文件中kernel一行最后是否有crashkernel=128M@64M，如果没有，添加上去，重启  
</span><span class='line'>如何设定 crashkernel 参数  
</span><span class='line'>在 kdump 的配置中，往往困惑于 crashkernel 的设置。“crashkernel=X@Y”，X 应该多大？ Y 又应该设在哪里呢？实际我们 可以完全省略“@Y”这一部分，这样，kernel 会为我们自动选择一个起始地址。而对于 X 的大小，般对 i386/x86_64 的系统， 设为 128M 即可；对于 powerpc 的系统，则要设为 256M。rhel6 引入的“auto”已经要被放弃了，代之以原来就有的如下语法：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;crashkernel=&lt;range1&gt;:&lt;size1&gt;[,&lt;range2&gt;:&lt;size2&gt;,...][@offset] 
</span><span class='line'>      range=start-[end] 
</span><span class='line'>      'start' is inclusive and 'end' is exclusive. 
</span><span class='line'>
</span><span class='line'>      For example: 
</span><span class='line'>      crashkernel=512M-2G:64M,2G-:128M
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;如何判断捕获内核是否加载  
</span><span class='line'>可通过查看 /sys/kernel/kexec_crash_loaded 的值。“1”为已经加载，“0”为还未加载。  
</span><span class='line'>缩小 crashkernel  
</span><span class='line'>可以通过向 /sys/kernel/kexec_crash_size 中输入一个比其原值小的数来缩小甚至完全释放 crashkernel。  
</span><span class='line'>
</span><span class='line'>##### 3）测试kdump是否可用
</span><span class='line'>执行
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;echo 1 &gt; /proc/sys/kernel/sysrq
</span><span class='line'>echo c &gt; /proc/sysrq-trigger</span></code></pre></td></tr></table></div></figure>
经过两次自动重启后，查看/var/crash/目录下是否有vmcore文件生成,如果有表示kdump可用</p>

<h4>2、生成带调试信息的vmlinux文件</h4>

<h5>1）</h5>

<p>centos: debuginfo.centos.org</p>

<h5>2）按顺序安装</h5>

<p>kernel-debuginfo-common-2.6.18-194.3.1.el5.i686.rpm和kernel-debuginfo-2.6.18-194.3.1.el5.i686.rpm，
之后会在/usr/lib/debug/lib/modules/2.6.18-194.3.1.el5/下生产vmlinux文件<br/>
或在源码里make binrpm-pkg -j8，然后该目录下会生成一个vmlinux<br/>
在编译内核之前，需要确认.config中，以下编译选项是否打开：</p>

<blockquote><p>（1）CONFIG_DEBUG_INFO ，必须打开该选项，否则crash会出现以下错误：<br/>
  crash no debugging data available<br/>
（2）CONFIG_STRICT_DEVMEM,必须打开该选项，否则crash会出现以下错误：<br/>
  crash: read error: kernel virtual address: c0670680  type: &ldquo;kernel_config_data&rdquo;<br/>
  WARNING: cannot read kernel_config_data<br/>
  crash: read error: kernel virtual address: c066bb68  type: &ldquo;cpu_possible_mask&rdquo;</p></blockquote>

<h4>3、进入vmlinux所在目录，</h4>

<p>执行crash /var/crash/2012-03-13-21:05/vmcore vmlinux <br/>
mod -S XXX  &ndash;导入XXX目录下所有符号<br/>
log &ndash;查看日志文件，找到最后一条，如EIP: [<f8ee53f5>] bshtej_interrupt+0x103f/0x11cb [tej21] SS:ESP 0068:c0768f38<br/>
l* bshtej_interrupt+0x103f 出现如下内容<br/>
<code>
0xf8ee53f5 is in bshtej_interrupt (/opt/dahdi-linux-complete-2.2.1+2.2.1/linux/drivers/dahdi/tej21/tej21.c:2910).
2904            int c, x;
2905
2906
2907            for(c = 0; c &lt; MAX_CARDS; c++)
2908            {
2909                if (!cards[c]) break;
2910                for (x=0;x&lt;cards[c]-&gt;numspans;x++) {
2911                    if (cards[c]-&gt;tspans[x]-&gt;sync)
2912                    {
2913
</code>
到此可确定死机问题出现在2910行。</p>

<h4>4、设置过滤等级：</h4>

<p>vmcore文件一般会收集内核崩溃时的各种信息，所以生成时间会较长，文件比较大，如果不需要某些信息的话，可对kdump.conf文件进行配置
<code>
vim  /etc/kdump.conf
</code>
将core_collector makedumpfile -c 这行打开，并加上-d 31，参数说明如下：
```
-c: Compress dump data by each page.
-d: Specify the type of unnecessary page for analysis.
    Dump  | zero    cache   cache   user    free
    Level | page    page    private data    page
  &mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
    0  |
    1  |    X
    2  |        X
    4  |        X   X
    8  |                X
    16  |                   X
    31  |   X   X   X   X   X</p>

<h5>5、根据Oops值大致判断错误：</h5>

<p>Oops的错误代码根据错误的原因会有不同的定义如果发现自己遇到的Oops和下面无法对应的话，最好去内核代码里查找：
<code>
* error_code:
 *    bit 0 == 0 means no page found, 1 means protection fault
 *    bit 1 == 0 means read, 1 means write
 *    bit 2 == 0 means kernel, 1 means user-mode
 *    bit 3 == 0 means data, 1 means instruction
</code></p>
]]></content>
  </entry>
  
</feed>
