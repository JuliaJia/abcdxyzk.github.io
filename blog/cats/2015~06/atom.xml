<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 2015~06 | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/2015~06/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2015-06-04T13:00:36+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Receive packet steering patch详解]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/06/03/kernel-net-rps/"/>
    <updated>2015-06-03T15:39:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/06/03/kernel-net-rps</id>
    <content type="html"><![CDATA[<p><a href="http://simohayha.iteye.com/blog/720850">http://simohayha.iteye.com/blog/720850</a></p>

<p>Receive packet steering简称rps，是google贡献给linux kernel的一个patch，主要的功能是解决多核情况下，网络协议栈的软中断的负载均衡。这里的负载均衡也就是指能够将软中断均衡的放在不同的cpu核心上运行。</p>

<p>简介在这里：<br/>
<a href="http://lwn.net/Articles/362339/">http://lwn.net/Articles/362339/</a></p>

<p>linux现在网卡的驱动支持两种模式，一种是NAPI，一种是非NAPI模式，这两种模式的区别，我前面的blog都有介绍，这里就再次简要的介绍下。</p>

<p>在NAPI中，中断收到数据包后调用__napi_schedule调度软中断，然后软中断处理函数中会调用注册的poll回掉函数中调用netif_receive_skb将数据包发送到3层，没有进行任何的软中断负载均衡。</p>

<p>在非NAPI中，中断收到数据包后调用netif_rx，这个函数会将数据包保存到input_pkt_queue，然后调度软中断，这里为了兼容NAPI的驱动，他的poll方法默认是process_backlog，最终这个函数会从input_pkt_queue中取得数据包然后发送到3层。</p>

<p>通过比较我们可以看到，不管是NAPI还是非NAPI的话都无法做到软中断的负载均衡，因为软中断此时都是运行在在硬件中断相应的cpu上。也就是说如果始终是cpu0相应网卡的硬件中断，那么始终都是cpu0在处理软中断，而此时cpu1就被浪费了，因为无法并行的执行多个软中断。</p>

<p>google的这个patch的基本原理是这样的,根据数据包的源地址，目的地址以及目的和源端口(这里它是将两个端口组合成一个4字节的无符数进行计算的，后面会看到)计算出一个hash值，然后根据这个hash值来选择软中断运行的cpu，从上层来看，也就是说将每个连接和cpu绑定，并通过这个hash值，来均衡软中断在多个cpu上。</p>

<p>这个介绍比较简单，我们来看代码是如何实现的。</p>

<p>它这里主要是hook了两个内核的函数，一个是netif_rx主要是针对非NAPI的驱动，一个是netif_receive_skb这个主要是针对NAPI的驱动，这两个函数我前面blog都有介绍过，想了解可以看我前面的blog，现在这里我只介绍打过patch的实现。</p>

<p>在看netif_rx和netif_receive_skb之前，我们先来看这个patch中两个重要的函数get_rps_cpu和enqueue_to_backlog，我们一个个看。</p>

<p>先来看相关的两个数据结构，首先是netdev_rx_queue，它表示对应的接收队列，因为有的网卡可能硬件上就支持多队列的模式，此时对应就会有多个rx队列，这个结构是挂载在net_device中的，也就是每个网络设备最终都会有一个或者多个rx队列。这个结构在sys文件系统中的表示类似这样的/sys/class/net/<device>/queues/rx-<n> 几个队列就是rx-n.
<code>
    struct netdev_rx_queue {
        // 保存了当前队列的rps map
        struct rps_map *rps_map;
        // 对应的kobject
        struct kobject kobj;
        // 指向第一个rx队列
        struct netdev_rx_queue *first;
        // 引用计数
        atomic_t count;
    } ____cacheline_aligned_in_smp;
</code></p>

<p>然后就是rps_map，其实这个也就是保存了能够执行数据包的cpu。
<code>
    struct rps_map {
        // cpu的个数，也就是cpus数组的个数
        unsigned int len;
        // RCU锁
        struct rcu_head rcu;
        // 保存了cpu的id.
        u16 cpus[0];
    };
</code></p>

<p>看完上面的结构，我们来看函数的实现。
get_rps_cpu主要是通过传递进来的skb然后来选择这个skb所应该被处理的cpu。它的逻辑很简单，就是通过skb计算hash，然后通过hash从对应的队列的rps_mapping中取得对应的cpu id。</p>

<p>这里有个要注意的就是这个hash值是可以交给硬件网卡去计算的，作者自己说是最好交由硬件去计算这个hash值，因为如果是软件计算的话会导致CPU 缓存不命中，带来一定的性能开销。</p>

<p>还有就是rps_mapping这个值是可以通过sys 文件系统设置的，位置在这里：
/sys/class/net/<device>/queues/rx-<n>/rps_cpus 。</p>

<pre><code>    static int get_rps_cpu(struct net_device *dev, struct sk_buff *skb)
    {
        struct ipv6hdr *ip6;
        struct iphdr *ip;
        struct netdev_rx_queue *rxqueue;
        struct rps_map *map;
        int cpu = -1;
        u8 ip_proto;
        u32 addr1, addr2, ports, ihl;
        // rcu锁
        rcu_read_lock();
        // 取得设备对应的rx 队列
        if (skb_rx_queue_recorded(skb)) {
        ..........................................
            rxqueue = dev-&gt;_rx + index;
        } else
            rxqueue = dev-&gt;_rx;

        if (!rxqueue-&gt;rps_map)
            goto done;
        // 如果硬件已经计算，则跳过计算过程
        if (skb-&gt;rxhash)
            goto got_hash; /* Skip hash computation on packet header */

        switch (skb-&gt;protocol) {
        case __constant_htons(ETH_P_IP):
            if (!pskb_may_pull(skb, sizeof(*ip)))
                goto done;
            // 得到计算hash的几个值
            ip = (struct iphdr *) skb-&gt;data;
            ip_proto = ip-&gt;protocol;
            // 两个地址
            addr1 = ip-&gt;saddr;
            addr2 = ip-&gt;daddr;
            // 得到ip头
            ihl = ip-&gt;ihl;
            break;
        case __constant_htons(ETH_P_IPV6):
            ..........................................
            break;
        default:
            goto done;
        }
        ports = 0;
        switch (ip_proto) {
        case IPPROTO_TCP:
        case IPPROTO_UDP:
        case IPPROTO_DCCP:
        case IPPROTO_ESP:
        case IPPROTO_AH:
        case IPPROTO_SCTP:
        case IPPROTO_UDPLITE:
            if (pskb_may_pull(skb, (ihl * 4) + 4))
            // 我们知道tcp头的前4个字节就是源和目的端口，因此这里跳过ip头得到tcp头的前4个字节
                ports = *((u32 *) (skb-&gt;data + (ihl * 4)));
            break;

        default:
            break;
        }
        // 计算hash
        skb-&gt;rxhash = jhash_3words(addr1, addr2, ports, hashrnd);
        if (!skb-&gt;rxhash)
            skb-&gt;rxhash = 1;

    got_hash:
        // 通过rcu得到对应rps map
        map = rcu_dereference(rxqueue-&gt;rps_map);
        if (map) {
            // 取得对应的cpu
            u16 tcpu = map-&gt;cpus[((u64) skb-&gt;rxhash * map-&gt;len) &gt;&gt; 32];
            // 如果cpu是online的，则返回计算出的这个cpu，否则跳出循环。
            if (cpu_online(tcpu)) {
                cpu = tcpu;
                goto done;
            }
        }

    done:
        rcu_read_unlock();
        // 如果上面失败，则返回-1.
        return cpu;
    }
</code></pre>

<p>然后是enqueue_to_backlog这个方法，首先我们知道在每个cpu都有一个softnet结构，而他有一个input_pkt_queue的队列，以前这个主要是用于非NAPi的驱动的，而这个patch则将这个队列也用与NAPI的处理中了。也就是每个cpu现在都会有一个input_pkt_queue队列，用于保存需要处理的数据包队列。这个队列作用现在是，如果发现不属于当前cpu处理的数据包，则我们可以直接将数据包挂载到他所属的cpu的input_pkt_queue中。</p>

<p>enqueue_to_backlog接受一个skb和cpu为参数，通过cpu来判断skb如何处理。要么加入所属的input_pkt_queue中，要么schecule 软中断。</p>

<p>还有个要注意就是我们知道NAPI为了兼容非NAPI模式，有个backlog的napi_struct结构，也就是非NAPI驱动会schedule backlog这个napi结构，而在enqueue_to_backlog中则是利用了这个结构，也就是它会schedule backlog，因为它会将数据放到input_pkt_queue中，而backlog的pool方法process_backlog就是从input_pkt_queue中取得数据然后交给上层处理。</p>

<p>这里还有一个会用到结构就是 rps_remote_softirq_cpus，它主要是保存了当前cpu上需要去另外的cpu schedule 软中断的cpu 掩码。因为我们可能将要处理的数据包放到了另外的cpu的input queue上，因此我们需要schedule 另外的cpu上的napi(也就是软中断),所以我们需要保存对应的cpu掩码，以便于后面遍历，然后schedule。</p>

<p>而这里为什么mask有两个元素，注释写的很清楚：
<code>
    /*
     * This structure holds the per-CPU mask of CPUs for which IPIs are scheduled
     * to be sent to kick remote softirq processing.  There are two masks since
     * the sending of IPIs must be done with interrupts enabled.  The select field
     * indicates the current mask that enqueue_backlog uses to schedule IPIs.
     * select is flipped before net_rps_action is called while still under lock,
     * net_rps_action then uses the non-selected mask to send the IPIs and clears
     * it without conflicting with enqueue_backlog operation.
     */
    struct rps_remote_softirq_cpus {
        // 对应的cpu掩码
        cpumask_t mask[2];
        // 表示应该使用的数组索引
        int select;
    };
</code></p>

<pre><code>    static int enqueue_to_backlog(struct sk_buff *skb, int cpu)
    {
        struct softnet_data *queue;
        unsigned long flags;
        // 取出传递进来的cpu的softnet-data结构
        queue = &amp;per_cpu(softnet_data, cpu);

        local_irq_save(flags);
        __get_cpu_var(netdev_rx_stat).total++;
        // 自旋锁
        spin_lock(&amp;queue-&gt;input_pkt_queue.lock);
        // 如果保存的队列还没到上限
        if (queue-&gt;input_pkt_queue.qlen &lt;= netdev_max_backlog) {
        // 如果当前队列的输入队列长度不为空
            if (queue-&gt;input_pkt_queue.qlen) {
    enqueue:
                // 将数据包加入到input_pkt_queue中,这里会有一个小问题，我们后面再说。
                __skb_queue_tail(&amp;queue-&gt;input_pkt_queue, skb);
                spin_unlock_irqrestore(&amp;queue-&gt;input_pkt_queue.lock,
                    flags);
                return NET_RX_SUCCESS;
            }

            /* Schedule NAPI for backlog device */
            // 如果可以调度软中断
            if (napi_schedule_prep(&amp;queue-&gt;backlog)) {
                // 首先判断数据包该不该当前的cpu处理
                if (cpu != smp_processor_id()) {
                    // 如果不该，
                    struct rps_remote_softirq_cpus *rcpus =
                        &amp;__get_cpu_var(rps_remote_softirq_cpus);

                    cpu_set(cpu, rcpus-&gt;mask[rcpus-&gt;select]);
                    __raise_softirq_irqoff(NET_RX_SOFTIRQ);
                } else
                    // 如果就是应该当前cpu处理，则直接schedule 软中断，这里可以看到传递进去的是backlog
                    __napi_schedule(&amp;queue-&gt;backlog);
            }
            goto enqueue;
        }

        spin_unlock(&amp;queue-&gt;input_pkt_queue.lock);

        __get_cpu_var(netdev_rx_stat).dropped++;
        local_irq_restore(flags);

        kfree_skb(skb);
        return NET_RX_DROP;
    }
</code></pre>

<p>这里会有一个小问题，那就是假设此时一个属于cpu0的包进入处理，此时我们运行在cpu1,此时将数据包加入到input队列，然后cpu0上面刚好又来了一个cpu0需要处理的数据包，此时由于qlen不为0则又将数据包加入到input队列中，我们会发现cpu0上的napi没机会进行调度了。</p>

<p>google的patch对这个是这样处理的，在软中断处理函数中当数据包处理完毕，会调用net_rps_action来调度前面保存到其他cpu上的input队列。</p>

<p>下面就是代码片断（net_rx_action）</p>

<pre><code>    // 得到对应的rcpus.
    rcpus = &amp;__get_cpu_var(rps_remote_softirq_cpus);
        select = rcpus-&gt;select;
        // 翻转select，防止和enqueue_backlog冲突
        rcpus-&gt;select ^= 1;

        // 打开中断，此时下面的调度才会起作用.
        local_irq_enable();
        // 这个函数里面调度对应的远程cpu的napi.
        net_rps_action(&amp;rcpus-&gt;mask[select]);
</code></pre>

<p>然后就是net_rps_action，这个函数很简单，就是遍历所需要处理的cpu，然后调度napi
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
<span class='line-number'>206</span>
<span class='line-number'>207</span>
<span class='line-number'>208</span>
<span class='line-number'>209</span>
<span class='line-number'>210</span>
<span class='line-number'>211</span>
<span class='line-number'>212</span>
<span class='line-number'>213</span>
<span class='line-number'>214</span>
<span class='line-number'>215</span>
<span class='line-number'>216</span>
<span class='line-number'>217</span>
<span class='line-number'>218</span>
<span class='line-number'>219</span>
<span class='line-number'>220</span>
<span class='line-number'>221</span>
<span class='line-number'>222</span>
<span class='line-number'>223</span>
<span class='line-number'>224</span>
<span class='line-number'>225</span>
<span class='line-number'>226</span>
<span class='line-number'>227</span>
<span class='line-number'>228</span>
<span class='line-number'>229</span>
<span class='line-number'>230</span>
<span class='line-number'>231</span>
<span class='line-number'>232</span>
<span class='line-number'>233</span>
<span class='line-number'>234</span>
<span class='line-number'>235</span>
<span class='line-number'>236</span>
<span class='line-number'>237</span>
<span class='line-number'>238</span>
<span class='line-number'>239</span>
<span class='line-number'>240</span>
<span class='line-number'>241</span>
<span class='line-number'>242</span>
<span class='line-number'>243</span>
<span class='line-number'>244</span>
<span class='line-number'>245</span>
<span class='line-number'>246</span>
<span class='line-number'>247</span>
<span class='line-number'>248</span>
<span class='line-number'>249</span>
<span class='line-number'>250</span>
<span class='line-number'>251</span>
<span class='line-number'>252</span>
<span class='line-number'>253</span>
<span class='line-number'>254</span>
<span class='line-number'>255</span>
<span class='line-number'>256</span>
<span class='line-number'>257</span>
<span class='line-number'>258</span>
<span class='line-number'>259</span>
<span class='line-number'>260</span>
<span class='line-number'>261</span>
<span class='line-number'>262</span>
<span class='line-number'>263</span>
<span class='line-number'>264</span>
<span class='line-number'>265</span>
<span class='line-number'>266</span>
<span class='line-number'>267</span>
<span class='line-number'>268</span>
<span class='line-number'>269</span>
<span class='line-number'>270</span>
<span class='line-number'>271</span>
<span class='line-number'>272</span>
<span class='line-number'>273</span>
<span class='line-number'>274</span>
<span class='line-number'>275</span>
<span class='line-number'>276</span>
<span class='line-number'>277</span>
<span class='line-number'>278</span>
<span class='line-number'>279</span>
<span class='line-number'>280</span>
<span class='line-number'>281</span>
<span class='line-number'>282</span>
<span class='line-number'>283</span>
<span class='line-number'>284</span>
<span class='line-number'>285</span>
<span class='line-number'>286</span>
<span class='line-number'>287</span>
<span class='line-number'>288</span>
<span class='line-number'>289</span>
<span class='line-number'>290</span>
<span class='line-number'>291</span>
<span class='line-number'>292</span>
<span class='line-number'>293</span>
<span class='line-number'>294</span>
<span class='line-number'>295</span>
<span class='line-number'>296</span>
<span class='line-number'>297</span>
<span class='line-number'>298</span>
<span class='line-number'>299</span>
<span class='line-number'>300</span>
<span class='line-number'>301</span>
<span class='line-number'>302</span>
<span class='line-number'>303</span>
<span class='line-number'>304</span>
<span class='line-number'>305</span>
<span class='line-number'>306</span>
<span class='line-number'>307</span>
<span class='line-number'>308</span>
<span class='line-number'>309</span>
<span class='line-number'>310</span>
<span class='line-number'>311</span>
<span class='line-number'>312</span>
<span class='line-number'>313</span>
<span class='line-number'>314</span>
<span class='line-number'>315</span>
<span class='line-number'>316</span>
<span class='line-number'>317</span>
<span class='line-number'>318</span>
<span class='line-number'>319</span>
<span class='line-number'>320</span>
<span class='line-number'>321</span>
<span class='line-number'>322</span>
<span class='line-number'>323</span>
<span class='line-number'>324</span>
<span class='line-number'>325</span>
<span class='line-number'>326</span>
<span class='line-number'>327</span>
<span class='line-number'>328</span>
<span class='line-number'>329</span>
<span class='line-number'>330</span>
<span class='line-number'>331</span>
<span class='line-number'>332</span>
<span class='line-number'>333</span>
<span class='line-number'>334</span>
<span class='line-number'>335</span>
<span class='line-number'>336</span>
<span class='line-number'>337</span>
<span class='line-number'>338</span>
<span class='line-number'>339</span>
<span class='line-number'>340</span>
<span class='line-number'>341</span>
<span class='line-number'>342</span>
<span class='line-number'>343</span>
<span class='line-number'>344</span>
<span class='line-number'>345</span>
<span class='line-number'>346</span>
<span class='line-number'>347</span>
<span class='line-number'>348</span>
<span class='line-number'>349</span>
<span class='line-number'>350</span>
<span class='line-number'>351</span>
<span class='line-number'>352</span>
<span class='line-number'>353</span>
<span class='line-number'>354</span>
<span class='line-number'>355</span>
<span class='line-number'>356</span>
<span class='line-number'>357</span>
<span class='line-number'>358</span>
<span class='line-number'>359</span>
<span class='line-number'>360</span>
<span class='line-number'>361</span>
<span class='line-number'>362</span>
<span class='line-number'>363</span>
<span class='line-number'>364</span>
<span class='line-number'>365</span>
<span class='line-number'>366</span>
<span class='line-number'>367</span>
<span class='line-number'>368</span>
<span class='line-number'>369</span>
<span class='line-number'>370</span>
<span class='line-number'>371</span>
<span class='line-number'>372</span>
<span class='line-number'>373</span>
<span class='line-number'>374</span>
<span class='line-number'>375</span>
<span class='line-number'>376</span>
<span class='line-number'>377</span>
<span class='line-number'>378</span>
<span class='line-number'>379</span>
<span class='line-number'>380</span>
<span class='line-number'>381</span>
<span class='line-number'>382</span>
<span class='line-number'>383</span>
<span class='line-number'>384</span>
<span class='line-number'>385</span>
<span class='line-number'>386</span>
<span class='line-number'>387</span>
<span class='line-number'>388</span>
<span class='line-number'>389</span>
<span class='line-number'>390</span>
<span class='line-number'>391</span>
<span class='line-number'>392</span>
<span class='line-number'>393</span>
<span class='line-number'>394</span>
<span class='line-number'>395</span>
<span class='line-number'>396</span>
<span class='line-number'>397</span>
<span class='line-number'>398</span>
<span class='line-number'>399</span>
<span class='line-number'>400</span>
<span class='line-number'>401</span>
<span class='line-number'>402</span>
<span class='line-number'>403</span>
<span class='line-number'>404</span>
<span class='line-number'>405</span>
<span class='line-number'>406</span>
<span class='line-number'>407</span>
<span class='line-number'>408</span>
<span class='line-number'>409</span>
<span class='line-number'>410</span>
<span class='line-number'>411</span>
<span class='line-number'>412</span>
<span class='line-number'>413</span>
<span class='line-number'>414</span>
<span class='line-number'>415</span>
<span class='line-number'>416</span>
<span class='line-number'>417</span>
<span class='line-number'>418</span>
<span class='line-number'>419</span>
<span class='line-number'>420</span>
<span class='line-number'>421</span>
<span class='line-number'>422</span>
<span class='line-number'>423</span>
<span class='line-number'>424</span>
<span class='line-number'>425</span>
<span class='line-number'>426</span>
<span class='line-number'>427</span>
<span class='line-number'>428</span>
<span class='line-number'>429</span>
<span class='line-number'>430</span>
<span class='line-number'>431</span>
<span class='line-number'>432</span>
<span class='line-number'>433</span>
<span class='line-number'>434</span>
<span class='line-number'>435</span>
<span class='line-number'>436</span>
<span class='line-number'>437</span>
<span class='line-number'>438</span>
<span class='line-number'>439</span>
<span class='line-number'>440</span>
<span class='line-number'>441</span>
<span class='line-number'>442</span>
<span class='line-number'>443</span>
<span class='line-number'>444</span>
<span class='line-number'>445</span>
<span class='line-number'>446</span>
<span class='line-number'>447</span>
<span class='line-number'>448</span>
<span class='line-number'>449</span>
<span class='line-number'>450</span>
<span class='line-number'>451</span>
<span class='line-number'>452</span>
<span class='line-number'>453</span>
<span class='line-number'>454</span>
<span class='line-number'>455</span>
<span class='line-number'>456</span>
<span class='line-number'>457</span>
<span class='line-number'>458</span>
<span class='line-number'>459</span>
<span class='line-number'>460</span>
<span class='line-number'>461</span>
<span class='line-number'>462</span>
<span class='line-number'>463</span>
<span class='line-number'>464</span>
<span class='line-number'>465</span>
<span class='line-number'>466</span>
<span class='line-number'>467</span>
<span class='line-number'>468</span>
<span class='line-number'>469</span>
<span class='line-number'>470</span>
<span class='line-number'>471</span>
<span class='line-number'>472</span>
<span class='line-number'>473</span>
<span class='line-number'>474</span>
<span class='line-number'>475</span>
<span class='line-number'>476</span>
<span class='line-number'>477</span>
<span class='line-number'>478</span>
<span class='line-number'>479</span>
<span class='line-number'>480</span>
<span class='line-number'>481</span>
<span class='line-number'>482</span>
<span class='line-number'>483</span>
<span class='line-number'>484</span>
<span class='line-number'>485</span>
<span class='line-number'>486</span>
<span class='line-number'>487</span>
<span class='line-number'>488</span>
<span class='line-number'>489</span>
<span class='line-number'>490</span>
<span class='line-number'>491</span>
<span class='line-number'>492</span>
<span class='line-number'>493</span>
<span class='line-number'>494</span>
<span class='line-number'>495</span>
<span class='line-number'>496</span>
<span class='line-number'>497</span>
<span class='line-number'>498</span>
<span class='line-number'>499</span>
<span class='line-number'>500</span>
<span class='line-number'>501</span>
<span class='line-number'>502</span>
<span class='line-number'>503</span>
<span class='line-number'>504</span>
<span class='line-number'>505</span>
<span class='line-number'>506</span>
<span class='line-number'>507</span>
<span class='line-number'>508</span>
<span class='line-number'>509</span>
<span class='line-number'>510</span>
<span class='line-number'>511</span>
<span class='line-number'>512</span>
<span class='line-number'>513</span>
<span class='line-number'>514</span>
<span class='line-number'>515</span>
<span class='line-number'>516</span>
<span class='line-number'>517</span>
<span class='line-number'>518</span>
<span class='line-number'>519</span>
<span class='line-number'>520</span>
<span class='line-number'>521</span>
<span class='line-number'>522</span>
<span class='line-number'>523</span>
<span class='line-number'>524</span>
<span class='line-number'>525</span>
<span class='line-number'>526</span>
<span class='line-number'>527</span>
<span class='line-number'>528</span>
<span class='line-number'>529</span>
<span class='line-number'>530</span>
<span class='line-number'>531</span>
<span class='line-number'>532</span>
<span class='line-number'>533</span>
<span class='line-number'>534</span>
<span class='line-number'>535</span>
<span class='line-number'>536</span>
<span class='line-number'>537</span>
<span class='line-number'>538</span>
<span class='line-number'>539</span>
<span class='line-number'>540</span>
<span class='line-number'>541</span>
<span class='line-number'>542</span>
<span class='line-number'>543</span>
<span class='line-number'>544</span>
<span class='line-number'>545</span>
<span class='line-number'>546</span>
<span class='line-number'>547</span>
<span class='line-number'>548</span>
<span class='line-number'>549</span>
<span class='line-number'>550</span>
<span class='line-number'>551</span>
<span class='line-number'>552</span>
<span class='line-number'>553</span>
<span class='line-number'>554</span>
<span class='line-number'>555</span>
<span class='line-number'>556</span>
<span class='line-number'>557</span>
<span class='line-number'>558</span>
<span class='line-number'>559</span>
<span class='line-number'>560</span>
<span class='line-number'>561</span>
<span class='line-number'>562</span>
<span class='line-number'>563</span>
<span class='line-number'>564</span>
<span class='line-number'>565</span>
<span class='line-number'>566</span>
<span class='line-number'>567</span>
<span class='line-number'>568</span>
<span class='line-number'>569</span>
<span class='line-number'>570</span>
<span class='line-number'>571</span>
<span class='line-number'>572</span>
<span class='line-number'>573</span>
<span class='line-number'>574</span>
<span class='line-number'>575</span>
<span class='line-number'>576</span>
<span class='line-number'>577</span>
<span class='line-number'>578</span>
<span class='line-number'>579</span>
<span class='line-number'>580</span>
<span class='line-number'>581</span>
<span class='line-number'>582</span>
<span class='line-number'>583</span>
<span class='line-number'>584</span>
<span class='line-number'>585</span>
<span class='line-number'>586</span>
<span class='line-number'>587</span>
<span class='line-number'>588</span>
<span class='line-number'>589</span>
<span class='line-number'>590</span>
<span class='line-number'>591</span>
<span class='line-number'>592</span>
<span class='line-number'>593</span>
<span class='line-number'>594</span>
<span class='line-number'>595</span>
<span class='line-number'>596</span>
<span class='line-number'>597</span>
<span class='line-number'>598</span>
<span class='line-number'>599</span>
<span class='line-number'>600</span>
<span class='line-number'>601</span>
<span class='line-number'>602</span>
<span class='line-number'>603</span>
<span class='line-number'>604</span>
<span class='line-number'>605</span>
<span class='line-number'>606</span>
<span class='line-number'>607</span>
<span class='line-number'>608</span>
<span class='line-number'>609</span>
<span class='line-number'>610</span>
<span class='line-number'>611</span>
<span class='line-number'>612</span>
<span class='line-number'>613</span>
<span class='line-number'>614</span>
<span class='line-number'>615</span>
<span class='line-number'>616</span>
<span class='line-number'>617</span>
<span class='line-number'>618</span>
<span class='line-number'>619</span>
<span class='line-number'>620</span>
<span class='line-number'>621</span>
<span class='line-number'>622</span>
<span class='line-number'>623</span>
<span class='line-number'>624</span>
<span class='line-number'>625</span>
<span class='line-number'>626</span>
<span class='line-number'>627</span>
<span class='line-number'>628</span>
<span class='line-number'>629</span>
<span class='line-number'>630</span>
<span class='line-number'>631</span>
<span class='line-number'>632</span>
<span class='line-number'>633</span>
<span class='line-number'>634</span>
<span class='line-number'>635</span>
<span class='line-number'>636</span>
<span class='line-number'>637</span>
<span class='line-number'>638</span>
<span class='line-number'>639</span>
<span class='line-number'>640</span>
<span class='line-number'>641</span>
<span class='line-number'>642</span>
<span class='line-number'>643</span>
<span class='line-number'>644</span>
<span class='line-number'>645</span>
<span class='line-number'>646</span>
<span class='line-number'>647</span>
<span class='line-number'>648</span>
<span class='line-number'>649</span>
<span class='line-number'>650</span>
<span class='line-number'>651</span>
<span class='line-number'>652</span>
<span class='line-number'>653</span>
<span class='line-number'>654</span>
<span class='line-number'>655</span>
<span class='line-number'>656</span>
<span class='line-number'>657</span>
<span class='line-number'>658</span>
<span class='line-number'>659</span>
<span class='line-number'>660</span>
<span class='line-number'>661</span>
<span class='line-number'>662</span>
<span class='line-number'>663</span>
<span class='line-number'>664</span>
<span class='line-number'>665</span>
<span class='line-number'>666</span>
<span class='line-number'>667</span>
<span class='line-number'>668</span>
<span class='line-number'>669</span>
<span class='line-number'>670</span>
<span class='line-number'>671</span>
<span class='line-number'>672</span>
<span class='line-number'>673</span>
<span class='line-number'>674</span>
<span class='line-number'>675</span>
<span class='line-number'>676</span>
<span class='line-number'>677</span>
<span class='line-number'>678</span>
<span class='line-number'>679</span>
<span class='line-number'>680</span>
<span class='line-number'>681</span>
<span class='line-number'>682</span>
<span class='line-number'>683</span>
<span class='line-number'>684</span>
<span class='line-number'>685</span>
<span class='line-number'>686</span>
<span class='line-number'>687</span>
<span class='line-number'>688</span>
<span class='line-number'>689</span>
<span class='line-number'>690</span>
<span class='line-number'>691</span>
<span class='line-number'>692</span>
<span class='line-number'>693</span>
<span class='line-number'>694</span>
<span class='line-number'>695</span>
<span class='line-number'>696</span>
<span class='line-number'>697</span>
<span class='line-number'>698</span>
<span class='line-number'>699</span>
<span class='line-number'>700</span>
<span class='line-number'>701</span>
<span class='line-number'>702</span>
<span class='line-number'>703</span>
<span class='line-number'>704</span>
<span class='line-number'>705</span>
<span class='line-number'>706</span>
<span class='line-number'>707</span>
<span class='line-number'>708</span>
<span class='line-number'>709</span>
<span class='line-number'>710</span>
<span class='line-number'>711</span>
<span class='line-number'>712</span>
<span class='line-number'>713</span>
<span class='line-number'>714</span>
<span class='line-number'>715</span>
<span class='line-number'>716</span>
<span class='line-number'>717</span>
<span class='line-number'>718</span>
<span class='line-number'>719</span>
<span class='line-number'>720</span>
<span class='line-number'>721</span>
<span class='line-number'>722</span>
<span class='line-number'>723</span>
<span class='line-number'>724</span>
<span class='line-number'>725</span>
<span class='line-number'>726</span>
<span class='line-number'>727</span>
<span class='line-number'>728</span>
<span class='line-number'>729</span>
<span class='line-number'>730</span>
<span class='line-number'>731</span>
<span class='line-number'>732</span>
<span class='line-number'>733</span>
<span class='line-number'>734</span>
<span class='line-number'>735</span>
<span class='line-number'>736</span>
<span class='line-number'>737</span>
<span class='line-number'>738</span>
<span class='line-number'>739</span>
<span class='line-number'>740</span>
<span class='line-number'>741</span>
<span class='line-number'>742</span>
<span class='line-number'>743</span>
<span class='line-number'>744</span>
<span class='line-number'>745</span>
<span class='line-number'>746</span>
<span class='line-number'>747</span>
<span class='line-number'>748</span>
<span class='line-number'>749</span>
<span class='line-number'>750</span>
<span class='line-number'>751</span>
<span class='line-number'>752</span>
<span class='line-number'>753</span>
<span class='line-number'>754</span>
<span class='line-number'>755</span>
<span class='line-number'>756</span>
<span class='line-number'>757</span>
<span class='line-number'>758</span>
<span class='line-number'>759</span>
<span class='line-number'>760</span>
<span class='line-number'>761</span>
<span class='line-number'>762</span>
<span class='line-number'>763</span>
<span class='line-number'>764</span>
<span class='line-number'>765</span>
<span class='line-number'>766</span>
<span class='line-number'>767</span>
<span class='line-number'>768</span>
<span class='line-number'>769</span>
<span class='line-number'>770</span>
<span class='line-number'>771</span>
<span class='line-number'>772</span>
<span class='line-number'>773</span>
<span class='line-number'>774</span>
<span class='line-number'>775</span>
<span class='line-number'>776</span>
<span class='line-number'>777</span>
<span class='line-number'>778</span>
<span class='line-number'>779</span>
<span class='line-number'>780</span>
<span class='line-number'>781</span>
<span class='line-number'>782</span>
<span class='line-number'>783</span>
<span class='line-number'>784</span>
<span class='line-number'>785</span>
<span class='line-number'>786</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void net_rps_action(cpumask_t *mask)
</span><span class='line'>{
</span><span class='line'>    int cpu;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    /* Send pending IPI's to kick RPS processing on remote cpus. */
</span><span class='line'>// 遍历
</span><span class='line'>for_each_cpu_mask_nr(cpu, *mask) {
</span><span class='line'>    struct softnet_data *queue = &amp;per_cpu(softnet_data, cpu);
</span><span class='line'>    if (cpu_online(cpu))
</span><span class='line'>        // 到对应的cpu调用csd方法。
</span><span class='line'>        __smp_call_function_single(cpu, &amp;queue-&gt;csd, 0);
</span><span class='line'>}
</span><span class='line'>// 清理mask
</span><span class='line'>cpus_clear(*mask);
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>
</span><span class='line'>上面我们看到会调用csd方法，而上面的csd回掉就是被初始化为trigger_softirq函数。
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static void trigger_softirq(void *data)
</span><span class='line'>{
</span><span class='line'>struct softnet_data *queue = data;
</span><span class='line'>// 调度napi可以看到依旧是backlog 这个napi结构体。
</span><span class='line'>__napi_schedule(&amp;queue-&gt;backlog);
</span><span class='line'>__get_cpu_var(netdev_rx_stat).received_rps++;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>
</span><span class='line'>上面的函数都分析完毕了，剩下的就很简单了。
</span><span class='line'>
</span><span class='line'>首先来看netif_rx如何被修改的，它被修改的很简单，首先是得到当前skb所应该被处理的cpu id，然后再通过比较这个cpu和当前正在处理的cpu id进行比较来做不同的处理。
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;int netif_rx(struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>int cpu;
</span><span class='line'>
</span><span class='line'>/* if netpoll wants it, pretend we never saw it */
</span><span class='line'>if (netpoll_rx(skb))
</span><span class='line'>    return NET_RX_DROP;
</span><span class='line'>
</span><span class='line'>if (!skb-&gt;tstamp.tv64)
</span><span class='line'>    net_timestamp(skb);
</span><span class='line'>// 得到cpu id。
</span><span class='line'>cpu = get_rps_cpu(skb-&gt;dev, skb);
</span><span class='line'>if (cpu &lt; 0)
</span><span class='line'>    cpu = smp_processor_id();
</span><span class='line'>// 通过cpu进行队列不同的处理
</span><span class='line'>return enqueue_to_backlog(skb, cpu);
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>
</span><span class='line'>然后是netif_receive_skb,这里patch将内核本身的这个函数改写为__netif_receive_skb。然后当返回值小于0,则说明不需要对队列进行处理，此时直接发送到3层。
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;int netif_receive_skb(struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>int cpu;
</span><span class='line'>
</span><span class='line'>cpu = get_rps_cpu(skb-&gt;dev, skb);
</span><span class='line'>
</span><span class='line'>if (cpu &lt; 0)
</span><span class='line'>    return __netif_receive_skb(skb);
</span><span class='line'>else
</span><span class='line'>    return enqueue_to_backlog(skb, cpu);
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;最后来总结一下，可以看到input_pkt_queue是一个FIFO的队列，而且如果当qlen有值的时候，也就是在另外的cpu有数据包放到input_pkt_queue中，则当前cpu不会调度napi，而是将数据包放到input_pkt_queue中，然后等待trigger_softirq来调度napi。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;因此这个patch完美的解决了软中断在多核下的均衡问题，并且没有由于是同一个连接会map到相同的cpu，并且input_pkt_queue的使用，因此乱序的问题也不会出现。&lt;/p&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[内核协议栈tcp层的内存管理]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2015/06/03/kernel-net-mem/"/&gt;
</span><span class='line'>&lt;updated&gt;2015-06-03T14:25:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2015/06/03/kernel-net-mem&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;p&gt;&lt;a href="http://simohayha.iteye.com/blog/532450"&gt;http://simohayha.iteye.com/blog/532450&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;a href="http://www.ibm.com/developerworks/cn/linux/l-hisock.html#table1"&gt;http://www.ibm.com/developerworks/cn/linux/l-hisock.html#table1&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;a href="http://blog.csdn.net/russell_tao/article/details/18711023"&gt;http://blog.csdn.net/russell_tao/article/details/18711023&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;我们先来看tcp内存管理相关的几个内核参数,这些都能通过proc文件系统来修改:
</span><span class='line'>&lt;code&gt;
</span><span class='line'>// 内核写buf的最大值.
</span><span class='line'>extern __u32 sysctl_wmem_max;
</span><span class='line'>// 协议栈读buf的最大值
</span><span class='line'>extern __u32 sysctl_rmem_max;
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;这两个值在/proc/sys/net/core 下。这里要注意，这两个值的单位是字节。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;它们的初始化在sk_init里面,这里可以看到这两个值的大小是依赖于num_physpages的，而这个值应该是物理页数。也就是说这两个值依赖于物理内存：&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    void __init sk_init(void)
</span><span class='line'>{
</span><span class='line'>    if (num_physpages &lt;= 4096) {
</span><span class='line'>        sysctl_wmem_max = 32767;
</span><span class='line'>        sysctl_rmem_max = 32767;
</span><span class='line'>        sysctl_wmem_default = 32767;
</span><span class='line'>        sysctl_rmem_default = 32767;
</span><span class='line'>    } else if (num_physpages &gt;= 131072) {
</span><span class='line'>        sysctl_wmem_max = 131071;
</span><span class='line'>        sysctl_rmem_max = 131071;
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;而我通过搜索源码，只有设置套接口选项的时候，才会用到这两个值，也就是setsockopt，optname为SO_SNDBUF或者SO_RCVBUF时，来限制设置的值:&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    case SO_SNDBUF:
</span><span class='line'>        if (val &gt; sysctl_wmem_max)
</span><span class='line'>            val = sysctl_wmem_max;
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;接下来就是整个tcp协议栈的socket的buf限制(也就是所有的socket).
</span><span class='line'>这里要注意，这个东西的单位都是以页为单位的，我们下面就会看到。
</span><span class='line'>&lt;code&gt;
</span><span class='line'>其中sysctl_tcp_mem[0]表示整个tcp sock的buf限制.
</span><span class='line'>sysctl_tcp_mem[1]也就是tcp sock内存使用的警戒线.
</span><span class='line'>sysctl_tcp_mem[2]也就是tcp sock内存使用的hard limit,当超过这个限制,我们就要禁止再分配buf.
</span><span class='line'>extern int sysctl_tcp_mem[3];
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;接下来就是针对每个sock的读写buf限制。
</span><span class='line'>&lt;code&gt;
</span><span class='line'>// 其中依次为最小buf,中等buf,以及最大buf.
</span><span class='line'>extern int sysctl_tcp_wmem[3];
</span><span class='line'>extern int sysctl_tcp_rmem[3];
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;tcp_init&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;这几个值的初始化在tcp_init里面，这里就能清晰的看到sysctl_tcp_mem的单位是页。而sysctl_tcp_wmem和sysctl_tcp_rmem的单位是字节。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    void __init tcp_init(void)
</span><span class='line'>{
</span><span class='line'>    .................................
</span><span class='line'>    // nr_pages就是页。
</span><span class='line'>    nr_pages = totalram_pages - totalhigh_pages;
</span><span class='line'>    limit = min(nr_pages, 1UL&lt;&lt;(28-PAGE_SHIFT)) &gt;&gt; (20-PAGE_SHIFT);
</span><span class='line'>    limit = (limit * (nr_pages &gt;&gt; (20-PAGE_SHIFT))) &gt;&gt; (PAGE_SHIFT-11);
</span><span class='line'>    limit = max(limit, 128UL);
</span><span class='line'>    sysctl_tcp_mem[0] = limit / 4 * 3;
</span><span class='line'>    sysctl_tcp_mem[1] = limit;
</span><span class='line'>    sysctl_tcp_mem[2] = sysctl_tcp_mem[0] * 2;
</span><span class='line'>
</span><span class='line'>    /* Set per-socket limits to no more than 1/128 the pressure threshold */
</span><span class='line'>    // 转换为字节。
</span><span class='line'>    limit = ((unsigned long)sysctl_tcp_mem[1]) &lt;&lt; (PAGE_SHIFT - 7);
</span><span class='line'>    max_share = min(4UL*1024*1024, limit);
</span><span class='line'>
</span><span class='line'>    sysctl_tcp_wmem[0] = SK_MEM_QUANTUM;
</span><span class='line'>    sysctl_tcp_wmem[1] = 16*1024;
</span><span class='line'>    sysctl_tcp_wmem[2] = max(64*1024, max_share);
</span><span class='line'>
</span><span class='line'>    sysctl_tcp_rmem[0] = SK_MEM_QUANTUM;
</span><span class='line'>    sysctl_tcp_rmem[1] = 87380;
</span><span class='line'>    sysctl_tcp_rmem[2] = max(87380, max_share);
</span><span class='line'>    ................................
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;然后就是读写buf的最小值
</span><span class='line'>&lt;code&gt;
</span><span class='line'>#define SOCK_MIN_SNDBUF 2048
</span><span class='line'>#define SOCK_MIN_RCVBUF 256
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;最后就是当前tcp协议栈已经分配了的buf的总大小。这里要注意，这个值也是以页为单位的。
</span><span class='line'>&lt;code&gt;
</span><span class='line'>atomic_t tcp_memory_allocated
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;而上面的这些值如何与协议栈关联起来呢，我们来看tcp_prot结构，可以看到这些值的地址都被放到对应的tcp_prot的域。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    struct proto tcp_prot = {
</span><span class='line'>    .name = "TCP",
</span><span class='line'>    .owner = THIS_MODULE,
</span><span class='line'>    ...................................................
</span><span class='line'>    .enter_memory_pressure = tcp_enter_memory_pressure,
</span><span class='line'>    .sockets_allocated = &amp;tcp_sockets_allocated,
</span><span class='line'>    .orphan_count = &amp;tcp_orphan_count,
</span><span class='line'>    .memory_allocated = &amp;tcp_memory_allocated,
</span><span class='line'>    .memory_pressure = &amp;tcp_memory_pressure,
</span><span class='line'>    .sysctl_mem = sysctl_tcp_mem,
</span><span class='line'>    .sysctl_wmem = sysctl_tcp_wmem,
</span><span class='line'>    .sysctl_rmem = sysctl_tcp_rmem,
</span><span class='line'>    ........................................................
</span><span class='line'>};
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;而对应的sock域中的几个值，这几个域非常重要，我们来看他们表示的含义&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;sk_rcvbuf和sk_sndbuf,这两个值分别代表每个sock的读写buf的最大限制&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;sk_rmem_alloc和sk_wmem_alloc这两个值分别代表已经提交的数据包的字节数。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;读buf意味着进入tcp层的数据大小，而当数据提交给用户空间之后，这个值会相应的减去提交的大小（也就类似写buf的sk_wmem_queued)。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;写buf意味着提交给ip层。可以看到这个值的增加是在tcp_transmit_skb中进行的。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;而sk_wmem_queued也就代表skb的写队列write_queue的大小。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;还有一个sk_forward_alloc，这个值表示一个预分配置，也就是整个tcp协议栈的内存cache，第一次为一个缓冲区分配buf的时候，我们不会直接分配精确的大小，而是按页来分配，而分配的大小就是这个值，下面我们会看到这个。并且这个值初始是0.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    struct sock {
</span><span class='line'>    int sk_rcvbuf;
</span><span class='line'>    atomic_t sk_rmem_alloc;
</span><span class='line'>    atomic_t sk_wmem_alloc;
</span><span class='line'>    int sk_forward_alloc;
</span><span class='line'>    ..........................
</span><span class='line'>    int sk_sndbuf;
</span><span class='line'>    // 这个表示写buf已经分配的字节长度
</span><span class='line'>    int sk_wmem_queued;
</span><span class='line'>    ...........................
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;sk_sndbuf和sk_rcvbuf,这两个的初始化在这里：
</span><span class='line'>&lt;code&gt;
</span><span class='line'>static int tcp_v4_init_sock(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>    ..................................
</span><span class='line'>    sk-&gt;sk_sndbuf = sysctl_tcp_wmem[1];
</span><span class='line'>    sk-&gt;sk_rcvbuf = sysctl_tcp_rmem[1];
</span><span class='line'>    ..........................
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;而当进入establish状态之后,sock会自己调整sndbuf和rcvbuf.他是通过tcp_init_buffer_space来进行调整的.这个函数会调用tcp_fixup_rcvbuf和tcp_fixup_sndbuf来调整读写buf的大小.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;这里有用到sk_userlock这个标记，这个标记主要就是用来标记SO_SNDBUF 和SO_RCVBUF套接口选项是否被设置。而是否设置对应的值为：&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    #define SOCK_SNDBUF_LOCK    1
</span><span class='line'>#define SOCK_RCVBUF_LOCK    2
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;我们可以看下面的设置SO_SNDBUF 和SO_RCVBUF的代码片断：&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    // 首先设置sk_userlocks.
</span><span class='line'>sk-&gt;sk_userlocks |= SOCK_SNDBUF_LOCK;
</span><span class='line'>if ((val * 2) &lt; SOCK_MIN_SNDBUF)
</span><span class='line'>    sk-&gt;sk_sndbuf = SOCK_MIN_SNDBUF;
</span><span class='line'>else
</span><span class='line'>    sk-&gt;sk_sndbuf = val * 2;
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;因此内核里面的处理是这样的，如果用户已经通过套接字选项设置了读或者写buf的大小，那么这里将不会调整读写buf的大小，否则就进入tcp_fixup_XXX来调整大小。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;还有一个要注意的就是MAX_TCP_HEADER，这个值表示了TCP + IP + link layer headers 以及option的长度。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;我们来看代码。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    static void tcp_init_buffer_space(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>    int maxwin;
</span><span class='line'>
</span><span class='line'>    // 判断sk_userlocks，来决定是否需要fix缓冲区大小。
</span><span class='line'>    if (!(sk-&gt;sk_userlocks &amp; SOCK_RCVBUF_LOCK))
</span><span class='line'>        tcp_fixup_rcvbuf(sk);
</span><span class='line'>    if (!(sk-&gt;sk_userlocks &amp; SOCK_SNDBUF_LOCK))
</span><span class='line'>        tcp_fixup_sndbuf(sk);
</span><span class='line'>......................................
</span><span class='line'>
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;接下来来看这两个函数如何来调整读写buf的大小，不过这里还有些疑问，就是为什么是要和3&lt;em&gt;sndmem以及4&lt;/em&gt;rcvmem：&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    static void tcp_fixup_sndbuf(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>    // 首先通过mss，tcp头，以及sk_buff的大小，得到一个最小范围的sndmem。
</span><span class='line'>    int sndmem = tcp_sk(sk)-&gt;rx_opt.mss_clamp + MAX_TCP_HEADER + 16 +sizeof(struct sk_buff);
</span><span class='line'>
</span><span class='line'>    // 然后取sysctl_tcp_wmem[2]和3倍的sndmem之间的最小值。
</span><span class='line'>    if (sk-&gt;sk_sndbuf &lt; 3 * sndmem)
</span><span class='line'>        sk-&gt;sk_sndbuf = min(3 * sndmem, sysctl_tcp_wmem[2]);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>static void tcp_fixup_rcvbuf(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>    // 这里和上面类似，也是先得到最小的一个rcvmem段。
</span><span class='line'>    int rcvmem = tp-&gt;advmss + MAX_TCP_HEADER + 16 + sizeof(struct sk_buff);
</span><span class='line'>
</span><span class='line'>    /* Try to select rcvbuf so that 4 mss-sized segments
</span><span class='line'>     * will fit to window and corresponding skbs will fit to our rcvbuf.
</span><span class='line'>     * (was 3; 4 is minimum to allow fast retransmit to work.)
</span><span class='line'>     */
</span><span class='line'>    // 这里则是通过sysctl_tcp_adv_win_scale来调整rcvmem的值。
</span><span class='line'>    while (tcp_win_from_space(rcvmem) &lt; tp-&gt;advmss)
</span><span class='line'>        rcvmem += 128;
</span><span class='line'>    if (sk-&gt;sk_rcvbuf &lt; 4 * rcvmem)
</span><span class='line'>        sk-&gt;sk_rcvbuf = min(4 * rcvmem, sysctl_tcp_rmem[2]);
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;ok，看完初始化，我们来看协议栈具体如何管理内存的，先来看发送端，发送端的主要实现是在tcp_sendmsg里面，这个函数我们前面已经详细的分析过了，我们这次只分析里面几个与内存相关的东西。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;来看代码片断：&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    int tcp_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,
</span><span class='line'>        size_t size)
</span><span class='line'>{
</span><span class='line'>    ..................................
</span><span class='line'>
</span><span class='line'>    if (copy &lt;= 0) {
</span><span class='line'>new_segment:
</span><span class='line'>        if (!sk_stream_memory_free(sk))
</span><span class='line'>            goto wait_for_sndbuf;
</span><span class='line'>
</span><span class='line'>        skb = sk_stream_alloc_skb(sk, select_size(sk),
</span><span class='line'>        sk-&gt;sk_allocation);
</span><span class='line'>        if (sk-&gt;sk_route_caps &amp; NETIF_F_ALL_CSUM)
</span><span class='line'>            skb-&gt;ip_summed = CHECKSUM_PARTIAL;
</span><span class='line'>
</span><span class='line'>        skb_entail(sk, skb);
</span><span class='line'>        copy = size_goal;
</span><span class='line'>        max = size_goal;
</span><span class='line'>    ..................
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;可以看到这里第一个sk_stream_memory_free用来判断是否还有空间来供我们分配，如果没有则跳到wait_for_sndbuf来等待buf的释放。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;然后如果有空间供我们分配，则调用sk_stream_alloc_skb来分配一个skb，然后这个大小的选择是通过select_size。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;最后调用skb_entail来更新相关的域。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;现在我们就来详细看上面的四个函数,先来看第一个：&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    static inline int sk_stream_memory_free(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>    return sk-&gt;sk_wmem_queued &lt; sk-&gt;sk_sndbuf;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;sk_stream_memory_free实现很简单，就是判断当前已经分配的写缓冲区的大小(sk_wmem_queued)是否小于当前写缓冲区(sk_sndbuf)的最大限制。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;然后是skb_entail，这个函数主要是当我们分配完buf后，进行一些相关域的更新，以及添加skb到writequeue。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    static inline void skb_entail(struct sock *sk, struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>    struct tcp_skb_cb *tcb = TCP_SKB_CB(skb);
</span><span class='line'>    ............................
</span><span class='line'>    skb_header_release(skb);
</span><span class='line'>    tcp_add_write_queue_tail(sk, skb);
</span><span class='line'>    // 增加sk_wmem_queued.
</span><span class='line'>    sk-&gt;sk_wmem_queued += skb-&gt;truesize;
</span><span class='line'>    // 这里调整sk_forward_alloc的大小，也就是预分配buf的大小(减小).
</span><span class='line'>    sk_mem_charge(sk, skb-&gt;truesize);
</span><span class='line'>    if (tp-&gt;nonagle &amp; TCP_NAGLE_PUSH)
</span><span class='line'>        tp-&gt;nonagle &amp;= ~TCP_NAGLE_PUSH;
</span><span class='line'>}
</span><span class='line'>// 这个函数很简单，就是将sk_forward_alloc - size.
</span><span class='line'>static inline void sk_mem_charge(struct sock *sk, int size)
</span><span class='line'>{
</span><span class='line'>    if (!sk_has_account(sk))
</span><span class='line'>        return;
</span><span class='line'>    sk-&gt;sk_forward_alloc -= size;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;然后是select_size，在看这个之前我们先来坎SKB_MAX_HEAD的实现.
</span><span class='line'>SKB_MAX_HEAD主要是得到要分配的tcp数据段（不包括头)在一页中最大为多少。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    #define SKB_WITH_OVERHEAD(X)    \
</span><span class='line'>    ((X) - SKB_DATA_ALIGN(sizeof(struct skb_shared_info)))
</span><span class='line'>#define SKB_MAX_ORDER(X, ORDER) \
</span><span class='line'>    SKB_WITH_OVERHEAD((PAGE_SIZE &lt;&lt; (ORDER)) - (X))
</span><span class='line'>#define SKB_MAX_HEAD(X)  (SKB_MAX_ORDER((X), 0))
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;我们带入代码来看，我们下面的代码是SKB_MAX_HEAD(MAX_TCP_HEADER)，展开这个宏可以看到就是PAGE_SIZE-MAX_TCP_HEADER-SKB_DATA_ALIGN(sizeof(struct skb_shared_info).其实也就是一页还能容纳多少tcp的数据。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    static inline int select_size(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>    // 首先取得存储的mss。
</span><span class='line'>    int tmp = tp-&gt;mss_cache;
</span><span class='line'>
</span><span class='line'>    // 然后判断是否使用scatter–gather(前面blog有介绍)
</span><span class='line'>    if (sk-&gt;sk_route_caps &amp; NETIF_F_SG) {
</span><span class='line'>        if (sk_can_gso(sk))
</span><span class='line'>            tmp = 0;
</span><span class='line'>        else {
</span><span class='line'>            // 然后开始计算buf的长度。
</span><span class='line'>            int pgbreak = SKB_MAX_HEAD(MAX_TCP_HEADER);
</span><span class='line'>
</span><span class='line'>            // 如果mss大于pgbreak,那么说明我们一页放不下当前需要的tcp数据，因此我们将会在skb的页区域分配，而skb的页区域是有限制的，因此tmp必须小于这个值。
</span><span class='line'>            if (tmp &gt;= pgbreak &amp;&amp;
</span><span class='line'>                    tmp &lt;= pgbreak + (MAX_SKB_FRAGS - 1) * PAGE_SIZE)
</span><span class='line'>                tmp = pgbreak;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    return tmp;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;sk_stream_alloc_skb&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;接下来来看sk_stream_alloc_skb的实现。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;1 它会调用alloc_skb_fclone来分配内存，这个函数就不详细分析了，我们只需要知道它会从slab里分配一块内存，而大小为size+max_header(上面的分析我们知道slect_size只计算数据段).&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;2 如果分配成功，则调用sk_wmem_schedule来判断我们所分配的skb的大小是否精确，是的话，就调整指针，然后返回。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;3 否则调用tcp_enter_memory_pressure设置标志进入TCP memory pressure zone。然后再调用sk_stream_moderate_sndbuf调整sndbuf(缩小sndbuf)。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    struct sk_buff *sk_stream_alloc_skb(struct sock *sk, int size, gfp_t gfp)
</span><span class='line'>{
</span><span class='line'>    struct sk_buff *skb;
</span><span class='line'>
</span><span class='line'>    // 4字节对其
</span><span class='line'>    size = ALIGN(size, 4);
</span><span class='line'>    // 分配skb。
</span><span class='line'>    skb = alloc_skb_fclone(size + sk-&gt;sk_prot-&gt;max_header, gfp);
</span><span class='line'>    if (skb) {
</span><span class='line'>        // 得到精确的大小。
</span><span class='line'>        if (sk_wmem_schedule(sk, skb-&gt;truesize)) {
</span><span class='line'>            // 返回skb。
</span><span class='line'>            skb_reserve(skb, skb_tailroom(skb) - size);
</span><span class='line'>                return skb;
</span><span class='line'>        }
</span><span class='line'>        __kfree_skb(skb);
</span><span class='line'>    } else {
</span><span class='line'>        // 否则设置全局标记进入pressure zone
</span><span class='line'>        sk-&gt;sk_prot-&gt;enter_memory_pressure(sk);
</span><span class='line'>        sk_stream_moderate_sndbuf(sk);
</span><span class='line'>    }
</span><span class='line'>    return NULL;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;ok,现在就来看上面的几个函数的实现。先来看几个简单的。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;首先是tcp_enter_memory_pressure,这个函数很简单，就是判断全局标记tcp_memory_pressure,然后设置这个标记。这个标记主要是用来通知其他模块调整的，比如窗口大小等等，详细的话自己搜索这个值，就知道了。
</span><span class='line'>&lt;code&gt;
</span><span class='line'>void tcp_enter_memory_pressure(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>    if (!tcp_memory_pressure) {
</span><span class='line'>        NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPMEMORYPRESSURES);
</span><span class='line'>        // 设置压力标志。
</span><span class='line'>        tcp_memory_pressure = 1;
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;然后是sk_stream_moderate_sndbuf，这个函数也是要使用sk_userlocks,来判断是否已经被用户设置了。可以看到如果我们自己设置过了snd_buf的话，内核就不会帮我们调整它的大小了。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    static inline void sk_stream_moderate_sndbuf(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>    if (!(sk-&gt;sk_userlocks &amp; SOCK_SNDBUF_LOCK)) {
</span><span class='line'>        // 它的大小调整为大于最小值，小于sk-&gt;sk_wmem_queued &gt;&gt; 1。
</span><span class='line'>        sk-&gt;sk_sndbuf = min(sk-&gt;sk_sndbuf, sk-&gt;sk_wmem_queued &gt;&gt; 1);
</span><span class='line'>        sk-&gt;sk_sndbuf = max(sk-&gt;sk_sndbuf, SOCK_MIN_SNDBUF);
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;sk_wmem_schedule&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;最后来看最核心的一个函数sk_wmem_schedule，这个函数只是对&lt;code&gt;__sk_mem_schedule&lt;/code&gt;的简单封装。这里要知道传递进来的size是skb-&gt;truesize，也就是所分配的skb的真实大小。并且第一次进入这个函数，也就是分配第一个缓冲区包时，sk_forward_alloc是为0的，也就是说，第一次必然会执行&lt;code&gt;__sk_mem_schedule&lt;/code&gt;函数。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    static inline int sk_wmem_schedule(struct sock *sk, int size)
</span><span class='line'>{
</span><span class='line'>    if (!sk_has_account(sk))
</span><span class='line'>        return 1;
</span><span class='line'>    // 先比较size(也就是skb-&gt;truesize)和预分配的内存大小。如果小于等于预分配的大小，则直接返回，否则调用__sk_mem_schedule进行调整。
</span><span class='line'>    return size &lt;= sk-&gt;sk_forward_alloc ||
</span><span class='line'>        __sk_mem_schedule(sk, size, SK_MEM_SEND);
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;来看&lt;code&gt;__sk_mem_schedule&lt;/code&gt;，这个函数的功能注释写的很清楚：&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;increase sk_forward_alloc and memory_allocated&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;然后来看源码。这里在看之前，我们要知道，协议栈通过读写buf的使用量，划分了3个区域，或者说标志。不同标志进行不同处理。这里的区域的划分是通过sysctl_tcp_mem，也就是prot-&gt;sysctl_mem这个数组进行的。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    // 页的大小
</span><span class='line'>#define SK_MEM_QUANTUM ((int)PAGE_SIZE)
</span><span class='line'>
</span><span class='line'>int __sk_mem_schedule(struct sock *sk, int size, int kind)
</span><span class='line'>{
</span><span class='line'>    struct proto *prot = sk-&gt;sk_prot;
</span><span class='line'>    // 首先得到size占用几个内存页。
</span><span class='line'>    int amt = sk_mem_pages(size);
</span><span class='line'>    int allocated;
</span><span class='line'>    // 更新sk_forward_alloc，可以看到这个值是页的大小的倍数。
</span><span class='line'>    sk-&gt;sk_forward_alloc += amt * SK_MEM_QUANTUM;
</span><span class='line'>
</span><span class='line'>    // amt+memory_allocated也就是当前的总得内存使用量加上将要分配的内存的话，现在的tcp协议栈的总得内存使用量。（可以看到是以页为单位的。
</span><span class='line'>    allocated = atomic_add_return(amt, prot-&gt;memory_allocated);
</span><span class='line'>
</span><span class='line'>    // 然后开始判断，将会落入哪一个区域。通过上面的分析我们知道sysctl_mem也就是sysctl_tcp_mem.
</span><span class='line'>
</span><span class='line'>    // 先判断是否小于等于内存最小使用限额。
</span><span class='line'>    if (allocated &lt;= prot-&gt;sysctl_mem[0]) {
</span><span class='line'>        // 这里取消memory_pressure，然后返回。
</span><span class='line'>        if (prot-&gt;memory_pressure &amp;&amp; *prot-&gt;memory_pressure)
</span><span class='line'>            *prot-&gt;memory_pressure = 0;
</span><span class='line'>        return 1;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    // 然后判断Under pressure。
</span><span class='line'>    if (allocated &gt; prot-&gt;sysctl_mem[1])
</span><span class='line'>        // 大于sysctl_mem[1]说明，已经进入pressure，一次你需要调用tcp_enter_memory_pressure来设置标志。
</span><span class='line'>        if (prot-&gt;enter_memory_pressure)
</span><span class='line'>            prot-&gt;enter_memory_pressure(sk);
</span><span class='line'>
</span><span class='line'>    // 如果超过的hard limit。则进入另外的处理。
</span><span class='line'>    if (allocated &gt; prot-&gt;sysctl_mem[2])
</span><span class='line'>        goto suppress_allocation;
</span><span class='line'>
</span><span class='line'>    // 判断类型，这里只有两种类型，读和写。总的内存大小判断完，这里开始判断单独的sock的读写内存。
</span><span class='line'>    if (kind == SK_MEM_RECV) {
</span><span class='line'>        if (atomic_read(&amp;sk-&gt;sk_rmem_alloc) &lt; prot-&gt;sysctl_rmem[0])
</span><span class='line'>            return 1;
</span><span class='line'>    } else { /* SK_MEM_SEND */
</span><span class='line'>        // 这里当为tcp的时候，写队列的大小只有当对端数据确认后才会更新，因此我们要用sk_wmem_queued来判断。
</span><span class='line'>        if (sk-&gt;sk_type == SOCK_STREAM) {
</span><span class='line'>            if (sk-&gt;sk_wmem_queued &lt; prot-&gt;sysctl_wmem[0])
</span><span class='line'>                return 1;
</span><span class='line'>        } else if (atomic_read(&amp;sk-&gt;sk_wmem_alloc) &lt;
</span><span class='line'>               prot-&gt;sysctl_wmem[0])
</span><span class='line'>                return 1;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    // 程序到达这里说明总的内存大小在sysctl_mem[0]和sysctl_mem[2]之间，因此我们再次判断memory_pressure
</span><span class='line'>    if (prot-&gt;memory_pressure) {
</span><span class='line'>        int alloc;
</span><span class='line'>
</span><span class='line'>        // 如果没有在memory_pressure区域，则我们直接返回1。
</span><span class='line'>        if (!*prot-&gt;memory_pressure)
</span><span class='line'>            return 1;
</span><span class='line'>        // 这个其实也就是计算整个系统分配的socket的多少。
</span><span class='line'>        alloc = percpu_counter_read_positive(prot-&gt;sockets_allocated);
</span><span class='line'>        // 这里假设其余的每个sock所占用的buf都和当前的sock一样大的时候，如果他们的总和小于sysctl_mem[2],也就是hard limit。那么我们也认为这次内存请求是成功的。
</span><span class='line'>        if (prot-&gt;sysctl_mem[2] &gt; alloc *
</span><span class='line'>            sk_mem_pages(sk-&gt;sk_wmem_queued +
</span><span class='line'>             atomic_read(&amp;sk-&gt;sk_rmem_alloc) +
</span><span class='line'>                 sk-&gt;sk_forward_alloc))
</span><span class='line'>            return 1;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>suppress_allocation:
</span><span class='line'>
</span><span class='line'>    // 到达这里说明，我们超过了hard limit或者说处于presure 区域。
</span><span class='line'>    if (kind == SK_MEM_SEND &amp;&amp; sk-&gt;sk_type == SOCK_STREAM) {
</span><span class='line'>        // 调整sk_sndbuf(减小).这个函数前面已经分析过了。
</span><span class='line'>        sk_stream_moderate_sndbuf(sk);
</span><span class='line'>        // 然后比较和sk_sndbuf的大小，如果大于的话，就说明下次我们再次要分配buf的时候会在tcp_memory_free阻塞住，因此这次我们返回1.
</span><span class='line'>        if (sk-&gt;sk_wmem_queued + size &gt;= sk-&gt;sk_sndbuf)
</span><span class='line'>            return 1;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /* Alas. Undo changes. */
</span><span class='line'>    // 到达这里说明，请求内存是不被接受的，因此undo所有的操作。然后返回0.
</span><span class='line'>    sk-&gt;sk_forward_alloc -= amt * SK_MEM_QUANTUM;
</span><span class='line'>    atomic_sub(amt, prot-&gt;memory_allocated);
</span><span class='line'>    return 0;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;接下来来看个很重要的函数skb_set_owner_w。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;顾名思义，这个函数也就是将一个skb和scok关联起来。只不过关联的时候更新sock相应的域。我们来看源码：&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    static inline void skb_set_owner_w(struct sk_buff *skb, struct sock *sk)
</span><span class='line'>{
</span><span class='line'>    skb_orphan(skb);
</span><span class='line'>    // 与传递进来的sock关联起来
</span><span class='line'>    skb-&gt;sk = sk;
</span><span class='line'>    // 设置skb的析构函数
</span><span class='line'>    skb-&gt;destructor = sock_wfree;
</span><span class='line'>    // 更新sk_wmem_alloc域，就是sk_wmem_alloc+truesize.
</span><span class='line'>    atomic_add(skb-&gt;truesize, &amp;sk-&gt;sk_wmem_alloc);
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;ok，接下来来看个scok_wfree函数，这个函数做得基本和上面函数相反。这个函数都是被kfree_skb自动调用的。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    void sock_wfree(struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>    struct sock *sk = skb-&gt;sk;
</span><span class='line'>    int res;
</span><span class='line'>
</span><span class='line'>    // 更新sk_wmem_alloc,减去skb的大小。
</span><span class='line'>    res = atomic_sub_return(skb-&gt;truesize, &amp;sk-&gt;sk_wmem_alloc);
</span><span class='line'>    if (!sock_flag(sk, SOCK_USE_WRITE_QUEUE))
</span><span class='line'>    // 唤醒等待队列，也就是唤醒等待内存分配。
</span><span class='line'>        sk-&gt;sk_write_space(sk);
</span><span class='line'>    if (res == 0)
</span><span class='line'>        __sk_free(sk);
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;而skb_set_owner_w是什么时候被调用呢，我们通过搜索代码可以看到，它是在tcp_transmit_skb中被调用的。而tcp_transmit_skb我们知道是传递数据包到ip层的函数。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;而kfree_skb被调用也就是在对端已经确认完我们发送的包后才会被调用来释放skb。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;tcp_rcv_established&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;接下来来看接收数据的内存管理。我们主要来看tcp_rcv_established这个函数，我前面的blog已经断断续续的分析过了，因此这里我们只看一些重要的代码片断。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;这里我们要知道，代码能到达下面的位置，则说明，数据并没有直接拷贝到用户空间。否则的话，是不会进入下面的片断的。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    if (!eaten) {
</span><span class='line'>    ..........................................
</span><span class='line'>
</span><span class='line'>    // 如果skb的大小大于预分配的值,如果大于则要另外处理。
</span><span class='line'>    if ((int)skb-&gt;truesize &gt; sk-&gt;sk_forward_alloc)
</span><span class='line'>            goto step5;
</span><span class='line'>    __skb_pull(skb, tcp_header_len);
</span><span class='line'>    __skb_queue_tail(&amp;sk-&gt;sk_receive_queue, skb);
</span><span class='line'>    // 这里关联skb和对应的sk，并且更新相关的域，我们下面会分析这个函数。
</span><span class='line'>    skb_set_owner_r(skb, sk);
</span><span class='line'>    tp-&gt;rcv_nxt = TCP_SKB_CB(skb)-&gt;end_seq;
</span><span class='line'>}
</span><span class='line'>...............................................
</span><span class='line'>
</span><span class='line'>step5:
</span><span class='line'>    if (th-&gt;ack &amp;&amp; tcp_ack(sk, skb, FLAG_SLOWPATH) &lt; 0)
</span><span class='line'>        goto discard;
</span><span class='line'>
</span><span class='line'>    tcp_rcv_rtt_measure_ts(sk, skb);
</span><span class='line'>
</span><span class='line'>    /* Process urgent data. */
</span><span class='line'>    tcp_urg(sk, skb, th);
</span><span class='line'>
</span><span class='line'>    /* step 7: process the segment text */
</span><span class='line'>    // 最核心的函数就是这个。我们接下来会详细分析这个函数。
</span><span class='line'>    tcp_data_queue(sk, skb);
</span><span class='line'>
</span><span class='line'>    tcp_data_snd_check(sk);
</span><span class='line'>    tcp_ack_snd_check(sk);
</span><span class='line'>    return 0;
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;先来看skb_set_owner_r函数，这个函数关联skb和sk其实它和skb_set_owner_w类似：&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    static inline void skb_set_owner_r(struct sk_buff *skb, struct sock *sk)
</span><span class='line'>{
</span><span class='line'>    skb_orphan(skb);
</span><span class='line'>    // 关联sk
</span><span class='line'>    skb-&gt;sk = sk;
</span><span class='line'>    // 设置析构函数
</span><span class='line'>    skb-&gt;destructor = sock_rfree;
</span><span class='line'>    // 更新rmem_alloc
</span><span class='line'>    atomic_add(skb-&gt;truesize, &amp;sk-&gt;sk_rmem_alloc);
</span><span class='line'>    // 改变forward_alloc.
</span><span class='line'>    sk_mem_charge(sk, skb-&gt;truesize);
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;tcp_data_queue&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;然后是tcp_data_queue，这个函数主要用来排队接收数据，并update相关的读buf。由于这个函数比较复杂，我们只关心我们感兴趣的部分：&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    static void tcp_data_queue(struct sock *sk, struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>    struct tcphdr *th = tcp_hdr(skb);
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>    int eaten = -1;
</span><span class='line'>    .......................................
</span><span class='line'>    // 首先判断skb的开始序列号和我们想要接收的序列号。如果相等开始处理这个数据包(也就是拷贝到用户空间).
</span><span class='line'>    if (TCP_SKB_CB(skb)-&gt;seq == tp-&gt;rcv_nxt) {
</span><span class='line'>        if (tcp_receive_window(tp) == 0)
</span><span class='line'>            goto out_of_window;
</span><span class='line'>
</span><span class='line'>        // tp的ucopy我前面的blog已经详细分析过了。这里就不解释了。
</span><span class='line'>        if (tp-&gt;ucopy.task == current &amp;&amp;
</span><span class='line'>            tp-&gt;copied_seq == tp-&gt;rcv_nxt &amp;&amp; tp-&gt;ucopy.len &amp;&amp;sock_owned_by_user(sk) &amp;&amp; !tp-&gt;urg_data)
</span><span class='line'>        {
</span><span class='line'>            // 计算将要拷贝给用户空间的大小。
</span><span class='line'>            int chunk = min_t(unsigned int, skb-&gt;len,tp-&gt;ucopy.len);
</span><span class='line'>
</span><span class='line'>            // 设置状态，说明我们处于进程上下文。
</span><span class='line'>            __set_current_state(TASK_RUNNING);
</span><span class='line'>
</span><span class='line'>            local_bh_enable();
</span><span class='line'>            // 拷贝skb
</span><span class='line'>            if (!skb_copy_datagram_iovec(skb, 0, tp-&gt;ucopy.iov, chunk)) {
</span><span class='line'>                tp-&gt;ucopy.len -= chunk;
</span><span class='line'>                tp-&gt;copied_seq += chunk;
</span><span class='line'>                // 更新eaten，它的默认值为-1.
</span><span class='line'>                eaten = (chunk == skb-&gt;len &amp;&amp; !th-&gt;fin);
</span><span class='line'>                tcp_rcv_space_adjust(sk);
</span><span class='line'>            }
</span><span class='line'>            local_bh_disable();
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        // 如果小于0则说明没有拷贝成功，或者说就没有进行拷贝。此时需要更新sock的相关域。
</span><span class='line'>        if (eaten &lt;= 0) {
</span><span class='line'>queue_and_out:
</span><span class='line'>            // 最关键的tcp_try_rmem_schedule函数。接下来会详细分析。
</span><span class='line'>            if (eaten &lt; 0 &amp;&amp;
</span><span class='line'>                    tcp_try_rmem_schedule(sk, skb-&gt;truesize))
</span><span class='line'>                goto drop;
</span><span class='line'>
</span><span class='line'>            // 关联skb和sk。到达这里说明tcp_try_rmem_schedule成功，也就是返回0.
</span><span class='line'>            skb_set_owner_r(skb, sk);
</span><span class='line'>            // 加skb到receive_queue.
</span><span class='line'>            __skb_queue_tail(&amp;sk-&gt;sk_receive_queue, skb);
</span><span class='line'>        }
</span><span class='line'>        // 更新期待序列号。
</span><span class='line'>        tp-&gt;rcv_nxt = TCP_SKB_CB(skb)-&gt;end_seq;
</span><span class='line'>        ..............................................
</span><span class='line'>
</span><span class='line'>        .....................................
</span><span class='line'>
</span><span class='line'>        tcp_fast_path_check(sk);
</span><span class='line'>
</span><span class='line'>        if (eaten &gt; 0)
</span><span class='line'>            __kfree_skb(skb);
</span><span class='line'>        else if (!sock_flag(sk, SOCK_DEAD))
</span><span class='line'>            sk-&gt;sk_data_ready(sk, 0);
</span><span class='line'>        return;
</span><span class='line'>    }
</span><span class='line'>    // 下面就是处理乱序包。以后会详细分析。
</span><span class='line'>    ......................................
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;tcp_try_rmem_schedule&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;接下来我们就来看tcp_try_rmem_schedule这个函数,这个函数如果返回0则说明sk_rmem_schedule返回1,而sk_rmem_schedule和sk_wmem_schedule是一样的。也就是看当前的skb加入后有没有超过读buf的限制。并更新相关的域。：&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    static inline int tcp_try_rmem_schedule(struct sock *sk, unsigned int size)
</span><span class='line'>{
</span><span class='line'>    // 首先判断rmem_alloc(当前的读buf字节数)是否大于最大buf字节数，如果大于则调用tcp_prune_queue调整分配的buf。否则调用sk_rmem_schedule来调整相关域（sk_forward_alloc）。
</span><span class='line'>    if (atomic_read(&amp;sk-&gt;sk_rmem_alloc) &gt; sk-&gt;sk_rcvbuf ||!sk_rmem_schedule(sk, size)) {
</span><span class='line'>
</span><span class='line'>        // 调整分配的buf。
</span><span class='line'>        if (tcp_prune_queue(sk) &lt; 0)
</span><span class='line'>            return -1;
</span><span class='line'>        // 更新sk的相关域。
</span><span class='line'>        if (!sk_rmem_schedule(sk, size)) {
</span><span class='line'>            if (!tcp_prune_ofo_queue(sk))
</span><span class='line'>                return -1;
</span><span class='line'>
</span><span class='line'>            if (!sk_rmem_schedule(sk, size))
</span><span class='line'>                return -1;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    return 0;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;来看sk_rmem_schedule，这个函数很简单，就是封装了&lt;code&gt;__sk_mem_schedule&lt;/code&gt;。而这个函数我们上面已经分析过了。
</span><span class='line'>&lt;code&gt;
</span><span class='line'>static inline int sk_rmem_schedule(struct sock *sk, int size)
</span><span class='line'>{
</span><span class='line'>    if (!sk_has_account(sk))
</span><span class='line'>        return 1;
</span><span class='line'>    return size &lt;= sk-&gt;sk_forward_alloc ||
</span><span class='line'>        __sk_mem_schedule(sk, size, SK_MEM_RECV);
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;tcp_prune_queue&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;最后是tcp_prune_queue，这个函数主要是用来丢掉一些skb，因为到这个函数就说明我们的内存使用已经到极限了，因此我们要合并一些buf。这个合并也就是将序列号连续的段进行合并。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;这里我们要知道tcp的包是有序的，因此内核中tcp专门有一个队列来保存那些Out of order segments。因此我们这里会先处理这个队列里面的skb。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;然后调用tcp_collapse来处理接收队列里面的skb。和上面的类似。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;这里要注意，合并的话都是按页来合并，也就是先分配一页大小的内存，然后将老的skb复制进去，最后free掉老的buf。</span></code></pre></td></tr></table></div></figure>
    static int tcp_prune_queue(struct sock <em>sk)
    {
        struct tcp_sock </em>tp = tcp_sk(sk);
        &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.
        // 如果rmem_alloc过于大，则重新计算窗口的大小。一半都会缩小窗口。
        if (atomic_read(&amp;sk->sk_rmem_alloc) >= sk->sk_rcvbuf)
            tcp_clamp_window(sk);
        // 如果处于pressure区域，则调整窗口大小。这里也是缩小窗口。
        else if (tcp_memory_pressure)
            tp->rcv_ssthresh = min(tp->rcv_ssthresh, 4U * tp->advmss);</p>

<pre><code>    // 处理ofo队列。
    tcp_collapse_ofo_queue(sk);
    // 如果接收队列为非空，则调用tcp_collapse来处理sk_receive_queue
    if (!skb_queue_empty(&amp;sk-&gt;sk_receive_queue))
        tcp_collapse(sk, &amp;sk-&gt;sk_receive_queue,
                 skb_peek(&amp;sk-&gt;sk_receive_queue),
                 NULL,
                 tp-&gt;copied_seq, tp-&gt;rcv_nxt);
    // 更新全局的已分配内存的大小，也就是memory_allocated，接下来会详细介绍这个函数。
    sk_mem_reclaim(sk);

    // 如果调整后小于sk_rcvbuf,则返回0.
    if (atomic_read(&amp;sk-&gt;sk_rmem_alloc) &lt;= sk-&gt;sk_rcvbuf)
        return 0;

    ......................................
    return -1;
}
</code></pre>

<pre><code>
#### tcp_collapse_ofo_queue 尝试减小ofo queue占内存的大小
</code></pre>

<pre><code>/* Collapse ofo queue. Algorithm: select contiguous sequence of skbs
 * and tcp_collapse() them until all the queue is collapsed.
 */
static void tcp_collapse_ofo_queue(struct sock *sk)
{
    struct tcp_sock *tp = tcp_sk(sk);
    struct sk_buff *skb = skb_peek(&amp;tp-&gt;out_of_order_queue);
    struct sk_buff *head;
    u32 start, end;

    if (skb == NULL)
        return;

    start = TCP_SKB_CB(skb)-&gt;seq;
    end = TCP_SKB_CB(skb)-&gt;end_seq;
    head = skb;

    for (;;) {
        struct sk_buff *next = NULL;

        if (!skb_queue_is_last(&amp;tp-&gt;out_of_order_queue, skb))
            next = skb_queue_next(&amp;tp-&gt;out_of_order_queue, skb);
        skb = next;

        /* Segment is terminated when we see gap or when
         * we are at the end of all the queue. */
        if (!skb ||
            after(TCP_SKB_CB(skb)-&gt;seq, end) ||
            before(TCP_SKB_CB(skb)-&gt;end_seq, start)) {  // 找到ofo queue中连续的一段skb，即 prev-&gt;end_seq &gt;= next-&gt;seq
            tcp_collapse(sk, &amp;tp-&gt;out_of_order_queue,
                     head, skb, start, end);            // 尝试减小这一段连续skb占用的内存
            head = skb;
            if (!skb)
                break;
            /* Start new segment */
            start = TCP_SKB_CB(skb)-&gt;seq;               // 下个skb就是新的一段的开始
            end = TCP_SKB_CB(skb)-&gt;end_seq;
        } else {
            if (before(TCP_SKB_CB(skb)-&gt;seq, start))    // 这种情况只可能是tcp_collapse中大包拆成小包，拆到一半内存不够，没拆完导致。
                start = TCP_SKB_CB(skb)-&gt;seq;
            if (after(TCP_SKB_CB(skb)-&gt;end_seq, end))
                end = TCP_SKB_CB(skb)-&gt;end_seq;
        }
    }
}
</code></pre>

<pre><code>
#### tcp_collapse，gro上来的包有可能是大于4k的包，所以这个函数有时是在拆包，利弊难定
</code></pre>

<pre><code>// 删除一个skb，返回下个skb
static struct sk_buff *tcp_collapse_one(struct sock *sk, struct sk_buff *skb,
                    struct sk_buff_head *list)
{
    struct sk_buff *next = NULL;

    if (!skb_queue_is_last(list, skb))
        next = skb_queue_next(list, skb);

    __skb_unlink(skb, list);
    __kfree_skb(skb);
    NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPRCVCOLLAPSED);

    return next;
}

/* Collapse contiguous sequence of skbs head..tail with
 * sequence numbers start..end.
 *
 * If tail is NULL, this means until the end of the list.
 *
 * Segments with FIN/SYN are not collapsed (only because this
 * simplifies code)
 */
static void
tcp_collapse(struct sock *sk, struct sk_buff_head *list,
         struct sk_buff *head, struct sk_buff *tail,
         u32 start, u32 end)
{
    struct sk_buff *skb, *n;
    bool end_of_skbs;

    /* First, check that queue is collapsible and find
     * the point where collapsing can be useful. */
    skb = head;
restart:
    end_of_skbs = true;
    skb_queue_walk_from_safe(list, skb, n) {
        if (skb == tail)
            break;
        /* No new bits? It is possible on ofo queue. */
        if (!before(start, TCP_SKB_CB(skb)-&gt;end_seq)) { // 这种情况现在是不会出现的，以前代码有可能出现？？
            skb = tcp_collapse_one(sk, skb, list);
            if (!skb)
                break;
            goto restart;
        }

        /* The first skb to collapse is:
         * - not SYN/FIN and
         * - bloated or contains data before "start" or
         *   overlaps to the next one.
         */
        if (!tcp_hdr(skb)-&gt;syn &amp;&amp; !tcp_hdr(skb)-&gt;fin &amp;&amp;         // SYN，FIN 不合并，简化操作
            (tcp_win_from_space(skb-&gt;truesize) &gt; skb-&gt;len ||    // 合并后可能减小空间的情况才合并
             before(TCP_SKB_CB(skb)-&gt;seq, start))) {            // seq到start的数据已经被读走了，有减小空间的可能
            end_of_skbs = false;
            break;
        }

        if (!skb_queue_is_last(list, skb)) {
            struct sk_buff *next = skb_queue_next(list, skb);
            if (next != tail &amp;&amp;
                TCP_SKB_CB(skb)-&gt;end_seq != TCP_SKB_CB(next)-&gt;seq) { // 两个skb之间有交集，有减小空间可能
                end_of_skbs = false;
                break;
            }
        }

        /* Decided to skip this, advance start seq. */
        start = TCP_SKB_CB(skb)-&gt;end_seq;     // 否则向后继续找可能减小空间的第一个skb
    }
    if (end_of_skbs || tcp_hdr(skb)-&gt;syn || tcp_hdr(skb)-&gt;fin)
        return;

    while (before(start, end)) {  // 落在在start到end的包就是这次要合并的
        struct sk_buff *nskb;
        unsigned int header = skb_headroom(skb); // skb中协议头的大小
        int copy = SKB_MAX_ORDER(header, 0);     // 一个页（4k）中出去协议头空间的大小，也就是能容下的数据大小

        /* Too big header? This can happen with IPv6. */
        if (copy &lt; 0)
            return;
        if (end - start &lt; copy)
            copy = end - start;
        nskb = alloc_skb(copy + header, GFP_ATOMIC);
        if (!nskb)
            return;

        skb_set_mac_header(nskb, skb_mac_header(skb) - skb-&gt;head);
        skb_set_network_header(nskb, (skb_network_header(skb) -
                          skb-&gt;head));
        skb_set_transport_header(nskb, (skb_transport_header(skb) -
                        skb-&gt;head));
        skb_reserve(nskb, header);
        memcpy(nskb-&gt;head, skb-&gt;head, header);
        memcpy(nskb-&gt;cb, skb-&gt;cb, sizeof(skb-&gt;cb));
        TCP_SKB_CB(nskb)-&gt;seq = TCP_SKB_CB(nskb)-&gt;end_seq = start;
        __skb_queue_before(list, skb, nskb);
        skb_set_owner_r(nskb, sk);

        /* Copy data, releasing collapsed skbs. */
        while (copy &gt; 0) {    // 如果copy = 0，这里就会出BUG，但如果没有认为改，是不会的。ipv6会吗？？？。后面版本改进这函数了，也不会出现copy=0了
            int offset = start - TCP_SKB_CB(skb)-&gt;seq;
            int size = TCP_SKB_CB(skb)-&gt;end_seq - start;

            BUG_ON(offset &lt; 0);
            if (size &gt; 0) { // copy旧的skb数据到新的skb上
                size = min(copy, size);
                if (skb_copy_bits(skb, offset, skb_put(nskb, size), size))
                    BUG();
                TCP_SKB_CB(nskb)-&gt;end_seq += size;
                copy -= size;
                start += size;
            }
            if (!before(start, TCP_SKB_CB(skb)-&gt;end_seq)) { // 旧的skb被copy完了就删掉
                skb = tcp_collapse_one(sk, skb, list);
                if (!skb ||
                    skb == tail ||
                    tcp_hdr(skb)-&gt;syn ||
                    tcp_hdr(skb)-&gt;fin)
                    return;
            }
        }
    }
}
</code></pre>

<pre><code>
来看sk_mem_reclaim函数，它只是简单的封装了`__sk_mem_reclaim`：
</code></pre>

<pre><code>static inline void sk_mem_reclaim(struct sock *sk)
{
    if (!sk_has_account(sk))
        return;
    // 如果sk_forward_alloc大于1页则调用__sk_mem_reclaim，我们知道sk_forward_alloc是以页为单位的，因此这里也就是和大于0一样。
    if (sk-&gt;sk_forward_alloc &gt;= SK_MEM_QUANTUM)
        __sk_mem_reclaim(sk);
}
</code></pre>

<pre><code>
`__sk_mem_reclaim`就是真正操作的函数，它会更新memory_allocated：
</code></pre>

<pre><code>void __sk_mem_reclaim(struct sock *sk)
{
    struct proto *prot = sk-&gt;sk_prot;
    // 更新memory_allocated，这里我们知道memory_allocated也是以页为单位的，因此需要将sk_forward_alloc转化为页。
    atomic_sub(sk-&gt;sk_forward_alloc &gt;&gt; SK_MEM_QUANTUM_SHIFT,prot-&gt;memory_allocated);

    // 更新这个sk的sk_forward_alloc为一页。
    sk-&gt;sk_forward_alloc &amp;= SK_MEM_QUANTUM - 1;
    // 判断是否处于pressure区域，是的话更新memory_pressure变量。
    if (prot-&gt;memory_pressure &amp;&amp; *prot-&gt;memory_pressure &amp;&amp;(atomic_read(prot-&gt;memory_allocated) &lt; （prot-&gt;sysctl_mem[0]))
        *prot-&gt;memory_pressure = 0;
}
</code></pre>

<pre><code>

最后看一下读buf的释放。这个函数会在kfree_skb中被调用。
</code></pre>

<pre><code>void sock_rfree(struct sk_buff *skb)
{

    struct sock *sk = skb-&gt;sk;
    // 更新rmem_alloc
    atomic_sub(skb-&gt;truesize, &amp;sk-&gt;sk_rmem_alloc);
    // 更新forward_alloc.
    sk_mem_uncharge(skb-&gt;sk, skb-&gt;truesize);
}
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TREE RCU实现]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/06/02/kernel-base-rcu/"/>
    <updated>2015-06-02T17:38:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/06/02/kernel-base-rcu</id>
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/junguo/article/details/8258231">http://blog.csdn.net/junguo/article/details/8258231</a></p>

<p><a href="http://blog.csdn.net/junguo/article/details/8258261">http://blog.csdn.net/junguo/article/details/8258261</a></p>

<p><a href="http://blog.csdn.net/junguo/article/details/8268277">http://blog.csdn.net/junguo/article/details/8268277</a></p>

<hr />

<h3>TREE RCU实现之一 —— 数据结构</h3>

<h4>代码分布</h4>

<p>在分析代码之前， 先看看代码的分布情况。RCU实现的代码包含在下列一些文件中，此处用到的是linux 3.6.4的代码。</p>

<p>&lt; include/linux/rcupdate.h >  RCU实现的头文件，所有使用RCU的代码都需要包含它<br/>
&lt; include/rcutree.h >  包含rcupdate.h中没有包含的函数声明。<br/>
&lt; include/rcutiny.h >  包含rcupdate.h中没有包含的函数声明。<br/>
&lt; kernel/rcupdate.c >  包括一些RCU实现的基础函数的实现。<br/>
&lt; kernel/rcutree.h >  包含Tree RCU用到的结构信息，TREE_RCU将所有的CPU组织成一颗树，通过层次结构来判别进程是否通过了宽限期，这种方式适用于多个CPU的系统。<br/>
&lt; kernel/rcutree.c >  包含Tree RCU的主要实现代码。<br/>
&lt; kernel/rcutree_plugin.h >  其实也是TREE RCU实现的一部分。主要包含了抢入式TreeRCU的代码。适用于抢入式的系统，抢入式的系统适用于需要低延迟的桌面或者嵌入式系统。<br/>
&lt; kernel/rcutiny.c >  Tiny RCU的主要实现代码，TINY_RCU适用于单个CPU，尤其是嵌入式操作系统。<br/>
&lt; kernel/rcutiny_plugin.h >  主要包含了抢入式Tiny RCU的代码<br/>
&lt; kernel/rcu.h >  定义了debug的接口，实现了<code>__rcu_reclaim</code>。<br/>
&lt; kernel/rcutorture.c>  对RCU进行稳定性测试的代码，通过配置CONFIG_RCU_TORTURE_TEST，可以在系统启动的时候运行稳定性测试。<br/>
&lt; kernel/rcutree_trace.c>  通过配置CONFIG_RCU_TRACE，可以记录RCU的运行信息。<br/>
&lt; include/trace/events/rcu.h>  为rcutree_trace.c定义的头文件。</p>

<h4>RCU处理的基本流程</h4>

<p>RCU实现的关键集中在宽限期的处理上，这个过程需要保证销毁对象前，当前系统中所有CPU上运行的进程都通过了静止状态（quiescent state）。</p>

<p>  1， 程序调用call_rcu，将要删除的对象保存起来。并标记或者开始一个宽限期（同一时间只能运行一个宽限期，所以当已经有宽限期在运行的时候，其它的宽限期必须等待）。</p>

<p>  2， 在读取数据开始和结尾处增加 rcu_read_lock 和 rcu_read_unlock来标记读过程。为了保证删除过程知道读过程的结束，在非抢占式RCU实现中是在rcu_read_lock开始处禁止进程抢占。这样做就可以保证再运行下一次进程切换的时候，读过程已经结束。其实系统也不会去统计各个CPU上是否存在过读线程，所以所有的CPU都会在进程切换的时候通知系统它处于进制状态。当所有的CPU都通过静止状态的时候，系统就会标记它通过了一个宽限期。</p>

<p>  3，由于一个宽限期结束的时候，只有最后一个通过静止状态的CPU知道当前的宽限期已经结束，它并不会去通知其它CPU；同时出于性能考虑，系统也不会在宽限期结束后，马上去执行销毁过程。所以每个CPU都有一个固定的函数去检测是否有等待执行的宽限期，如果没有特别紧急的任务时，会去执行这些过程。</p>

<p>接下来，要分析Tree RCU的实现，先来看看它提供的一些接口函数。</p>

<p>  1， call_rcu  与 synchronize_rcu都是删除对象时调用的函数。call_rcu将数据提交后会返回，而synchronize_rcu会调用call_rcu，并一直等待对象被删除后才返回。还有call_rcu_bh与synchronize_rcu_bh等接口函数，会在后续讲述。</p>

<p>  2，rcu_read_lock 和 rcu_read_unlock</p>

<p>&lt;linux/rcuupdate.h>
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
<span class='line-number'>206</span>
<span class='line-number'>207</span>
<span class='line-number'>208</span>
<span class='line-number'>209</span>
<span class='line-number'>210</span>
<span class='line-number'>211</span>
<span class='line-number'>212</span>
<span class='line-number'>213</span>
<span class='line-number'>214</span>
<span class='line-number'>215</span>
<span class='line-number'>216</span>
<span class='line-number'>217</span>
<span class='line-number'>218</span>
<span class='line-number'>219</span>
<span class='line-number'>220</span>
<span class='line-number'>221</span>
<span class='line-number'>222</span>
<span class='line-number'>223</span>
<span class='line-number'>224</span>
<span class='line-number'>225</span>
<span class='line-number'>226</span>
<span class='line-number'>227</span>
<span class='line-number'>228</span>
<span class='line-number'>229</span>
<span class='line-number'>230</span>
<span class='line-number'>231</span>
<span class='line-number'>232</span>
<span class='line-number'>233</span>
<span class='line-number'>234</span>
<span class='line-number'>235</span>
<span class='line-number'>236</span>
<span class='line-number'>237</span>
<span class='line-number'>238</span>
<span class='line-number'>239</span>
<span class='line-number'>240</span>
<span class='line-number'>241</span>
<span class='line-number'>242</span>
<span class='line-number'>243</span>
<span class='line-number'>244</span>
<span class='line-number'>245</span>
<span class='line-number'>246</span>
<span class='line-number'>247</span>
<span class='line-number'>248</span>
<span class='line-number'>249</span>
<span class='line-number'>250</span>
<span class='line-number'>251</span>
<span class='line-number'>252</span>
<span class='line-number'>253</span>
<span class='line-number'>254</span>
<span class='line-number'>255</span>
<span class='line-number'>256</span>
<span class='line-number'>257</span>
<span class='line-number'>258</span>
<span class='line-number'>259</span>
<span class='line-number'>260</span>
<span class='line-number'>261</span>
<span class='line-number'>262</span>
<span class='line-number'>263</span>
<span class='line-number'>264</span>
<span class='line-number'>265</span>
<span class='line-number'>266</span>
<span class='line-number'>267</span>
<span class='line-number'>268</span>
<span class='line-number'>269</span>
<span class='line-number'>270</span>
<span class='line-number'>271</span>
<span class='line-number'>272</span>
<span class='line-number'>273</span>
<span class='line-number'>274</span>
<span class='line-number'>275</span>
<span class='line-number'>276</span>
<span class='line-number'>277</span>
<span class='line-number'>278</span>
<span class='line-number'>279</span>
<span class='line-number'>280</span>
<span class='line-number'>281</span>
<span class='line-number'>282</span>
<span class='line-number'>283</span>
<span class='line-number'>284</span>
<span class='line-number'>285</span>
<span class='line-number'>286</span>
<span class='line-number'>287</span>
<span class='line-number'>288</span>
<span class='line-number'>289</span>
<span class='line-number'>290</span>
<span class='line-number'>291</span>
<span class='line-number'>292</span>
<span class='line-number'>293</span>
<span class='line-number'>294</span>
<span class='line-number'>295</span>
<span class='line-number'>296</span>
<span class='line-number'>297</span>
<span class='line-number'>298</span>
<span class='line-number'>299</span>
<span class='line-number'>300</span>
<span class='line-number'>301</span>
<span class='line-number'>302</span>
<span class='line-number'>303</span>
<span class='line-number'>304</span>
<span class='line-number'>305</span>
<span class='line-number'>306</span>
<span class='line-number'>307</span>
<span class='line-number'>308</span>
<span class='line-number'>309</span>
<span class='line-number'>310</span>
<span class='line-number'>311</span>
<span class='line-number'>312</span>
<span class='line-number'>313</span>
<span class='line-number'>314</span>
<span class='line-number'>315</span>
<span class='line-number'>316</span>
<span class='line-number'>317</span>
<span class='line-number'>318</span>
<span class='line-number'>319</span>
<span class='line-number'>320</span>
<span class='line-number'>321</span>
<span class='line-number'>322</span>
<span class='line-number'>323</span>
<span class='line-number'>324</span>
<span class='line-number'>325</span>
<span class='line-number'>326</span>
<span class='line-number'>327</span>
<span class='line-number'>328</span>
<span class='line-number'>329</span>
<span class='line-number'>330</span>
<span class='line-number'>331</span>
<span class='line-number'>332</span>
<span class='line-number'>333</span>
<span class='line-number'>334</span>
<span class='line-number'>335</span>
<span class='line-number'>336</span>
<span class='line-number'>337</span>
<span class='line-number'>338</span>
<span class='line-number'>339</span>
<span class='line-number'>340</span>
<span class='line-number'>341</span>
<span class='line-number'>342</span>
<span class='line-number'>343</span>
<span class='line-number'>344</span>
<span class='line-number'>345</span>
<span class='line-number'>346</span>
<span class='line-number'>347</span>
<span class='line-number'>348</span>
<span class='line-number'>349</span>
<span class='line-number'>350</span>
<span class='line-number'>351</span>
<span class='line-number'>352</span>
<span class='line-number'>353</span>
<span class='line-number'>354</span>
<span class='line-number'>355</span>
<span class='line-number'>356</span>
<span class='line-number'>357</span>
<span class='line-number'>358</span>
<span class='line-number'>359</span>
<span class='line-number'>360</span>
<span class='line-number'>361</span>
<span class='line-number'>362</span>
<span class='line-number'>363</span>
<span class='line-number'>364</span>
<span class='line-number'>365</span>
<span class='line-number'>366</span>
<span class='line-number'>367</span>
<span class='line-number'>368</span>
<span class='line-number'>369</span>
<span class='line-number'>370</span>
<span class='line-number'>371</span>
<span class='line-number'>372</span>
<span class='line-number'>373</span>
<span class='line-number'>374</span>
<span class='line-number'>375</span>
<span class='line-number'>376</span>
<span class='line-number'>377</span>
<span class='line-number'>378</span>
<span class='line-number'>379</span>
<span class='line-number'>380</span>
<span class='line-number'>381</span>
<span class='line-number'>382</span>
<span class='line-number'>383</span>
<span class='line-number'>384</span>
<span class='line-number'>385</span>
<span class='line-number'>386</span>
<span class='line-number'>387</span>
<span class='line-number'>388</span>
<span class='line-number'>389</span>
<span class='line-number'>390</span>
<span class='line-number'>391</span>
<span class='line-number'>392</span>
<span class='line-number'>393</span>
<span class='line-number'>394</span>
<span class='line-number'>395</span>
<span class='line-number'>396</span>
<span class='line-number'>397</span>
<span class='line-number'>398</span>
<span class='line-number'>399</span>
<span class='line-number'>400</span>
<span class='line-number'>401</span>
<span class='line-number'>402</span>
<span class='line-number'>403</span>
<span class='line-number'>404</span>
<span class='line-number'>405</span>
<span class='line-number'>406</span>
<span class='line-number'>407</span>
<span class='line-number'>408</span>
<span class='line-number'>409</span>
<span class='line-number'>410</span>
<span class='line-number'>411</span>
<span class='line-number'>412</span>
<span class='line-number'>413</span>
<span class='line-number'>414</span>
<span class='line-number'>415</span>
<span class='line-number'>416</span>
<span class='line-number'>417</span>
<span class='line-number'>418</span>
<span class='line-number'>419</span>
<span class='line-number'>420</span>
<span class='line-number'>421</span>
<span class='line-number'>422</span>
<span class='line-number'>423</span>
<span class='line-number'>424</span>
<span class='line-number'>425</span>
<span class='line-number'>426</span>
<span class='line-number'>427</span>
<span class='line-number'>428</span>
<span class='line-number'>429</span>
<span class='line-number'>430</span>
<span class='line-number'>431</span>
<span class='line-number'>432</span>
<span class='line-number'>433</span>
<span class='line-number'>434</span>
<span class='line-number'>435</span>
<span class='line-number'>436</span>
<span class='line-number'>437</span>
<span class='line-number'>438</span>
<span class='line-number'>439</span>
<span class='line-number'>440</span>
<span class='line-number'>441</span>
<span class='line-number'>442</span>
<span class='line-number'>443</span>
<span class='line-number'>444</span>
<span class='line-number'>445</span>
<span class='line-number'>446</span>
<span class='line-number'>447</span>
<span class='line-number'>448</span>
<span class='line-number'>449</span>
<span class='line-number'>450</span>
<span class='line-number'>451</span>
<span class='line-number'>452</span>
<span class='line-number'>453</span>
<span class='line-number'>454</span>
<span class='line-number'>455</span>
<span class='line-number'>456</span>
<span class='line-number'>457</span>
<span class='line-number'>458</span>
<span class='line-number'>459</span>
<span class='line-number'>460</span>
<span class='line-number'>461</span>
<span class='line-number'>462</span>
<span class='line-number'>463</span>
<span class='line-number'>464</span>
<span class='line-number'>465</span>
<span class='line-number'>466</span>
<span class='line-number'>467</span>
<span class='line-number'>468</span>
<span class='line-number'>469</span>
<span class='line-number'>470</span>
<span class='line-number'>471</span>
<span class='line-number'>472</span>
<span class='line-number'>473</span>
<span class='line-number'>474</span>
<span class='line-number'>475</span>
<span class='line-number'>476</span>
<span class='line-number'>477</span>
<span class='line-number'>478</span>
<span class='line-number'>479</span>
<span class='line-number'>480</span>
<span class='line-number'>481</span>
<span class='line-number'>482</span>
<span class='line-number'>483</span>
<span class='line-number'>484</span>
<span class='line-number'>485</span>
<span class='line-number'>486</span>
<span class='line-number'>487</span>
<span class='line-number'>488</span>
<span class='line-number'>489</span>
<span class='line-number'>490</span>
<span class='line-number'>491</span>
<span class='line-number'>492</span>
<span class='line-number'>493</span>
<span class='line-number'>494</span>
<span class='line-number'>495</span>
<span class='line-number'>496</span>
<span class='line-number'>497</span>
<span class='line-number'>498</span>
<span class='line-number'>499</span>
<span class='line-number'>500</span>
<span class='line-number'>501</span>
<span class='line-number'>502</span>
<span class='line-number'>503</span>
<span class='line-number'>504</span>
<span class='line-number'>505</span>
<span class='line-number'>506</span>
<span class='line-number'>507</span>
<span class='line-number'>508</span>
<span class='line-number'>509</span>
<span class='line-number'>510</span>
<span class='line-number'>511</span>
<span class='line-number'>512</span>
<span class='line-number'>513</span>
<span class='line-number'>514</span>
<span class='line-number'>515</span>
<span class='line-number'>516</span>
<span class='line-number'>517</span>
<span class='line-number'>518</span>
<span class='line-number'>519</span>
<span class='line-number'>520</span>
<span class='line-number'>521</span>
<span class='line-number'>522</span>
<span class='line-number'>523</span>
<span class='line-number'>524</span>
<span class='line-number'>525</span>
<span class='line-number'>526</span>
<span class='line-number'>527</span>
<span class='line-number'>528</span>
<span class='line-number'>529</span>
<span class='line-number'>530</span>
<span class='line-number'>531</span>
<span class='line-number'>532</span>
<span class='line-number'>533</span>
<span class='line-number'>534</span>
<span class='line-number'>535</span>
<span class='line-number'>536</span>
<span class='line-number'>537</span>
<span class='line-number'>538</span>
<span class='line-number'>539</span>
<span class='line-number'>540</span>
<span class='line-number'>541</span>
<span class='line-number'>542</span>
<span class='line-number'>543</span>
<span class='line-number'>544</span>
<span class='line-number'>545</span>
<span class='line-number'>546</span>
<span class='line-number'>547</span>
<span class='line-number'>548</span>
<span class='line-number'>549</span>
<span class='line-number'>550</span>
<span class='line-number'>551</span>
<span class='line-number'>552</span>
<span class='line-number'>553</span>
<span class='line-number'>554</span>
<span class='line-number'>555</span>
<span class='line-number'>556</span>
<span class='line-number'>557</span>
<span class='line-number'>558</span>
<span class='line-number'>559</span>
<span class='line-number'>560</span>
<span class='line-number'>561</span>
<span class='line-number'>562</span>
<span class='line-number'>563</span>
<span class='line-number'>564</span>
<span class='line-number'>565</span>
<span class='line-number'>566</span>
<span class='line-number'>567</span>
<span class='line-number'>568</span>
<span class='line-number'>569</span>
<span class='line-number'>570</span>
<span class='line-number'>571</span>
<span class='line-number'>572</span>
<span class='line-number'>573</span>
<span class='line-number'>574</span>
<span class='line-number'>575</span>
<span class='line-number'>576</span>
<span class='line-number'>577</span>
<span class='line-number'>578</span>
<span class='line-number'>579</span>
<span class='line-number'>580</span>
<span class='line-number'>581</span>
<span class='line-number'>582</span>
<span class='line-number'>583</span>
<span class='line-number'>584</span>
<span class='line-number'>585</span>
<span class='line-number'>586</span>
<span class='line-number'>587</span>
<span class='line-number'>588</span>
<span class='line-number'>589</span>
<span class='line-number'>590</span>
<span class='line-number'>591</span>
<span class='line-number'>592</span>
<span class='line-number'>593</span>
<span class='line-number'>594</span>
<span class='line-number'>595</span>
<span class='line-number'>596</span>
<span class='line-number'>597</span>
<span class='line-number'>598</span>
<span class='line-number'>599</span>
<span class='line-number'>600</span>
<span class='line-number'>601</span>
<span class='line-number'>602</span>
<span class='line-number'>603</span>
<span class='line-number'>604</span>
<span class='line-number'>605</span>
<span class='line-number'>606</span>
<span class='line-number'>607</span>
<span class='line-number'>608</span>
<span class='line-number'>609</span>
<span class='line-number'>610</span>
<span class='line-number'>611</span>
<span class='line-number'>612</span>
<span class='line-number'>613</span>
<span class='line-number'>614</span>
<span class='line-number'>615</span>
<span class='line-number'>616</span>
<span class='line-number'>617</span>
<span class='line-number'>618</span>
<span class='line-number'>619</span>
<span class='line-number'>620</span>
<span class='line-number'>621</span>
<span class='line-number'>622</span>
<span class='line-number'>623</span>
<span class='line-number'>624</span>
<span class='line-number'>625</span>
<span class='line-number'>626</span>
<span class='line-number'>627</span>
<span class='line-number'>628</span>
<span class='line-number'>629</span>
<span class='line-number'>630</span>
<span class='line-number'>631</span>
<span class='line-number'>632</span>
<span class='line-number'>633</span>
<span class='line-number'>634</span>
<span class='line-number'>635</span>
<span class='line-number'>636</span>
<span class='line-number'>637</span>
<span class='line-number'>638</span>
<span class='line-number'>639</span>
<span class='line-number'>640</span>
<span class='line-number'>641</span>
<span class='line-number'>642</span>
<span class='line-number'>643</span>
<span class='line-number'>644</span>
<span class='line-number'>645</span>
<span class='line-number'>646</span>
<span class='line-number'>647</span>
<span class='line-number'>648</span>
<span class='line-number'>649</span>
<span class='line-number'>650</span>
<span class='line-number'>651</span>
<span class='line-number'>652</span>
<span class='line-number'>653</span>
<span class='line-number'>654</span>
<span class='line-number'>655</span>
<span class='line-number'>656</span>
<span class='line-number'>657</span>
<span class='line-number'>658</span>
<span class='line-number'>659</span>
<span class='line-number'>660</span>
<span class='line-number'>661</span>
<span class='line-number'>662</span>
<span class='line-number'>663</span>
<span class='line-number'>664</span>
<span class='line-number'>665</span>
<span class='line-number'>666</span>
<span class='line-number'>667</span>
<span class='line-number'>668</span>
<span class='line-number'>669</span>
<span class='line-number'>670</span>
<span class='line-number'>671</span>
<span class='line-number'>672</span>
<span class='line-number'>673</span>
<span class='line-number'>674</span>
<span class='line-number'>675</span>
<span class='line-number'>676</span>
<span class='line-number'>677</span>
<span class='line-number'>678</span>
<span class='line-number'>679</span>
<span class='line-number'>680</span>
<span class='line-number'>681</span>
<span class='line-number'>682</span>
<span class='line-number'>683</span>
<span class='line-number'>684</span>
<span class='line-number'>685</span>
<span class='line-number'>686</span>
<span class='line-number'>687</span>
<span class='line-number'>688</span>
<span class='line-number'>689</span>
<span class='line-number'>690</span>
<span class='line-number'>691</span>
<span class='line-number'>692</span>
<span class='line-number'>693</span>
<span class='line-number'>694</span>
<span class='line-number'>695</span>
<span class='line-number'>696</span>
<span class='line-number'>697</span>
<span class='line-number'>698</span>
<span class='line-number'>699</span>
<span class='line-number'>700</span>
<span class='line-number'>701</span>
<span class='line-number'>702</span>
<span class='line-number'>703</span>
<span class='line-number'>704</span>
<span class='line-number'>705</span>
<span class='line-number'>706</span>
<span class='line-number'>707</span>
<span class='line-number'>708</span>
<span class='line-number'>709</span>
<span class='line-number'>710</span>
<span class='line-number'>711</span>
<span class='line-number'>712</span>
<span class='line-number'>713</span>
<span class='line-number'>714</span>
<span class='line-number'>715</span>
<span class='line-number'>716</span>
<span class='line-number'>717</span>
<span class='line-number'>718</span>
<span class='line-number'>719</span>
<span class='line-number'>720</span>
<span class='line-number'>721</span>
<span class='line-number'>722</span>
<span class='line-number'>723</span>
<span class='line-number'>724</span>
<span class='line-number'>725</span>
<span class='line-number'>726</span>
<span class='line-number'>727</span>
<span class='line-number'>728</span>
<span class='line-number'>729</span>
<span class='line-number'>730</span>
<span class='line-number'>731</span>
<span class='line-number'>732</span>
<span class='line-number'>733</span>
<span class='line-number'>734</span>
<span class='line-number'>735</span>
<span class='line-number'>736</span>
<span class='line-number'>737</span>
<span class='line-number'>738</span>
<span class='line-number'>739</span>
<span class='line-number'>740</span>
<span class='line-number'>741</span>
<span class='line-number'>742</span>
<span class='line-number'>743</span>
<span class='line-number'>744</span>
<span class='line-number'>745</span>
<span class='line-number'>746</span>
<span class='line-number'>747</span>
<span class='line-number'>748</span>
<span class='line-number'>749</span>
<span class='line-number'>750</span>
<span class='line-number'>751</span>
<span class='line-number'>752</span>
<span class='line-number'>753</span>
<span class='line-number'>754</span>
<span class='line-number'>755</span>
<span class='line-number'>756</span>
<span class='line-number'>757</span>
<span class='line-number'>758</span>
<span class='line-number'>759</span>
<span class='line-number'>760</span>
<span class='line-number'>761</span>
<span class='line-number'>762</span>
<span class='line-number'>763</span>
<span class='line-number'>764</span>
<span class='line-number'>765</span>
<span class='line-number'>766</span>
<span class='line-number'>767</span>
<span class='line-number'>768</span>
<span class='line-number'>769</span>
<span class='line-number'>770</span>
<span class='line-number'>771</span>
<span class='line-number'>772</span>
<span class='line-number'>773</span>
<span class='line-number'>774</span>
<span class='line-number'>775</span>
<span class='line-number'>776</span>
<span class='line-number'>777</span>
<span class='line-number'>778</span>
<span class='line-number'>779</span>
<span class='line-number'>780</span>
<span class='line-number'>781</span>
<span class='line-number'>782</span>
<span class='line-number'>783</span>
<span class='line-number'>784</span>
<span class='line-number'>785</span>
<span class='line-number'>786</span>
<span class='line-number'>787</span>
<span class='line-number'>788</span>
<span class='line-number'>789</span>
<span class='line-number'>790</span>
<span class='line-number'>791</span>
<span class='line-number'>792</span>
<span class='line-number'>793</span>
<span class='line-number'>794</span>
<span class='line-number'>795</span>
<span class='line-number'>796</span>
<span class='line-number'>797</span>
<span class='line-number'>798</span>
<span class='line-number'>799</span>
<span class='line-number'>800</span>
<span class='line-number'>801</span>
<span class='line-number'>802</span>
<span class='line-number'>803</span>
<span class='line-number'>804</span>
<span class='line-number'>805</span>
<span class='line-number'>806</span>
<span class='line-number'>807</span>
<span class='line-number'>808</span>
<span class='line-number'>809</span>
<span class='line-number'>810</span>
<span class='line-number'>811</span>
<span class='line-number'>812</span>
<span class='line-number'>813</span>
<span class='line-number'>814</span>
<span class='line-number'>815</span>
<span class='line-number'>816</span>
<span class='line-number'>817</span>
<span class='line-number'>818</span>
<span class='line-number'>819</span>
<span class='line-number'>820</span>
<span class='line-number'>821</span>
<span class='line-number'>822</span>
<span class='line-number'>823</span>
<span class='line-number'>824</span>
<span class='line-number'>825</span>
<span class='line-number'>826</span>
<span class='line-number'>827</span>
<span class='line-number'>828</span>
<span class='line-number'>829</span>
<span class='line-number'>830</span>
<span class='line-number'>831</span>
<span class='line-number'>832</span>
<span class='line-number'>833</span>
<span class='line-number'>834</span>
<span class='line-number'>835</span>
<span class='line-number'>836</span>
<span class='line-number'>837</span>
<span class='line-number'>838</span>
<span class='line-number'>839</span>
<span class='line-number'>840</span>
<span class='line-number'>841</span>
<span class='line-number'>842</span>
<span class='line-number'>843</span>
<span class='line-number'>844</span>
<span class='line-number'>845</span>
<span class='line-number'>846</span>
<span class='line-number'>847</span>
<span class='line-number'>848</span>
<span class='line-number'>849</span>
<span class='line-number'>850</span>
<span class='line-number'>851</span>
<span class='line-number'>852</span>
<span class='line-number'>853</span>
<span class='line-number'>854</span>
<span class='line-number'>855</span>
<span class='line-number'>856</span>
<span class='line-number'>857</span>
<span class='line-number'>858</span>
<span class='line-number'>859</span>
<span class='line-number'>860</span>
<span class='line-number'>861</span>
<span class='line-number'>862</span>
<span class='line-number'>863</span>
<span class='line-number'>864</span>
<span class='line-number'>865</span>
<span class='line-number'>866</span>
<span class='line-number'>867</span>
<span class='line-number'>868</span>
<span class='line-number'>869</span>
<span class='line-number'>870</span>
<span class='line-number'>871</span>
<span class='line-number'>872</span>
<span class='line-number'>873</span>
<span class='line-number'>874</span>
<span class='line-number'>875</span>
<span class='line-number'>876</span>
<span class='line-number'>877</span>
<span class='line-number'>878</span>
<span class='line-number'>879</span>
<span class='line-number'>880</span>
<span class='line-number'>881</span>
<span class='line-number'>882</span>
<span class='line-number'>883</span>
<span class='line-number'>884</span>
<span class='line-number'>885</span>
<span class='line-number'>886</span>
<span class='line-number'>887</span>
<span class='line-number'>888</span>
<span class='line-number'>889</span>
<span class='line-number'>890</span>
<span class='line-number'>891</span>
<span class='line-number'>892</span>
<span class='line-number'>893</span>
<span class='line-number'>894</span>
<span class='line-number'>895</span>
<span class='line-number'>896</span>
<span class='line-number'>897</span>
<span class='line-number'>898</span>
<span class='line-number'>899</span>
<span class='line-number'>900</span>
<span class='line-number'>901</span>
<span class='line-number'>902</span>
<span class='line-number'>903</span>
<span class='line-number'>904</span>
<span class='line-number'>905</span>
<span class='line-number'>906</span>
<span class='line-number'>907</span>
<span class='line-number'>908</span>
<span class='line-number'>909</span>
<span class='line-number'>910</span>
<span class='line-number'>911</span>
<span class='line-number'>912</span>
<span class='line-number'>913</span>
<span class='line-number'>914</span>
<span class='line-number'>915</span>
<span class='line-number'>916</span>
<span class='line-number'>917</span>
<span class='line-number'>918</span>
<span class='line-number'>919</span>
<span class='line-number'>920</span>
<span class='line-number'>921</span>
<span class='line-number'>922</span>
<span class='line-number'>923</span>
<span class='line-number'>924</span>
<span class='line-number'>925</span>
<span class='line-number'>926</span>
<span class='line-number'>927</span>
<span class='line-number'>928</span>
<span class='line-number'>929</span>
<span class='line-number'>930</span>
<span class='line-number'>931</span>
<span class='line-number'>932</span>
<span class='line-number'>933</span>
<span class='line-number'>934</span>
<span class='line-number'>935</span>
<span class='line-number'>936</span>
<span class='line-number'>937</span>
<span class='line-number'>938</span>
<span class='line-number'>939</span>
<span class='line-number'>940</span>
<span class='line-number'>941</span>
<span class='line-number'>942</span>
<span class='line-number'>943</span>
<span class='line-number'>944</span>
<span class='line-number'>945</span>
<span class='line-number'>946</span>
<span class='line-number'>947</span>
<span class='line-number'>948</span>
<span class='line-number'>949</span>
<span class='line-number'>950</span>
<span class='line-number'>951</span>
<span class='line-number'>952</span>
<span class='line-number'>953</span>
<span class='line-number'>954</span>
<span class='line-number'>955</span>
<span class='line-number'>956</span>
<span class='line-number'>957</span>
<span class='line-number'>958</span>
<span class='line-number'>959</span>
<span class='line-number'>960</span>
<span class='line-number'>961</span>
<span class='line-number'>962</span>
<span class='line-number'>963</span>
<span class='line-number'>964</span>
<span class='line-number'>965</span>
<span class='line-number'>966</span>
<span class='line-number'>967</span>
<span class='line-number'>968</span>
<span class='line-number'>969</span>
<span class='line-number'>970</span>
<span class='line-number'>971</span>
<span class='line-number'>972</span>
<span class='line-number'>973</span>
<span class='line-number'>974</span>
<span class='line-number'>975</span>
<span class='line-number'>976</span>
<span class='line-number'>977</span>
<span class='line-number'>978</span>
<span class='line-number'>979</span>
<span class='line-number'>980</span>
<span class='line-number'>981</span>
<span class='line-number'>982</span>
<span class='line-number'>983</span>
<span class='line-number'>984</span>
<span class='line-number'>985</span>
<span class='line-number'>986</span>
<span class='line-number'>987</span>
<span class='line-number'>988</span>
<span class='line-number'>989</span>
<span class='line-number'>990</span>
<span class='line-number'>991</span>
<span class='line-number'>992</span>
<span class='line-number'>993</span>
<span class='line-number'>994</span>
<span class='line-number'>995</span>
<span class='line-number'>996</span>
<span class='line-number'>997</span>
<span class='line-number'>998</span>
<span class='line-number'>999</span>
<span class='line-number'>1000</span>
<span class='line-number'>1001</span>
<span class='line-number'>1002</span>
<span class='line-number'>1003</span>
<span class='line-number'>1004</span>
<span class='line-number'>1005</span>
<span class='line-number'>1006</span>
<span class='line-number'>1007</span>
<span class='line-number'>1008</span>
<span class='line-number'>1009</span>
<span class='line-number'>1010</span>
<span class='line-number'>1011</span>
<span class='line-number'>1012</span>
<span class='line-number'>1013</span>
<span class='line-number'>1014</span>
<span class='line-number'>1015</span>
<span class='line-number'>1016</span>
<span class='line-number'>1017</span>
<span class='line-number'>1018</span>
<span class='line-number'>1019</span>
<span class='line-number'>1020</span>
<span class='line-number'>1021</span>
<span class='line-number'>1022</span>
<span class='line-number'>1023</span>
<span class='line-number'>1024</span>
<span class='line-number'>1025</span>
<span class='line-number'>1026</span>
<span class='line-number'>1027</span>
<span class='line-number'>1028</span>
<span class='line-number'>1029</span>
<span class='line-number'>1030</span>
<span class='line-number'>1031</span>
<span class='line-number'>1032</span>
<span class='line-number'>1033</span>
<span class='line-number'>1034</span>
<span class='line-number'>1035</span>
<span class='line-number'>1036</span>
<span class='line-number'>1037</span>
<span class='line-number'>1038</span>
<span class='line-number'>1039</span>
<span class='line-number'>1040</span>
<span class='line-number'>1041</span>
<span class='line-number'>1042</span>
<span class='line-number'>1043</span>
<span class='line-number'>1044</span>
<span class='line-number'>1045</span>
<span class='line-number'>1046</span>
<span class='line-number'>1047</span>
<span class='line-number'>1048</span>
<span class='line-number'>1049</span>
<span class='line-number'>1050</span>
<span class='line-number'>1051</span>
<span class='line-number'>1052</span>
<span class='line-number'>1053</span>
<span class='line-number'>1054</span>
<span class='line-number'>1055</span>
<span class='line-number'>1056</span>
<span class='line-number'>1057</span>
<span class='line-number'>1058</span>
<span class='line-number'>1059</span>
<span class='line-number'>1060</span>
<span class='line-number'>1061</span>
<span class='line-number'>1062</span>
<span class='line-number'>1063</span>
<span class='line-number'>1064</span>
<span class='line-number'>1065</span>
<span class='line-number'>1066</span>
<span class='line-number'>1067</span>
<span class='line-number'>1068</span>
<span class='line-number'>1069</span>
<span class='line-number'>1070</span>
<span class='line-number'>1071</span>
<span class='line-number'>1072</span>
<span class='line-number'>1073</span>
<span class='line-number'>1074</span>
<span class='line-number'>1075</span>
<span class='line-number'>1076</span>
<span class='line-number'>1077</span>
<span class='line-number'>1078</span>
<span class='line-number'>1079</span>
<span class='line-number'>1080</span>
<span class='line-number'>1081</span>
<span class='line-number'>1082</span>
<span class='line-number'>1083</span>
<span class='line-number'>1084</span>
<span class='line-number'>1085</span>
<span class='line-number'>1086</span>
<span class='line-number'>1087</span>
<span class='line-number'>1088</span>
<span class='line-number'>1089</span>
<span class='line-number'>1090</span>
<span class='line-number'>1091</span>
<span class='line-number'>1092</span>
<span class='line-number'>1093</span>
<span class='line-number'>1094</span>
<span class='line-number'>1095</span>
<span class='line-number'>1096</span>
<span class='line-number'>1097</span>
<span class='line-number'>1098</span>
<span class='line-number'>1099</span>
<span class='line-number'>1100</span>
<span class='line-number'>1101</span>
<span class='line-number'>1102</span>
<span class='line-number'>1103</span>
<span class='line-number'>1104</span>
<span class='line-number'>1105</span>
<span class='line-number'>1106</span>
<span class='line-number'>1107</span>
<span class='line-number'>1108</span>
<span class='line-number'>1109</span>
<span class='line-number'>1110</span>
<span class='line-number'>1111</span>
<span class='line-number'>1112</span>
<span class='line-number'>1113</span>
<span class='line-number'>1114</span>
<span class='line-number'>1115</span>
<span class='line-number'>1116</span>
<span class='line-number'>1117</span>
<span class='line-number'>1118</span>
<span class='line-number'>1119</span>
<span class='line-number'>1120</span>
<span class='line-number'>1121</span>
<span class='line-number'>1122</span>
<span class='line-number'>1123</span>
<span class='line-number'>1124</span>
<span class='line-number'>1125</span>
<span class='line-number'>1126</span>
<span class='line-number'>1127</span>
<span class='line-number'>1128</span>
<span class='line-number'>1129</span>
<span class='line-number'>1130</span>
<span class='line-number'>1131</span>
<span class='line-number'>1132</span>
<span class='line-number'>1133</span>
<span class='line-number'>1134</span>
<span class='line-number'>1135</span>
<span class='line-number'>1136</span>
<span class='line-number'>1137</span>
<span class='line-number'>1138</span>
<span class='line-number'>1139</span>
<span class='line-number'>1140</span>
<span class='line-number'>1141</span>
<span class='line-number'>1142</span>
<span class='line-number'>1143</span>
<span class='line-number'>1144</span>
<span class='line-number'>1145</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline void __rcu_read_lock(void)
</span><span class='line'>{
</span><span class='line'>    preempt_disable();
</span><span class='line'>}&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static inline void __rcu_read_unlock(void)
</span><span class='line'>{
</span><span class='line'>preempt_enable();
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static inline void rcu_read_lock(void)
</span><span class='line'>{
</span><span class='line'>__rcu_read_lock();
</span><span class='line'>__acquire(RCU);
</span><span class='line'>rcu_lock_acquire(&amp;rcu_lock_map);
</span><span class='line'>rcu_lockdep_assert(!rcu_is_cpu_idle(),
</span><span class='line'>        "rcu_read_lock() used illegally while idle");
</span><span class='line'>}
</span><span class='line'>static inline void rcu_read_unlock(void)
</span><span class='line'>{
</span><span class='line'>rcu_lockdep_assert(!rcu_is_cpu_idle(),
</span><span class='line'>        "rcu_read_unlock() used illegally while idle");
</span><span class='line'>rcu_lock_release(&amp;rcu_lock_map);
</span><span class='line'>__release(RCU);
</span><span class='line'>__rcu_read_unlock();
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>rcu_read_lock与rcu_read_unlock在非抢占式下的实现比较简单就是 preempt_disable与preempt_enable。这样做的目的是当调用schedule的时候，就可以肯定读的过程已经结束。其它_acquire(RCU)等函数是调试用的代码，暂不做讨论。
</span><span class='line'>
</span><span class='line'>  3， rcu_note_context_switch 在schedule中调用，每次进程切换就代表着一个静止状态。该函数会把当前的CPU状态设置为通过状态。
</span><span class='line'>
</span><span class='line'>  4， rcu_check_callbacks 在每次时钟周期里调用(update_process_times)。通过它会触发软件中断，软件中断对应着rcu_process_callbacks，这是一个真正繁忙的函数，他会检测当前CPU的状态，向父节点传递静止状态信息，调用注册函数等一系列工作。
</span><span class='line'>
</span><span class='line'>在进一步了解这些函数之前，我们先来看看你Tree RCU的结构。
</span><span class='line'>
</span><span class='line'>#### TREE RCU简介
</span><span class='line'>
</span><span class='line'>  在统计CPU的状态的时候，需要用到一个结构来存放所有CPU的状态。在早期的实现中，所有的状态都保存在一个结构中，这样做的后果是所有的CPU在更新自己状态的时候，都需要锁定该结构对象，一定程度上影响了系统性能。为了提高性能，把一定数目的CPU组成了一个节点（默认设定64个CPU为一个节点）；当节点超过64个的时候，再把这些节点按64为单位划分为归属不同的父节点；如此类推，最后的一个单独的节点作为根节点。这样在更新CPU状态的时候，只需要锁定自己所属的节点就可以了。按节点设置的数目，可见这个结构只对CPU数成百上千的系统才真正起作用（我都没见过超过32个cpu的机器，不知道是啥样的感觉）。
</span><span class='line'>
</span><span class='line'>![](/images/kernel/2015-06-02-50.png)  
</span><span class='line'>
</span><span class='line'>  这样所有的CPU就按层级结构组织了起来，也就是一个树结构。当一个系统的CPU数少于64个的时候，只要一个rcu_node就可以。
</span><span class='line'>
</span><span class='line'>  每个CPU在完成宽限期检测的时候，就会去更新它所属的rcu_node的值，当一个rcu_node所包含的CPU的状态都更新过以后，该node就会去更新它所属的父节点的值。直到最后一个根节点。
</span><span class='line'>
</span><span class='line'>#### TREE RCU数据结构
</span><span class='line'>
</span><span class='line'>为了实现该结构，系统提供了以下结构。
</span><span class='line'>
</span><span class='line'>##### rcu_data
</span><span class='line'>
</span><span class='line'>由于RCU需要统计每个CPU是否通过了宽限期，提供了rcu_data来保存信息。另外每个销毁的对象并不是直接删除，也保存在rcu_data中，等到合适的时机来执行。
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;struct rcu_data {  
</span><span class='line'>/* 1) 静止状态和宽限期处理: */  
</span><span class='line'>unsigned long   completed;      /* 对比 rsp-&gt;completed */  
</span><span class='line'>                                /* 目的是检测宽限期是否完成. */  
</span><span class='line'>unsigned long   gpnum;          /* 当前CPU上最高的宽限期数目*/  
</span><span class='line'>                                /* 在宽限期开始的时候设置. */  
</span><span class='line'>unsigned long   passed_quiesce_gpnum;  
</span><span class='line'>                                /* 已经通过的宽限期数目. */  
</span><span class='line'>bool            passed_quiesce; /* 是否通过了静止状态，在进程切换等状态会设置. */  
</span><span class='line'>bool            qs_pending;     /* 对于当前执行的宽限期，该CPU是否执行完成. */  
</span><span class='line'>bool            beenonline;     /* CPU是否在线，不在线的CPU需要特殊处理，以提高性能*/  
</span><span class='line'>bool            preemptible;    /* 是否抢占式RCU? */  
</span><span class='line'>struct rcu_node *mynode;        /* 这个CPU对应的 rcu_node */  
</span><span class='line'>unsigned long grpmask;          /* 占用1bit，对应与所属的rcu_node. */  
</span><span class='line'>#ifdef CONFIG_RCU_CPU_STALL_INFO  
</span><span class='line'>unsigned long   ticks_this_gp;  /* The number of scheduling-clock */  
</span><span class='line'>                                /*  ticks this CPU has handled */  
</span><span class='line'>                                /*  during and after the last grace */  
</span><span class='line'>                                /* period it is aware of. */  
</span><span class='line'>#endif /* #ifdef CONFIG_RCU_CPU_STALL_INFO */  
</span><span class='line'>/* 2) 批处理*/  
</span><span class='line'>/* 
</span><span class='line'> * 
</span><span class='line'> * 当nxtlist不为空的时候，会通过nxttail划分为以下几部分 
</span><span class='line'> * 每一个部分为空的时候，它的指针会被设置成与它的下一部分相同 
</span><span class='line'> * 当nxtlist为空的时候，所有的nxttail都会指向nxtlist的地址，这时候nxtlist指向NULL 
</span><span class='line'> * 
</span><span class='line'> * [nxtlist, *nxttail[RCU_DONE_TAIL]): 
</span><span class='line'> *    批处理的开始节点# &lt;= -&gt;completed 
</span><span class='line'> *    这些节点的宽限期已经完成，可以执行销毁操作。 
</span><span class='line'> *    当调用rcu_process_callbacks()的时候，下一批完成宽限期的节点也会放到这儿. 
</span><span class='line'> * [*nxttail[RCU_DONE_TAIL], *nxttail[RCU_WAIT_TAIL]): 
</span><span class='line'> *    批处理的开始节点 # &lt;= -&gt;completed - 1: 等待当前的批处理完成 
</span><span class='line'> * [*nxttail[RCU_WAIT_TAIL], *nxttail[RCU_NEXT_READY_TAIL]): 
</span><span class='line'> *    已知的当下次宽限期开始，可以开始等待的节点。 
</span><span class='line'> * [*nxttail[RCU_NEXT_READY_TAIL], *nxttail[RCU_NEXT_TAIL]): 
</span><span class='line'> *    当前不确定下次宽限期开始后，是否可以开始等待状态的节点。 
</span><span class='line'> *    *nxttail[RCU_NEXT_TAIL] 的值将永远是NULL， 
</span><span class='line'> *    它表示nxtlist的结束. 
</span><span class='line'> * 
</span><span class='line'> */  
</span><span class='line'>struct rcu_head *nxtlist;  
</span><span class='line'>struct rcu_head **nxttail[RCU_NEXT_SIZE];  
</span><span class='line'>long            qlen_lazy;      /* # kfree_rcu调用的次数，kfee_rcu等同于call_rcu，只是它不需要销毁的对象提供销毁函数*/  
</span><span class='line'>long            qlen;           /* # 当前需要执行销毁操作的次数，每次call_rcu会加一，执行过后减一*/  
</span><span class='line'>long            qlen_last_fqs_check;  
</span><span class='line'>                                /* 对应与qlen，最后一次执行的次数*/  
</span><span class='line'>unsigned long   n_cbs_invoked;  /* 执行销毁操作的次数. */  
</span><span class='line'>unsigned long   n_cbs_orphaned; /* 统计离线后CPU上剩下的callback函数的个数 */  
</span><span class='line'>unsigned long   n_cbs_adopted;  /* 从离线后的CPU上移出的callback函数的个数 */  
</span><span class='line'>unsigned long   n_force_qs_snap;  
</span><span class='line'>                                /* 其它CPU是否在执行fore_qs? */  
</span><span class='line'>long            blimit;         /* nxtlist保存的上限 */  
</span><span class='line'>
</span><span class='line'>/* 3) 动态时钟,*/  
</span><span class='line'>struct rcu_dynticks *dynticks;  /* 每个CPU都包含一个动态时钟. */  
</span><span class='line'>int dynticks_snap;              /* 用于检测CPU是否在线. */  
</span><span class='line'>
</span><span class='line'>/* 4) 强制执行时候处理的CPU */  
</span><span class='line'>unsigned long dynticks_fqs;     /* 由于进入dynticks idle而被处理的CPU. */  
</span><span class='line'>unsigned long offline_fqs;      /* 由于不在在线被处理的CPU. */  
</span><span class='line'>
</span><span class='line'>/* 5) __rcu_pending() 的统计信息，这些信息都是在记录调用信息的时候使用. */  
</span><span class='line'>unsigned long n_rcu_pending;    /* rcu_pending() 调用次数，自从启动. */  
</span><span class='line'>unsigned long n_rp_qs_pending;  
</span><span class='line'>unsigned long n_rp_report_qs;  
</span><span class='line'>unsigned long n_rp_cb_ready;  
</span><span class='line'>unsigned long n_rp_cpu_needs_gp;  
</span><span class='line'>unsigned long n_rp_gp_completed;  
</span><span class='line'>unsigned long n_rp_gp_started;  
</span><span class='line'>unsigned long n_rp_need_fqs;  
</span><span class='line'>unsigned long n_rp_need_nothing;  
</span><span class='line'>
</span><span class='line'>/* 6) _rcu_barrier() 的回调函数. */  
</span><span class='line'>struct rcu_head barrier_head;  
</span><span class='line'>
</span><span class='line'>int cpu;  
</span><span class='line'>struct rcu_state *rsp;  
</span><span class='line'>};  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>1，completed ，gpnum ， passed_quiesce_gpnum
</span><span class='line'>
</span><span class='line'>  gpnum表示当前正在运行的宽限期的个数，每当一个宽限期开始的时候，会设置这个值与其父节点相同。passed_quiesce_gpnum为当前CPU通过的宽限期个数，它的值在宽限期开始的时候小于gpnum，当这个CPU经过一个静止状态的时候，会把它设置成gpnum的值，通过对比它与父节点中的gpnum是否相同，可以确定该CPU是否通过了宽限期。passed_quiesce_gpnum只是表示这个CPU通过了宽限期，而completed表示所有的CPU都通过了宽限期，设置该值的同时，可以将nxtlist中等待的回调函数移动到完成队列。
</span><span class='line'>
</span><span class='line'>2，nxtlist 与nxttail
</span><span class='line'>
</span><span class='line'>  nxtlist保存的是指向rcu_head对象，rcu_head的定义如下：        
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;struct callback_head {
</span><span class='line'>struct callback_head *next;
</span><span class='line'>void (*func)(struct callback_head *head);
</span><span class='line'>};
</span><span class='line'>#define rcu_head callback_head
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>rcu_head的结构并不复杂，它包含一个回调函数指针。而next可以把rcu_head连成一个列表。
</span><span class='line'>
</span><span class='line'>![](/images/kernel/2015-06-02-51.png)  
</span><span class='line'>
</span><span class='line'>nxtlist指向一个rcu_head 列表，而nxttail的四个元素是指向指针的指针，它们指向的是rcu_head对象的next。RCU_DONE_TAIL指向的rcu_head对象之前的对象是可以销毁的对象。RCU_WAIT_TAIL指向的正在等待宽限期的元素，RCU_NEXT_READ_TAIL指向的是等待下次宽限期的元素，RCU_NEXT_TAIL指向最后一个元素，这个元素总是指向NULL。
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>##### rcu_node
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;struct rcu_node {  
</span><span class='line'>raw_spinlock_t lock;    /* rcu_node的锁，用来保护以下的一些成员*/  
</span><span class='line'>
</span><span class='line'>unsigned long gpnum;    /* 该节点当前的宽限期的数量 */  
</span><span class='line'>                        /* 该值等于或者比父节点的值小1*/  
</span><span class='line'>unsigned long completed; /* 该节点完成的宽限期数量*/  
</span><span class='line'>                         /* 该值等于或者比父节点的值小1*/  
</span><span class='line'>unsigned long qsmask;   /* 标记这个节点对应的所有CPU或者子节点是否完成了当前的宽限期*/  
</span><span class='line'>                        /* 每一个bit对应一个cpu或者一个子节点.*/  
</span><span class='line'>unsigned long expmask;  /* 需要执行 -&gt;blkd_tasks 的元素 */                              
</span><span class='line'>                        /*  (应用于TREE_PREEMPT_RCU). */  
</span><span class='line'>atomic_t wakemask;      /* 需要唤醒kthread的CPU. */  
</span><span class='line'>
</span><span class='line'>unsigned long qsmaskinit;  
</span><span class='line'>                        /* 每个宽限期开始时，用它来初始化qsmask，不存在或者不在线的CPU需要清除. */  
</span><span class='line'>unsigned long grpmask;  /* 对应于父节点中的位置. */  
</span><span class='line'>                        /* 只是用一bit. */  
</span><span class='line'>int     grplo;          /* 该节点代表的CPU或者子节点开始的位置. */  
</span><span class='line'>int     grphi;          /* 该节点代表的CPU或者子节点结束的位置. */  
</span><span class='line'>u8      grpnum;         /* 下一级的CPU或者子节点的个数. */  
</span><span class='line'>u8      level;          /* 跟节点是 0. */  
</span><span class='line'>struct rcu_node *parent;  
</span><span class='line'>struct list_head blkd_tasks;  
</span><span class='line'>                        /* 阻断读关键段的任务列表 */  
</span><span class='line'>                        /*  */  
</span><span class='line'>
</span><span class='line'>struct list_head *gp_tasks;  
</span><span class='line'>                        /* 指向第一个阻断读关键段的任务 */  
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>struct list_head *exp_tasks;  
</span><span class='line'>
</span><span class='line'>/*以下为抢先式下加速RCU过程的变量*/
</span><span class='line'>
</span><span class='line'>#ifdef CONFIG_RCU_BOOST  
</span><span class='line'>struct list_head *boost_tasks;  
</span><span class='line'>                        /* Pointer to first task that needs to be */  
</span><span class='line'>                        /*  priority boosted, or NULL if no priority */  
</span><span class='line'>                        /*  boosting is needed for this rcu_node */  
</span><span class='line'>                        /*  structure.  If there are no tasks */  
</span><span class='line'>                        /*  queued on this rcu_node structure that */  
</span><span class='line'>                        /*  are blocking the current grace period, */  
</span><span class='line'>                        /*  there can be no such task. */  
</span><span class='line'>unsigned long boost_time;  
</span><span class='line'>                        /* When to start boosting (jiffies). */  
</span><span class='line'>struct task_struct *boost_kthread_task;  
</span><span class='line'>                        /* kthread that takes care of priority */  
</span><span class='line'>                        /*  boosting for this rcu_node structure. */  
</span><span class='line'>unsigned int boost_kthread_status;  
</span><span class='line'>                        /* State of boost_kthread_task for tracing. */  
</span><span class='line'>unsigned long n_tasks_boosted;  
</span><span class='line'>                        /* Total number of tasks boosted. */  
</span><span class='line'>unsigned long n_exp_boosts;  
</span><span class='line'>                        /* Number of tasks boosted for expedited GP. */  
</span><span class='line'>unsigned long n_normal_boosts;  
</span><span class='line'>                        /* Number of tasks boosted for normal GP. */  
</span><span class='line'>unsigned long n_balk_blkd_tasks;  
</span><span class='line'>                        /* Refused to boost: no blocked tasks. */  
</span><span class='line'>unsigned long n_balk_exp_gp_tasks;  
</span><span class='line'>                        /* Refused to boost: nothing blocking GP. */  
</span><span class='line'>unsigned long n_balk_boost_tasks;  
</span><span class='line'>                        /* Refused to boost: already boosting. */  
</span><span class='line'>unsigned long n_balk_notblocked;  
</span><span class='line'>                        /* Refused to boost: RCU RS CS still running. */  
</span><span class='line'>unsigned long n_balk_notyet;  
</span><span class='line'>                        /* Refused to boost: not yet time. */  
</span><span class='line'>unsigned long n_balk_nos;  
</span><span class='line'>                        /* Refused to boost: not sure why, though. */  
</span><span class='line'>                        /*  This can happen due to race conditions. */  
</span><span class='line'>#endif /* #ifdef CONFIG_RCU_BOOST */  
</span><span class='line'>struct task_struct *node_kthread_task;  
</span><span class='line'>                        /* kthread that takes care of this rcu_node */  
</span><span class='line'>                        /*  structure, for example, awakening the */  
</span><span class='line'>                        /*  per-CPU kthreads as needed. */  
</span><span class='line'>unsigned int node_kthread_status;  
</span><span class='line'>                        /* State of node_kthread_task for tracing. */  
</span><span class='line'>} ____cacheline_internodealigned_in_smp;  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>每个rcu_node代表着 一组CPU或者子节点。在非抢占式下，它的结构并不复杂。由于可能有多个CPU对它进行处理，所有进行相应操作的时候，需要lock保护。
</span><span class='line'>
</span><span class='line'>##### rcu_state
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;struct rcu_state {  
</span><span class='line'>struct rcu_node node[NUM_RCU_NODES];    /* 保存了所有的节点. */  
</span><span class='line'>struct rcu_node *level[RCU_NUM_LVLS];   /* 每个层级所指向的节点. */  
</span><span class='line'>u32 levelcnt[MAX_RCU_LVLS + 1];         /* # 每一层的节点数. */  
</span><span class='line'>u8 levelspread[RCU_NUM_LVLS];           /* 每一层的CPU/节点数. */  
</span><span class='line'>struct rcu_data __percpu *rda;          /* 指向rcu_data. */  
</span><span class='line'>void (*call)(struct rcu_head *head,     /* rcu_barrier指向的回调函数. */  
</span><span class='line'>             void (*func)(struct rcu_head *head));  
</span><span class='line'>
</span><span class='line'>/* The following fields are guarded by the root rcu_node's lock. */  
</span><span class='line'>
</span><span class='line'>u8      fqs_state ____cacheline_internodealigned_in_smp;  
</span><span class='line'>                                        /* 调用force_quiescent_state时的状态. */  
</span><span class='line'>u8      fqs_active;                     /* force_quiescent_state() 正在运行*/  
</span><span class='line'>
</span><span class='line'>u8      fqs_need_gp;                    /* 因为 force_quiescent_state() 正在运行*/  
</span><span class='line'>                                        /* 一个CPU需要运行的宽限期被阻止*/  
</span><span class='line'>
</span><span class='line'>u8      boost;                          /* 加速. */  
</span><span class='line'>unsigned long gpnum;                    /* 当前的宽限起数量. */  
</span><span class='line'>unsigned long completed;                /* # 最后一次完成的宽限期数量. */  
</span><span class='line'>
</span><span class='line'>/* 以下的成员被根rcu_node的lock保护. */  
</span><span class='line'>
</span><span class='line'>raw_spinlock_t onofflock;               /* 开始一个新的宽限期的时候，阻止CPU上下线*/  
</span><span class='line'>
</span><span class='line'>struct rcu_head *orphan_nxtlist;        /* 等待宽限期的孤儿回调函数的列表 */  
</span><span class='line'>
</span><span class='line'>struct rcu_head **orphan_nxttail;       /* 以上列表的结尾. */  
</span><span class='line'>struct rcu_head *orphan_donelist;       /* 需要执行的孤儿回调函数列表 */  
</span><span class='line'>
</span><span class='line'>struct rcu_head **orphan_donetail;      /* 以上列表的结尾. */  
</span><span class='line'>long qlen_lazy;                         /* 懒惰回调函数的个数. */  
</span><span class='line'>long qlen;                              /* 总的回调函数的个数. */  
</span><span class='line'>struct task_struct *rcu_barrier_in_progress;  
</span><span class='line'>                                        /* 调用rcu_barrier()的进程, */  
</span><span class='line'>                                        /* 没有的话指向NULL. */  
</span><span class='line'>struct mutex barrier_mutex;             /* 执行barrier需要的互斥锁. */  
</span><span class='line'>atomic_t barrier_cpu_count;             /* # 等待barrier的CPU数 . */  
</span><span class='line'>struct completion barrier_completion;   /* 在barrier结束的时候调用. */  
</span><span class='line'>unsigned long n_barrier_done;           /* 在_rcu_barrier()开始结束处都需要调用++ */  
</span><span class='line'>
</span><span class='line'>raw_spinlock_t fqslock;                 /* 只有一个进程能调用 force_quiescent_state().*/  
</span><span class='line'>
</span><span class='line'>unsigned long jiffies_force_qs;         /* force_quiescent_state()开始的时间 */  
</span><span class='line'>
</span><span class='line'>unsigned long n_force_qs;               /* 调用force_quiescent_state()的次数 */  
</span><span class='line'>
</span><span class='line'>unsigned long n_force_qs_lh;            /* 因为lock不可用，而退出force_quiescent_state()的次数 */  
</span><span class='line'>
</span><span class='line'>unsigned long n_force_qs_ngp;           /* 因为当前有宽限期执行，而退出force_quiescent_state()的次数*/  
</span><span class='line'>
</span><span class='line'>unsigned long gp_start;                 /* 宽限期开始的时间*/  
</span><span class='line'>
</span><span class='line'>unsigned long jiffies_stall;              
</span><span class='line'>
</span><span class='line'>unsigned long gp_max;                   /*  最长的宽限的jiffie数 */  
</span><span class='line'>
</span><span class='line'>char *name;                             /* 结构的名字. */  
</span><span class='line'>struct list_head flavors;               /* 系统中的rcu_state. */  
</span><span class='line'>};  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>rcu_state 保存了所有的node，宽限期的判断只要取出根节点，也就是第一个元素就可以。还有一些初始化要用到的变量。还有孤儿回调函数用于处理离线CPU遗留的信息。剩下还有很多统计信息，这些内容在讲解代码实现的时候再仔细考虑。
</span><span class='line'>
</span><span class='line'>-------------
</span><span class='line'>
</span><span class='line'>### TREE RCU实现之二 —— 主干函数
</span><span class='line'>
</span><span class='line'>RCU的实现集中在以下几个步骤：  
</span><span class='line'>  1， 调用call_rcu，将回调函数增加到列表。  
</span><span class='line'>  2,   开始一个宽限期。  
</span><span class='line'>  3,   每个CPU报告自己的状态，直到最后一个CPU，结束一个宽限期。  
</span><span class='line'>  4， 宽限期结束，每个CPU处理自己的回调函数。  
</span><span class='line'>
</span><span class='line'>#### call_rcu的实现
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static void  
</span><span class='line'>__call_rcu(struct rcu_head *head, void (*func)(struct rcu_head *rcu),  
</span><span class='line'>   struct rcu_state *rsp, bool lazy)  
</span><span class='line'>{  
</span><span class='line'>unsigned long flags;  
</span><span class='line'>struct rcu_data *rdp;  
</span><span class='line'>
</span><span class='line'>WARN_ON_ONCE((unsigned long)head &amp; 0x3); /* 检测head在内存中是否对齐! */  
</span><span class='line'>debug_rcu_head_queue(head);  
</span><span class='line'>head-&gt;func = func;  
</span><span class='line'>head-&gt;next = NULL;  
</span><span class='line'>
</span><span class='line'>smp_mb(); /* Ensure RCU update seen before callback registry. */  
</span><span class='line'>
</span><span class='line'>/* 
</span><span class='line'> * 这是一个检测宽限期开始或者结束的机会。 
</span><span class='line'> * 当我们看到一个结束的时候，可能还会看到一个开始。 
</span><span class='line'> * 反过来，看到一个开始的时候，不一定能看到一个结束， 
</span><span class='line'> * 因为宽限期结束需要一定时间。 
</span><span class='line'> */  
</span><span class='line'>local_irq_save(flags);  
</span><span class='line'>rdp = this_cpu_ptr(rsp-&gt;rda);  
</span><span class='line'>
</span><span class='line'>/* 将要增加callback到nxtlist. */  
</span><span class='line'>ACCESS_ONCE(rdp-&gt;qlen)++;  
</span><span class='line'>if (lazy)  
</span><span class='line'>    rdp-&gt;qlen_lazy++;  
</span><span class='line'>else  
</span><span class='line'>    rcu_idle_count_callbacks_posted();  
</span><span class='line'>smp_mb();  /* Count before adding callback for rcu_barrier(). */  
</span><span class='line'>*rdp-&gt;nxttail[RCU_NEXT_TAIL] = head;  
</span><span class='line'>rdp-&gt;nxttail[RCU_NEXT_TAIL] = &amp;head-&gt;next;  
</span><span class='line'>
</span><span class='line'>if (__is_kfree_rcu_offset((unsigned long)func))  
</span><span class='line'>    trace_rcu_kfree_callback(rsp-&gt;name, head, (unsigned long)func,  
</span><span class='line'>                                 rdp-&gt;qlen_lazy, rdp-&gt;qlen);  
</span><span class='line'>else  
</span><span class='line'>    trace_rcu_callback(rsp-&gt;name, head, rdp-&gt;qlen_lazy, rdp-&gt;qlen);  
</span><span class='line'>
</span><span class='line'>/* 去处理rcu_core。 */  
</span><span class='line'>__call_rcu_core(rsp, rdp, head, flags);  
</span><span class='line'>local_irq_restore(flags);  
</span><span class='line'>}  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>call_rcu中最主要的工作，就是将回调函数加入到CPU的nxtlist列表。这里用到了指针处理的小技巧，我们来看看。首先看看nxttail的初始化：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static void init_callback_list(struct rcu_data *rdp)  
</span><span class='line'>{  
</span><span class='line'>int i;  
</span><span class='line'>
</span><span class='line'>rdp-&gt;nxtlist = NULL;  
</span><span class='line'>for (i = 0; i &lt; RCU_NEXT_SIZE; i++)  
</span><span class='line'>    rdp-&gt;nxttail[i] = &amp;rdp-&gt;nxtlist;  
</span><span class='line'>}  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>我们看到nxttail的全部成员都指向了nxtlist的地址。当nxtlist为空的时候，也是这个情形。
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;*rdp-&gt;nxttail[RCU_NEXT_TAIL] = head;       
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;当nxtlist为空的时候， *rdp-&gt;nxttail[RCU_NEXT_TAIL] 得到的其实就是nxtlist，将head的值赋予它。
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;rdp-&gt;nxttail[RCU_NEXT_TAIL] = &amp;head-&gt;next;
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;之后 RCU_NEXT_TAIL指向 head的next指针。这样当再有一个节点加入的时候，*rdp-&gt;nxttail[RCU_NEXT_TAIL]得到的其实就是前一次加入的head的next指针，它将指向新加入的值。如此，nxtlist就成为了一个链表。或者这样理解，rdp-&gt;nxttail[RCU_NEXT_TAIL] 指向的就是nxtlist中最后一个节点的 next指针。
</span><span class='line'>
</span><span class='line'>除了将回调函数插入，该函数其它代码多为检查代码。而最后要调用`__call_rcu_core`，该函数的功用主要是在回调函数太多或者等待时间过长的状态下，强制执行RCU状态更新。我们暂时不关注。
</span><span class='line'>
</span><span class='line'>开始一个宽限期
</span><span class='line'>
</span><span class='line'>在一个宽限期结束，或者当一个CPU检测到自身有需要一个宽限期的时候会开始一个新的宽限期，开始宽限期的代码如下：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static void  
</span><span class='line'>rcu_start_gp(struct rcu_state *rsp, unsigned long flags)  
</span><span class='line'>__releases(rcu_get_root(rsp)-&gt;lock)  
</span><span class='line'>{  
</span><span class='line'>struct rcu_data *rdp = this_cpu_ptr(rsp-&gt;rda);  
</span><span class='line'>struct rcu_node *rnp = rcu_get_root(rsp);  
</span><span class='line'>
</span><span class='line'>if (!rcu_scheduler_fully_active ||  
</span><span class='line'>        !cpu_needs_another_gp(rsp, rdp)) {  
</span><span class='line'>    /* 
</span><span class='line'>     * 如果scheduler 还没有启动non-idle任务 
</span><span class='line'>     * 或者不需要启动一个新的宽限期则退出。 
</span><span class='line'>     * 需要再次判断cpu_needs_another_gp， 
</span><span class='line'>     * 是因为可能有多个CPU执行这个过程。 
</span><span class='line'>     */  
</span><span class='line'>    raw_spin_unlock_irqrestore(&amp;rnp-&gt;lock, flags);  
</span><span class='line'>    return;  
</span><span class='line'>}  
</span><span class='line'>
</span><span class='line'>if (rsp-&gt;fqs_active) {  
</span><span class='line'>    /* 
</span><span class='line'>     * 这个CPU需要一个宽限期，而force_quiescent_state() 
</span><span class='line'>     * 正在运行，告诉它开始一个。 
</span><span class='line'>     */  
</span><span class='line'>    rsp-&gt;fqs_need_gp = 1;  
</span><span class='line'>    raw_spin_unlock_irqrestore(&amp;rnp-&gt;lock, flags);  
</span><span class='line'>    return;  
</span><span class='line'>}  
</span><span class='line'>
</span><span class='line'>/* 开始一个新的宽限期并且初始化。 */  
</span><span class='line'>rsp-&gt;gpnum++;  
</span><span class='line'>trace_rcu_grace_period(rsp-&gt;name, rsp-&gt;gpnum, "start");  
</span><span class='line'>WARN_ON_ONCE(rsp-&gt;fqs_state == RCU_GP_INIT);  
</span><span class='line'>rsp-&gt;fqs_state = RCU_GP_INIT; /* 阻止 force_quiescent_state。 */  
</span><span class='line'>rsp-&gt;jiffies_force_qs = jiffies + RCU_JIFFIES_TILL_FORCE_QS;  
</span><span class='line'>record_gp_stall_check_time(rsp);  
</span><span class='line'>raw_spin_unlock(&amp;rnp-&gt;lock);  /* leave irqs disabled. */  
</span><span class='line'>
</span><span class='line'>/* 排除CPU的热插拔。*/  
</span><span class='line'>raw_spin_lock(&amp;rsp-&gt;onofflock);  /* irqs already disabled. */  
</span><span class='line'>
</span><span class='line'>/* 
</span><span class='line'> * 从父节点开始以广度优先的方式，遍历所有的节点，设置qsmask的值， 
</span><span class='line'> * 所有在线CPU所在bit都将被设置成1。 
</span><span class='line'> * 通过遍历rsp-&gt;node[]数组就可以达到这个目的。 
</span><span class='line'> * 其它CPU在自己所属的节点还没有被设置前，只有可能访问这个节点， 
</span><span class='line'> * 因为它所作的判断是宽限期还没有开始。 
</span><span class='line'> * 此外，我们排除了CPU热插拔。 
</span><span class='line'> *  
</span><span class='line'> * 直到初始化过程完成之前，这个宽限期不可能完成，因为至少当前的 
</span><span class='line'> * CPU所属的bit将不会被设置。这个是因为我们启动了禁止中断，所以 
</span><span class='line'> * 这个CPU不会调用到宽限期检测代码。 
</span><span class='line'> */  
</span><span class='line'>rcu_for_each_node_breadth_first(rsp, rnp) {  
</span><span class='line'>    raw_spin_lock(&amp;rnp-&gt;lock);      /* irqs already disabled. */  
</span><span class='line'>    rcu_preempt_check_blocked_tasks(rnp);  
</span><span class='line'>    rnp-&gt;qsmask = rnp-&gt;qsmaskinit;  
</span><span class='line'>    rnp-&gt;gpnum = rsp-&gt;gpnum;  
</span><span class='line'>    rnp-&gt;completed = rsp-&gt;completed;  
</span><span class='line'>    if (rnp == rdp-&gt;mynode)  
</span><span class='line'>        rcu_start_gp_per_cpu(rsp, rnp, rdp);  
</span><span class='line'>    rcu_preempt_boost_start_gp(rnp);  
</span><span class='line'>    trace_rcu_grace_period_init(rsp-&gt;name, rnp-&gt;gpnum,  
</span><span class='line'>                        rnp-&gt;level, rnp-&gt;grplo,  
</span><span class='line'>                        rnp-&gt;grphi, rnp-&gt;qsmask);  
</span><span class='line'>    raw_spin_unlock(&amp;rnp-&gt;lock);    /* irqs remain disabled. */  
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>rnp = rcu_get_root(rsp);  
</span><span class='line'>raw_spin_lock(&amp;rnp-&gt;lock);              /* irqs already disabled. */  
</span><span class='line'>rsp-&gt;fqs_state = RCU_SIGNAL_INIT; /* force_quiescent_state now OK. */  
</span><span class='line'>raw_spin_unlock(&amp;rnp-&gt;lock);            /* irqs remain disabled. */  
</span><span class='line'>raw_spin_unlock_irqrestore(&amp;rsp-&gt;onofflock, flags);  
</span><span class='line'>}  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>标记一个新的宽限期开始，rcu_state要做的就是将gp_num加1。然后再设置所有node，qsmask被设置成qsmasinit，qsmask每个bit代表一个CPU，所有在线的CPU都将被设置成1；gpnum将被设置成新值。嗯，一个新宽限期的开始只需要设置这些标记位。
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>#### CPU的宽限期检测
</span><span class='line'>
</span><span class='line'>当一个宽限期开始后，每个CPU都需要检测自己的状态，如果已经通过静止状态，那么就向上一级node进行报告。
</span><span class='line'>
</span><span class='line'>这个处理过程，可以分为两个步骤：  
</span><span class='line'>  1， 检测新的处理过程开始，设置rcu_data中的gpnum和passed_quiesce，另外用qs_pending标记一个待处理的新宽限期的开始。  
</span><span class='line'>  2， 一个静止状态结束，向上一级node报告这个过程。  
</span><span class='line'>
</span><span class='line'>这两个过程通过rcu_check_quiescent_state()来实现，需要注意的是这个函数隔一段时间调用一次，并不只调用一次。
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;/* 
</span><span class='line'>* 检测这个CPU是否还不知道一个新宽限期开始，如果是设置它的变量。 
</span><span class='line'>* 否则检查它是不是第一次通过静止状态，如果是，向上报告。 
</span><span class='line'>*/  
</span><span class='line'>static void  
</span><span class='line'>rcu_check_quiescent_state(struct rcu_state *rsp, struct rcu_data *rdp)  
</span><span class='line'>{  
</span><span class='line'>/* 如果有新的宽限期开始，记录它并返回。*/  
</span><span class='line'>if (check_for_new_grace_period(rsp, rdp))  
</span><span class='line'>    return;  
</span><span class='line'>
</span><span class='line'>/* 
</span><span class='line'> * 这个CPU是否已经处理过它的宽限期?如果是返回。 
</span><span class='line'> */  
</span><span class='line'>if (!rdp-&gt;qs_pending)  
</span><span class='line'>    return;  
</span><span class='line'>
</span><span class='line'>/* 
</span><span class='line'> * 是否通过了静止状态？如果没有，返回。 
</span><span class='line'> */  
</span><span class='line'>if (!rdp-&gt;passed_quiesce)  
</span><span class='line'>    return;  
</span><span class='line'>
</span><span class='line'>/* 
</span><span class='line'> * 向所属的node报告。(但rcu_report_qs_rdp() 仍然会去判断它)。 
</span><span class='line'> */  
</span><span class='line'>rcu_report_qs_rdp(rdp-&gt;cpu, rsp, rdp, rdp-&gt;passed_quiesce_gpnum);  
</span><span class='line'>}  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code class=""&gt;
</span><span class='line'>###### A， CPU检测新宽限期的开始
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;/*  
</span><span class='line'> * 为当前CPU，更新rcu_data的状态，去标记一个新宽限期的开始 
</span><span class='line'> * 如果当前CPU启动了一个宽限期或者检测到一个新的宽限期开始， 
</span><span class='line'> * 都需要调用这个函数。这个过程必须锁定父节点的lock，另外需 
</span><span class='line'> * 要禁止中断 
</span><span class='line'> */  
</span><span class='line'>static void __note_new_gpnum(struct rcu_state *rsp, struct rcu_node *rnp, struct rcu_data *rdp)  
</span><span class='line'>{  
</span><span class='line'>if (rdp-&gt;gpnum != rnp-&gt;gpnum) {  
</span><span class='line'>    /* 
</span><span class='line'>     * 如果当前的宽限期需要处理这个CPU的状态，设置并 
</span><span class='line'>     * 去检测它的静止状态。否则不要去管它。 
</span><span class='line'>     */          
</span><span class='line'>    rdp-&gt;gpnum = rnp-&gt;gpnum;  
</span><span class='line'>    trace_rcu_grace_period(rsp-&gt;name, rdp-&gt;gpnum, "cpustart");  
</span><span class='line'>    if (rnp-&gt;qsmask &amp; rdp-&gt;grpmask) {  
</span><span class='line'>        rdp-&gt;qs_pending = 1;  
</span><span class='line'>        rdp-&gt;passed_quiesce = 0;  
</span><span class='line'>    } else {  
</span><span class='line'>        rdp-&gt;qs_pending = 0;  
</span><span class='line'>    }  
</span><span class='line'>    zero_cpu_stall_ticks(rdp);  
</span><span class='line'>}  
</span><span class='line'>}  
</span><span class='line'>
</span><span class='line'>static void note_new_gpnum(struct rcu_state *rsp, struct rcu_data *rdp)  
</span><span class='line'>{  
</span><span class='line'>unsigned long flags;  
</span><span class='line'>struct rcu_node *rnp;  
</span><span class='line'>
</span><span class='line'>local_irq_save(flags);  
</span><span class='line'>rnp = rdp-&gt;mynode;  
</span><span class='line'>if (rdp-&gt;gpnum == ACCESS_ONCE(rnp-&gt;gpnum) || /* outside lock. */  
</span><span class='line'>        !raw_spin_trylock(&amp;rnp-&gt;lock)) { /* irqs already off, so later. */  
</span><span class='line'>    local_irq_restore(flags);  
</span><span class='line'>    return;  
</span><span class='line'>}  
</span><span class='line'>__note_new_gpnum(rsp, rnp, rdp);  
</span><span class='line'>raw_spin_unlock_irqrestore(&amp;rnp-&gt;lock, flags);  
</span><span class='line'>}  
</span><span class='line'>
</span><span class='line'>/* 
</span><span class='line'> * 在我们的上次检测之后，其它CPU启动了一个新的宽限期？ 
</span><span class='line'> * 如果是更新相应的rcu_data的状态。 
</span><span class='line'> * 必须是在rdp对应的CPU上执行。 
</span><span class='line'> */  
</span><span class='line'>static int  
</span><span class='line'>check_for_new_grace_period(struct rcu_state *rsp, struct rcu_data *rdp)  
</span><span class='line'>{  
</span><span class='line'>unsigned long flags;  
</span><span class='line'>int ret = 0;  
</span><span class='line'>
</span><span class='line'>local_irq_save(flags);  
</span><span class='line'>if (rdp-&gt;gpnum != rsp-&gt;gpnum) {  
</span><span class='line'>    note_new_gpnum(rsp, rdp);  
</span><span class='line'>    ret = 1;  
</span><span class='line'>}  
</span><span class='line'>local_irq_restore(flags);  
</span><span class='line'>return ret;  
</span><span class='line'>}  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>check_for_new_grace_period 和 note_new_gpnum分别用来检测rdp的gpnum与rsp已经对应的rnp的值是否相同，来确定是否有一个新的宽限期开始。之所以需要检测两次，是因为在rsp设置以后，rnp可能并没有设置完成。
</span><span class='line'>
</span><span class='line'>`__note_new_gpnum` 将设置gpnum的值。另外设置 qs_pending为1，该标记位代表该节点还没有向父节点报告自己的状态；passed_quiesce为0，表示需要一个静止状态，设置该位是因为下次调用rcu_check_quiescent_state()可能是在一个读过程还没有结束的时候。
</span><span class='line'>
</span><span class='line'>qs_pending的状态有可能为0，这只在以下情形下出现：当前CPU在宽限期开始的时候实在离线状态，而现在变成了在线。
</span><span class='line'>
</span><span class='line'>我们注意到在 check_for_new_grace_period检测到有新的宽限期开始后，rcu_check_quiescent_state将直接返回，因为这个宽限期可能是在该CPU的上一个静止状态之前已经开始，所以需要等待下一个静止状态。
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>###### B，CPU报告静止状态
</span><span class='line'>
</span><span class='line'>当再一次调用到rcu_check_quiescent_state()的时候，check_for_new_grace_period()将返回FALSE，接着运行后面的函数来判断 qs_pending 和 passed_quiesce 的值来决定是否调用rcu_report_qs_rdp。需要判断qs_peding是因为当这次rcu_report_qs_rdp调用成功的时候，下次再运行rcu_check_quiescent_state()则不需要继续运行后续函数。
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static void  
</span><span class='line'>rcu_report_qs_rdp(int cpu, struct rcu_state *rsp, struct rcu_data *rdp, long lastgp)  
</span><span class='line'>{  
</span><span class='line'>unsigned long flags;  
</span><span class='line'>unsigned long mask;  
</span><span class='line'>struct rcu_node *rnp;  
</span><span class='line'>
</span><span class='line'>rnp = rdp-&gt;mynode;  
</span><span class='line'>raw_spin_lock_irqsave(&amp;rnp-&gt;lock, flags);  
</span><span class='line'>if (lastgp != rnp-&gt;gpnum || rnp-&gt;completed == rnp-&gt;gpnum) {  
</span><span class='line'>    /* 
</span><span class='line'>     * 如果宽限期的处理已经完成，那么返回。 
</span><span class='line'>     */          
</span><span class='line'>    rdp-&gt;passed_quiesce = 0; /* need qs for new gp. */  
</span><span class='line'>    raw_spin_unlock_irqrestore(&amp;rnp-&gt;lock, flags);  
</span><span class='line'>    return;  
</span><span class='line'>}  
</span><span class='line'>mask = rdp-&gt;grpmask;  
</span><span class='line'>if ((rnp-&gt;qsmask &amp; mask) == 0) {  
</span><span class='line'>    raw_spin_unlock_irqrestore(&amp;rnp-&gt;lock, flags);  
</span><span class='line'>} else {  
</span><span class='line'>    rdp-&gt;qs_pending = 0;  
</span><span class='line'>    /* 
</span><span class='line'>     *  可以确定这个宽限期还没有结束，所以可以确定当前CPU上的 
</span><span class='line'>     *  所有回调函数可以在下次宽限期结束后处理。 
</span><span class='line'>     */  
</span><span class='line'>    rdp-&gt;nxttail[RCU_NEXT_READY_TAIL] = rdp-&gt;nxttail[RCU_NEXT_TAIL];  
</span><span class='line'>
</span><span class='line'>    rcu_report_qs_rnp(mask, rsp, rnp, flags); /* rlses rnp-&gt;lock */  
</span><span class='line'>}  
</span><span class='line'>}  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;从我看来，这个函数只会调用到最后一个else分支，而之前的连个if分支都不会调用到。因为在调用该函数前，代码已经做了必要的检测。
</span><span class='line'>
</span><span class='line'>以此来看，这个函数的功用就是设置qs_pending的值，阻止这次宽限期没有完成之前再次调用掉该函数；设置nxttail，决定下次宽限期后可以执行的回调函数；然后向父节点报告静止状态完成。
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>###### C，向上报告
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static void  
</span><span class='line'>rcu_report_qs_rnp(unsigned long mask, struct rcu_state *rsp,  
</span><span class='line'>  struct rcu_node *rnp, unsigned long flags)  
</span><span class='line'>__releases(rnp-&gt;lock)  
</span><span class='line'>{  
</span><span class='line'>struct rcu_node *rnp_c;  
</span><span class='line'>
</span><span class='line'>/* 向上遍历所有层级 */  
</span><span class='line'>for (;;) {  
</span><span class='line'>    if (!(rnp-&gt;qsmask &amp; mask)) {  
</span><span class='line'>        /* 这个CPU的标记已经被清除，证明已经处理过了，返回 */  
</span><span class='line'>        raw_spin_unlock_irqrestore(&amp;rnp-&gt;lock, flags);  
</span><span class='line'>        return;  
</span><span class='line'>    }  
</span><span class='line'>    rnp-&gt;qsmask &amp;= ~mask;  
</span><span class='line'>    trace_rcu_quiescent_state_report(rsp-&gt;name, rnp-&gt;gpnum,  
</span><span class='line'>                 mask, rnp-&gt;qsmask, rnp-&gt;level,  
</span><span class='line'>                 rnp-&gt;grplo, rnp-&gt;grphi,  
</span><span class='line'>                 !!rnp-&gt;gp_tasks);  
</span><span class='line'>    if (rnp-&gt;qsmask != 0 || rcu_preempt_blocked_readers_cgp(rnp)) {  
</span><span class='line'>        /* 这个节点中还有其它CPU没有处理完成，那么返回 */  
</span><span class='line'>        raw_spin_unlock_irqrestore(&amp;rnp-&gt;lock, flags);  
</span><span class='line'>        return;  
</span><span class='line'>    }  
</span><span class='line'>    mask = rnp-&gt;grpmask;  
</span><span class='line'>    if (rnp-&gt;parent == NULL) {  
</span><span class='line'>        /* 到这儿，已经到了根节点 */  
</span><span class='line'>        break;  
</span><span class='line'>    }  
</span><span class='line'>    raw_spin_unlock_irqrestore(&amp;rnp-&gt;lock, flags);  
</span><span class='line'>    rnp_c = rnp;  
</span><span class='line'>    rnp = rnp-&gt;parent;  
</span><span class='line'>    raw_spin_lock_irqsave(&amp;rnp-&gt;lock, flags);  
</span><span class='line'>    WARN_ON_ONCE(rnp_c-&gt;qsmask);  
</span><span class='line'>}  
</span><span class='line'>/* 
</span><span class='line'> *  程序运行到这儿，说明所有的CPU都通过了宽限期， 
</span><span class='line'> *  那么调用rcu_report_qs_rsp()来结束这个宽限期。 
</span><span class='line'> */   
</span><span class='line'>rcu_report_qs_rsp(rsp, flags); /* releases rnp-&gt;lock. */  
</span><span class='line'>}  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>这个过程并不复杂，清理rnp中qsmask对应该CPU的bit。然后判断该节点是否处理完成，如果是则继续向上调用，否则就退出函数。最后一个CPU调用后，可以调用到rcu_report_qs_rsp()。
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static void rcu_report_qs_rsp(struct rcu_state *rsp, unsigned long flags)  
</span><span class='line'>__releases(rcu_get_root(rsp)-&gt;lock)  
</span><span class='line'>{  
</span><span class='line'>unsigned long gp_duration;  
</span><span class='line'>struct rcu_node *rnp = rcu_get_root(rsp);  
</span><span class='line'>struct rcu_data *rdp = this_cpu_ptr(rsp-&gt;rda);  
</span><span class='line'>
</span><span class='line'>WARN_ON_ONCE(!rcu_gp_in_progress(rsp));  
</span><span class='line'>
</span><span class='line'>/* 
</span><span class='line'> * Ensure that all grace-period and pre-grace-period activity 
</span><span class='line'> * is seen before the assignment to rsp-&gt;completed. 
</span><span class='line'> */  
</span><span class='line'>smp_mb(); /* See above block comment. */  
</span><span class='line'>gp_duration = jiffies - rsp-&gt;gp_start;  
</span><span class='line'>if (gp_duration &gt; rsp-&gt;gp_max)  
</span><span class='line'>    rsp-&gt;gp_max = gp_duration;  
</span><span class='line'>
</span><span class='line'>/* 
</span><span class='line'> * 当前CPU知道宽限期已经结束，不过其它CPU都认为它还在运行。 
</span><span class='line'> * 由于completed还没有设置，其它CPU都不会对父node进行处理。 
</span><span class='line'> * 所以这时候将各个node标记为完成是安全的。 
</span><span class='line'> *  
</span><span class='line'> * 不过当前CPU有等待下一次宽限期的回调函数的时候，我们会 
</span><span class='line'> * 先去处理下一个宽限期。 
</span><span class='line'> * 这儿使用RCU_WAIT_TAIL代替了RCU_DONE_TAIL，这是因为当前 
</span><span class='line'> * CPU还没有进一步处理完成状态，当前RCU_WAIT_TAIL状态的元 
</span><span class='line'> * 素其实在这次宽限期结束后，已经可以执行了。 
</span><span class='line'> *  
</span><span class='line'> */  
</span><span class='line'>if (*rdp-&gt;nxttail[RCU_WAIT_TAIL] == NULL) {  
</span><span class='line'>    raw_spin_unlock(&amp;rnp-&gt;lock);  /* irqs remain disabled. */  
</span><span class='line'>
</span><span class='line'>    /* 
</span><span class='line'>     * 设置 rnp-&gt;completed的值，避免这个过程要等到下一次宽限期开始。          
</span><span class='line'>     */  
</span><span class='line'>    rcu_for_each_node_breadth_first(rsp, rnp) {  
</span><span class='line'>        raw_spin_lock(&amp;rnp-&gt;lock); /* irqs already disabled. */  
</span><span class='line'>        rnp-&gt;completed = rsp-&gt;gpnum;  
</span><span class='line'>        raw_spin_unlock(&amp;rnp-&gt;lock); /* irqs remain disabled. */  
</span><span class='line'>    }  
</span><span class='line'>    rnp = rcu_get_root(rsp);  
</span><span class='line'>    raw_spin_lock(&amp;rnp-&gt;lock); /* irqs already disabled. */  
</span><span class='line'>}  
</span><span class='line'>
</span><span class='line'>rsp-&gt;completed = rsp-&gt;gpnum;  /* Declare the grace period complete. */  
</span><span class='line'>trace_rcu_grace_period(rsp-&gt;name, rsp-&gt;completed, "end");  
</span><span class='line'>rsp-&gt;fqs_state = RCU_GP_IDLE;  
</span><span class='line'>rcu_start_gp(rsp, flags);  /* releases root node's rnp-&gt;lock. */  
</span><span class='line'>}  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>这个过程最主要的内容就是设置rsp-&gt;completed的值，中间多了对node的处理。因为在rcu_start_gp中也会对node进行处理，当前CPU无法判断其它CPU是否需要一个宽限期，但它自身还有等待宽限期的回调函数的时候，它确定会有一个新的宽限期马上开始，所以忽略这个过程。     
</span><span class='line'>
</span><span class='line'>##### CPU的宽限期结束处理
</span><span class='line'>
</span><span class='line'>这个过程也可以分为两个步骤，第一步是检查宽限期是否结束，第二步是调用已完成的回调函数。
</span><span class='line'>
</span><span class='line'>###### A, CPU检测宽限期的结束
</span><span class='line'>
</span><span class='line'>每个CPU都会定期检查当前的宽限期是否结束，如果结束将处理自身状态已经nxtlist表。rcu_process_gp_end就是用来做这个事情:
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static void  
</span><span class='line'>rcu_process_gp_end(struct rcu_state *rsp, struct rcu_data *rdp)  
</span><span class='line'>{  
</span><span class='line'>unsigned long flags;  
</span><span class='line'>struct rcu_node *rnp;  
</span><span class='line'>
</span><span class='line'>local_irq_save(flags);  
</span><span class='line'>rnp = rdp-&gt;mynode;  
</span><span class='line'>if (rdp-&gt;completed == ACCESS_ONCE(rnp-&gt;completed) || /* outside lock. */  
</span><span class='line'>        !raw_spin_trylock(&amp;rnp-&gt;lock)) { /* irqs already off, so later. */  
</span><span class='line'>    local_irq_restore(flags);  
</span><span class='line'>    return;  
</span><span class='line'>}  
</span><span class='line'>__rcu_process_gp_end(rsp, rnp, rdp);  
</span><span class='line'>raw_spin_unlock_irqrestore(&amp;rnp-&gt;lock, flags);  
</span><span class='line'>}  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>当 rdp-&gt;completed与rnp-&gt;completed的值不同的时候，会调用`__rcu_process_gp_end`来完成具体的工作。
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static void  
</span><span class='line'>__rcu_process_gp_end(struct rcu_state *rsp, struct rcu_node *rnp, struct rcu_data *rdp)  
</span><span class='line'>{  
</span><span class='line'>/* 之前的宽限期是否完成？ */  
</span><span class='line'>if (rdp-&gt;completed != rnp-&gt;completed) {  
</span><span class='line'>
</span><span class='line'>    /* 推进回调函数，即使是NULL指针也没关系。 */  
</span><span class='line'>    rdp-&gt;nxttail[RCU_DONE_TAIL] = rdp-&gt;nxttail[RCU_WAIT_TAIL];  
</span><span class='line'>    rdp-&gt;nxttail[RCU_WAIT_TAIL] = rdp-&gt;nxttail[RCU_NEXT_READY_TAIL];  
</span><span class='line'>    rdp-&gt;nxttail[RCU_NEXT_READY_TAIL] = rdp-&gt;nxttail[RCU_NEXT_TAIL];  
</span><span class='line'>
</span><span class='line'>    /* 更新completed。 */  
</span><span class='line'>    rdp-&gt;completed = rnp-&gt;completed;  
</span><span class='line'>    trace_rcu_grace_period(rsp-&gt;name, rdp-&gt;gpnum, "cpuend");  
</span><span class='line'>
</span><span class='line'>    /* 
</span><span class='line'>     * 如果当前的CPU在外部的静止的状态（如离线状态）， 
</span><span class='line'>     * 可能已经错过了其它CPU发起的宽限期。所以需要更 
</span><span class='line'>     * 新gpnum的值，同时要注意不要错过当前正在运行的 
</span><span class='line'>     * 宽限期，所以它的值被设置成与rnp-&gt;completed相同， 
</span><span class='line'>     * 此时rnp-&gt;gpnum 可以已经加1，那么后续的调用 
</span><span class='line'>     * rcu_check_quiescent_state()会去检测新的宽限期。 
</span><span class='line'>     */       
</span><span class='line'>    if (ULONG_CMP_LT(rdp-&gt;gpnum, rdp-&gt;completed))  
</span><span class='line'>        rdp-&gt;gpnum = rdp-&gt;completed;  
</span><span class='line'>
</span><span class='line'>    /* 
</span><span class='line'>     * 如果下次的宽限期不需要当前CPU报告静止状态, 
</span><span class='line'>     * 设置qs_pending为0。 
</span><span class='line'>     */  
</span><span class='line'>    if ((rnp-&gt;qsmask &amp; rdp-&gt;grpmask) == 0)  
</span><span class='line'>        rdp-&gt;qs_pending = 0;  
</span><span class='line'>}  
</span><span class='line'>}  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>这个过程的重点是设置nxttail的值，将根据它来进行下一步的处理。
</span><span class='line'>
</span><span class='line'>###### B,回调函数的调用
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static void rcu_do_batch(struct rcu_state *rsp, struct rcu_data *rdp)  
</span><span class='line'>{  
</span><span class='line'>unsigned long flags;  
</span><span class='line'>struct rcu_head *next, *list, **tail;  
</span><span class='line'>int bl, count, count_lazy, i;  
</span><span class='line'>
</span><span class='line'>/* 没有回调函数，那么返回。*/  
</span><span class='line'>if (!cpu_has_callbacks_ready_to_invoke(rdp)) {  
</span><span class='line'>    trace_rcu_batch_start(rsp-&gt;name, rdp-&gt;qlen_lazy, rdp-&gt;qlen, 0);  
</span><span class='line'>    trace_rcu_batch_end(rsp-&gt;name, 0, !!ACCESS_ONCE(rdp-&gt;nxtlist),  
</span><span class='line'>            need_resched(), is_idle_task(current),  
</span><span class='line'>            rcu_is_callbacks_kthread());  
</span><span class='line'>    return;  
</span><span class='line'>}  
</span><span class='line'>
</span><span class='line'>/* 
</span><span class='line'> * 提取回调函数的list，需要禁用中断，以防止调用call_rcu()。  
</span><span class='line'> */   
</span><span class='line'>local_irq_save(flags);  
</span><span class='line'>WARN_ON_ONCE(cpu_is_offline(smp_processor_id()));  
</span><span class='line'>bl = rdp-&gt;blimit;  
</span><span class='line'>trace_rcu_batch_start(rsp-&gt;name, rdp-&gt;qlen_lazy, rdp-&gt;qlen, bl);  
</span><span class='line'>list = rdp-&gt;nxtlist;  
</span><span class='line'>/*  
</span><span class='line'> * 已经将list指向了nxtlist，此时将nxtlist指向 *rdp-&gt;nxttail[RCU_DONE_TAIL]。 
</span><span class='line'> * 由于nxttail指向的是 rcu_head中的next指针的地址，所以此处得到的就是next所 
</span><span class='line'> * 指向的rcu_head对象。 
</span><span class='line'> */  
</span><span class='line'>rdp-&gt;nxtlist = *rdp-&gt;nxttail[RCU_DONE_TAIL];  
</span><span class='line'>/*将*rdp-&gt;nxttail[RCU_DONE_TAIL]指向NULL，也就是将list中的最后一个元素的next设置成NULL*/  
</span><span class='line'>*rdp-&gt;nxttail[RCU_DONE_TAIL] = NULL;  
</span><span class='line'>/*tail指向list最后一个元素的next指针的地址*/  
</span><span class='line'>tail = rdp-&gt;nxttail[RCU_DONE_TAIL];  
</span><span class='line'>/*此时rdp-&gt;nxttail[RCU_DONE_TAIL]指向的内容已经移出，所以让它重新指向nxtlist的地址*/  
</span><span class='line'>for (i = RCU_NEXT_SIZE - 1; i &gt;= 0; i--)  
</span><span class='line'>if (rdp-&gt;nxttail[i] == rdp-&gt;nxttail[RCU_DONE_TAIL])  
</span><span class='line'>    rdp-&gt;nxttail[i] = &amp;rdp-&gt;nxtlist;  
</span><span class='line'>local_irq_restore(flags);  
</span><span class='line'>
</span><span class='line'>/* 调用回调函数 */  
</span><span class='line'>count = count_lazy = 0;  
</span><span class='line'>while (list) {  
</span><span class='line'>    next = list-&gt;next;  
</span><span class='line'>    prefetch(next);  
</span><span class='line'>    debug_rcu_head_unqueue(list);  
</span><span class='line'>    if (__rcu_reclaim(rsp-&gt;name, list))  
</span><span class='line'>        count_lazy++;  
</span><span class='line'>    list = next;  
</span><span class='line'>    /* 当已经全部运行完毕或者CPU有更重要的事情的时候，退出循环。 */  
</span><span class='line'>    if (++count &gt;= bl &amp;&amp;  
</span><span class='line'>            (need_resched() ||  
</span><span class='line'>            (!is_idle_task(current) &amp;&amp; !rcu_is_callbacks_kthread())))  
</span><span class='line'>        break;  
</span><span class='line'>}  
</span><span class='line'>
</span><span class='line'>local_irq_save(flags);  
</span><span class='line'>trace_rcu_batch_end(rsp-&gt;name, count, !!list, need_resched(),  
</span><span class='line'>        is_idle_task(current),  
</span><span class='line'>        rcu_is_callbacks_kthread());  
</span><span class='line'>
</span><span class='line'>/* 更新数量。并将没有执行完的回调函数重新放进列表。 */  
</span><span class='line'>if (list != NULL) {  
</span><span class='line'>*tail = rdp-&gt;nxtlist;  
</span><span class='line'>rdp-&gt;nxtlist = list;  
</span><span class='line'>for (i = 0; i &lt; RCU_NEXT_SIZE; i++)  
</span><span class='line'>    if (&amp;rdp-&gt;nxtlist == rdp-&gt;nxttail[i])  
</span><span class='line'>        rdp-&gt;nxttail[i] = tail;  
</span><span class='line'>    else  
</span><span class='line'>        break;  
</span><span class='line'>}  
</span><span class='line'>smp_mb(); /* 为了 rcu_barrier()统计运行过的回调函数 */  
</span><span class='line'>rdp-&gt;qlen_lazy -= count_lazy;  
</span><span class='line'>ACCESS_ONCE(rdp-&gt;qlen) -= count;  
</span><span class='line'>rdp-&gt;n_cbs_invoked += count;  
</span><span class='line'>
</span><span class='line'>/* Reinstate batch limit if we have worked down the excess. */  
</span><span class='line'>if (rdp-&gt;blimit == LONG_MAX &amp;&amp; rdp-&gt;qlen &lt;= qlowmark)  
</span><span class='line'>    rdp-&gt;blimit = blimit;  
</span><span class='line'>
</span><span class='line'>/* Reset -&gt;qlen_last_fqs_check trigger if enough CBs have drained. */  
</span><span class='line'>if (rdp-&gt;qlen == 0 &amp;&amp; rdp-&gt;qlen_last_fqs_check != 0) {  
</span><span class='line'>    rdp-&gt;qlen_last_fqs_check = 0;  
</span><span class='line'>    rdp-&gt;n_force_qs_snap = rsp-&gt;n_force_qs;  
</span><span class='line'>} else if (rdp-&gt;qlen &lt; rdp-&gt;qlen_last_fqs_check - qhimark)  
</span><span class='line'>    rdp-&gt;qlen_last_fqs_check = rdp-&gt;qlen;  
</span><span class='line'>WARN_ON_ONCE((rdp-&gt;nxtlist == NULL) != (rdp-&gt;qlen == 0));  
</span><span class='line'>
</span><span class='line'>local_irq_restore(flags);  
</span><span class='line'>
</span><span class='line'>/* 如果还有回调函数没有执行，通知再次调用软中断 */  
</span><span class='line'>if (cpu_has_callbacks_ready_to_invoke(rdp))  
</span><span class='line'>    invoke_rcu_core();  
</span><span class='line'>}  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>rcu_do_batch主要作用是取出nxtlist中，nxttail[RCU_DONE_TAIL]之前的元素，遍历执行它们。这时候销毁过程真正的执行了。这段函数需要仔细想想nxttail的处理。
</span><span class='line'>
</span><span class='line'>到此RCU中涉及到的主干函数介绍完了，但是还需要与进程切换等过程交互。将在下节分析它们。
</span><span class='line'>
</span><span class='line'>-------------
</span><span class='line'>
</span><span class='line'>### TREE RCU实现之三 —— 定期调用 
</span><span class='line'>
</span><span class='line'>上一节，介绍过了RCU实现中用到的主要函数。不过还需要定期的运行这些函数，整个机制才完整。
</span><span class='line'>
</span><span class='line'>RCU的实现是通过在update_process_times() 中调用rcu_check_callbacks()来达到这个目的的。每个CPU都会定期的调用update_process_times()。rcu_check_callbacks()会去检查当前的RCU机制中是否有需要处理的内容，如当前CPU需要开启一个新的宽限期，当前CPU上的宽限期还没有处理完成。如果有需要处理的内容，将触发一个软件中断，真正的操作由软件中断触发的rcu_process_callbacks()来完成。
</span><span class='line'>
</span><span class='line'>#### rcu_check_callbacks
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;void rcu_check_callbacks(int cpu, int user)  
</span><span class='line'>{  
</span><span class='line'>trace_rcu_utilization("Start scheduler-tick");  
</span><span class='line'>increment_cpu_stall_ticks();  
</span><span class='line'>if (user || rcu_is_cpu_rrupt_from_idle()) {  
</span><span class='line'>     /* 
</span><span class='line'>      * 如果是从用户模式或者是idle模式调用该函数， 
</span><span class='line'>      * 那么这个CPU是静止状态。 
</span><span class='line'>      *  
</span><span class='line'>      * 此处不需要内存屏障。因为rcu_sched_qs()和 
</span><span class='line'>      * and rcu_bh_qs()支处理CPU自身的局部变量， 
</span><span class='line'>      * 其它CPU不会访问和修改,至少当CPU在线的时候。 
</span><span class='line'>      *  
</span><span class='line'>      */                  
</span><span class='line'>      rcu_sched_qs(cpu);  
</span><span class='line'>      rcu_bh_qs(cpu);          
</span><span class='line'>} else if (!in_softirq()) {                  
</span><span class='line'>     /* 
</span><span class='line'>      * 运行到这儿，如果不是软件中断。如果当前CPU上运行的 
</span><span class='line'>      * 软中断的读过程，肯定已经完成，所以标记它。 
</span><span class='line'>      * 
</span><span class='line'>      */                 
</span><span class='line'>     rcu_bh_qs(cpu);  
</span><span class='line'>}  
</span><span class='line'>rcu_preempt_check_callbacks(cpu); /*抢先式下的检测*/  
</span><span class='line'>if (rcu_pending(cpu))  
</span><span class='line'>    invoke_rcu_core();  
</span><span class='line'>trace_rcu_utilization("End scheduler-tick");  
</span><span class='line'>}  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>该函数的主要功能是通过 rcu_pending()判断是否当前有需要处理的rcu内容，如果有调用invoke_rcu_core()。
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static int rcu_pending(int cpu)  
</span><span class='line'>{  
</span><span class='line'>struct rcu_state *rsp;  
</span><span class='line'>
</span><span class='line'>for_each_rcu_flavor(rsp)  
</span><span class='line'>if (__rcu_pending(rsp, per_cpu_ptr(rsp-&gt;rda, cpu)))  
</span><span class='line'>    return 1;  
</span><span class='line'>return 0;  
</span><span class='line'>}  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>rcu_pending会循环所有的rcu_state，在非抢占式模式下，有rcu_sched_state 和rcu_bh_state 两个实例。
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static int __rcu_pending(struct rcu_state *rsp, struct rcu_data *rdp)  
</span><span class='line'>{  
</span><span class='line'>struct rcu_node *rnp = rdp-&gt;mynode;  
</span><span class='line'>
</span><span class='line'>rdp-&gt;n_rcu_pending++;  
</span><span class='line'>
</span><span class='line'>/* Check for CPU stalls, if enabled. */  
</span><span class='line'>check_cpu_stall(rsp, rdp);  
</span><span class='line'>
</span><span class='line'>/*  是否宽限期在等待这个CPU去完成静止状态呢?  */  
</span><span class='line'>if (rcu_scheduler_fully_active &amp;&amp;  
</span><span class='line'>        rdp-&gt;qs_pending &amp;&amp; !rdp-&gt;passed_quiesce) {  
</span><span class='line'>
</span><span class='line'>    /* 
</span><span class='line'>     * 如果force_quiescent_state() 需要马上执行，而这个CPU 
</span><span class='line'>     * 需要一个静止状态，强制执行本地进程切换。       
</span><span class='line'>     */  
</span><span class='line'>    rdp-&gt;n_rp_qs_pending++;  
</span><span class='line'>    if (!rdp-&gt;preemptible &amp;&amp;  
</span><span class='line'>        ULONG_CMP_LT(ACCESS_ONCE(rsp-&gt;jiffies_force_qs) - 1,  
</span><span class='line'>         jiffies))  
</span><span class='line'>    set_need_resched();  
</span><span class='line'>} else if (rdp-&gt;qs_pending &amp;&amp; rdp-&gt;passed_quiesce) {  
</span><span class='line'>    rdp-&gt;n_rp_report_qs++;  
</span><span class='line'>    return 1;  
</span><span class='line'>}  
</span><span class='line'>
</span><span class='line'>/* 这个CPU是否有callbacks等着调用? */  
</span><span class='line'>if (cpu_has_callbacks_ready_to_invoke(rdp)) {  
</span><span class='line'>    rdp-&gt;n_rp_cb_ready++;  
</span><span class='line'>    return 1;  
</span><span class='line'>}  
</span><span class='line'>
</span><span class='line'>/* 当前CPU有需要执行的宽限期，而没有其它的宽限期在执行?  */  
</span><span class='line'>if (cpu_needs_another_gp(rsp, rdp)) {  
</span><span class='line'>    rdp-&gt;n_rp_cpu_needs_gp++;  
</span><span class='line'>    return 1;  
</span><span class='line'>}  
</span><span class='line'>
</span><span class='line'>/* 另一个CPU上执行的宽限期结束?   */  
</span><span class='line'>if (ACCESS_ONCE(rnp-&gt;completed) != rdp-&gt;completed) { /* outside lock */  
</span><span class='line'>        rdp-&gt;n_rp_gp_completed++;  
</span><span class='line'>    return 1;  
</span><span class='line'>}  
</span><span class='line'>
</span><span class='line'>/* 有新的RCU开始? */  
</span><span class='line'>if (ACCESS_ONCE(rnp-&gt;gpnum) != rdp-&gt;gpnum) { /* outside lock */  
</span><span class='line'>        rdp-&gt;n_rp_gp_started++;  
</span><span class='line'>    return 1;  
</span><span class='line'>}  
</span><span class='line'>
</span><span class='line'>/* 一个宽限期运行了太长时间，需要强制执行? */  
</span><span class='line'>if (rcu_gp_in_progress(rsp) &amp;&amp;  
</span><span class='line'>        ULONG_CMP_LT(ACCESS_ONCE(rsp-&gt;jiffies_force_qs), jiffies)) {  
</span><span class='line'>    rdp-&gt;n_rp_need_fqs++;  
</span><span class='line'>    return 1;  
</span><span class='line'>}  
</span><span class='line'>
</span><span class='line'>/* 无事可做 */  
</span><span class='line'>rdp-&gt;n_rp_need_nothing++;  
</span><span class='line'>return 0;  
</span><span class='line'>}  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>`__rcu_pending` 判断了可能存在的各种情形，如果有需要处理的工作的话，就返回1，否则返回0。
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static void invoke_rcu_core(void)  
</span><span class='line'>{  
</span><span class='line'>raise_softirq(RCU_SOFTIRQ);  
</span><span class='line'>}  
</span><span class='line'>
</span><span class='line'>
</span><span class='line'> invoke_rcu_core()的作用是开启软中断。在初始化的时候，系统已经注册了软中断。
</span><span class='line'>
</span><span class='line'>open_softirq(RCU_SOFTIRQ, rcu_process_callbacks);
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static void rcu_process_callbacks(struct softirq_action *unused)  
</span><span class='line'>{  
</span><span class='line'>struct rcu_state *rsp;  
</span><span class='line'>
</span><span class='line'>trace_rcu_utilization("Start RCU core");  
</span><span class='line'>for_each_rcu_flavor(rsp)  
</span><span class='line'>__rcu_process_callbacks(rsp);  
</span><span class='line'>trace_rcu_utilization("End RCU core");  
</span><span class='line'>}  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static void  
</span><span class='line'>__rcu_process_callbacks(struct rcu_state *rsp)  
</span><span class='line'>{  
</span><span class='line'>unsigned long flags;  
</span><span class='line'>struct rcu_data *rdp = __this_cpu_ptr(rsp-&gt;rda);  
</span><span class='line'>
</span><span class='line'>WARN_ON_ONCE(rdp-&gt;beenonline == 0);  
</span><span class='line'>
</span><span class='line'>/* 
</span><span class='line'> * 如果一个宽限期运行了很长时间，那么强制静止状态。 
</span><span class='line'> *  
</span><span class='line'> */  
</span><span class='line'>if (ULONG_CMP_LT(ACCESS_ONCE(rsp-&gt;jiffies_force_qs), jiffies))  
</span><span class='line'>    force_quiescent_state(rsp, 1);  
</span><span class='line'>
</span><span class='line'>/* 
</span><span class='line'> * 处理宽限期结束相关内容。 
</span><span class='line'> */  
</span><span class='line'>rcu_process_gp_end(rsp, rdp);  
</span><span class='line'>
</span><span class='line'>/* 检测是否有新的宽限期开始或者静止状态需要向上报告。 */  
</span><span class='line'>rcu_check_quiescent_state(rsp, rdp);  
</span><span class='line'>
</span><span class='line'>/* 当前CPU需要新的宽限期吗? */  
</span><span class='line'>if (cpu_needs_another_gp(rsp, rdp)) {  
</span><span class='line'>    raw_spin_lock_irqsave(&amp;rcu_get_root(rsp)-&gt;lock, flags);  
</span><span class='line'>    rcu_start_gp(rsp, flags);  /* releases above lock */  
</span><span class='line'>}  
</span><span class='line'>
</span><span class='line'>/* 如果有等着调用的回调函数，那么调用它。 */  
</span><span class='line'>if (cpu_has_callbacks_ready_to_invoke(rdp))  
</span><span class='line'>    invoke_rcu_callbacks(rsp, rdp);  
</span><span class='line'>}  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;软件中断其实就是调用之前提到过的函数来完成具体的任务。&lt;/p&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[Linux kernel 内存屏障在RCU上的应用]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2015/06/02/kernel-base-rcu-apply/"/&gt;
</span><span class='line'>&lt;updated&gt;2015-06-02T17:36:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2015/06/02/kernel-base-rcu-apply&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;p&gt;&lt;a href="http://blog.csdn.net/jianchaolv/article/details/7527647"&gt;http://blog.csdn.net/jianchaolv/article/details/7527647&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;内存屏障主要解决的问题是编译器的优化和CPU的乱序执行。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;编译器在优化的时候，生成的汇编指令可能和c语言程序的执行顺序不一样，在需要程序严格按照c语言顺序执行时，需要显式的告诉编译不需要优化，这在linux下是通过barrier()宏完成的，它依靠volidate关键字和memory关键字，前者告诉编译barrier()周围的指令不要被优化，后者作用是告诉编译器汇编代码会使内存里面的值更改，编译器应使用内存里的新值而非寄存器里保存的老值。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;同样，CPU执行会通过乱序以提高性能。汇编里的指令不一定是按照我们看到的顺序执行的。linux中通过mb()系列宏来保证执行的顺序。简单的说，如果在程序某处插入了mb()/rmb()/wmb()宏，则宏之前的程序保证比宏之后的程序先执行，从而实现串行化。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;即使是编译器生成的汇编码有序，处理器也不一定能保证有序。就算编译器生成了有序的汇编码，到了处理器那里也拿不准是不 是会按照代码顺序执行。所以就算编译器保证有序了，程序员也还是要往代码里面加内存屏障才能保证绝对访存有序，这倒不如编译器干脆不管算了，因为内存屏障 本身就是一个sequence point，加入后已经能够保证编译器也有序。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;处理器虽然乱序执行，但最终会得出正确的结果，所以逻辑上讲程序员本不需要关心处理器乱序的问题。但是在SMP并发执行的情况下，处理器无法知道并发程序之间的逻辑，比如，在不同core上的读者和写者之间的逻辑。简单讲，处理器只保证在单个core上按照code中的顺序给出最终结果。这就要求程序员通过mb()/rmb()/wmb()/read_barrier_depends来告知处理器，从而得到正确的并发结果。内存屏障、数据依赖屏障都是为了处理SMP环境下的数据同步问题，UP根本不存在这个问题。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;下面分析下内存屏障在RCU上的应用：</span></code></pre></td></tr></table></div></figure>
    #define rcu_assign_pointer(p, v) ({ \
        smp_wmb();                      \
        (p)= (v);                       \
    })</p>

<pre><code>#define rcu_dereference(p) ({     \
    typeof(p)_________p1 = p;     \
    smp_read_barrier_depends();   \
    (_________p1);                \
}) 
</code></pre>

<pre><code>
rcu_assign_pointer()通常用于写者的发布，rcu_dereference()通常用于读者的订阅。

写者：
</code></pre>

<pre><code>p-&gt;a = 1;
p-&gt;b = 2;
p-&gt;c = 3;
rcu_assign_pointer(gp, p);
</code></pre>

<pre><code>
读者：
</code></pre>

<pre><code>rcu_read_lock();
p = rcu_dereference(gp);
if (p != NULL) {
    do_something_with(p-&gt;a, p-&gt;b, p-&gt;c);
}
rcu_read_unlock();
</code></pre>

<pre><code>
rcu_assign_pointer()是说，先把那块内存写好，再把指针指过去。这里使用的内存写屏障是为了保证并发的读者读到数据一致性。在这条语句之前的读者读到旧的指针和旧的内存，这条语句之后的读者读到新的指针和新的内存。如果没有这条语句，很有可能出现读者读到新的指针和旧的内存。也就是说，这里通过内存屏障刷新了p所指向的内存的值，至于gp本身的值有没有更新还不确定。实际上，gp本身值的真正更新要等到并发的读者来促发。

rcu_dereference() 原语用的是数据依赖屏障，smp_read_barrier_dependence,它要求后面的读操作如果依赖前面的读操作，则前面的读操作需要首先完成。根据数据之间的依赖，要读p-&gt;a, p-&gt;b, p-&gt;c, 就必须先读p，要先读p，就必须先读p1，要先读p1，就必须先读gp。也就是说读者所在的core在进行后续的操作之前，gp必须是同步过的当前时刻的最新值。如果没有这个数据依赖屏障，有可能读者所在的core很长一段时间内一直用的是旧的gp值。所以，这里使用数据依赖屏障是为了督促写者将gp值准备好，是为了呼应写者，这个呼应的诉求是通过数据之间的依赖关系来促发的，也就是说到了非呼应不可的地步了。

下面看看kernel中常用的链表操作是如何使用这样的发布、订阅机制的：

写者：
</code></pre>

<pre><code>static inline void list_add_rcu(struct list_head *new, struct list_head *head)
{
    __list_add_rcu(new, head, head-&gt;next);
}

static inline void __list_add_rcu(struct list_head * new,
struct list_head * prev, struct list_head * next)
{
    new-&gt;next = next;
    new-&gt;prev = prev;
    smp_wmb();
    next-&gt;prev = new;
    prev-&gt;next = new;
}
</code></pre>

<pre><code>
读者：
</code></pre>

<pre><code>#define list_for_each_entry_rcu(pos, head, member)                \
    for(pos = list_entry((head)-&gt;next, typeof(*pos), member);     \
            prefetch(rcu_dereference(pos)-&gt;member.next),          \
            &amp;pos-&gt;member!= (head);                                \
        pos= list_entry(pos-&gt;member.next, typeof(*pos), member))
</code></pre>

<pre><code>
写者通过调用list_add_rcu来发布新的节点，其实是发布next-&gt;prev, prev-&gt;next这两个指针。读者通过list_for_each_entry_rcu来订阅这连个指针，我们将list_for_each_entry_rcu订阅部分简化如下：
</code></pre>

<pre><code>pos = prev-&gt;next;
prefetch(rcu_dereference(pos)-&gt;next);
</code></pre>

<pre><code>
读者通过rcu_dereference订阅的是pos，而由于数据依赖关系，又间接订阅了prev-&gt;next指针，或者说是促发prev-&gt;next的更新。

下面介绍下其他相关链表操作的函数：

safe版本的iterate的函数？为什么就safe了？
</code></pre>

<pre><code>#define list_for_each_safe(pos,n, head)                    \
    for(pos = (head)-&gt;next, n = pos-&gt;next; pos != (head);  \
            pos= n, n = pos-&gt;next)

#define list_for_each(pos, head)                                \
    for(pos = (head)-&gt;next; prefetch(pos-&gt;next), pos != (head); \
            pos= pos-&gt;next)
</code></pre>

<pre><code>
当在iterate的过程中执行删除操作的时候，比如：
</code></pre>

<pre><code>list_for_each(pos,head)
    list_del(pos)
</code></pre>

<pre><code>这样会断链，为了避免这种断链，增加了safe版本的iterate函数。另外，由于preftech的缘故，有可能引用一个无效的指针LIST_POISON1。这里的safe是指，为避免有些cpu的preftech的影响，干脆在iterate的过程中去掉preftech。

还有一个既有rcu+safe版本的iterative函数：
</code></pre>

<pre><code>#define list_for_each_safe_rcu(pos, n, head)              \
    for(pos = (head)-&gt;next;                               \
            n= rcu_dereference(pos)-&gt;next, pos != (head); \
            pos= n)
</code></pre>

<p>```</p>

<p>只要用这个版本的iterate函数，就可以和多个_rcu版本的写操作(如：list_add_rcu())并发执行。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[kmalloc、vmalloc、malloc的区别]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/06/02/kernel-mm-mm/"/>
    <updated>2015-06-02T16:48:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/06/02/kernel-mm-mm</id>
    <content type="html"><![CDATA[<p>blog.csdn.net/macrossdzh/article/details/5958368</p>

<p>简单的说：<br/>
  kmalloc和vmalloc是分配的是内核的内存,malloc分配的是用户的内存<br/>
  kmalloc保证分配的内存在物理上是连续的,vmalloc保证的是在虚拟地址空间上的连续,malloc不保证任何东西(这点是自己猜测的,不一定正确)<br/>
  kmalloc能分配的大小有限,vmalloc和malloc能分配的大小相对较大<br/>
  内存只有在要被DMA访问的时候才需要物理上连续<br/>
  vmalloc比kmalloc要慢</p>

<p>详细的解释：<br/>
  对于提供了MMU（存储管理器，辅助操作系统进行内存管理，提供虚实地址转换等硬件支持）的处理器而言，Linux提供了复杂的存储管理系统，使得进程所能访问的内存达到4GB。
  进程的4GB内存空间被人为的分为两个部分&ndash;用户空间与内核空间。用户空间地址分布从0到3GB(PAGE_OFFSET，在0x86中它等于0xC0000000)，3GB到4GB为内核空间。<br/>
  内核空间中，从3G到vmalloc_start这段地址是物理内存映射区域（该区域中包含了内核镜像、物理页框表mem_map等等），比如我们使用 的 VMware虚拟系统内存是160M，那么3G～3G+160M这片内存就应该映射物理内存。在物理内存映射区之后，就是vmalloc区域。对于 160M的系统而言，vmalloc_start位置应在3G+160M附近（在物理内存映射区与vmalloc_start期间还存在一个8M的gap 来防止跃界），vmalloc_end的位置接近4G(最后位置系统会保留一片128k大小的区域用于专用页面映射)</p>

<p>  kmalloc和get_free_page申请的内存位于物理内存映射区域，而且在物理上也是连续的，它们与真实的物理地址只有一个固定的偏移，因此存在较简单的转换关系，virt_to_phys()可以实现内核虚拟地址转化为物理地址：
<code>
    #define __pa(x) ((unsigned long)(x)-PAGE_OFFSET)
    extern inline unsigned long virt_to_phys(volatile void * address)
    {
        return __pa(address);
    }
</code></p>

<p>上面转换过程是将虚拟地址减去3G（PAGE_OFFSET=0XC000000）。</p>

<p>与之对应的函数为phys_to_virt()，将内核物理地址转化为虚拟地址：
<code>
    #define __va(x) ((void *)((unsigned long)(x)+PAGE_OFFSET))
    extern inline void * phys_to_virt(unsigned long address)
    {
        return __va(address);
    }
</code>
virt_to_phys()和phys_to_virt()都定义在include/asm-i386/io.h中。</p>

<p>而vmalloc申请的内存则位于vmalloc_start～vmalloc_end之间，与物理地址没有简单的转换关系，虽然在逻辑上它们也是连续的，但是在物理上它们不要求连续。</p>

<hr />

<p>blog.csdn.net/kris_fei/article/details/17243527</p>

<p>平台： msm8x25<br/>
系统： android 4.1<br/>
内核： 3.4.0</p>

<h4>概念</h4>

<p>由于系统的连续物理内存有限，这使得非连续物理内存的使用在linux内核中出现，这叫vmalloc机制。和前者一样，vmalloc机制中的虚拟地址也是连续的。</p>

<h5>Vmallocinfo</h5>

<p>Vmalloc机制并不是狭义地指使用vmalloc函数分配，其他还有如ioremap, iotable_init等。可以从/proc/vmallocinfo获取到此信息：</p>

<pre><code>    #cat /proc/vmallocinfo
    0xf3600000-0xf36ff0001044480 binder_mmap+0xb0/0x224 ioremap
    ………..
    0xf6680000-0xf66c1000 266240 kgsl_page_alloc_map_kernel+0x98/0xe8 ioremap
    0xf6700000-0xf67ff0001044480 binder_mmap+0xb0/0x224 ioremap
    …………….
    0xf6f00000-0xf6f41000 266240 kgsl_page_alloc_map_kernel+0x98/0xe8 ioremap
    0xf7200000-0xf72ff0001044480 binder_mmap+0xb0/0x224 ioremap
    0xfa000000-0xfa001000   4096 iotable_init+0x0/0xb0 phys=c0800000 ioremap
    ……………..
    0xfa105000-0xfa106000   4096 iotable_init+0x0/0xb0 phys=a9800000 ioremap
    0xfa200000-0xfa3000001048576 pmd_empty_section_gap+0x0/0x3c ioremap
    0xfa300000-0xfa4000001048576 iotable_init+0x0/0xb0 phys=100000 ioremap
    0xfa400000-0xfa5000001048576 iotable_init+0x0/0xb0 phys=aa500000 ioremap
    0xfa500000-0xfa6000001048576 pmd_empty_section_gap+0x0/0x3c ioremap
    0xfa701000-0xfa702000   4096 iotable_init+0x0/0xb0 phys=c0400000 ioremap
    …………..
    0xfa800000-0xfa9000001048576 pmd_empty_section_gap+0x0/0x3c ioremap
    0xfa900000-0xfb60000013631488 iotable_init+0x0/0xb0 phys=ac000000 ioremap
    0xfefdc000-0xff000000 147456 pcpu_get_vm_areas+0x0/0x56c vmalloc
</code></pre>

<p>上面的列数意思依次是：虚拟地址，分配大小，哪个函数分配的，物理地址，分配类型。</p>

<p>后面会提到vmalloc size的划分是按照此info来修改的。</p>

<h4>分配标志</h4>

<p>是否划分到vamlloc区域主要是以下重要的标志来决定的：</p>

<p>File: kernel/include/linux/vmalloc.h
<code>
    /* bits in flags ofvmalloc's vm_struct below */
    #defineVM_IOREMAP    0x00000001     /* ioremap()and friends */
    #define VM_ALLOC     0x00000002     /* vmalloc() */
    #defineVM_MAP        0x00000004     /* vmap()ed pages */
    #defineVM_USERMAP    0x00000008     /* suitable forremap_vmalloc_range */
    #defineVM_VPAGES     0x00000010     /* buffer for pages was vmalloc'ed */
    #defineVM_UNLIST     0x00000020     /* vm_struct is not listed in vmlist */
    /* bits [20..32]reserved for arch specific ioremap internals */
</code></p>

<p>Vmallocinfo中的函数，你可以对照源码看一下，在设置flag的时候就会有VM_IOREMAP, VM_ALLOC这些标志。</p>

<h5>Vmalloc区域</h5>

<p>Vmalloc的区域是由两个宏变量来表示： VMALLOC_START,VMALLOC_END.</p>

<p>File: kernel/arch/arm/include/asm/pgtable.h
<code>
    #defineVMALLOC_OFFSET       (8*1024*1024)
    #defineVMALLOC_START        (((unsigned long)high_memory + VMALLOC_OFFSET) &amp; ~(VMALLOC_OFFSET-1))
    #defineVMALLOC_END          0xff000000UL
</code></p>

<p>VMALLOC_START：看上去会随着high_memory的值变化。</p>

<p>VMALLOC_OFFSET：系统会在low memory和VMALLOC区域留8M，防止访问越界。因此假如理论上vmalloc size有300M，实际可用的也是只有292M。</p>

<p>File: kernel/Documentation/arm/memory.txt有给出更好的解释：
<code>
VMALLOC_START   VMALLOC_END-1    vmalloc() / ioremap() space. Memory returned byvmalloc/ioremap will be dynamically placed in this region. Machine specificstatic mappings are also located here through iotable_init(). VMALLOC_START isbased upon the value of the high_memoryvariable, and VMALLOC_END is equal to 0xff000000.
</code></p>

<p>下图摘自网络，看下VMALLOC_START和VMALLOC_END的位置。0xc0000000到VMALLOC_START为low memory虚拟地址区域。</p>

<h4>Vmallocsize 计算</h4>

<p>有了以上知识后我们看下vmalloc size是如何分配的，目前有两种方法，kernel默认分配一个, 以及开机从cmdline分配。</p>

<h5>1. 从cmdline分配</h5>

<p>File: device/qcom/msm7627a/BoardConfig.mk</p>

<p>BOARD_KERNEL_CMDLINE := androidboot.hardware=qcom loglevel=7vmalloc=200M</p>

<p>上面的值在build的时候会被赋值给kernel 的cmdline。</p>

<p>开机的时候early_vmalloc()会去读取vmalloc这个值。</p>

<p>File: kernel/arch/arm/mm/mmu.c
```
    static int__init early_vmalloc(char <em>arg)
    {
        /</em>cmdline中的vmalloc会被解析到vmlloc_reserve中。*/
        unsigned long vmalloc_reserve = memparse(arg, NULL);</p>

<pre><code>    /*小于16M则用16M。*/
    if (vmalloc_reserve &lt; SZ_16M) {
        vmalloc_reserve = SZ_16M;
        printk(KERN_WARNING
                "vmalloc area too small, limiting to %luMB\n",
                vmalloc_reserve &gt;&gt; 20);
    }

    /*大于可用虚拟地址内存则使用可用地址部分再减去32M。*/
    if (vmalloc_reserve &gt; VMALLOC_END - (PAGE_OFFSET + SZ_32M)) {
        vmalloc_reserve = VMALLOC_END - (PAGE_OFFSET + SZ_32M);
        printk(KERN_WARNING
                "vmalloc area is too big, limiting to %luMB\n",
                vmalloc_reserve &gt;&gt; 20);
    }

    /*计算偏移起始地址。*/
    vmalloc_min = (void *)(VMALLOC_END - vmalloc_reserve);
    return 0;
}
early_param("vmalloc",early_vmalloc);
</code></pre>

<pre><code>
vmalloc_min会影响arm_lowmem_limit,arm_lowmem_limit其实就是high_memory。因为此过程不是我们要分析的重点，如果有兴趣可分析kernel/arch/arm/mm/mmu.c中的sanity_check_meminfo()函数。

所以，VMALLOC_START受到了hight_memory的影响而发生了变化，最终使得vmalloc size也变化了！

##### 2. 开机默认分配：

File: kernel/arch/arm/mm/mmu.c
</code></pre>

<pre><code>static void * __initdata vmalloc_min =
    (void *)(VMALLOC_END - (240 &lt;&lt; 20) - VMALLOC_OFFSET);
</code></pre>

<pre><code>
当cmdline无vmalloc参数传进来的时候，early_vmalloc()函数也不会调用到，vmalloc_min的值就会被默认传进来了，默认是240M。

后面的步骤和方法1一样了！

开机log有memory layout 信息：
</code></pre>

<pre><code>[    0.000000] [cpuid: 0] Virtual kernelmemory layout:
[    0.000000] [cpuid:0]     vector  : 0xffff0000 - 0xffff1000  (   4 kB)
[    0.000000] [cpuid:0]     fixmap  : 0xfff00000 - 0xfffe0000   (896 kB)
[    0.000000] [cpuid:0]     vmalloc : 0xf3000000 - 0xff000000   ( 192MB)
[    0.000000] [cpuid:0]     lowmem  : 0xc0000000 - 0xf2800000   (808 MB)
[    0.000000] [cpuid:0]     pkmap   : 0xbfe00000 -0xc0000000   (   2 MB)
[    0.000000] [cpuid:0]     modules : 0xbf000000 - 0xbfe00000  (  14 MB)
[    0.000000] [cpuid:0]       .text : 0xc0008000 -0xc0893034   (8749 kB)
[    0.000000] [cpuid:0]       .init : 0xc0894000 -0xc08cdc00   ( 231 kB)
[    0.000000] [cpuid:0]       .data : 0xc08ce000 -0xc09f8eb8   (1196 kB)
[    0.000000] [cpuid:0]        .bss : 0xc0a78eec -0xc0f427a8   (4903 kB)
</code></pre>

<p>```</p>

<p>其中看到vmalloc为192MB , cmdline中使用vmllaoc就是200M。</p>

<p>Lowmem为地段内存部分，可见lowmem和vmalloc中间有8M空隙。</p>

<h5>Vmalloc该分配多大?</h5>

<p>Linux内核版本从3.2到3.3 默认的vmalloc size由128M 增大到了240M，3.4.0上的</p>

<p>修改Commit信息如下：</p>

<p>To accommodate all static mappings on machines withpossible highmem usage, the default vmalloc area size is changed to 240 MB sothat VMALLOC_START is no higher than 0xf0000000 by default.</p>

<p>看其意思是因为开机的静态映射增加了，所以要扩大。</p>

<p>另外3.2到3.3版本的一个重大变化是将android引入到主线内核中。我想增大vmalloc size到240M是基于此考虑吧。当然，各家厂商都也可以基于自己平台来动态修改size的。</p>

<p>那么如何判断当前vmalloc size不足呢？</p>

<p>/proc/meminfo中有vmalloc信息:<br/>
VmallocTotal:     540672 kB<br/>
VmallocUsed:      165268 kB<br/>
VmallocChunk:     118788kB</p>

<p>事实上这里的VmallocUsed只是表示已经被真正使用掉的vmalloc区域，但是区域之前的空隙也就是碎片没有被计算进去。</p>

<p>所以，回到前面说的/proc/vmallocinfo，假设我们的vmalloc size就是200M。那么区域为0xf3000000- 0xff000000，从vmallocinfo中可以看到，前面大部分虚拟地址空间都用掉了，剩下0xfb600000到0xfefdc000这57M空间，假如申请了64M，那么就会失败了。</p>

<p>开机分配使用掉vmalloc之后到底该剩余多少目前没有具体依据，一般来说1GB RAM可以设置为400~600M。</p>
]]></content>
  </entry>
  
</feed>
