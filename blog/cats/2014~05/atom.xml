<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 2014~05 | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/2014~05/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2014-12-10T00:00:03+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[TSC时间错误]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/05/29/debug-mark-tsc/"/>
    <updated>2014-05-29T14:03:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/05/29/debug-mark-tsc</id>
    <content type="html"><![CDATA[<p>arch/x86/kernel/tsc.c:<br/>
  开机初始化会调用tsc_init() -> set_cyc2ns_scale() 设置per_cpu变量cyc2ns、cyc2ns_offset。以供后面shced_clock()->native_sched_clock()->__cycles_2_ns()调用。</p>

<p>在cpufreq_tsc()中如果<br/>
   //cpu具有稳定的tsc <br/>
    if (boot_cpu_has(X86_FEATURE_CONSTANT_TSC)) <br/>
        return 0;<br/>
  所以一般不会注册time_cpufreq_notifier函数，也就不会再调用set_cyc2ns_scale。</p>

<ul>
<li>现象：top、ps出来的TIME和CPU的值非常异常。</li>
</ul>


<hr />

<p><a href="https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=733043">https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=733043</a></p>

<p>Xeon E5 has a bug, it doesn&rsquo;t reset TSC on warm reboot, just keep it instead.
 see &ldquo;BT81. X X X No Fix TSC is Not Affected by Warm Reset&rdquo; <a href="http://www.intel.com/content/dam/www/public/us/en/documents/specification-updates/xeon-e5-family-spec-update.pdf">http://www.intel.com/content/dam/www/public/us/en/documents/specification-updates/xeon-e5-family-spec-update.pdf</a></p>

<p> And also kernel 2.6.32 has a bug.<br/>
 Xeon bug + kernel bug = hung after warm reboot (or kexec) after 208.5 days<br/>
 since booting. So, administrators should shutdown it once at all, then<br/>
 boot it again because &ldquo;shutdown -r&rdquo; causes hang up.</p>

<p> Red Hat has released a fix for this as kernel 2.6.32-220, 2.6.32-279<br/>
 and 2.6.32-358 series (RHEL6.x) <a href="https://access.redhat.com/site/solutions/433883">https://access.redhat.com/site/solutions/433883</a> (for detail subscriber only :-(</p>

<p> Attached patch is based on upstream patch.<br/>
 see <a href="http://kernel.opensuse.org/cgit/kernel/patch/?id=9993bc635d01a6ee7f6b833b4ee65ce7c06350b1">http://kernel.opensuse.org/cgit/kernel/patch/?id=9993bc635d01a6ee7f6b833b4ee65ce7c06350b1</a></p>

<hr />

<p>  Red Hat Enterprise Linux 6.1 (kernel-2.6.32-131.26.1.el6 and newer)<br/>
  Red Hat Enterprise Linux 6.2 (kernel-2.6.32-220.4.2.el6 and newer)<br/>
  Red Hat Enterprise Linux 6.3 (kernel-2.6.32-279 series)<br/>
  Red Hat Enterprise Linux 6.4 (kernel-2.6.32-358 series)<br/>
  Any Intel® Xeon® E5, Intel® Xeon® E5 v2, or Intel® Xeon® E7 v2 series processor</p>

<hr />

<p>From 9993bc635d01a6ee7f6b833b4ee65ce7c06350b1 Mon Sep 17 00:00:00 2001<br/>
From: Salman Qazi <a href="&#109;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#115;&#x71;&#97;&#x7a;&#105;&#64;&#103;&#111;&#x6f;&#103;&#108;&#x65;&#46;&#x63;&#x6f;&#109;">&#115;&#113;&#x61;&#x7a;&#105;&#64;&#103;&#111;&#x6f;&#103;&#108;&#101;&#46;&#x63;&#x6f;&#109;</a><br/>
Date: Sat, 10 Mar 2012 00:41:01 +0000<br/>
Subject: sched/x86: Fix overflow in cyc2ns_offset</p>

<p>When a machine boots up, the TSC generally gets reset.  However,
when kexec is used to boot into a kernel, the TSC value would be
carried over from the previous kernel.  The computation of
cycns_offset in set_cyc2ns_scale is prone to an overflow, if the
machine has been up more than 208 days prior to the kexec.  The
overflow happens when we multiply *scale, even though there is
enough room to store the final answer.</p>

<p>We fix this issue by decomposing tsc_now into the quotient and
remainder of division by CYC2NS_SCALE_FACTOR and then performing
the multiplication separately on the two components.</p>

<p>Refactor code to share the calculation with the previous
fix in __cycles_2_ns().</p>

<p>Signed-off-by: Salman Qazi <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#115;&#x71;&#x61;&#x7a;&#x69;&#64;&#103;&#x6f;&#111;&#x67;&#x6c;&#x65;&#x2e;&#x63;&#x6f;&#x6d;">&#115;&#113;&#97;&#x7a;&#105;&#x40;&#103;&#111;&#x6f;&#x67;&#108;&#101;&#46;&#x63;&#111;&#109;</a><br/>
Acked-by: John Stultz <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#x6a;&#111;&#x68;&#x6e;&#x2e;&#115;&#116;&#x75;&#x6c;&#116;&#x7a;&#64;&#108;&#105;&#110;&#x61;&#x72;&#x6f;&#x2e;&#x6f;&#x72;&#103;">&#106;&#x6f;&#x68;&#x6e;&#46;&#115;&#x74;&#x75;&#108;&#116;&#122;&#x40;&#x6c;&#x69;&#x6e;&#97;&#114;&#111;&#46;&#x6f;&#114;&#x67;</a><br/>
Acked-by: Peter Zijlstra <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#97;&#x2e;&#112;&#x2e;&#x7a;&#105;&#x6a;&#x6c;&#x73;&#x74;&#x72;&#x61;&#x40;&#99;&#x68;&#101;&#x6c;&#x6c;&#x6f;&#46;&#x6e;&#108;">&#97;&#46;&#112;&#x2e;&#122;&#x69;&#106;&#x6c;&#x73;&#x74;&#x72;&#97;&#64;&#99;&#104;&#101;&#x6c;&#x6c;&#x6f;&#46;&#110;&#108;</a><br/>
Cc: Paul Turner <a href="&#109;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#112;&#106;&#116;&#64;&#103;&#x6f;&#x6f;&#x67;&#x6c;&#101;&#46;&#99;&#x6f;&#109;">&#x70;&#x6a;&#116;&#x40;&#103;&#x6f;&#111;&#103;&#108;&#101;&#46;&#x63;&#111;&#109;</a><br/>
Cc: john stultz <a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#106;&#111;&#x68;&#x6e;&#115;&#116;&#x75;&#108;&#x40;&#117;&#x73;&#x2e;&#105;&#98;&#x6d;&#46;&#99;&#111;&#109;">&#106;&#111;&#x68;&#x6e;&#115;&#x74;&#x75;&#108;&#x40;&#x75;&#x73;&#46;&#x69;&#98;&#x6d;&#46;&#99;&#x6f;&#x6d;</a><br/>
Link: <a href="http://lkml.kernel.org/r/20120310004027.19291.88460.stgit@dungbeetle.mtv.corp.google.com  ">http://lkml.kernel.org/r/20120310004027.19291.88460.stgit@dungbeetle.mtv.corp.google.com  </a>
Signed-off-by: Ingo Molnar <a href="&#109;&#x61;&#x69;&#108;&#116;&#111;&#58;&#x6d;&#105;&#x6e;&#x67;&#111;&#x40;&#101;&#x6c;&#116;&#101;&#x2e;&#x68;&#117;">&#109;&#105;&#110;&#103;&#x6f;&#64;&#101;&#x6c;&#116;&#x65;&#x2e;&#104;&#117;</a></p>

<hr />

<pre><code>diff --git a/arch/x86/include/asm/timer.h b/arch/x86/include/asm/timer.h
index 431793e..34baa0e 100644
--- a/arch/x86/include/asm/timer.h
+++ b/arch/x86/include/asm/timer.h
@@ -57,14 +57,10 @@ DECLARE_PER_CPU(unsigned long long, cyc2ns_offset);

 static inline unsigned long long __cycles_2_ns(unsigned long long cyc)
 {
-   unsigned long long quot;
-   unsigned long long rem;
    int cpu = smp_processor_id();
    unsigned long long ns = per_cpu(cyc2ns_offset, cpu);
-   quot = (cyc &gt;&gt; CYC2NS_SCALE_FACTOR);
-   rem = cyc &amp; ((1ULL &lt;&lt; CYC2NS_SCALE_FACTOR) - 1);
-   ns += quot * per_cpu(cyc2ns, cpu) +
-       ((rem * per_cpu(cyc2ns, cpu)) &gt;&gt; CYC2NS_SCALE_FACTOR);
+   ns += mult_frac(cyc, per_cpu(cyc2ns, cpu),
+           (1UL &lt;&lt; CYC2NS_SCALE_FACTOR));
    return ns;
 }

diff --git a/arch/x86/kernel/tsc.c b/arch/x86/kernel/tsc.c
index a62c201..183c592 100644
--- a/arch/x86/kernel/tsc.c
+++ b/arch/x86/kernel/tsc.c
@@ -620,7 +620,8 @@ static void set_cyc2ns_scale(unsigned long cpu_khz, int cpu)

    if (cpu_khz) {
        *scale = (NSEC_PER_MSEC &lt;&lt; CYC2NS_SCALE_FACTOR)/cpu_khz;
-       *offset = ns_now - (tsc_now * *scale &gt;&gt; CYC2NS_SCALE_FACTOR);
+       *offset = ns_now - mult_frac(tsc_now, *scale,
+                        (1UL &lt;&lt; CYC2NS_SCALE_FACTOR));
    }

    sched_clock_idle_wakeup_event(0);
diff --git a/include/linux/kernel.h b/include/linux/kernel.h
index e834342..d801acb 100644
--- a/include/linux/kernel.h
+++ b/include/linux/kernel.h
@@ -85,6 +85,19 @@
 }                          \
 )

+/*
+ * Multiplies an integer by a fraction, while avoiding unnecessary
+ * overflow or loss of precision.
+ */
+#define mult_frac(x, numer, denom)(            \
+{                          \
+   typeof(x) quot = (x) / (denom);         \
+   typeof(x) rem  = (x) % (denom);         \
+   (quot * (numer)) + ((rem * (numer)) / (denom)); \
+}                          \
+)
+
+
 #define _RET_IP_       (unsigned long)__builtin_return_address(0)
 #define _THIS_IP_  ({ __label__ __here; __here: (unsigned long)&amp;&amp;__here; }) 
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mark problem]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/05/29/mark-base/"/>
    <updated>2014-05-29T13:57:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/05/29/mark-base</id>
    <content type="html"><![CDATA[<h4>C语言中宽字符和多字节字符 MB_CUR_MAX</h4>

<p>stdlib.h<br/>
MB_CUR_MAX 当前locale中多字节字符的最大字节数目<br/>
如果把字符串当成多字节字符处理会慢很多<br/>
sort命令的一些版本中会根据locale中的LANG来设置比较函数，如果没设置好会导致sort跑的很慢。</p>

<h4>内核栈溢出</h4>

<p>因为内核栈中栈底保存thread_info，所以如果内核栈溢出会破坏thread_info，这样当进程发生睡眠、中断、抢占等调度时就会出错。<br/>
容易报try_to_wakeup+XXX错误，等等</p>

<h4>定时器 timer 注意</h4>

<p>如果mod_timer设置成马上执行，然后下面又是setup_timer。<br/>
有可能的情况是：进入了中断执行过程，可是setup_timer又改变timer结构，导致继续执行时用到timer结构出错。</p>

<h4>查看内核栈</h4>

<p>用 echo t > /proc/sysrq-trigger 把内核栈整个打出来。<br/>
可以看/proc/{pid}/wchan，里面是该进程阻塞位置的内核函数名，在所有办法都没戏的时候可以看它。</p>

<h4>mark</h4>

<p><a href="http://blog.donghao.org/2013/03/20/%E4%BF%AE%E5%A4%8Dext4%E6%97%A5%E5%BF%97%EF%BC%88jbd2%EF%BC%89bug/">修复ext4日志（jbd2）bug</a><br/>
<a href="http://blog.donghao.org/2013/07/17/rhel6%E5%86%8D%E6%AC%A1%E5%8F%91%E7%8E%B0jbd2%E7%9A%84bug/">rhel6再次发现jbd2的bug</a><br/>
<a href="http://blog.donghao.org/2013/08/28/rhel6-%E7%9A%84%E8%BD%AFraid%E9%97%AE%E9%A2%98/">rhel6 的软RAID问题</a><br/>
<a href="kernel.taobao.org/index.php/Kernel_Documents/stable_pages">stable pages</a><br/>
<a href="http://blog.donghao.org/2014/04/24/%E8%BF%BD%E8%B8%AAcpu%E8%B7%91%E6%BB%A1/">追踪CPU跑满</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[VirtualBox摄像头功能]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/05/28/vm-ex-packages/"/>
    <updated>2014-05-28T21:44:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/05/28/vm-ex-packages</id>
    <content type="html"><![CDATA[<h4>1、下载Oracle VM VirtualBox Extension Pack。下载网址如下：</h4>

<p><a href="https://www.virtualbox.org/wiki/Downloads">https://www.virtualbox.org/wiki/Downloads</a></p>

<h4>2、安装Oracle VM VirtualBox Extension Pack</h4>

<p>安装外部扩展包很简单</p>

<h5>第一：打开Oracle VirtualBox，在菜单栏中找到“管理”–>“全局设定”</h5>

<h5>第二：打开“全局设定”，参考下图：</h5>

<p><img src="/images/system/20140528.jpg" alt="" /></p>

<h5>第三：“Extension Packages”中添加下载的Oracle VM VirtualBox Extension Pack，根据提示安装即可，</h5>

<p>然后虚拟机就能用摄像头了</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux的进程内核栈]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/05/06/kernel-mm-stack/"/>
    <updated>2014-05-06T14:38:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/05/06/kernel-mm-stack</id>
    <content type="html"><![CDATA[<p><a href="http://blog.chinaunix.net/uid-20543672-id-2996319.html">http://blog.chinaunix.net/uid-20543672-id-2996319.html</a></p>

<ul>
<li>内核具有非常小的栈，它可能只和一个4096或8192字节大小的页那样小</li>
</ul>


<h4>什么是进程的“内核栈”？</h4>

<p>  在每一个进程的生命周期中，必然会通过到系统调用陷入内核。在执行系统调用陷入内核之后，这些内核代码所使用的栈并不是原先用户空间中的栈，而是一个内核空间的栈，这个称作进程的“内核栈”。</p>

<p>  比如，有一个简单的字符驱动实现了open方法。在这个驱动挂载后，应用程序对那个驱动所对应的设备节点执行open操作，这个应用程序的open其实 就通过glib库调用了Linux的open系统调用，执行系统调用陷入内核后，处理器转换为了特权模式（具体的转换机制因构架而异，对于ARM来说普通 模式和用户模式的的栈针（SP）是不同的寄存器），此时使用的栈指针就是内核栈指针，他指向内核为每个进程分配的内核栈空间。</p>

<h4>内核栈的作用</h4>

<p>  我个人的理解是：在陷入内核后，系统调用中也是存在函数调用和自动变量，这些都需要栈支持。用户空间的栈显然不安全，需要内核栈的支持。此外，内核栈同时用于保存一些系统调用前的应用层信息（如用户空间栈指针、系统调用参数）。</p>

<h4>内核栈与进程结构体的关联</h4>

<p>  每个进程在创建的时候都会得到一个内核栈空间，内核栈和进程的对应关系是通过2个结构体中的指针成员来完成的：</p>

<h5>（1）struct task_struct</h5>

<p>  在学习Linux进程管理肯定要学的结构体，在内核中代表了一个进程，其中记录的进程的所有状态信息，定义在Sched.h (include\linux)。<br/>
  其中有一个成员：void *stack;就是指向下面的内核栈结构体的“栈底”。<br/>
  在系统运行的时候，宏current获得的就是当前进程的struct task_struct结构体。</p>

<h5>（2）内核栈结构体union thread_union</h5>

<pre><code>    union thread_union {
        struct thread_info thread_info;
        unsigned long stack[THREAD_SIZE/sizeof(long)];
    };
</code></pre>

<p> 其中struct thread_info是记录部分进程信息的结构体，其中包括了进程上下文信息:
<code>
    /*
     * low level task data that entry.S needs immediate access to.
     * __switch_to() assumes cpu_context follows immediately after cpu_domain.
     */
    struct thread_info {
        unsigned long    flags;    /* low level flags */
        int      preempt_count;  /* 0 =&gt; preemptable, &lt;0 =&gt; bug */
        mm_segment_t    addr_limit;  /* address limit */
        struct task_struct  *task;    /* main task structure */
        struct exec_domain  *exec_domain;  /* execution domain */
        __u32      cpu;    /* cpu */
        __u32      cpu_domain;  /* cpu domain */
        struct cpu_context_save  cpu_context;  /* cpu context */
        __u32      syscall;  /* syscall number */
        __u8      used_cp[16];  /* thread used copro */
        unsigned long    tp_value;
        struct crunch_state  crunchstate;
        union fp_state    fpstate __attribute__((aligned(8)));
        union vfp_state    vfpstate;
    #ifdef CONFIG_ARM_THUMBEE
        unsigned long    thumbee_state;  /* ThumbEE Handler Base register */
        #endif
        struct restart_block  restart_block;
    };
</code>
  关键是其中的task成员，指向的是所创建的进程的struct task_struct结构体</p>

<p>  而其中的stack成员就是内核栈。从这里可以看出内核栈空间和 thread_info是共用一块空间的。如果内核栈溢出， thread_info就会被摧毁，系统崩溃了～～～</p>

<p>内核栈&mdash;struct thread_info&mdash;-struct task_struct三者的关系入下图：
<img src="/images/kernel/20140506.jpg" alt="" /></p>

<h4>内核栈的产生</h4>

<p>  在进程被创建的时候，fork族的系统调用中会分别为内核栈和struct task_struct分配空间，调用过程是：
fork族的系统调用&mdash;>do_fork&mdash;>copy_process&mdash;>dup_task_struct
在dup_task_struct函数中：
```
    static struct task_struct <em>dup_task_struct(struct task_struct </em>orig)
    {
        struct task_struct <em>tsk;
        struct thread_info </em>ti;
        unsigned long *stackend;</p>

<pre><code>    int err;

    prepare_to_copy(orig);

    tsk = alloc_task_struct();
    if (!tsk)
        return NULL;

    ti = alloc_thread_info(tsk);
    if (!ti) {
        free_task_struct(tsk);
        return NULL;
    }

    err = arch_dup_task_struct(tsk, orig);
    if (err)
        goto out;

    tsk-&gt;stack = ti;

    err = prop_local_init_single(&amp;tsk-&gt;dirties);
    if (err)
        goto out;

    setup_thread_stack(tsk, orig);
    ......
</code></pre>

<pre><code>其中alloc_task_struct使用内核的slab分配器去为所要创建的进程分配struct task_struct的空间  
而alloc_thread_info使用内核的伙伴系统去为所要创建的进程分配内核栈（union thread_union ）空间

#### 注意：
后面的tsk-&gt;stack = ti;语句，这就是关联了struct task_struct和内核栈
而在setup_thread_stack(tsk, orig);中，关联了内核栈和struct task_struct：
</code></pre>

<pre><code>static inline void setup_thread_stack(struct task_struct *p, struct task_struct *org)
{
    *task_thread_info(p) = *task_thread_info(org);
    task_thread_info(p)-&gt;task = p;
}
</code></pre>

<pre><code>
#### 内核栈的大小
  由于是每一个进程都分配一个内核栈空间，所以不可能分配很大。这个大小是构架相关的，一般以页为单位。其实也就是上面我们看到的THREAD_SIZE， 这个值一般为4K或者8K。对于ARM构架，这个定义在Thread_info.h (arch\arm\include\asm)，
</code></pre>

<pre><code>#define THREAD_SIZE_ORDER  1
#define THREAD_SIZE   8192
#define THREAD_START_SP   (THREAD_SIZE - 8)
</code></pre>

<p>```
所以ARM的内核栈是8KB
在（内核）驱动编程时需要注意的问题：
  由于栈空间的限制，在编写的驱动（特别是被系统调用使用的底层函数）中要注意避免对栈空间消耗较大的代码，比如递归算法、局部自动变量定义的大小等等</p>
]]></content>
  </entry>
  
</feed>
