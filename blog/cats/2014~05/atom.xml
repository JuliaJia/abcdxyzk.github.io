<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 2014~05 | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/2014~05/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2014-12-24T23:53:30+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[tsc时钟初始化]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/05/29/kernel-sched-tsc/"/>
    <updated>2014-05-29T14:03:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/05/29/kernel-sched-tsc</id>
    <content type="html"><![CDATA[<h5>tsc时钟源初始化</h5>

<pre><code>//    调用路径：time_init-&gt;tsc_init
//    函数任务：
//        1.矫正tsc，获取tsc频率，设置cpu频率等于tsc频率
//        2.初始化基于tsc的延迟函数
//        3.检查tsc的特性
//            3.1 tsc之间是否同步
//                3.1.1 如果tsc之间不同步，标记tsc不稳定，设置rating=0
//            3.2 tsc是否稳定
//        4.注册tsc时钟源设备
</code></pre>

<pre><code>void __init tsc_init(void)
{
    u64 lpj;
    int cpu;

    //矫正tsc，获取tsc频率
    tsc_khz = x86_platform.calibrate_tsc();
    //cpu频率等于tsc频率
    cpu_khz = tsc_khz;
    //计算辅助cycle到ns转换的辅助参数scale
    for_each_possible_cpu(cpu)
        set_cyc2ns_scale(cpu_khz, cpu);
    //初始化基于tsc的延迟函数，ndely，udelay，mdelay
    use_tsc_delay();
    //检查cpu之间tsc是否同步
    if (unsynchronized_tsc())
        mark_tsc_unstable("TSCs unsynchronized");
    //检查tsc是否可靠
    check_system_tsc_reliable();
    //注册tsc时钟源设备
    init_tsc_clocksource();
}
</code></pre>

<h5>延迟函数ndelay，udelay，mdelay</h5>

<p>通过tsc实现短延迟
<code>
    void use_tsc_delay(void)
    {
        //通过tsc进行短延迟
        delay_fn = delay_tsc;
    }
</code></p>

<h5>tsc延迟函数</h5>

<p>通过rep_nop实现轮询时的短延迟，查询tsc时禁止内核抢占，确保不受不同cpu间影响。
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void delay_tsc(unsigned long loops)
</span><span class='line'>{
</span><span class='line'>    unsigned long bclock, now;
</span><span class='line'>    int cpu;
</span><span class='line'>    //短延迟，禁止内核抢占
</span><span class='line'>    preempt_disable();
</span><span class='line'>    //delay_tsc当前运行的cpu
</span><span class='line'>    cpu = smp_processor_id();
</span><span class='line'>    rdtsc_barrier();
</span><span class='line'>    rdtscl(bclock);
</span><span class='line'>    for (;;) {
</span><span class='line'>        rdtsc_barrier();
</span><span class='line'>        rdtscl(now);
</span><span class='line'>        if ((now - bclock) &gt;= loops)
</span><span class='line'>            break;
</span><span class='line'>        //允许rt策略进程运行
</span><span class='line'>        preempt_enable();
</span><span class='line'>        //空操作
</span><span class='line'>        rep_nop();
</span><span class='line'>        preempt_disable();&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    //delay_tsc在运行过程中，可能会迁移到不同的cpu
</span><span class='line'>    //tsc
</span><span class='line'>    if (unlikely(cpu != smp_processor_id())) {
</span><span class='line'>        loops -= (now - bclock);
</span><span class='line'>        cpu = smp_processor_id();
</span><span class='line'>        rdtsc_barrier();
</span><span class='line'>        rdtscl(bclock);
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>preempt_enable();
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;}</span></code></pre></td></tr></table></div></figure></p>

<h5>检查tsc是否同步</h5>

<pre><code>//    调用路径：tsc_init-&gt;unsynchronized_tsc
//    检查办法：
//        1.如果apic在多块板卡，则tsc不同步
//        2.如果cpuid显示具有稳定的tsc，则tsc同步
//        3.intel cpu的tsc都是同步的
//        4.默认其他品牌的多核的tsc不同步
</code></pre>

<pre><code>    __cpuinit int unsynchronized_tsc(void)
    {
        //如果apic分布在多块板卡上，tsc可能不同步
        if (apic_is_clustered_box())
            return 1;
        //cpu具有稳定的tsc
        if (boot_cpu_has(X86_FEATURE_CONSTANT_TSC))
            return 0;
        //intel cpu的tsc都是同步的
        if (boot_cpu_data.x86_vendor != X86_VENDOR_INTEL) {
            //非intel cpu，如果cpu个数&gt;1,则认为不同步
            if (num_possible_cpus() &gt; 1)
                tsc_unstable = 1;
        }
        return tsc_unstable;
    }
</code></pre>

<h5>标记tsc不稳定</h5>

<pre><code>//    调用路径：tsc_init-&gt;mark_tsc_unstable
//    函数任务：
//        1.如果tsc时钟已经注册，异步设置tsc的rating=0，标识其不稳定
//        2.如果tsc时钟还未注册，同步设置tsc的rating=0，标识其不稳定
</code></pre>

<pre><code>    void mark_tsc_unstable(char *reason)
    {
        if (!tsc_unstable) {
            tsc_unstable = 1;
            sched_clock_stable = 0;
            //tsc已经注册，
            if (clocksource_tsc.mult)
            {
                clocksource_mark_unstable(&amp;clocksource_tsc);
            }
            //如果tsc时钟源未注册，修改rating为最低，从而不会被当做最佳的时钟源
            else {
                clocksource_tsc.flags |= CLOCK_SOURCE_UNSTABLE;
                clocksource_tsc.rating = 0;
            }
        }
    }
</code></pre>

<h5>注册tsc时钟源</h5>

<pre><code>    //    函数任务：
    //        1.计算tsc的mult
    //        2.检查tsc是否稳定
    //            2.1 如果tsc不稳定，降低其rating，清除时钟源连续标志
    //        3.向系统注册tsc clocksource
    //    调用路径：tsc_init-&gt;init_tsc_clocksource
</code></pre>

<pre><code>    static void __init init_tsc_clocksource(void)
    {
        // 计算tsc的mult
        clocksource_tsc.mult = clocksource_khz2mult(tsc_khz,
                clocksource_tsc.shift);
        // 如果tsc的可靠性已经验证，则清除 必须验证 标记
        if (tsc_clocksource_reliable)
            clocksource_tsc.flags &amp;= ~CLOCK_SOURCE_MUST_VERIFY;

        // 检查tsc是否稳定
        // 在tsc_init前通过全局变量标记tsc是否稳定，可靠
        if (check_tsc_unstable()) {
            // 如果tsc不稳定，则降低rating最低，清除连续标记
            clocksource_tsc.rating = 0;
            clocksource_tsc.flags &amp;= ~CLOCK_SOURCE_IS_CONTINUOUS;
        }
        // 向系统注册tsc clocksource
        clocksource_register(&amp;clocksource_tsc);
    }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TSC时间错误]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/05/29/debug-mark-tsc/"/>
    <updated>2014-05-29T14:03:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/05/29/debug-mark-tsc</id>
    <content type="html"><![CDATA[<p>arch/x86/kernel/tsc.c:<br/>
  开机初始化会调用tsc_init() -> set_cyc2ns_scale() 设置per_cpu变量cyc2ns、cyc2ns_offset。以供后面shced_clock()->native_sched_clock()->__cycles_2_ns()调用。</p>

<p>在cpufreq_tsc()中如果<br/>
   //cpu具有稳定的tsc <br/>
    if (boot_cpu_has(X86_FEATURE_CONSTANT_TSC)) <br/>
        return 0;<br/>
  所以一般不会注册time_cpufreq_notifier函数，也就不会再调用set_cyc2ns_scale。</p>

<ul>
<li>现象：top、ps出来的TIME和CPU的值非常异常。</li>
</ul>


<hr />

<p><a href="https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=733043">https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=733043</a></p>

<p>Xeon E5 has a bug, it doesn&rsquo;t reset TSC on warm reboot, just keep it instead.
 see &ldquo;BT81. X X X No Fix TSC is Not Affected by Warm Reset&rdquo; <a href="http://www.intel.com/content/dam/www/public/us/en/documents/specification-updates/xeon-e5-family-spec-update.pdf">http://www.intel.com/content/dam/www/public/us/en/documents/specification-updates/xeon-e5-family-spec-update.pdf</a></p>

<p> And also kernel 2.6.32 has a bug.<br/>
 Xeon bug + kernel bug = hung after warm reboot (or kexec) after 208.5 days<br/>
 since booting. So, administrators should shutdown it once at all, then<br/>
 boot it again because &ldquo;shutdown -r&rdquo; causes hang up.</p>

<p> Red Hat has released a fix for this as kernel 2.6.32-220, 2.6.32-279<br/>
 and 2.6.32-358 series (RHEL6.x) <a href="https://access.redhat.com/site/solutions/433883">https://access.redhat.com/site/solutions/433883</a> (for detail subscriber only :-(</p>

<p> Attached patch is based on upstream patch.<br/>
 see <a href="http://kernel.opensuse.org/cgit/kernel/patch/?id=9993bc635d01a6ee7f6b833b4ee65ce7c06350b1">http://kernel.opensuse.org/cgit/kernel/patch/?id=9993bc635d01a6ee7f6b833b4ee65ce7c06350b1</a></p>

<hr />

<p>  Red Hat Enterprise Linux 6.1 (kernel-2.6.32-131.26.1.el6 and newer)<br/>
  Red Hat Enterprise Linux 6.2 (kernel-2.6.32-220.4.2.el6 and newer)<br/>
  Red Hat Enterprise Linux 6.3 (kernel-2.6.32-279 series)<br/>
  Red Hat Enterprise Linux 6.4 (kernel-2.6.32-358 series)<br/>
  Any Intel® Xeon® E5, Intel® Xeon® E5 v2, or Intel® Xeon® E7 v2 series processor</p>

<hr />

<p>From 9993bc635d01a6ee7f6b833b4ee65ce7c06350b1 Mon Sep 17 00:00:00 2001<br/>
From: Salman Qazi &lt;<code>sqazi@google.com</code>><br/>
Date: Sat, 10 Mar 2012 00:41:01 +0000<br/>
Subject: sched/x86: Fix overflow in cyc2ns_offset</p>

<p>When a machine boots up, the TSC generally gets reset.  However,
when kexec is used to boot into a kernel, the TSC value would be
carried over from the previous kernel.  The computation of
cycns_offset in set_cyc2ns_scale is prone to an overflow, if the
machine has been up more than 208 days prior to the kexec.  The
overflow happens when we multiply *scale, even though there is
enough room to store the final answer.</p>

<p>We fix this issue by decomposing tsc_now into the quotient and
remainder of division by CYC2NS_SCALE_FACTOR and then performing
the multiplication separately on the two components.</p>

<p>Refactor code to share the calculation with the previous
fix in __cycles_2_ns().</p>

<p>Signed-off-by: Salman Qazi &lt;<code>sqazi@google.com</code>><br/>
Acked-by: John Stultz &lt;<code>john.stultz@linaro.org</code>><br/>
Acked-by: Peter Zijlstra &lt;<code>a.p.zijlstra@chello.nl</code>><br/>
Cc: Paul Turner &lt;<code>pjt@google.com</code>><br/>
Cc: john stultz &lt;<code>johnstul@us.ibm.com</code>><br/>
Link: <a href="http://lkml.kernel.org/r/20120310004027.19291.88460.stgit@dungbeetle.mtv.corp.google.com  ">http://lkml.kernel.org/r/20120310004027.19291.88460.stgit@dungbeetle.mtv.corp.google.com  </a>
Signed-off-by: Ingo Molnar &lt;<code>mingo@elte.hu</code>></p>

<hr />

<pre><code>diff --git a/arch/x86/include/asm/timer.h b/arch/x86/include/asm/timer.h
index 431793e..34baa0e 100644
--- a/arch/x86/include/asm/timer.h
+++ b/arch/x86/include/asm/timer.h
@@ -57,14 +57,10 @@ DECLARE_PER_CPU(unsigned long long, cyc2ns_offset);

 static inline unsigned long long __cycles_2_ns(unsigned long long cyc)
 {
-   unsigned long long quot;
-   unsigned long long rem;
    int cpu = smp_processor_id();
    unsigned long long ns = per_cpu(cyc2ns_offset, cpu);
-   quot = (cyc &gt;&gt; CYC2NS_SCALE_FACTOR);
-   rem = cyc &amp; ((1ULL &lt;&lt; CYC2NS_SCALE_FACTOR) - 1);
-   ns += quot * per_cpu(cyc2ns, cpu) +
-       ((rem * per_cpu(cyc2ns, cpu)) &gt;&gt; CYC2NS_SCALE_FACTOR);
+   ns += mult_frac(cyc, per_cpu(cyc2ns, cpu),
+           (1UL &lt;&lt; CYC2NS_SCALE_FACTOR));
    return ns;
 }

diff --git a/arch/x86/kernel/tsc.c b/arch/x86/kernel/tsc.c
index a62c201..183c592 100644
--- a/arch/x86/kernel/tsc.c
+++ b/arch/x86/kernel/tsc.c
@@ -620,7 +620,8 @@ static void set_cyc2ns_scale(unsigned long cpu_khz, int cpu)

    if (cpu_khz) {
        *scale = (NSEC_PER_MSEC &lt;&lt; CYC2NS_SCALE_FACTOR)/cpu_khz;
-       *offset = ns_now - (tsc_now * *scale &gt;&gt; CYC2NS_SCALE_FACTOR);
+       *offset = ns_now - mult_frac(tsc_now, *scale,
+                        (1UL &lt;&lt; CYC2NS_SCALE_FACTOR));
    }

    sched_clock_idle_wakeup_event(0);
diff --git a/include/linux/kernel.h b/include/linux/kernel.h
index e834342..d801acb 100644
--- a/include/linux/kernel.h
+++ b/include/linux/kernel.h
@@ -85,6 +85,19 @@
 }                          \
 )

+/*
+ * Multiplies an integer by a fraction, while avoiding unnecessary
+ * overflow or loss of precision.
+ */
+#define mult_frac(x, numer, denom)(            \
+{                          \
+   typeof(x) quot = (x) / (denom);         \
+   typeof(x) rem  = (x) % (denom);         \
+   (quot * (numer)) + ((rem * (numer)) / (denom)); \
+}                          \
+)
+
+
 #define _RET_IP_       (unsigned long)__builtin_return_address(0)
 #define _THIS_IP_  ({ __label__ __here; __here: (unsigned long)&amp;&amp;__here; }) 
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mark problem]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/05/29/mark-base/"/>
    <updated>2014-05-29T13:57:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/05/29/mark-base</id>
    <content type="html"><![CDATA[<h4>C语言中宽字符和多字节字符 MB_CUR_MAX</h4>

<p>stdlib.h<br/>
MB_CUR_MAX 当前locale中多字节字符的最大字节数目<br/>
如果把字符串当成多字节字符处理会慢很多<br/>
sort命令的一些版本中会根据locale中的LANG来设置比较函数，如果没设置好会导致sort跑的很慢。</p>

<h4>内核栈溢出</h4>

<p>因为内核栈中栈底保存thread_info，所以如果内核栈溢出会破坏thread_info，这样当进程发生睡眠、中断、抢占等调度时就会出错。<br/>
容易报try_to_wakeup+XXX错误，等等</p>

<h4>定时器 timer 注意</h4>

<p>如果mod_timer设置成马上执行，然后下面又是setup_timer。<br/>
有可能的情况是：进入了中断执行过程，可是setup_timer又改变timer结构，导致继续执行时用到timer结构出错。</p>

<h4>查看内核栈</h4>

<p>用 echo t > /proc/sysrq-trigger 把内核栈整个打出来。<br/>
可以看/proc/{pid}/wchan，里面是该进程阻塞位置的内核函数名，在所有办法都没戏的时候可以看它。</p>

<h4>mark</h4>

<p><a href="http://blog.donghao.org/2013/03/20/%E4%BF%AE%E5%A4%8Dext4%E6%97%A5%E5%BF%97%EF%BC%88jbd2%EF%BC%89bug/">修复ext4日志（jbd2）bug</a><br/>
<a href="http://blog.donghao.org/2013/07/17/rhel6%E5%86%8D%E6%AC%A1%E5%8F%91%E7%8E%B0jbd2%E7%9A%84bug/">rhel6再次发现jbd2的bug</a><br/>
<a href="http://blog.donghao.org/2013/08/28/rhel6-%E7%9A%84%E8%BD%AFraid%E9%97%AE%E9%A2%98/">rhel6 的软RAID问题</a><br/>
<a href="kernel.taobao.org/index.php/Kernel_Documents/stable_pages">stable pages</a><br/>
<a href="http://blog.donghao.org/2014/04/24/%E8%BF%BD%E8%B8%AAcpu%E8%B7%91%E6%BB%A1/">追踪CPU跑满</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[VirtualBox摄像头功能]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/05/28/vm-ex-packages/"/>
    <updated>2014-05-28T21:44:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/05/28/vm-ex-packages</id>
    <content type="html"><![CDATA[<h4>1、下载Oracle VM VirtualBox Extension Pack。下载网址如下：</h4>

<p><a href="https://www.virtualbox.org/wiki/Downloads">https://www.virtualbox.org/wiki/Downloads</a></p>

<h4>2、安装Oracle VM VirtualBox Extension Pack</h4>

<p>安装外部扩展包很简单</p>

<h5>第一：打开Oracle VirtualBox，在菜单栏中找到“管理”–>“全局设定”</h5>

<h5>第二：打开“全局设定”，参考下图：</h5>

<p><img src="/images/system/20140528.jpg" alt="" /></p>

<h5>第三：“Extension Packages”中添加下载的Oracle VM VirtualBox Extension Pack，根据提示安装即可，</h5>

<p>然后虚拟机就能用摄像头了</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[周期性调度器scheduler_tick]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/05/22/kernel-sched-tick/"/>
    <updated>2014-05-22T16:57:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/05/22/kernel-sched-tick</id>
    <content type="html"><![CDATA[<p>周期性调度器由中断实现，系统定时产生一个中断，然后启动周期性调度器，周期性调度器执行过程中要关闭中断, 周期性调度器执行完毕后再打开中断(handle_IRQ_event,  IRQF_DISABLED)</p>

<p>周期性调度器主要做两个工作：<br/>
a)更新相关统计量<br/>
b) 检查进程执行的时间是否超过了它对应的ideal_runtime，如果超过了，则告诉系统，需要启动主调度器(schedule)进行进程切换。(注意 thread_info:preempt_count、thread_info:flags (TIF_NEED_RESCHED))</p>

<h4>周期性调度器</h4>

<pre><code>    |----&gt;do_timer()   更新jiffies_64
    |----&gt;update_process_times()
          |----&gt;scheduler_tick()
          |----&gt;update_rq_clock()  更新当前调度队列rq的clock
          |----&gt;curr-&gt;sched_class-&gt;task_tick() 
          |         对于普通进程，即task_tick_fair()
          |         task_struct: struct sched_class *sched_class

update_rq_clock()----delta = sched_clock_cpu(cpu_of(rq)) - rq-&gt;clock
         |-----两次相邻两次周期性调度器运行的时间差
         |----rq-&gt;clock += delta; 更新运行队列上的时钟
               |----&gt;update_rq_clock_task(rq, delta)
               |     即rq-&gt;clock_task += delta
</code></pre>

<h4>普通进程</h4>

<pre><code>task_tick_fair()----&gt;entity_tick()   没有考虑组调度
   |----&gt;update_curr() 更新相关统计量
   |----&gt;check_preempt_tick()   
   |        检查进程本次获得CPU使用权的执行时间是否超过了
   |        它对应的ideal_runtime值，如果超过了，则将当前进
   |        程的TIF_NEED_RESCHED标志位置位

update_curr()
   |----delta_exec = (unsigned long)(now - curr-&gt;exec_start);  
   |            exec_start当前进程开始获得
   |            cpu使用权时的时间戳;
   |            进程本次所获得的CPU执行权的时间;
   |----&gt;__update_curr(cfs_rq, curr, delta_exec);
         |----&gt;curr-&gt;sum_exec_runtime += delta_exec; 
         |     更新该进程获得CPU执行权总时间
         |
         |----&gt;curr-&gt;vruntime += delta_exec_weighted;
         |     更新该进程获得CPU执行权的虚拟时间
         |
         |----&gt;update_min_vruntime()
         |     更新cfs_rq-&gt;min_vruntime
         |
   |----&gt;curr-&gt;exec_start = now    
   |        更新进程下次运行起始时间
   |        (如果被抢占，下次被调度时将会更新)

check_preempt_tick()
   |----ideal_runtime = sched_slice(cfs_rq, curr);
   |----delta_exec = curr-&gt;sum_exec_runtime 
   |                 - curr-&gt;prev_sum_exec_runtime;
   |----if(delta_exec &gt; ideal_runtime)  
   |          resched_task(rq_of(cfs_rq)-&gt;curr);
   |          把当前进程的TIF_NEED_RESCHED标志位置位
   |----else
   |    delta = curr-&gt;vruntime - se-&gt;vruntime;  //这是什么？
   |    if (delta &gt; ideal_runtime)  
   |        resched_task(rq_of(cfs_rq)-&gt;curr);
   |        把当前进程的TIF_NEED_RESCHED标志位置位
</code></pre>

<h4>实时进程</h4>

<pre><code>task_tick_rt()
    |----&gt;update_curr_rt();
    |----&gt;if (p-&gt;policy != SCHED_RR) return;  SCHED_FIFO只有主动放弃CPU使用权
    |----&gt;rt.timeslice值减一，若没有运行完时间则直接返回，
    |     否则再次分配时间片，加入队列尾部，设置TIF_NEED_RESCHED

update_curr_rt()
    |----delta_exec = rq-&gt;clock - curr-&gt;se.exec_start; //本次运行时间
    |----curr-&gt;se.sum_exec_runtime += delta_exec; //更新总得运行时间
    |----curr-&gt;se.exec_start = rq-&gt;clock; //更新下次进程运行的起始时间
    |----if (sched_rt_runtime(rt_rq) != RUNTIME_INF)
    |-------{
    |           rt_rq-&gt;rt_time += delta_exec;
    |                if (sched_rt_runtime_exceeded(rt_rq))
    |                   resched_task(curr);
    |       }
</code></pre>
]]></content>
  </entry>
  
</feed>
