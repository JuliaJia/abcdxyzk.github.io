<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: kernel~net | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/kernel~net/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2014-12-23T01:47:18+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[收包软中断和netif_rx]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/12/16/kernel-net-softirq-rx/"/>
    <updated>2014-12-16T15:30:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/12/16/kernel-net-softirq-rx</id>
    <content type="html"><![CDATA[<h5>初始化报文接收软中断</h5>

<pre><code>static int __init net_dev_init(void)
{
    ......
    open_softirq(NET_RX_SOFTIRQ, net_rx_action);
    ......
}
</code></pre>

<h5>报文接收软中断的处理函数net_rx_action详解：</h5>

<pre><code>static void net_rx_action(struct softirq_action *h)
{
    /*取得本地cpu 的softnet_data 的poll_list  链表*/
    struct list_head *list = &amp;__get_cpu_var(softnet_data).poll_list;
    /*设置软中断处理程序一次允许的最大执行时间为2个jiffies*/
    unsigned long time_limit = jiffies + 2;
　　
    /*设置软中断接收函数一次最多处理的报文个数为 300 */
    int budget = netdev_budget;
    /*关闭本地cpu的中断，下面判断list是否为空时防止硬中断抢占*/
    local_irq_disable();
    /*循环处理pool_list 链表上的等待处理的napi*/
    while (!list_empty(list))
    {
        struct napi_struct *n;
        int work, weight;

        /*如果处理报文超出一次处理最大的个数
          或允许时间超过最大时间就停止执行，
          跳到softnet_break 处*/
        if (unlikely(budget &lt;= 0 || time_after(jiffies, time_limit)))
        {
            goto softnet_break;
        }
        /*使能本地中断，上面判断list为空已完成，下面调用NAPI
          的轮询函数是在硬中断开启的情况下执行*/
        local_irq_enable();

        /* 取得softnet_data pool_list 链表上的一个napi,
           即使现在硬中断抢占软中断，会把一个napi挂到pool_list的尾端
           软中断只会从pool_list 头部移除一个pool_list，这样不存在临界区*/
        n = list_entry(list-&gt;next, struct napi_struct, poll_list);
        /*用weighe 记录napi 一次轮询允许处理的最大报文数*/
        weight = n-&gt;weight;
        /* work 记录一个napi总共处理的报文数*/
        work = 0;
　　
        /*如果取得的napi状态是被调度的，就执行napi的轮询处理函数*/
        if (test_bit(NAPI_STATE_SCHED, &amp;n-&gt;state))
        {
            work = n-&gt;poll(n, weight);
        }
        WARN_ON_ONCE(work &gt; weight);
        /*预算减去已经处理的报文数*/
        budget -= work;
        /*禁止本地CPU 的中断，下面会有把没执行完的NAPI挂到softnet_data
          尾部的操作，和硬中断存在临界区。同时while循环时判断list是否
          为空时也要禁止硬中断抢占*/
        local_irq_disable();
　　
        /*如果napi 一次轮询处理的报文数正好等于允许处理的最大数,
          说明一次轮询没处理完全部需要处理的报文*/
        if (unlikely(work == weight))
        {
            /*如果napi已经被禁用，就把napi 从 softnet_data 的pool_list 上移除*/
            if (unlikely(napi_disable_pending(n)))
            {
                local_irq_enable();
                napi_complete(n);
                local_irq_disable();
            }
            else
            {
                /*否则，把napi 移到 pool_list 的尾端*/
                list_move_tail(&amp;n-&gt;poll_list, list);
            }
        }
    }
out:
    local_irq_enable();
    return;
　　
    /*如果处理时间超时，或处理的报文数到了最多允许处理的个数，
      说明还有napi 上有报文需要处理，调度软中断。
      否则，说明这次软中断处理完全部的napi上的需要处理的报文，不再需要
      调度软中断了*/
softnet_break:
    __get_cpu_var(netdev_rx_stat).time_squeeze++;
    __raise_softirq_irqoff(NET_RX_SOFTIRQ);
    goto out;
}
</code></pre>

<h5>虚拟NAPI backlog 的轮询函数process_backlog（）:</h5>

<p>参数：<br/>
napi : 本地cpu上softnet_data 的backlog .<br/>
quota :  一次轮询可以处理的最多报文数。</p>

<h6>函数详解：</h6>

<pre><code class="">static int process_backlog(struct napi_struct *napi, int quota)
{
    int work = 0;

    /*取得本地CPU上的softnet_data  数据*/
    struct softnet_data *queue = &amp;__get_cpu_var(softnet_data);
　　
    /*开始计时，一旦允许时间到，就退出轮询*/
    unsigned long start_time = jiffies;
    napi-&gt;weight = weight_p;
　　
    /*循环从softnet_data 的输入队列取报文并处理，直到队列中没有报文了,
     或处理的报文数大于了允许的上限值了，
     或轮询函数执行时间大于一个jiffies 了
　　*/
    do
    {
        struct sk_buff *skb;
        /*禁用本地中断，要存队列中取skb,防止抢占*/
        local_irq_disable();
　　
        /*从softnet_data 的输入队列中取得一个skb*/
        skb = __skb_dequeue(&amp;queue-&gt;input_pkt_queue);
　　
        /*如果队列中没有skb,则使能中断并退出轮询*/
        if (!skb)
        {
            /*把napi 从 softnet_data 的 pool_list 链表上摘除*/
            __napi_complete(napi);
            /*使能本地CPU的中断*/
            local_irq_enable();
            break;
        }
        /*skb 已经摘下来了，使能中断*/
        local_irq_enable();
　　
        /*把skb送到协议栈相关协议模块进行处理,详细处理见后续章节*/
        netif_receive_skb(skb);
    } while (++work &lt; quota &amp;&amp; jiffies == start_time);
    /*返回处理报文个数*/
    return work;
}
</code></pre>

<h5>linux旧的收包方式提供给驱动的接口netif_rx():</h5>

<pre><code class="">int netif_rx(struct sk_buff *skb)
{
    struct softnet_data *queue;
    unsigned long flags;
　
    /*如果接收skb的时间戳没设定，设定接收时间戳*/
    if (!skb-&gt;tstamp.tv64)
    {
        net_timestamp(skb);
    }
　　
    /*禁止本地cpu的中断*/
    local_irq_save(flags);
　　
    /*取得本地cpu的softnet_data*/
    queue = &amp;__get_cpu_var(softnet_data);

    /*每个CPU都有一个统计数据，增加统计数据*/
    __get_cpu_var(netdev_rx_stat).total++;
　　
    /*如果本地CPU的输入队列中的skb 个数小于允许的最多的个数*/
    if (queue-&gt;input_pkt_queue.qlen &lt;= netdev_max_backlog)
    {
        /*如果本地cpu的输入队列长度不为0,表示输入队列已经有skb了，
        并且特殊的napi backlog 已经挂入了softnet_data  的
        pool_list上了*/
        if (queue-&gt;input_pkt_queue.qlen)
        {
enqueue:
            /*把skb 放入CPU的输入队列 input_pkt_queue*/
            __skb_queue_tail(&amp;queue-&gt;input_pkt_queue, skb);

            /*使能中断 并 返回*/
            local_irq_restore(flags);
            return NET_RX_SUCCESS;
        }
        /*如果输入队列为空，则把 特殊的napi backlog 挂到softnet_data
        的 pool_list 上 并返回把skb放入输入队列并返回*/
        napi_schedule(&amp;queue-&gt;backlog);
        goto enqueue;
    }
    /*如果本地cpu的输入队列已经满了，则丢弃报文，
      并增加丢包计数并返回*/
    __get_cpu_var(netdev_rx_stat).dropped++;
    local_irq_restore(flags);
　　
    kfree_skb(skb);
    return NET_RX_DROP;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux内核网络分层结构]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/08/01/net-struct/"/>
    <updated>2014-08-01T16:52:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/08/01/net-struct</id>
    <content type="html"><![CDATA[<p><a href="http://liucw.blog.51cto.com/6751239/1221140">http://liucw.blog.51cto.com/6751239/1221140</a></p>

<h4>内核网络结构</h4>

<p>  在Linux内核中，对网络部分按照网络协议层、网络设备层、设备驱动功能层和网络媒介层的分层体系设计。</p>

<p>  网络驱动功能层主要通过网络驱动程序实现。</p>

<p>  在Linux内核，所有的网络设备都被抽象为一个接口处理，该接口提供了所有的网络操作。</p>

<p>  net_device结构表示网络设备在内核中的情况，也就是网络设备接口。网络设备接口既包括软件虚拟的网络设备接口，如环路设备，也包括了网络硬件设备，如以太网卡。</p>

<p>  Linux内核有一个dev_base的全局指针，指向一个设备链表，包括了系统内的所有网络设备。该设备链表每个节点是一个网络设备。</p>

<p>  在net_device结构中提供了许多供系统访问和协议层调用的设备方法，包括初始化、打开关闭设备、数据包发送和接收等。</p>

<h4>与网络有关的数据结构</h4>

<p>  内核对网络数据包的处理都是基于sk_buff结构的，该结构是内核网络部分最重要的数据结构。</p>

<p>  网络协议栈中各层协议都可以通过对该结构的操作实现本层协议数据的添加或者删除。使用sk_buff结构避免了网络协议栈各层来回复制数据导致的效率低下。</p>

<p><img src="/images/kernel/20140801-1.png" alt="" /></p>

<p>  sk_buff结构可以分为两个部分，一部分是存储数据包缓存，在图中表示为PackertData，另一部分是由一组用于内核管理的指针组成。<br/>
  sk_buff管理的指针最主要的是下面4个：</p>

<blockquote><p>head指向数据缓冲(PackertData)的内核首地址；<br/>
data指向当前数据包的首地址；<br/>
tail指向当前数据包的尾地址；<br/>
end 指向数据缓冲的内核尾地址。<br/>
  数据包的大小在内核网络协议栈的处理过程中会发生改变，因此data和tail指针也会不断变化，而head和tail指针是不会发生改变的。</p></blockquote>

<p>  对于一个TCP数据包为例，sk_buff还提供了几个指针直接指向各层协议头。mac指针指向数据的mac头；nh指针指向网络协议头，一般是IP协议头；h指向传输层协议头，在本例中是TCP协议头。</p>

<p>  对各层设置指针的是方便了协议栈对数据包的处理。</p>

<h4>net_device结构</h4>

<p>  Linux内核中网络设备最重要的数据结构就是net_device结构了，它是网络驱动程序最重要的部分。<br/>
  net_device结构保存在include/linux/netdevices.h头文件，理解该结构对理解网络设备驱动有很大帮助。<br/>
  内核中所有网络设备的信息和操作都在net_device设备中，无论是注册网络设备，还是设置网络设备参数，都用到该结构。<br/>
  下面是主要数据成员。</p>

<blockquote><p>设备名称<br/>
总线参数<br/>
协议参数<br/>
链接层变量<br/>
接口标志</p></blockquote>

<h4>数据包接收流程</h4>

<p>  在Linux内核中，一个网络数据包从网卡接收到用户空间需要经过链路层、传输层和socket的处理，最终到达用户空间。<br/>
<img src="/images/kernel/20140801-2.png" alt="" /><br/>
  以DM9000网卡为例，当网卡收到数据包以后，调用中断处理函数 dm9000_interrupt()，该函数检查中断处理类型，如果是接收数据包中断，则调用 dm9000_rx()函数接收数据包到内核空间。</p>

<p>  dm9000_rx()函数收到数据包完成后，内核会继续调用 netif_rx()函数，函数的作用是把网卡接收到数据提交给协议栈处理。</p>

<p>  协议栈使用 net_rx_action()函数处理接收数据包队列，该函数处理数据包后如果是 IP数据包则提交给 ip_recv()函数处理。ip_recv()函数主要是检查一个数据包IP头的合法性，检查通过后交给 ip_local_deliver()和 ip_local_deliver_finish()函数处理，之所以分开处理是因为内核中有防火墙相关的代码需要动态加载到此处。</p>

<p>  IP头处理完毕后，以UDP数据包为例将交由 udp_recv()函数处理，与 ip_recv()函数类亿，该函数检查 UDP头的合法性，然后交给 udp_queue_recv()函数处理，最后提交给 sock_queue_recv()函数处理。</p>

<p>  数据包进入 socket部分的第一个函数是 skb_recv_datagram()，该函数从内核的 socket队列取出数据包，交给 socket部分的 udp_recvmsg()函数，该函数负责处理UDP的数据，sock_recvmsg()处理提交给 sock_read()函数。</p>

<p>  sock_read()函数读取接收到的数据缓冲，把数据返回给 sys_read()系统调用。sys_read()函数调用最终把数据复制到用户空间，供用户使得。</p>

<h4>数据包发送流程</h4>

<p>  以UDP数据包发送流程为例，在DM9000网卡上如何发送一个数据包。</p>

<p><img src="/images/kernel/20140801-3.png" alt="" /></p>

<p>  当用户空间的应用程序通过 socket函数 sento()发送一个UDP数据后，会调用内核空间的 sock_writev()函数，然后通过 sock_sendmsg()函数处理。sock_sendmsg()函数调用 inet_sendmsg()函数处理，inet_sendmsg()函数会把要发送的数据交给传输层的 udp_sendmsg()函数处理。</p>

<p>  udp_sendmsg()函数在数据前加入UDP头，然后把数据交给 ip_build_xmit()函数处理，该函数根据 socket提供的目的 IP和端口信息构造IP头，然后调用 output_maybe_reroute()函数处理。out_maybe_reroute()函数检查数据包是否需要经过路由，最后交给 ip_output()函数写入到发送队列，写入完成后由 ip_finish_output()函数处理后续工作。</p>

<p>  链路层的 dev_queue_xmit()函数处理发送队列，调用 DM9000网卡的发送数据包函数 dm9000_xmit()发送数据包，发送完毕后，调用 dm9000_xmit_done函数处理发送结果。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux 内核发包]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/07/31/net-sendmsg/"/>
    <updated>2014-07-31T11:28:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/07/31/net-sendmsg</id>
    <content type="html"><![CDATA[<pre><code>    #include &lt;linux/module.h&gt;
    #include &lt;linux/kernel.h&gt;
    #include &lt;linux/init.h&gt;
    #include &lt;linux/workqueue.h&gt;
    #include &lt;linux/timer.h&gt;
    #include &lt;linux/in.h&gt;
    #include &lt;linux/inet.h&gt;
    #include &lt;linux/socket.h&gt;
    #include &lt;net/sock.h&gt;

    struct socket       *sock;

    unsigned char buffer[10]=
    { 1,2,3,4,5,6,7,8,9,0,};

    static int ker_send_udp(char* ip_addr, unsigned char * data, size_t len )
    {
        int ret;
        u32 remote_ip = in_aton(ip_addr);

        struct sockaddr_in sin = {
            .sin_family = AF_INET,
            .sin_port = htons(65530),
            .sin_addr = {.s_addr = remote_ip}
        };

        struct kvec iov = {.iov_base = (void *)data, .iov_len = len};
        struct msghdr udpmsg;

        udpmsg.msg_name = (void *)&amp;sin;
        udpmsg.msg_namelen = sizeof(sin);
        udpmsg.msg_control = NULL;
        udpmsg.msg_controllen = 0;
        udpmsg.msg_flags=0;

        ret = kernel_sendmsg(sock, &amp;udpmsg, &amp;iov, 1, len);
        printk("rets = %d\n",ret);

        return 0;
    }

    static int socket_init (void)
    {
        int ret;
        ret = sock_create_kern (PF_INET, SOCK_DGRAM,IPPROTO_UDP, &amp;sock);
        printk("retc = %d\n",ret);

        ker_send_udp("192.168.1.253", buffer, 10);
        return 0;
    }

    static void socket_exit (void)
    {   
        sock_release (sock);
    }

    module_init (socket_init);
    module_exit (socket_exit);
    MODULE_LICENSE ("GPL");
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[内核tcp的定时器管理]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/09/27/kernel-net-tcp-timer/"/>
    <updated>2013-09-27T16:11:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/09/27/kernel-net-tcp-timer</id>
    <content type="html"><![CDATA[<h5>在内核中tcp协议栈有6种类型的定时器：</h5>

<pre><code>1 重传定时器。
2 delayed ack定时器
3 零窗口探测定时器
上面三种定时器都是作为tcp状态机的一部分来实现的。
4 keep-alive 定时器 主要是管理established状态的连接。
5 time_wait定时器 主要是用来客户端关闭时的time_wait状态用到。
6 syn-ack定时器(主要是用在listening socket) 管理新的连接请求时所用到。
</code></pre>

<h5>而在内核中，tcp协议栈管理定时器主要有下面4个函数：</h5>

<pre><code>inet_csk_reset_xmit_timer   这个函数是用来重启定时器
inet_csk_clear_xmit_timer   这个函数用来删除定时器。
上面两个函数都是针对状态机里面的定时器。
tcp_set_keepalive   这个函数是用来管理keepalive 定时器的接口。
tcp_synack_timer    这个函数是用来管理syn_ack定时器的接口。
</code></pre>

<h5>先来看定时器的初始化。</h5>

<p>首先是在tcp_v4_init_sock中对定时器的初始化，它会调用tcp_init_xmit_timers，我们就先来看这个函数：
<code>
    void tcp_init_xmit_timers(struct sock *sk)
    {
        inet_csk_init_xmit_timers(sk, &amp;tcp_write_timer, &amp;tcp_delack_timer, &amp;tcp_keepalive_timer);
    }
</code>
可以看到这个函数很简单，就是调用inet_csk_init_xmit_timers,然后把3个定时器的回掉函数传递进去，下面我们来看inet_csk_init_xmit_timers。
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
<span class='line-number'>206</span>
<span class='line-number'>207</span>
<span class='line-number'>208</span>
<span class='line-number'>209</span>
<span class='line-number'>210</span>
<span class='line-number'>211</span>
<span class='line-number'>212</span>
<span class='line-number'>213</span>
<span class='line-number'>214</span>
<span class='line-number'>215</span>
<span class='line-number'>216</span>
<span class='line-number'>217</span>
<span class='line-number'>218</span>
<span class='line-number'>219</span>
<span class='line-number'>220</span>
<span class='line-number'>221</span>
<span class='line-number'>222</span>
<span class='line-number'>223</span>
<span class='line-number'>224</span>
<span class='line-number'>225</span>
<span class='line-number'>226</span>
<span class='line-number'>227</span>
<span class='line-number'>228</span>
<span class='line-number'>229</span>
<span class='line-number'>230</span>
<span class='line-number'>231</span>
<span class='line-number'>232</span>
<span class='line-number'>233</span>
<span class='line-number'>234</span>
<span class='line-number'>235</span>
<span class='line-number'>236</span>
<span class='line-number'>237</span>
<span class='line-number'>238</span>
<span class='line-number'>239</span>
<span class='line-number'>240</span>
<span class='line-number'>241</span>
<span class='line-number'>242</span>
<span class='line-number'>243</span>
<span class='line-number'>244</span>
<span class='line-number'>245</span>
<span class='line-number'>246</span>
<span class='line-number'>247</span>
<span class='line-number'>248</span>
<span class='line-number'>249</span>
<span class='line-number'>250</span>
<span class='line-number'>251</span>
<span class='line-number'>252</span>
<span class='line-number'>253</span>
<span class='line-number'>254</span>
<span class='line-number'>255</span>
<span class='line-number'>256</span>
<span class='line-number'>257</span>
<span class='line-number'>258</span>
<span class='line-number'>259</span>
<span class='line-number'>260</span>
<span class='line-number'>261</span>
<span class='line-number'>262</span>
<span class='line-number'>263</span>
<span class='line-number'>264</span>
<span class='line-number'>265</span>
<span class='line-number'>266</span>
<span class='line-number'>267</span>
<span class='line-number'>268</span>
<span class='line-number'>269</span>
<span class='line-number'>270</span>
<span class='line-number'>271</span>
<span class='line-number'>272</span>
<span class='line-number'>273</span>
<span class='line-number'>274</span>
<span class='line-number'>275</span>
<span class='line-number'>276</span>
<span class='line-number'>277</span>
<span class='line-number'>278</span>
<span class='line-number'>279</span>
<span class='line-number'>280</span>
<span class='line-number'>281</span>
<span class='line-number'>282</span>
<span class='line-number'>283</span>
<span class='line-number'>284</span>
<span class='line-number'>285</span>
<span class='line-number'>286</span>
<span class='line-number'>287</span>
<span class='line-number'>288</span>
<span class='line-number'>289</span>
<span class='line-number'>290</span>
<span class='line-number'>291</span>
<span class='line-number'>292</span>
<span class='line-number'>293</span>
<span class='line-number'>294</span>
<span class='line-number'>295</span>
<span class='line-number'>296</span>
<span class='line-number'>297</span>
<span class='line-number'>298</span>
<span class='line-number'>299</span>
<span class='line-number'>300</span>
<span class='line-number'>301</span>
<span class='line-number'>302</span>
<span class='line-number'>303</span>
<span class='line-number'>304</span>
<span class='line-number'>305</span>
<span class='line-number'>306</span>
<span class='line-number'>307</span>
<span class='line-number'>308</span>
<span class='line-number'>309</span>
<span class='line-number'>310</span>
<span class='line-number'>311</span>
<span class='line-number'>312</span>
<span class='line-number'>313</span>
<span class='line-number'>314</span>
<span class='line-number'>315</span>
<span class='line-number'>316</span>
<span class='line-number'>317</span>
<span class='line-number'>318</span>
<span class='line-number'>319</span>
<span class='line-number'>320</span>
<span class='line-number'>321</span>
<span class='line-number'>322</span>
<span class='line-number'>323</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void inet_csk_init_xmit_timers(struct sock &lt;em&gt;sk,
</span><span class='line'>                    void (&lt;/em&gt;retransmit_handler)(unsigned long),
</span><span class='line'>                    void (&lt;em&gt;delack_handler)(unsigned long),
</span><span class='line'>                    void (&lt;/em&gt;keepalive_handler)(unsigned long))
</span><span class='line'>{
</span><span class='line'>    struct inet_connection_sock *icsk = inet_csk(sk);&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    //安装定时器，设置定时器的回掉函数。
</span><span class='line'>setup_timer(&amp;icsk-&gt;icsk_retransmit_timer, retransmit_handler, (unsigned long)sk);
</span><span class='line'>setup_timer(&amp;icsk-&gt;icsk_delack_timer, delack_handler, (unsigned long)sk);
</span><span class='line'>setup_timer(&amp;sk-&gt;sk_timer, keepalive_handler, (unsigned long)sk);
</span><span class='line'>icsk-&gt;icsk_pending = icsk-&gt;icsk_ack.pending = 0;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;我 们可以看到icsk-&gt;icsk_retransmit_timer定时器，也就是重传定时器的回调函数是tcp_write_timer,而 icsk-&gt;icsk_delack_timer定时器也就是delayed-ack 定时器的回调函数是tcp_delack_timer,最后sk-&gt;sk_timer也就是keepalive定时器的回掉函数是 tcp_keepalive_timer.  
</span><span class='line'>这里还有一个要注意的，tcp_write_timer还会处理0窗口定时器。  
</span><span class='line'>这里有关内核定时器的一些基础的东西我就不介绍了，想了解的可以去看下ldd第三版。  
</span><span class='line'>接下来我们就来一个个的分析这6个定时器，首先是重传定时器。  
</span><span class='line'>我们知道4层最终调用tcp_xmit_write来讲数据发送到3层，并且tcp是字节流的，因此每次他总是发送一段数据到3层，而每次当它发送完毕(返回正确),则它就会启动重传定时器，我们来看代码：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static int tcp_write_xmit(struct sock *sk, unsigned int mss_now, int nonagle,
</span><span class='line'>          int push_one, gfp_t gfp)
</span><span class='line'>{
</span><span class='line'>struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>struct sk_buff *skb;
</span><span class='line'>unsigned int tso_segs, sent_pkts;
</span><span class='line'>int cwnd_quota;
</span><span class='line'>int result;
</span><span class='line'>
</span><span class='line'>.............................................
</span><span class='line'>
</span><span class='line'>while ((skb = tcp_send_head(sk))) {
</span><span class='line'>..................................................
</span><span class='line'>
</span><span class='line'>    //可以看到只有当传输成功，我们才会走到下面的函数。
</span><span class='line'>    if (unlikely(tcp_transmit_skb(sk, skb, 1, gfp)))
</span><span class='line'>        break;
</span><span class='line'>
</span><span class='line'>    /* Advance the send_head.  This one is sent out.
</span><span class='line'>     * This call will increment packets_out.
</span><span class='line'>     */
</span><span class='line'>    //最终在这个函数中启动重传定时器。
</span><span class='line'>    tcp_event_new_data_sent(sk, skb);
</span><span class='line'>
</span><span class='line'>    tcp_minshall_update(tp, mss_now, skb);
</span><span class='line'>    sent_pkts++;
</span><span class='line'>
</span><span class='line'>    if (push_one)
</span><span class='line'>        break;
</span><span class='line'>}
</span><span class='line'>...........................
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;现在我们来看tcp_event_new_data_sent,如何启动定时器的.
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static void tcp_event_new_data_sent(struct sock *sk, struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>unsigned int prior_packets = tp-&gt;packets_out;
</span><span class='line'>
</span><span class='line'>tcp_advance_send_head(sk, skb);
</span><span class='line'>tp-&gt;snd_nxt = TCP_SKB_CB(skb)-&gt;end_seq;
</span><span class='line'>
</span><span class='line'>/* Don't override Nagle indefinately with F-RTO */
</span><span class='line'>if (tp-&gt;frto_counter == 2)
</span><span class='line'>    tp-&gt;frto_counter = 3;
</span><span class='line'>//关键在这里.
</span><span class='line'>tp-&gt;packets_out += tcp_skb_pcount(skb);
</span><span class='line'>if (!prior_packets)
</span><span class='line'>    inet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS, inet_csk(sk)-&gt;icsk_rto, TCP_RTO_MAX);
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;可以看到只有当prior_packets为0时才会重启定时器,而prior_packets则是发送未确认的段的个数,也就是说如果发送了很多段,如果前面的段没有确认,那么后面发送的时候不会重启这个定时器.  
</span><span class='line'>我们要知道，定时器的间隔是通过rtt来得到的，具体的算法，可以看下tcp/ip详解。  
</span><span class='line'>当 启动了重传定时器，我们就会等待ack的到来，如果超时还没到来，那么就调用重传定时器的回调函数，否则最终会调用tcp_rearm_rto来删除或者 重启定时器，这个函数是在tcp_ack()-&gt;tcp_clean_rtx_queue()中被调用的。tcp_ack是专门用来处理ack。  
</span><span class='line'>这个函数很简单，就是通过判断packets_out，这个值表示当前还未确认的段的个数。然后来进行相关操作。  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static void tcp_rearm_rto(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>
</span><span class='line'>//为0说明所有的传输的段都已经acked。此时remove定时器。否则重启定时器。
</span><span class='line'>if (!tp-&gt;packets_out) {
</span><span class='line'>    inet_csk_clear_xmit_timer(sk, ICSK_TIME_RETRANS);
</span><span class='line'>} else {
</span><span class='line'>    inet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS,
</span><span class='line'>                  inet_csk(sk)-&gt;icsk_rto, TCP_RTO_MAX);
</span><span class='line'>}
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;  接下来来看tcp_write_timer的实现。这个函数主要是通过icsk-&gt;icsk_pending来判断是那个定时器导致超时，这里只有两 种，一种是ICSK_TIME_RETRANS，也就是重传定时器，另一种是ICSK_TIME_PROBE0也就是0窗口定时器。
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;#define ICSK_TIME_RETRANS   1   /* Retransmit timer */
</span><span class='line'>#define ICSK_TIME_PROBE0    3   /* Zero window probe timer */
</span><span class='line'>static void tcp_write_timer(unsigned long data)
</span><span class='line'>{
</span><span class='line'>struct sock *sk = (struct sock *)data;
</span><span class='line'>struct inet_connection_sock *icsk = inet_csk(sk);
</span><span class='line'>int event;
</span><span class='line'>
</span><span class='line'>//首先加锁。
</span><span class='line'>bh_lock_sock(sk);
</span><span class='line'>//如果是进程空间则什么也不做。
</span><span class='line'>if (sock_owned_by_user(sk)) {
</span><span class='line'>    /* Try again later */
</span><span class='line'>    sk_reset_timer(sk, &amp;icsk-&gt;icsk_retransmit_timer, jiffies + (HZ / 20));
</span><span class='line'>    goto out_unlock;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>//如果状态为close或者icsk_pending为空，则什么也不做。
</span><span class='line'>if (sk-&gt;sk_state == TCP_CLOSE || !icsk-&gt;icsk_pending)
</span><span class='line'>    goto out;
</span><span class='line'>//如果超时时间已经过了，则重启定时器。
</span><span class='line'>
</span><span class='line'>if (time_after(icsk-&gt;icsk_timeout, jiffies)) {
</span><span class='line'>    sk_reset_timer(sk, &amp;icsk-&gt;icsk_retransmit_timer, icsk-&gt;icsk_timeout);
</span><span class='line'>    goto out;
</span><span class='line'>}
</span><span class='line'>//取出定时器类型。
</span><span class='line'>event = icsk-&gt;icsk_pending;
</span><span class='line'>icsk-&gt;icsk_pending = 0;
</span><span class='line'>
</span><span class='line'>//通过判断event来确定进入那个函数进行处理。
</span><span class='line'>switch (event) {
</span><span class='line'>case ICSK_TIME_RETRANS:
</span><span class='line'>    tcp_retransmit_timer(sk);
</span><span class='line'>    break;
</span><span class='line'>case ICSK_TIME_PROBE0:
</span><span class='line'>    tcp_probe_timer(sk);
</span><span class='line'>    break;
</span><span class='line'>}
</span><span class='line'>TCP_CHECK_TIMER(sk);
</span><span class='line'>
</span><span class='line'>out:
</span><span class='line'>sk_mem_reclaim(sk);
</span><span class='line'>out_unlock:
</span><span class='line'>bh_unlock_sock(sk);
</span><span class='line'>sock_put(sk);
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;我们这里只看重传定时器，0窗口定时器后面紧接着会介绍。  
</span><span class='line'>tcp_retransmit_timer,这个函数用来处理数据段的重传。  
</span><span class='line'>这里要注意，重传的时候为了防止确认二义性，使用karn算法，也就是定时器退避策略。下面的代码最后部分会修改定时器的值，这里是增加一倍。
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static void tcp_retransmit_timer(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>struct inet_connection_sock *icsk = inet_csk(sk);
</span><span class='line'>
</span><span class='line'>//如果没有需要确认的段，则什么也不做。
</span><span class='line'>if (!tp-&gt;packets_out)
</span><span class='line'>    goto out;
</span><span class='line'>
</span><span class='line'>WARN_ON(tcp_write_queue_empty(sk));
</span><span class='line'>
</span><span class='line'>/**首先进行一些合法性判断，其中:
</span><span class='line'> * snd_wnd为窗口大小。
</span><span class='line'> * sock_flag用来判断sock的状态。
</span><span class='line'> * 最后一个判断是当前的连接状态不能处于syn_sent和syn_recv状态,也就是连接还未建
</span><span class='line'> * 立状态.
</span><span class='line'>if (!tp-&gt;snd_wnd &amp;&amp; !sock_flag(sk, SOCK_DEAD) &amp;&amp;
</span><span class='line'>    !((1 &lt;&lt; sk-&gt;sk_state) &amp; (TCPF_SYN_SENT | TCPF_SYN_RECV))) {
</span><span class='line'>    //tcp_time_stamp也就是jifes，而rcv_tstamp表示最后一个ack接收的时间，也就是最后一次对端确认的时间。因此这两个时间之差不能大于tcp_rto_max,因为tcp_rto_max为我们重传定时器的间隔时间的最大值。
</span><span class='line'>    if (tcp_time_stamp - tp-&gt;rcv_tstamp &gt; TCP_RTO_MAX) {
</span><span class='line'>        tcp_write_err(sk);
</span><span class='line'>        goto out;
</span><span class='line'>    }
</span><span class='line'>    //这个函数用来进入loss状态，也就是进行一些拥塞以及流量的控制。
</span><span class='line'>    tcp_enter_loss(sk, 0);
</span><span class='line'>    //现在开始重传skb。
</span><span class='line'>    tcp_retransmit_skb(sk, tcp_write_queue_head(sk));
</span><span class='line'>    __sk_dst_reset(sk);
</span><span class='line'>    //然后重启定时器，继续等待ack的到来。
</span><span class='line'>    goto out_reset_timer;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>//程序到达这里说明上面的校验失败，因此下面这个函数用来判断我们重传需要的次数。如果超过了重传次数，直接跳转到out。
</span><span class='line'>if (tcp_write_timeout(sk))
</span><span class='line'>    goto out;
</span><span class='line'>
</span><span class='line'>//到达这里说明我们重传的次数还没到。icsk-&gt;icsk_retransmits表示重传的次数。
</span><span class='line'>if (icsk-&gt;icsk_retransmits == 0) {
</span><span class='line'>    //这里其实也就是收集一些统计信息。
</span><span class='line'>    int mib_idx;
</span><span class='line'>
</span><span class='line'>    if (icsk-&gt;icsk_ca_state == TCP_CA_Disorder) {
</span><span class='line'>        if (tcp_is_sack(tp))
</span><span class='line'>            mib_idx = LINUX_MIB_TCPSACKFAILURES;
</span><span class='line'>        else
</span><span class='line'>            mib_idx = LINUX_MIB_TCPRENOFAILURES;
</span><span class='line'>    } else if (icsk-&gt;icsk_ca_state == TCP_CA_Recovery) {
</span><span class='line'>        if (tcp_is_sack(tp))
</span><span class='line'>            mib_idx = LINUX_MIB_TCPSACKRECOVERYFAIL;
</span><span class='line'>        else
</span><span class='line'>            mib_idx = LINUX_MIB_TCPRENORECOVERYFAIL;
</span><span class='line'>    } else if (icsk-&gt;icsk_ca_state == TCP_CA_Loss) {
</span><span class='line'>        mib_idx = LINUX_MIB_TCPLOSSFAILURES;
</span><span class='line'>    } else {
</span><span class='line'>        mib_idx = LINUX_MIB_TCPTIMEOUTS;
</span><span class='line'>    }
</span><span class='line'>    NET_INC_STATS_BH(sock_net(sk), mib_idx);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>//是否使用f-rto算法。
</span><span class='line'>if (tcp_use_frto(sk)) {
</span><span class='line'>    tcp_enter_frto(sk);
</span><span class='line'>} else {
</span><span class='line'>    //否则处理sack.
</span><span class='line'>    tcp_enter_loss(sk, 0);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>// 再次尝试重传队列的第一个段。
</span><span class='line'>if (tcp_retransmit_skb(sk, tcp_write_queue_head(sk)) &gt; 0) {
</span><span class='line'>    //重传失败。
</span><span class='line'>    if (!icsk-&gt;icsk_retransmits)
</span><span class='line'>        icsk-&gt;icsk_retransmits = 1;
</span><span class='line'>    inet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS,
</span><span class='line'>                  min(icsk-&gt;icsk_rto, TCP_RESOURCE_PROBE_INTERVAL),
</span><span class='line'>                  TCP_RTO_MAX);
</span><span class='line'>    goto out;
</span><span class='line'>}
</span><span class='line'>//icsk-&gt;icsk_backoff主要用在零窗口定时器。
</span><span class='line'>icsk-&gt;icsk_backoff++;
</span><span class='line'>//icsk_retransmits也就是重试次数。
</span><span class='line'>icsk-&gt;icsk_retransmits++;
</span><span class='line'>
</span><span class='line'>out_reset_timer:
</span><span class='line'>//计算rto，并重启定时器，这里使用karn算法，也就是下次超时时间增加一倍/
</span><span class='line'>icsk-&gt;icsk_rto = min(icsk-&gt;icsk_rto &lt;&lt; 1, TCP_RTO_MAX);
</span><span class='line'>//重启定时器，可以看到超时时间就是我们上面的icsk_rto.
</span><span class='line'>inet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS, icsk-&gt;icsk_rto, TCP_RTO_MAX);
</span><span class='line'>if (icsk-&gt;icsk_retransmits &gt; sysctl_tcp_retries1)
</span><span class='line'>    __sk_dst_reset(sk);
</span><span class='line'>
</span><span class='line'>out:;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;下面我们来看tcp_write_timeout，它用来判断重传次数是否已经到了。这里主要分为两个分支，一个是状态为syn_sent或者syn_recv状态，一个是另外的状态。而这里系统设置的重传次数一共有4种。  
</span><span class='line'>1 sysctl_tcp_syn_retries，它表示syn分节的重传次数。  
</span><span class='line'>2 sysctl_tcp_retries1 它表示的是最大的重试次数，当超过了这个值，我们就需要检测路由表了。  
</span><span class='line'>3 sysctl_tcp_retries2 这个值也是表示重试最大次数，只不过这个值一般要比上面的值大。和上面那个不同的是，当重试次数超过这个值，我们就必须放弃重试了。  
</span><span class='line'>4 sysctl_tcp_orphan_retries 主要是针对孤立的socket(也就是已经从进程上下文中删除了，可是还有一些清理工作没有完成).对于这种socket，我们重试的最大的次数就是它。  
</span><span class='line'>下面来看代码：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static int tcp_write_timeout(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>struct inet_connection_sock *icsk = inet_csk(sk);
</span><span class='line'>//retry_untry表示我们需要重传的最大次数。
</span><span class='line'>int retry_until;
</span><span class='line'>
</span><span class='line'>//判断socket状态。
</span><span class='line'>if ((1 &lt;&lt; sk-&gt;sk_state) &amp; (TCPF_SYN_SENT | TCPF_SYN_RECV)) {
</span><span class='line'>    if (icsk-&gt;icsk_retransmits)
</span><span class='line'>        dst_negative_advice(&amp;sk-&gt;sk_dst_cache);
</span><span class='line'>    //设置重传最大值
</span><span class='line'>    retry_until = icsk-&gt;icsk_syn_retries ? : sysctl_tcp_syn_retries;
</span><span class='line'>} else {
</span><span class='line'>    //是否需要检测路由表。
</span><span class='line'>    if (icsk-&gt;icsk_retransmits &gt;= sysctl_tcp_retries1) {
</span><span class='line'>        /* Black hole detection */
</span><span class='line'>        tcp_mtu_probing(icsk, sk);
</span><span class='line'>
</span><span class='line'>        dst_negative_advice(&amp;sk-&gt;sk_dst_cache);
</span><span class='line'>    }
</span><span class='line'>    //设置重传最大次数为sysctl_tcp_retries2
</span><span class='line'>    retry_until = sysctl_tcp_retries2;
</span><span class='line'>    if (sock_flag(sk, SOCK_DEAD)) {
</span><span class='line'>        //表示是一个孤立的socket。
</span><span class='line'>        const int alive = (icsk-&gt;icsk_rto &lt; TCP_RTO_MAX);
</span><span class='line'>
</span><span class='line'>        //从tcp_orphan_retries(这个函数中会通过sysctl_tcp_orphan_retries来进行计算)中取得重传最大次数。
</span><span class='line'>        retry_until = tcp_orphan_retries(sk, alive);
</span><span class='line'>
</span><span class='line'>        if (tcp_out_of_resources(sk, alive || icsk-&gt;icsk_retransmits &lt; retry_until))
</span><span class='line'>            return 1;
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>//最终进行判断，如果重传次数已到则返回1,否则为0.
</span><span class='line'>if (icsk-&gt;icsk_retransmits &gt;= retry_until) {
</span><span class='line'>    /* Has it gone just too far? */
</span><span class='line'>    tcp_write_err(sk);
</span><span class='line'>    return 1;
</span><span class='line'>}
</span><span class='line'>return 0;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;下面来介绍下tcp_enter_loss，这个函数主要用来标记丢失的段(也就是没有acked的段),然后通过执行slow start来降低传输速率.  
</span><span class='line'>有关slow start以及Congestion avoidance算法描述可以看rfc2001:  
</span><span class='line'>http://www.faqs.org/rfcs/rfc2001.html
</span><span class='line'>
</span><span class='line'>下面4个算法主要是用来对拥塞进行控制的，这四个算法其实都是彼此相连的。slow start和Congestion avoidance使用了相同的机制，他们都涉及到了拥塞窗口的定义。其中拥塞窗口限制着传输的长度，它的大小根据拥塞程度上升或者下降。  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Slow start
</span><span class='line'>Congestion avoidance
</span><span class='line'>Fast re-transmit
</span><span class='line'>Fast recovery
</span><span class='line'>&lt;code&gt;
</span><span class='line'>然后下面主要是介绍了slow start和Congestion avoidance的一些实现细节。
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>CWND - Sender side limit
</span><span class='line'>RWND - Receiver side limit
</span><span class='line'>Slow start threshold ( SSTHRESH ) - Used to determine whether slow start is used or congestion avoidance
</span><span class='line'>When starting, probe slowly - IW &lt;= 2 * SMSS
</span><span class='line'>Initial size of SSTHRESH can be arbitrarily high, as high as the RWND
</span><span class='line'>Use slow start when SSTHRESH &gt; CWND. Else, use Congestion avoidance
</span><span class='line'>Slow start - CWND is increased by an amount less than or equal to the SMSS for every ACK
</span><span class='line'>Congestion avoidance - CWND += SMSS&lt;em&gt;SMSS/CWND
</span><span class='line'>When loss is detected - SSTHRESH = max( FlightSize/2, 2&lt;/em&gt;SMSS )</span></code></pre></td></tr></table></div></figure>
这里要注意在slow start中，窗口的大小是指数级的增长的。并且当cwnd(拥塞窗口)小于等于ssthresh，就是slow start模式，否则就执行Congestion avoidance。</p>

<h5>现在我们来看tcp_enter_loss的实现。</h5>

<p>首先来介绍下下面要用到的几个关键域的含义。<br/>
1 icsk->icsk_ca_state 这个域表示拥塞控制的状态。<br/>
2 tp->snd_una 这个域表示tcp滑动窗口中的发送未确认的第一个字节的序列号。<br/>
3 tp->prior_ssthresh 这个域表示前一个snd_ssthresh得大小，也就是说每次改变snd_ssthresh前都要保存老的snd_ssthresh到这个域。<br/>
4 tp->snd_ssthresh  slow start开始时的threshold大小<br/>
5 tp->snd_cwnd_cnt 这个域表示拥塞窗口的大小。<br/>
6 TCP_SKB_CB(skb)->sacked tcp数据中的sack标记。<br/>
7 tp->high_seq 拥塞开始时，snd_nxt的大小。<br/>
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
<span class='line-number'>206</span>
<span class='line-number'>207</span>
<span class='line-number'>208</span>
<span class='line-number'>209</span>
<span class='line-number'>210</span>
<span class='line-number'>211</span>
<span class='line-number'>212</span>
<span class='line-number'>213</span>
<span class='line-number'>214</span>
<span class='line-number'>215</span>
<span class='line-number'>216</span>
<span class='line-number'>217</span>
<span class='line-number'>218</span>
<span class='line-number'>219</span>
<span class='line-number'>220</span>
<span class='line-number'>221</span>
<span class='line-number'>222</span>
<span class='line-number'>223</span>
<span class='line-number'>224</span>
<span class='line-number'>225</span>
<span class='line-number'>226</span>
<span class='line-number'>227</span>
<span class='line-number'>228</span>
<span class='line-number'>229</span>
<span class='line-number'>230</span>
<span class='line-number'>231</span>
<span class='line-number'>232</span>
<span class='line-number'>233</span>
<span class='line-number'>234</span>
<span class='line-number'>235</span>
<span class='line-number'>236</span>
<span class='line-number'>237</span>
<span class='line-number'>238</span>
<span class='line-number'>239</span>
<span class='line-number'>240</span>
<span class='line-number'>241</span>
<span class='line-number'>242</span>
<span class='line-number'>243</span>
<span class='line-number'>244</span>
<span class='line-number'>245</span>
<span class='line-number'>246</span>
<span class='line-number'>247</span>
<span class='line-number'>248</span>
<span class='line-number'>249</span>
<span class='line-number'>250</span>
<span class='line-number'>251</span>
<span class='line-number'>252</span>
<span class='line-number'>253</span>
<span class='line-number'>254</span>
<span class='line-number'>255</span>
<span class='line-number'>256</span>
<span class='line-number'>257</span>
<span class='line-number'>258</span>
<span class='line-number'>259</span>
<span class='line-number'>260</span>
<span class='line-number'>261</span>
<span class='line-number'>262</span>
<span class='line-number'>263</span>
<span class='line-number'>264</span>
<span class='line-number'>265</span>
<span class='line-number'>266</span>
<span class='line-number'>267</span>
<span class='line-number'>268</span>
<span class='line-number'>269</span>
<span class='line-number'>270</span>
<span class='line-number'>271</span>
<span class='line-number'>272</span>
<span class='line-number'>273</span>
<span class='line-number'>274</span>
<span class='line-number'>275</span>
<span class='line-number'>276</span>
<span class='line-number'>277</span>
<span class='line-number'>278</span>
<span class='line-number'>279</span>
<span class='line-number'>280</span>
<span class='line-number'>281</span>
<span class='line-number'>282</span>
<span class='line-number'>283</span>
<span class='line-number'>284</span>
<span class='line-number'>285</span>
<span class='line-number'>286</span>
<span class='line-number'>287</span>
<span class='line-number'>288</span>
<span class='line-number'>289</span>
<span class='line-number'>290</span>
<span class='line-number'>291</span>
<span class='line-number'>292</span>
<span class='line-number'>293</span>
<span class='line-number'>294</span>
<span class='line-number'>295</span>
<span class='line-number'>296</span>
<span class='line-number'>297</span>
<span class='line-number'>298</span>
<span class='line-number'>299</span>
<span class='line-number'>300</span>
<span class='line-number'>301</span>
<span class='line-number'>302</span>
<span class='line-number'>303</span>
<span class='line-number'>304</span>
<span class='line-number'>305</span>
<span class='line-number'>306</span>
<span class='line-number'>307</span>
<span class='line-number'>308</span>
<span class='line-number'>309</span>
<span class='line-number'>310</span>
<span class='line-number'>311</span>
<span class='line-number'>312</span>
<span class='line-number'>313</span>
<span class='line-number'>314</span>
<span class='line-number'>315</span>
<span class='line-number'>316</span>
<span class='line-number'>317</span>
<span class='line-number'>318</span>
<span class='line-number'>319</span>
<span class='line-number'>320</span>
<span class='line-number'>321</span>
<span class='line-number'>322</span>
<span class='line-number'>323</span>
<span class='line-number'>324</span>
<span class='line-number'>325</span>
<span class='line-number'>326</span>
<span class='line-number'>327</span>
<span class='line-number'>328</span>
<span class='line-number'>329</span>
<span class='line-number'>330</span>
<span class='line-number'>331</span>
<span class='line-number'>332</span>
<span class='line-number'>333</span>
<span class='line-number'>334</span>
<span class='line-number'>335</span>
<span class='line-number'>336</span>
<span class='line-number'>337</span>
<span class='line-number'>338</span>
<span class='line-number'>339</span>
<span class='line-number'>340</span>
<span class='line-number'>341</span>
<span class='line-number'>342</span>
<span class='line-number'>343</span>
<span class='line-number'>344</span>
<span class='line-number'>345</span>
<span class='line-number'>346</span>
<span class='line-number'>347</span>
<span class='line-number'>348</span>
<span class='line-number'>349</span>
<span class='line-number'>350</span>
<span class='line-number'>351</span>
<span class='line-number'>352</span>
<span class='line-number'>353</span>
<span class='line-number'>354</span>
<span class='line-number'>355</span>
<span class='line-number'>356</span>
<span class='line-number'>357</span>
<span class='line-number'>358</span>
<span class='line-number'>359</span>
<span class='line-number'>360</span>
<span class='line-number'>361</span>
<span class='line-number'>362</span>
<span class='line-number'>363</span>
<span class='line-number'>364</span>
<span class='line-number'>365</span>
<span class='line-number'>366</span>
<span class='line-number'>367</span>
<span class='line-number'>368</span>
<span class='line-number'>369</span>
<span class='line-number'>370</span>
<span class='line-number'>371</span>
<span class='line-number'>372</span>
<span class='line-number'>373</span>
<span class='line-number'>374</span>
<span class='line-number'>375</span>
<span class='line-number'>376</span>
<span class='line-number'>377</span>
<span class='line-number'>378</span>
<span class='line-number'>379</span>
<span class='line-number'>380</span>
<span class='line-number'>381</span>
<span class='line-number'>382</span>
<span class='line-number'>383</span>
<span class='line-number'>384</span>
<span class='line-number'>385</span>
<span class='line-number'>386</span>
<span class='line-number'>387</span>
<span class='line-number'>388</span>
<span class='line-number'>389</span>
<span class='line-number'>390</span>
<span class='line-number'>391</span>
<span class='line-number'>392</span>
<span class='line-number'>393</span>
<span class='line-number'>394</span>
<span class='line-number'>395</span>
<span class='line-number'>396</span>
<span class='line-number'>397</span>
<span class='line-number'>398</span>
<span class='line-number'>399</span>
<span class='line-number'>400</span>
<span class='line-number'>401</span>
<span class='line-number'>402</span>
<span class='line-number'>403</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void tcp_enter_loss(struct sock &lt;em&gt;sk, int how)
</span><span class='line'>{
</span><span class='line'>    const struct inet_connection_sock &lt;/em&gt;icsk = inet_csk(sk);
</span><span class='line'>    struct tcp_sock &lt;em&gt;tp = tcp_sk(sk);
</span><span class='line'>    struct sk_buff &lt;/em&gt;skb;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    /* 1 拥塞控制状态小于TCP_CA_Disorder
</span><span class='line'> * 2 发送未确认的序列号等于拥塞开始时的下一个将要发送的序列号
</span><span class='line'> * 3 状态为TCP_CA_Loss，并且还未重新传输过。
</span><span class='line'> * 如果有一个满足说明有数据丢失,因此降低threshold。
</span><span class='line'> */
</span><span class='line'>if (icsk-&gt;icsk_ca_state &lt;= TCP_CA_Disorder || tp-&gt;snd_una == tp-&gt;high_seq ||
</span><span class='line'>    (icsk-&gt;icsk_ca_state == TCP_CA_Loss &amp;&amp; !icsk-&gt;icsk_retransmits)) {
</span><span class='line'>    //保存老的snd_ssthresh。
</span><span class='line'>    tp-&gt;prior_ssthresh = tcp_current_ssthresh(sk);
</span><span class='line'>    //减小snd_ssthresh
</span><span class='line'>    tp-&gt;snd_ssthresh = icsk-&gt;icsk_ca_ops-&gt;ssthresh(sk);
</span><span class='line'>    //设置拥塞状态。
</span><span class='line'>    tcp_ca_event(sk, CA_EVENT_LOSS);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>//设置拥塞窗口大小
</span><span class='line'>tp-&gt;snd_cwnd    = 1;
</span><span class='line'>tp-&gt;snd_cwnd_cnt   = 0;
</span><span class='line'>//设置时间
</span><span class='line'>tp-&gt;snd_cwnd_stamp = tcp_time_stamp;
</span><span class='line'>
</span><span class='line'>tp-&gt;bytes_acked = 0;
</span><span class='line'>//清空所有相关的计数器。
</span><span class='line'>tcp_clear_retrans_partial(tp);
</span><span class='line'>
</span><span class='line'>if (tcp_is_reno(tp))
</span><span class='line'>    tcp_reset_reno_sack(tp);
</span><span class='line'>
</span><span class='line'>if (!how) {
</span><span class='line'>    /* Push undo marker, if it was plain RTO and nothing
</span><span class='line'>     * was retransmitted. */
</span><span class='line'>    tp-&gt;undo_marker = tp-&gt;snd_una;
</span><span class='line'>} else {
</span><span class='line'>    tp-&gt;sacked_out = 0;
</span><span class='line'>    tp-&gt;fackets_out = 0;
</span><span class='line'>}
</span><span class='line'>tcp_clear_all_retrans_hints(tp);
</span><span class='line'>
</span><span class='line'>//遍历sock的write队列。
</span><span class='line'>tcp_for_write_queue(skb, sk) {
</span><span class='line'>    if (skb == tcp_send_head(sk))
</span><span class='line'>        break;
</span><span class='line'>    //判断sack段。
</span><span class='line'>    if (TCP_SKB_CB(skb)-&gt;sacked &amp; TCPCB_RETRANS)
</span><span class='line'>        tp-&gt;undo_marker = 0;
</span><span class='line'>    TCP_SKB_CB(skb)-&gt;sacked &amp;= (~TCPCB_TAGBITS)|TCPCB_SACKED_ACKED;
</span><span class='line'>
</span><span class='line'>    //如果how为1,则说明不管sack段，此时标记所有的段为丢失(sack的意思去看tcp/ip详解).
</span><span class='line'>    if (!(TCP_SKB_CB(skb)-&gt;sacked&amp;TCPCB_SACKED_ACKED) || how) {
</span><span class='line'>        //设置sack段。
</span><span class='line'>        TCP_SKB_CB(skb)-&gt;sacked &amp;= ~TCPCB_SACKED_ACKED;
</span><span class='line'>        TCP_SKB_CB(skb)-&gt;sacked |= TCPCB_LOST;
</span><span class='line'>        //update 相关的域。
</span><span class='line'>        tp-&gt;lost_out += tcp_skb_pcount(skb);
</span><span class='line'>        tp-&gt;retransmit_high = TCP_SKB_CB(skb)-&gt;end_seq;
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>tcp_verify_left_out(tp);
</span><span class='line'>//设置当前的reordering的长度
</span><span class='line'>tp-&gt;reordering = min_t(unsigned int, tp-&gt;reordering,
</span><span class='line'>               sysctl_tcp_reordering);
</span><span class='line'>//设置拥塞状态。
</span><span class='line'>tcp_set_ca_state(sk, TCP_CA_Loss);
</span><span class='line'>tp-&gt;high_seq = tp-&gt;snd_nxt;
</span><span class='line'>//由于我们修改了拥塞窗口，因此设置ecn状态。
</span><span class='line'>TCP_ECN_queue_cwr(tp);
</span><span class='line'>/* Abort F-RTO algorithm if one is in progress */
</span><span class='line'>tp-&gt;frto_counter = 0;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;接 下来来看零窗口探测定时器。至于为什么会出现零窗口，这里就不阐述了，详细的可以去看tcp/ip详解。我们知道当0窗口之后,客户机会等待服务器端的窗 口打开报文，可是由于ip是不可靠的，有可能这个报文会丢失，因此就需要客户机发送一个探测段，用来提醒服务器及时汇报当前的窗口大小。这里我们知道当对 端接收窗口关闭后，我们这边的发送窗口也会关闭，此时不能发送任何一般的数据，除了探测段。  
</span><span class='line'>在内核中是通过tcp_ack_probe来控制零窗口的定时器的。也就是说接收到对端的窗口报告数据后，会进入这个函数。我们来看实现：  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static void tcp_ack_probe(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>const struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>struct inet_connection_sock *icsk = inet_csk(sk);
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>//首先判断是否对端的接收窗口是否已经有空间。
</span><span class='line'>if (!after(TCP_SKB_CB(tcp_send_head(sk))-&gt;end_seq, tcp_wnd_end(tp))) {
</span><span class='line'>    //如果有空间则删除零窗口探测定时器。
</span><span class='line'>    icsk-&gt;icsk_backoff = 0;
</span><span class='line'>    inet_csk_clear_xmit_timer(sk, ICSK_TIME_PROBE0);
</span><span class='line'>    /* Socket must be waked up by subsequent tcp_data_snd_check().
</span><span class='line'>     * This function is not for random using!
</span><span class='line'>     */
</span><span class='line'>} else {
</span><span class='line'>    //否则启动定时器。
</span><span class='line'>    inet_csk_reset_xmit_timer(sk, ICSK_TIME_PROBE0,
</span><span class='line'>                  min(icsk-&gt;icsk_rto &lt;&lt; icsk-&gt;icsk_backoff, TCP_RTO_MAX),
</span><span class='line'>                  TCP_RTO_MAX);
</span><span class='line'>}
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;我们知道零窗口定时器和重传的定时器是一个定时器，只不过在回调函数中，进行event判断，从而进入不同的处理。而它调用的是tcp_probe_timer函数。  
</span><span class='line'>这个函数主要就是用来发送探测包，我们来看它的实现：  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static void tcp_probe_timer(struct sock *sk)
</span><span class='line'>{
</span><span class='line'>struct inet_connection_sock *icsk = inet_csk(sk);
</span><span class='line'>struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>int max_probes;
</span><span class='line'>/* 1 tp-&gt;packets_out不为0说明，当定时器被安装之后，对端的接收窗口已经被打开。这* 时就不需要传输探测包。
</span><span class='line'> * 2 tcp_send_head用来检测是否有新的段被传输。
</span><span class='line'> * 如果上面有一个满足，则不需要发送探测包，并直接返回。
</span><span class='line'> */
</span><span class='line'>if (tp-&gt;packets_out || !tcp_send_head(sk)) {
</span><span class='line'>    icsk-&gt;icsk_probes_out = 0;
</span><span class='line'>    return;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>//设置最大的重试次数。
</span><span class='line'>max_probes = sysctl_tcp_retries2;
</span><span class='line'>
</span><span class='line'>//这里的处理和上面的tcp_write_timeout很类似。
</span><span class='line'>if (sock_flag(sk, SOCK_DEAD)) {
</span><span class='line'>    const int alive = ((icsk-&gt;icsk_rto &lt;&lt; icsk-&gt;icsk_backoff) &lt; TCP_RTO_MAX);
</span><span class='line'>
</span><span class='line'>    max_probes = tcp_orphan_retries(sk, alive);
</span><span class='line'>
</span><span class='line'>    if (tcp_out_of_resources(sk, alive || icsk-&gt;icsk_probes_out &lt;= max_probes))
</span><span class='line'>        return;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>//如果重试次数大于最大的重试次数，则报错。
</span><span class='line'>if (icsk-&gt;icsk_probes_out &gt; max_probes) {
</span><span class='line'>    tcp_write_err(sk);
</span><span class='line'>} else {
</span><span class='line'>    /* Only send another probe if we didn't close things up. */
</span><span class='line'>//否则发送探测包。这个函数里面会发送探测包，并重启定时器。
</span><span class='line'>    tcp_send_probe0(sk);
</span><span class='line'>}
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;然 后来看delay ack定时器。所谓的delay ack也就是ack不会马上发送，而是等待一段时间和数据一起发送，这样就减少了一个数据包的发送。这里一般是将ack包含在tcp option中发送的。这里的定时器就是用来控制这段时间，如果定时器到期，都没有数据要发送给对端，此时单独发送这个ack。如果在定时器时间内，有数 据要发送，此时这个ack和数据一起发送给对端。  
</span><span class='line'>前面我们知道delay ack定时器的回调函数是tcp_delack_timer。在分析这个函数之前，我们先来看下这个定时器是什么时候被启动的。  
</span><span class='line'>首先我们知道内核接收数据都是在tcp_rcv_eastablished实现的，当我们接收完数据后，此时进入是否进行delay ack.  
</span><span class='line'>在tcp_rcv_eastablished最终会调用__tcp_ack_snd_check进行判断。  
</span><span class='line'>可以看到这个函数很简单，就是判断是否需要发送delay ack，如果是则tcp_send_delayed_ack，否则直接发送ack恢复给对端。
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static void __tcp_ack_snd_check(struct sock *sk, int ofo_possible)
</span><span class='line'>{
</span><span class='line'>struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>
</span><span class='line'>/* 1 第一个判断表示多于一个的段在等待ack，并且我们的receive buf有足够的空间，
</span><span class='line'> *   这是因为这种情况，表明应用程序读取比较快，而对端的发送速度依赖于ack的到达时间，* 因此我们不希望对端减慢速度。
</span><span class='line'> * 2 这个sock处在quickack 模式
</span><span class='line'> * 3 我们有 out-of-order数据,此时必须马上给对端以确认。
</span><span class='line'> *   当上面的任意一个为真，则立即发送ack。
</span><span class='line'>**/
</span><span class='line'>if (((tp-&gt;rcv_nxt - tp-&gt;rcv_wup) &gt; inet_csk(sk)-&gt;icsk_ack.rcv_mss
</span><span class='line'>     /* ... and right edge of window advances far enough.
</span><span class='line'>      * (tcp_recvmsg() will send ACK otherwise). Or...
</span><span class='line'>      */
</span><span class='line'>     &amp;&amp; __tcp_select_window(sk) &gt;= tp-&gt;rcv_wnd) ||
</span><span class='line'>    /* We ACK each frame or... */
</span><span class='line'>    tcp_in_quickack_mode(sk) ||
</span><span class='line'>    /* We have out of order data. */
</span><span class='line'>    (ofo_possible &amp;&amp; skb_peek(&amp;tp-&gt;out_of_order_queue))) {
</span><span class='line'>    /* Then ack it now */
</span><span class='line'>    tcp_send_ack(sk);
</span><span class='line'>} else {
</span><span class='line'>    /* Else, send delayed ack. */
</span><span class='line'>    //在这里启动定时器。
</span><span class='line'>    tcp_send_delayed_ack(sk);
</span><span class='line'>}
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;上面还有一个tcp_in_quickack_mode，这个函数我们说了，它是用来判断是否处在quickack 模式。  
</span><span class='line'>来看这个函数：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static inline int tcp_in_quickack_mode(const struct sock *sk)
</span><span class='line'>{
</span><span class='line'>const struct inet_connection_sock *icsk = inet_csk(sk);
</span><span class='line'>return icsk-&gt;icsk_ack.quick &amp;&amp; !icsk-&gt;icsk_ack.pingpong;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;其中icsk-&gt;icsk_ack.pingpong域被设置的情况只有当tcp连接是交互式的，比如telnet等等。icsk-&gt;icsk_ack.quick表示能够 quickack的数量。
</span><span class='line'>然后我们来看tcp_delack_timer的实现。  
</span><span class='line'>在看之前，我们要知道icsk-&gt;icsk_ack.pending表示的是当前的ack的状态。
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static void tcp_delack_timer(unsigned long data)
</span><span class='line'>{
</span><span class='line'>struct sock *sk = (struct sock *)data;
</span><span class='line'>struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>struct inet_connection_sock *icsk = inet_csk(sk);
</span><span class='line'>
</span><span class='line'>bh_lock_sock(sk);
</span><span class='line'>//用户进程正在使用，则等会再尝试。
</span><span class='line'>if (sock_owned_by_user(sk)) {
</span><span class='line'>    /* Try again later. */
</span><span class='line'>    icsk-&gt;icsk_ack.blocked = 1;
</span><span class='line'>    NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_DELAYEDACKLOCKED);
</span><span class='line'>    sk_reset_timer(sk, &amp;icsk-&gt;icsk_delack_timer, jiffies + TCP_DELACK_MIN);
</span><span class='line'>    goto out_unlock;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>sk_mem_reclaim_partial(sk);
</span><span class='line'>
</span><span class='line'>//判断sock状态 以及ack的状态。如果是close或者已经处在ICSK_ACK_TIMER，则直接跳出。
</span><span class='line'>if (sk-&gt;sk_state == TCP_CLOSE || !(icsk-&gt;icsk_ack.pending &amp; ICSK_ACK_TIMER))
</span><span class='line'>    goto out;
</span><span class='line'>
</span><span class='line'>//如果已经超时，则重启定时器，并退出。
</span><span class='line'>if (time_after(icsk-&gt;icsk_ack.timeout, jiffies)) {
</span><span class='line'>    sk_reset_timer(sk, &amp;icsk-&gt;icsk_delack_timer, icsk-&gt;icsk_ack.timeout);
</span><span class='line'>    goto out;
</span><span class='line'>}
</span><span class='line'>//清除ack状态。
</span><span class='line'>icsk-&gt;icsk_ack.pending &amp;= ~ICSK_ACK_TIMER;
</span><span class='line'>
</span><span class='line'>//开始遍历prequeue。此时主要的目的是为了调用tcp_rcv_eastablished.这里会调用tcp_ack_snd_check来发送ack。
</span><span class='line'>if (!skb_queue_empty(&amp;tp-&gt;ucopy.prequeue)) {
</span><span class='line'>    struct sk_buff *skb;
</span><span class='line'>
</span><span class='line'>    NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPSCHEDULERFAILED);
</span><span class='line'>
</span><span class='line'>    //遍历prequeue队列，发送未发送的ack。
</span><span class='line'>    while ((skb = __skb_dequeue(&amp;tp-&gt;ucopy.prequeue)) != NULL)
</span><span class='line'>        sk_backlog_rcv(sk, skb);
</span><span class='line'>
</span><span class='line'>    tp-&gt;ucopy.memory = 0;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>//检测是否有ack还需要被发送。也就是处于ICSK_ACK_SCHED状态的ack
</span><span class='line'>if (inet_csk_ack_scheduled(sk)) {
</span><span class='line'>
</span><span class='line'>    if (!icsk-&gt;icsk_ack.pingpong) {
</span><span class='line'>        /* Delayed ACK missed: inflate ATO. */
</span><span class='line'>        icsk-&gt;icsk_ack.ato = min(icsk-&gt;icsk_ack.ato &lt;&lt; 1, icsk-&gt;icsk_rto);
</span><span class='line'>    } else {
</span><span class='line'>        //到这里说明已经长时间没有通信，并且处于交互模式。这个时候我们需要关闭pingpong模式。
</span><span class='line'>        icsk-&gt;icsk_ack.pingpong = 0;
</span><span class='line'>        icsk-&gt;icsk_ack.ato      = TCP_ATO_MIN;
</span><span class='line'>    }
</span><span class='line'>    //立即发送ack。
</span><span class='line'>    tcp_send_ack(sk);
</span><span class='line'>    NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_DELAYEDACKS);
</span><span class='line'>}
</span><span class='line'>TCP_CHECK_TIMER(sk);
</span><span class='line'>
</span><span class='line'>out:
</span><span class='line'>if (tcp_memory_pressure)
</span><span class='line'>    sk_mem_reclaim(sk);
</span><span class='line'>out_unlock:
</span><span class='line'>bh_unlock_sock(sk);
</span><span class='line'>sock_put(sk);
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[接收包的主流程]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2013/09/09/kernel-net-rx/"/&gt;
</span><span class='line'>&lt;updated&gt;2013-09-09T18:10:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2013/09/09/kernel-net-rx&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;pre&gt;&lt;code&gt;    int tcp_v4_rcv(struct sk_buff *skb)    linux/net/ipv4/tcp_ipv4.c #1611
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  //tcp刚刚收到从ipv4发上来的包&lt;br/&gt;
</span><span class='line'>  （struct tcphdr: 定义在/include/net/tcp.h中，即包的tcp首部，不包括options部分）&lt;br/&gt;
</span><span class='line'>  （struct sock ：定义在/include/net/sock.h中，即表示socket）&lt;br/&gt;
</span><span class='line'>  检查skb-&gt;pkt_type != PACKET_HOST 则丢弃&lt;br/&gt;
</span><span class='line'>  检查th-&gt;doff &lt; sizeof(struct tcphdr) / 4，即首部大小不合理，则丢弃&lt;br/&gt;
</span><span class='line'>  检查checksum&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  （TCP_SKB_CB(skb)：定义在tcp.h是获取一个实际指向skb-&gt;cb[0]的tcp_skb_cb类型指针；将到达的首部剥离后，从中拷贝一些信息到这个变量，供tcp控制功能使用；tcp_skb_cb是在tcp刚收到时填写在包中的）&lt;br/&gt;
</span><span class='line'>  注意：&lt;br/&gt;
</span><span class='line'>    1. tcp_skb_cb-&gt;end_seq = seq + th-&gt;fin + th-&gt;fin + len-doff*4&lt;br/&gt;
</span><span class='line'>    2. when 和 sacked 没有被赋值&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  sk = __inet_lookup(&hellip;) 从一个hash表中获取该收包对应的sock结构，根据源IP地址+端口，目的IP地址+端口，inet_iif检查sk-&gt;sk_state == TCP_TIME_WAIT，TCP在该状态下则丢弃任何接收到的包并转入后续的特殊处理（未看，和关闭连接的状态迁移有关需要后续来看$），马上准备进入CLOSED状态了；&lt;br/&gt;
</span><span class='line'>  检查sk_filter(sk,skb)，则被过滤器阻拦，丢弃&lt;br/&gt;
</span><span class='line'>  检查!sock_owned_by_user(sk)，不明白sock-&gt;sk_lock的意义是什么，只有检查满足才能进入接收，否则 sk_add_backlog(sk, skb)将该sk_buff记录进sk_backlog队列；（注意这部操作加锁了！）&lt;br/&gt;
</span><span class='line'>（struct tcp_sock *tp = tcp_sk(sk)：tcp_sock定义在tcp.h中，通过tcp_sk直接将sock指针转换为tcp_sock型）&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  ret = tcp_v4_do_rcv(sk, skb) 进入进一步接收处理！&lt;br/&gt;
</span><span class='line'>（之后的异常操作未看）&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;hr /&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    int tcp_v4_do_rcv(struct sock *sk, struct sk_buff *skb)    linux/net/ipv4/tcp_ipv4.c #1542
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  //在正常状态下由tcp_v4_rcv调用，进一步进行针对接收包的处理&lt;br/&gt;
</span><span class='line'>  检查sk-&gt;sk_state == TCP_ESTABLISHED&lt;br/&gt;
</span><span class='line'>则tcp_rcv_established(sk, skb, skb-&gt;h.th, skb-&gt;len)，连接已经建立，则进入进一步接收处理！&lt;br/&gt;
</span><span class='line'>  检查sk-&gt;sk_state == TCP_LISTEN，&lt;br/&gt;
</span><span class='line'>则struct sock *nsk = tcp_v4_hnd_req(sk, skb);    //该函数中判断能否找到已有的连接请求，如果有则说明接收到的是一个ack并在其中创建一个新的sock即nsk；如果没有则说明接收到的是 syn，nsk即为sk；&lt;br/&gt;
</span><span class='line'>  if(nsk!=sk) tcp_child_process(sk,nsk,skb)    //当nsk==sk时，接收的是SYN，不进行此步直接进入tcp_rcv_state_process；否则是ack说明已经创建好了的nsk，在 tcp_child_process对nsk进行tcp_rcv_state_process状态转移处理；&lt;br/&gt;
</span><span class='line'>  tcp_rcv_state_process(sk, skb, skb-&gt;h.th, skb-&gt;len); 非常重要函数！处理tcp的状态转移&lt;br/&gt;
</span><span class='line'>  reset: tcp_v4_send_reset(rsk, skb);    reset，未看$&lt;br/&gt;
</span><span class='line'>  discard: kfree_skb(skb);&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;hr /&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    int tcp_rcv_established(struct sock *sk, struct sk_buff *skb,struct tcphdr *th, unsigned len)    linux/net/ipv4/tcp_input.c #3881
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Header Prediction：基于效率的考虑，将包的处理后续阶段分为fast path和slow path两种，前者用于普通的包，后者用于特殊的包；该header prediction即用于区分两种包的流向。&lt;br/&gt;
</span><span class='line'>1.(tcp_flag_word(th) &amp; TCP_HP_BITS) == tp-&gt;pred_flags 判断标志位是不是正常情况；tcp_flag_word返回指向tcphdr的第三个32位基址（即length前面），而TCP_HP_BITS是把 PSH标志位给屏蔽掉即该位值不影响流向；所以总的来说pred_flag应该等于0xS?10 &lt;&lt; 16 + snd_wnd（那么pred_flag是在tcp_fast_path_check或tcp_fast_path_on中更新值的）&lt;br/&gt;
</span><span class='line'>2.TCP_SKB_CB(skb)-&gt;seq == tp-&gt;rcv_nxt 判断所收包是否为我们正想要接收的，非乱序包&lt;br/&gt;
</span><span class='line'>3.*ptr != htonl((TCPOPT_NOP &lt;&lt; 24) | (TCPOPT_NOP &lt;&lt; 16) | (TCPOPT_TIMESTAMP &lt;&lt; 8) | TCPOLEN_TIMESTAMP) 若包中没有正常的timestamp选项则转入slow path
</span><span class='line'> timestamp选项处理： 从包中的ts选项中获取数据，以此刷新tp-&gt;rx_opt的saw_tstamp,rcv_tsval,rcv_tsecr域；ts选项含三个 32bit，其中后两个分别记录着tsval和tsecr；（注意，ts_recent并不在此处更新，在后面的tcp_store_ts_recent 中更新）&lt;br/&gt;
</span><span class='line'>  struct tcp_options_received: 定义在tcp.h中，其中saw_tstamp表明timestamp选项是否有效，ts_recent_stamp是我们最近一次更新 ts_recent的时间，ts_recent是下一次回显的时戳一般等于下次发包中的rcv_tsecr；rcv_tsval是该data从发端发出时的时戳值，rcv_tsecr是回显时间戳（即该ack对应的data或者该data对应的上次ack中的ts_tsval值），（注意两端时钟无需同步；当ack被收端推迟时，所回复的ack中的timestamp指向所回复包群中的第一个确认包 “When an incoming segment belongs to the current window, but arrives out of order (which implies that an earlier segment was lost), the timestamp of the earlier segment is returned as soon as it arrives, rather than the timestamp of the segment that arrived out of order.”这条细节未看明白$）从包中的时间戳选项中记录这两个值&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;4.PAWS check：(s32)(tp-&gt;rx_opt.rcv_tsval - tp-&gt;rx_opt.ts_recent) &lt; 0，则转入slow path&lt;br/&gt;
</span><span class='line'>  （PAWS:Protection Against Wrapped Sequence Numbers, SeqNo有可能会有回环交叠（因为它最大只有32bit），两个相同序号的包实际上是不同的两个包，此时判断tsval是否小于ts_recent即判断该包是否是一个过去时间的一个多余的包，然后将其作为一个重复包丢弃）&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;Fast Path：&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  1.当len == tcp_header_len，即这是一个纯ack（区别于piggyback），注意这是个纯ack，所以它通过长度来进行判断而不是标识！&lt;br/&gt;
</span><span class='line'>tcp_store_ts_recent(tp): tp-&gt;rx_opt.ts_recent = tp-&gt;rx_opt.rcv_tsval;&lt;br/&gt;
</span><span class='line'>tcp_ack(sk, skb, 0) 处理ack，进一步处理，未看！&lt;br/&gt;
</span><span class='line'>&lt;code&gt;__kfree_skb(skb)&lt;/code&gt; 释放该包&lt;br/&gt;
</span><span class='line'> tcp_data_snd_check(sk,tp) 检查有无更进一步的data包处理&lt;br/&gt;
</span><span class='line'>  2.当len &lt; tcp_header_len，说明该包的首部太小，清除之；&lt;br/&gt;
</span><span class='line'>  3.当len &gt; tcp_header_len，它是一个data包，tcp_copy_to_iovec函数未看，它决定该payload是否可以直接拷贝给用户空间：&lt;br/&gt;
</span><span class='line'>可，tcp_store_ts_recent(tp);&lt;br/&gt;
</span><span class='line'>  tcp_rcv_rtt_measure_ts(sk,skb); //计算RTT&lt;br/&gt;
</span><span class='line'>  &lt;code&gt;__skb_pull(skb, tcp_header_len);&lt;/code&gt; //剥tcp首部&lt;br/&gt;
</span><span class='line'>   tp-&gt;rcv_nxt = TCP_SKB_CB(skb)-&gt;end_seq; //更新rcv_next&lt;br/&gt;
</span><span class='line'>($ 那么将data拷贝到用户空间的操作在何处体现？难道是在tcp_copy_to_iovec中？)&lt;br/&gt;
</span><span class='line'>不可，除了以上的操作之外，还要&lt;br/&gt;
</span><span class='line'>  &lt;code&gt;__skb_queue_tail(&amp;sk-&gt;sk_receive_queue, skb);&lt;/code&gt; //将该包加入到接收sk_buff队列尾部&lt;br/&gt;
</span><span class='line'>tcp_event_data_recv()：management tasks处理&lt;br/&gt;
</span><span class='line'>若TCP_SKB_CB(skb)-&gt;ack_seq != tp-&gt;snd_una，说明这是一个有效的ack包&lt;br/&gt;
</span><span class='line'>  tcp_ack(sk, skb, FLAG_DATA); //FLAG_DATA说明这是一个背在data上的ack&lt;br/&gt;
</span><span class='line'>  tcp_data_snd_check(sk, tp); //该函数调用tcp_push_pending_frames函数，如果sk-&gt;sk_send_head存在则最终调用 tcp_write_xmit函数发包&lt;br/&gt;
</span><span class='line'>  &lt;code&gt;__tcp_ack_snd_check(sk, 0);&lt;/code&gt; //检查基于该收包事件，有无进一步的ack包处理（Delayed ACK，Quick ACK）&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h5&gt;Slow Path：&lt;/h5&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  tcp_checksum_complete_user(sk, skb)：checksum检查&lt;br/&gt;
</span><span class='line'>  tcp_fast_parse_options(skb, th, tp)：timestamp选项检查；tcp_paws_discard(sk, skb)：PAWS检查&lt;br/&gt;
</span><span class='line'>  tcp_sequence(tp, TCP_SKB_CB(skb)-&gt;seq, TCP_SKB_CB(skb)-&gt;end_seq)：检查是否乱序，并在其中激活QuickACK模式&lt;br/&gt;
</span><span class='line'>上面两行中，都会再检查RST标志，若没激活则tcp_send_dupack，作用不明，貌似是针对该错包回复一个冗余的ack&lt;br/&gt;
</span><span class='line'>  检查RST标志，tcp_reset(sk) 该函数没什么操作，填写一些错误信息后进入tcp_done函数(该函数进行一些关闭tcp连接的收尾操作)&lt;br/&gt;
</span><span class='line'>  tcp_replace_ts_recent(tp, TCP_SKB_CB(skb)-&gt;seq)：更新timestamp信息&lt;br/&gt;
</span><span class='line'>  检查SYN标志，在连接已建立的状态下，收到SYN是错误的，因此tcp_reset(sk)&lt;br/&gt;
</span><span class='line'>  检查ACK标志，tcp_ack(sk, skb, FLAG_SLOWPATH)&lt;br/&gt;
</span><span class='line'>  tcp_rcv_rtt_measure_ts(sk, skb)：更新RTT&lt;br/&gt;
</span><span class='line'>  tcp_urg(sk, skb, th)：处理URG标志&lt;br/&gt;
</span><span class='line'>  tcp_data_queue(sk, skb)：处理接收包所含数据，未看&lt;br/&gt;
</span><span class='line'>  tcp_data_snd_check(sk, tp) &amp; tcp_ack_snd_check(sk)：检查有无进一步的data或ack发送&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;hr /&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    static void tcp_event_data_recv(struct sock *sk, struct tcp_sock *tp, struct sk_buff *skb)    linux/net/ipv4/tcp_input.c #502
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  //
</span><span class='line'>  inet_csk_schedule_ack(sk)：将icsk_pending置为ICSK_ACK_SCHED，但具体意义不明&lt;br/&gt;
</span><span class='line'>  （struct inet_connection_sock：/linux/include/net/inet_connection_sock，面向INET连接的 socket结构，记录着和tcp连接有关的很多变量，比如本函数要处理的ATO（Acknowledgement timeout）信息；tcp_sock是其上的拓展，它的具体意义尚待发掘）&lt;br/&gt;
</span><span class='line'>  tcp_measure_rcv_mss(sk, skb)：更新rcv_mss，说是与delayed ACK有关，但是具体是怎么运作的？&lt;br/&gt;
</span><span class='line'>  tcp_rcv_rtt_measure(tp)：更新RTT，为什么又更新一遍$&lt;br/&gt;
</span><span class='line'>  接下来的一些列操作是更新inet_connection_sock中的ATO信息，具体操作代码中有注释，但这些信息的运作方式还不明&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;hr /&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static int tcp_ack(struct sock *sk, struct sk_buff *skb, int flag)    /linux/net/ipv4/tcp_input.c #2491
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  //处理接受到的ack，内容非常复杂
</span><span class='line'>  首先介绍一下ack可以携带的各个FLAG：
</span><span class='line'>&lt;code&gt;
</span><span class='line'>FLAG_DATA：              Incoming frame contained data.
</span><span class='line'>FLAG_WIN_UPDATE：        Incoming ACK was a window update
</span><span class='line'>FLAG_DATA_ACKED：        This ACK acknowledged new data.
</span><span class='line'>FLAG_RETRANS_DATA_ACKED：Some of which was retransmitted.
</span><span class='line'>FLAG_SYN_ACKED：         This ACK acknowledged SYN.
</span><span class='line'>FLAG_DATA_SACKED：       New SACK.
</span><span class='line'>FLAG_ECE：               ECE in this ACK.
</span><span class='line'>FLAG_DATA_LOST：         SACK detected data lossage.
</span><span class='line'>FLAG_SLOWPATH：          Do not skip RFC checks for window update.
</span><span class='line'>FLAG_ACKED：             (FLAG_DATA_ACKED|FLAG_SYN_ACKED)
</span><span class='line'>FLAG_NOT_DUP：           (FLAG_DATA|FLAG_WIN_UPDATE|FLAG_ACKED)
</span><span class='line'>FLAG_CA_ALERT：          (FLAG_DATA_SACKED|FLAG_ECE)
</span><span class='line'>FLAG_FORWARD_PROGRESS： (FLAG_ACKED|FLAG_DATA_SACKED)
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>  prior_snd_una = tp-&gt;snd_una;ack_seq = TCP_SKB_CB(skb)-&gt;seq; ack = TCP_SKB_CB(skb)-&gt;ack_seq;&lt;br/&gt;
</span><span class='line'>  //1记录着上一次被确认的data序号；2记录着所收ack包的序号；3记录着所收ack包确认对象的data序号；&lt;br/&gt;
</span><span class='line'>  首先判断若ack在tp-&gt;snd_nxt之后或者在prio_snd_una之前，则说明该ack非法或者过时（在过时的情况下，若sacked打开则还需tcp_sacktag_write_queue处理） 24</span></code></pre></td></tr></table></div></figure>
    if (!(flag&amp;FLAG_SLOWPATH) &amp;&amp; after(ack, prior_snd_una))
        tcp_update_wl（即tp->snd_wl1 = ack_seq）; tp->snd_una=ack; //为什么此种情况下并不更新窗口？
    else
        flag |= tcp_ack_update_window(sk, tp, skb, ack, ack_seq);
        //nwin = ntohs(skb->h.th->window)从ack中记录通告窗口
        如果检查需要更新发送窗口，则tp->snd_wl1 = ack_seq; tp->snd_wnd = nwin;
        tp->snd_una = ack;
        if (TCP_SKB_CB(skb)->sacked) flag |= tcp_sacktag_write_queue(sk, skb, prior_snd_una); //该函数未看</p>

<pre><code>    tp-&gt;rcv_tstamp = tcp_time_stamp; //rcv_tstamp记录着最近一次收到ack的时戳
    prior_in_flight = tcp_packets_in_flight(tp);
    if(!tp-&gt;packets_out) icsk-&gt;icsk_prbes_out = 0;
    if (sk-&gt;sk_send_head) tcp_ack_probe(sk);    //若此时网络中没有data，直接进入zero-window probe的ack处理;通告窗口的数据已经得到处理，所以tcp_ack_probe中仅仅是重置probe计时器，即 icsk-&gt;icsk_retransmit_timer

    flag |= tcp_clean_rtx_queue(sk, &amp;seq_rtt);   //从重传队列中移除被确认的data包

    if (tcp_ack_is_dubious(sk, flag)) { //该函数判断此ack是否可疑，判真情况下具体是flag不为FLAG_NOT_DUP，或flag是FLAG_CA_ALERT，或 icsk_ca_state不为TCP_CA_OPEN状态
    if ((flag &amp; FLAG_DATA_ACKED) &amp;&amp; tcp_may_raise_cwnd(sk, flag))
    //如果这个包是一个对新数据包的ack，那么通过tcp_may_raise_cwnd函数来判断是否要进行窗口操作，判真情况下具体是flag不是 FLAG_ECE或snd_cwnd&lt;snd_ssthresh（慢启动？）且icsk_ca_state不为TCP_CA_RECOVERY和 TCP_CA_CWR状态（所以，为什么TCP_CA_LOSS状态可以增窗呢？）
        tcp_cong_avoid(sk, ack, seq_rtt, prior_in_flight, 0);  
    //该函数会调用icsk-&gt;icsk_ca_ops-&gt;cong_avoid(sk, ack, rtt, in_flight, good)， 这是个函数指针；另外会更新snd_cwnd_stamp
    tcp_fastretrans_alert(sk, prior_snd_una, prior_packets, flag); //未看，极其重要的函数
}else{
    if ((flag &amp; FLAG_DATA_ACKED)) tcp_cong_avoid(sk, ack, seq_rtt, prior_in_flight, 1);
}
</code></pre>

<pre><code>tcp_ack中有很多新的内容，都还未涉及，要注意！！！！！！

---------
</code></pre>

<pre><code>static void tcp_data_queue(struct sock *sk, struct sk_buff *skb)    /linux/net/ipv4/tcp_input.c #3139
</code></pre>

<p>```
  //将数据拷贝至用户空间<br/>
若TCP_SKB_CB(skb)->seq == TCP_SKB_CB(skb)->end_seq 则空包丢弃<br/>
__skb_pull(skb, th->doff*4) //剥离tcp首部</p>

<h5>1.若TCP_SKB_CB(skb)->seq == tp->rcv_nxt且tcp_receive_window(tp)!=0，非乱序且处于接受窗口中，正常的情况</h5>

<p>若tp->ucopy.task == current, tp->copied_seq == tp->rcv_nxt, tp->ucopy.len等条件满足，则可以拷贝至用户空间<br/>
  //current是什么不明？ucopy.len貌似是用户最先设定的数据包的量，每次收包之后减小直至零<br/>
    skb_copy_datagram_iovec(skb, 0, tp->ucopy.iov, chunk) //向ucopy.iov拷贝数据<br/>
    tcp_rcv_space_adjust(sk) //计算TCP接受buffer空间大小，拷贝完<br/>
tp->rcv_nxt = TCP_SKB_CB(skb)->end_seq;<br/>
if(th->fin) tcp_fin(skb, sk, th); //原来fin的处理在这里！<br/>
若!skb_queue_empty(&amp;tp->out_of_order_queue)<br/>
    tcp_ofo_queue(sk); //看out_of_order_queue中有没有可以移到receive_queue中<br/>
    tcp_sack_remove(tp) //RCV.NXT advances, some SACKs should be eaten<br/>
    tcp_fast_path_check(sk,tp)   //tp->pred_flag值的更新<br/>
  清除skb并return</p>

<h5>2.若!after(TCP_SKB_CB(skb)->end_seq, tp->rcv_nxt) 说明这是一个重传的包</h5>

<p>  tcp_dsack_set(tp, TCP_SKB_CB(skb)->seq, TCP_SKB_CB(skb)->end_seq);   //在其中打开并填写dsack信息,在dyokucate_sack[0]中从seq到end_seq，修改dsack和eff_sacks值<br/>
  tcp_enter_quickack_mode(sk); //进入quick ack模式<br/>
  清除skb并return<br/>
若!before(TCP_SKB_CB(skb)->seq, tp->rcv_nxt + tcp_receive_window(tp))<br/>
  清除skb并return<br/>
若before(TCP_SKB_CB(skb)->seq, tp->rcv_nxt) 说明这是一个Partial包，即seq&lt;rcv_next&lt;end_seq<br/>
  tcp_dsack_set(tp, TCP_SKB_CB(skb)->seq, tp->rcv_nxt); //填写dsack信息，从seq到rcv_nxt</p>

<h5>3. 其他情况，说明收到了一个乱序包</h5>

<p>若out_of_order_queue为空，则<br/>
（注：out_of_order_queue是一个sk_buff_head结构，它的prev/next指针分别指向最后一个和第一个sk_buff结构，块的排放顺序对应其序号的大小顺序）<br/>
  初始化sack相关域，num_sacks/eff_sacks为1，dsack为0，selective_acks[0]从seq到end_seq；<br/>
  <code>__skb_queue_head(&amp;tp-&gt;out_of_order_queue,skb);</code> //将收包加入out_of_order_queue的头部</p>

<p>若out_of_order_queue不为空，则首先获取skb1 = tp->out_of_order_queue.prev即最新的一个乱序块<br/>
  若seq == TCP_SKB_CB(skb1)->end_seq，说明收包能够接在最新乱序块的右边<br/>
    <code>__skb_append(skb1, skb, &amp;tp-&gt;out_of_order_queue);</code><br/>
    tp->selective_acks[0].end_seq = end_seq; //将新收包接在skb1的右边，看来第一个selective_acks块对应的是最新的乱序序列<br/>
  循环执行skb1=skb1->prev，直到找到!after(TCP_SKB_CB(skb1)->seq, seq)表明需要将收包插在此块之后，或skb1=(struct sk_buff<em>)&amp;tp->out_of_order_queue表明收包比队列中的所与块的序列都要小<br/>
    循环内需要找到收包与队列已有包中的重复部分，然后tcp_dsack_set设置该部分为dsack内容<br/>
  <code>__skb_insert(skb, skb1, skb1-&gt;next, &amp;tp-&gt;out_of_order_queue);</code> //将收包对应的块插入到队列中<br/>
  再次循环执行skb1=skb1->next，直到找到!after(end_seq, TCP_SKB_CB(skb1)->seq)表明需要将从收包到该包之间的所有包全部从队列中移除，或者skb1=(struct sk_buff</em>)&amp;tp->out_of_order_queue表明需要将收包之后的所有包都移出<br/>
    循环内需要将当前的队列包与收包的交叠部分设置为dsack值（当然随着循环的推进，dsack处于不断更新的状况），还要通过 <code>__skb_unlink(skb1, &amp;tp-&gt;out_of_order_queue)，__kfree_skb(skb1);</code>将当前的队列包移除<br/>
  （该处的两部循环，旨在通过比较队列中块的序号和所收包的序号范围，将队列中的包连续化，即消除孔洞）</p>

<hr />
]]></content>
  </entry>
  
</feed>
