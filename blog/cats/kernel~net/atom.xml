<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: kernel~net | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/kernel~net/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2015-03-19T18:36:29+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[TCP的TSO处理（一）]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/03/19/kernel-net-tso2/"/>
    <updated>2015-03-19T18:27:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/03/19/kernel-net-tso2</id>
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/zhangskd/article/details/7699081">http://blog.csdn.net/zhangskd/article/details/7699081</a></p>

<h4>概述</h4>

<p>In computer networking, large segment offload (LSO) is a technique for increasing outbound
throughput of high-bandwidth network connections by reducing CPU overhead. It works by queuing
up large buffers and letting the network interface card (NIC) split them into separate packets.
The technique is also called TCP segmentation offload (TSO) when applied to TCP, or generic
segmentation offload (GSO).</p>

<p>The inbound counterpart of large segment offload is large recive offload (LRO).</p>

<p>When large chunks of data are to be sent over a computer network, they need to be first broken
down to smaller segments that can pass through all the network elements like routers and
switches between the source and destination computers. This process it referred to as
segmentation. Segmentation is often done by the TCP protocol in the host computer. Offloading
this work to the NIC is called TCP segmentation offload (TSO).</p>

<p>For example, a unit of 64KB (65,536 bytes) of data is usually segmented to 46 segments of 1448
bytes each before it is sent over the network through the NIC. With some intelligence in the NIC,
the host CPU can hand over the 64KB of data to the NIC in a single transmit request, the NIC can
break that data down into smaller segments of 1448 bytes, add the TCP, IP, and data link layer
protocol headers——according to a template provided by the host&rsquo;s TCP/IP stack——to each
segment, and send the resulting frames over the network. This significantly reduces the work
done by the CPU. Many new NICs on the market today support TSO. [1]</p>

<h4>具体</h4>

<p>It is a method to reduce CPU workload of packet cutting in 1500byte and asking hardware to
perform the same functionality.</p>

<p>1.TSO feature is implemented using the hardware support. This means hardware should be
able to segment the packets in max size of 1500 byte and reattach the header with every
packets.</p>

<p>2.Every network hardware is represented by netdevice structure in kernel. If hardware supports
TSO, it enables the Segmentation offload features in netdevice, mainly represented by
&ldquo; NETIF_F_TSO&rdquo; and other fields. [2]</p>

<p>TCP Segmentation Offload is supported in Linux by the network device layer. A driver that wants
to offer TSO needs to set the NETIF_F_TSO bit in the network device structure. In order for a
device to support TSO, it needs to also support Net : TCP Checksum Offloading and
Net : Scatter Gather.</p>

<p>The driver will then receive super-sized skb&rsquo;s. These are indicated to the driver by
skb_shinfo(skb)->gso_size being non-zero. The gso_size is the size the hardware should
fragment the TCP data. TSO may change how and when TCP decides to send data. [3]</p>

<h4>实现</h4>

<pre><code>    /* This data is invariant across clones and lives at the end of the 
     * header data, ie. at skb-&gt;end. 
     */  
    struct skb_share_info {  
        ...  
       unsigned short gso_size; // 每个数据段的大小  
       unsigned short gso_segs; // skb被分割成多少个数据段  
       unsigned short gso_type;  
       struct sk_buff *frag_list; // 分割后的数据包列表  
       ...  
    }
</code></pre>

<pre><code>    /* Initialize TSO state of skb. 
     * This must be invoked the first time we consider transmitting 
     * SKB onto the wire. 
     */  
    static int tcp_init_tso_segs(struct sock *sk, struct sk_buff *skb,  
                                                unsigned int mss_now)  
    {  
        int tso_segs = tcp_skb_pcount(skb);  

        /* 如果还没有分段，或者有多个分段但是分段长度不等于当前MSS，则需处理*/  
        if (! tso_segs || (tso_segs &gt; 1 &amp;&amp; tcp_skb_mss(skb) != mss_now)) {  
            tcp_set_skb_tso_segs(sk, skb, mss_now);  

            tso_segs = tcp_skb_pcount(skb);/* 重新获取分段数量 */  
        }  
        return tso_segs;  
    }  

    /* Initialize TSO segments for a packet. */  
    static void tcp_set_skb_tso_segs(struct sock *sk, struct sk_buff *skb,  
                                            unsigned int mss_now)  
    {  
        /* 有以下情况则不需要分片： 
          * 1. 数据的长度不超过允许的最大长度MSS 
         * 2. 网卡不支持GSO 
         * 3. 网卡不支持重新计算校验和 
         */  
        if (skb-&gt;len &lt;= mss_now || ! sk_can_gso(sk) ||  
            skb-&gt;ip_summed == CHECKSUM_NONE) {  

            /* Avoid the costly divide in the normal non-TSO case.*/  
            skb_shinfo(skb)-&gt;gso_segs = 1;  
            skb_shinfo(skb)-&gt;gso_size = 0;  
            skb_shinfo(skb)-&gt;gso_type = 0;  
        } else {  

            /* 计算需要分成几个数据段*/  
            skb_shinfo(skb)-&gt;gso_segs = DIV_ROUND_UP(skb-&gt;len, mss_now);/*向上取整*/  
            skb_shinfo(skb)-&gt;gso_size = mss_now; /* 每个数据段的大小*/  
            skb_shinfo(skb)-&gt;gso_type = sk-&gt;sk_gso_type;  
        }  
    }  

    /* Due to TSO, an SKB can be composed of multiple actual packets.  
     * To keep these tracked properly, we use this. 
     */  
    static inline int tcp_skb_pcount (const struct sk_buff *skb)  
    {  
        return skb_shinfo(skb)-&gt;gso_segs;  
    }  

    /* This is valid if tcp_skb_pcount() &gt; 1 */  
    static inline int tcp_skb_mss(const struct sk_buff *skb)  
    {  
        return skb_shinfo(skb)-&gt;gso_size;  
    }  

    static inline int sk_can_gso(const struct sock *sk)  
    {  
        /* sk_route_caps标志网卡驱动的特征, sk_gso_type表示GSO的类型， 
         * 设置为SKB_GSO_TCPV4 
         */  
        return net_gso_ok(sk-&gt;sk_route_caps, sk-&gt;sk_gso_type);  
    }  

    static inline int net_gso_ok(int features, int gso_type)  
    {  
        int feature = gso_type &lt;&lt; NETIF_F_GSO_SHIFT;  
        return (features &amp; feature) == feature;  
    }
</code></pre>

<h5>sk_gso_max_size</h5>

<p>NIC also specify the maximum segment size which it can handle, in sk_gso_max_size field.
Mostly it will be set to 64k. This 64k values means if the data at TCP is more than 64k,
then again TCP has to segment it in 64k and then push to interface.</p>

<p>相关变量，sock中：unsigned int sk_gso_max_size.</p>

<pre><code>    /* RFC2861 Check whether we are limited by application or congestion window 
     * This is the inverse of cwnd check in tcp_tso_should_defer 
     * 函数返回1，受拥塞控制窗口的限制，需要增加拥塞控制窗口； 
     * 函数返回0，受应用程序的限制，不需要增加拥塞控制窗口。 
     */  

    int tcp_is_cwnd_limited(const struct sock *sk, u32 in_flight)  
    {  
        const struct tcp_sock *tp = tcp_sk(sk);  
        u32 left;  

        if (in_flight &gt;= tp-&gt;snd_cwnd)  
            return 1;  

        /* left表示还可以发送的数据量 */  
        left = tp-&gt;snd_cwnd - in_flight;  


        /* 如果使用gso，符合以下条件，认为是拥塞窗口受到了限制， 
         * 可以增加拥塞窗口。 
         */  
        if (sk_can_gso(sk) &amp;&amp;   
            left * sysctl_tcp_tso_win_divisor &lt; tp-&gt;snd_cwnd &amp;&amp;  
            left * tp-&gt;mss_cache &lt; sk-&gt;sk_gso_max_size)  
            return 1;  

        /* 如果left大于允许的突发流量，那么拥塞窗口的增长已经很快了， 
         * 不能再增加了。 
         */  
        return left &lt;= tcp_max_burst(tp);  
    }
</code></pre>

<h4>TSO Nagle</h4>

<p>GSO, Generic Segmentation Offload，是协议栈提高效率的一个策略。</p>

<p>它尽可能晚的推迟分段(segmentation)，最理想的是在网卡驱动里分段，在网卡驱动里把
大包(super-packet)拆开，组成SG list，或在一块预先分配好的内存中重组各段，然后交给
网卡。</p>

<p>The idea behind GSO seems to be that many of the performance benefits of LSO (TSO/UFO)
can be obtained in a hardware-independent way, by passing large &ldquo;superpackets&rdquo; around for
as long as possible, and deferring segmentation to the last possible moment - for devices
without hardware segmentation/fragmentation support, this would be when data is actually
handled to the device driver; for devices with hardware support, it could even be done in hardware.</p>

<p>Try to defer sending, if possible, in order to minimize the amount of TSO splitting we do.
View it as a kind of TSO Nagle test.</p>

<p>通过延迟数据包的发送，来减少TSO分段的次数，达到减小CPU负载的目的。</p>

<pre><code>    struct tcp_sock {  
        ...  
        u32 tso_deferred; /* 上次TSO延迟的时间戳 */  
        ...  
    };
</code></pre>

<pre><code>    /** This algorithm is from John Heffner. 
     * 0: send now ; 1: deferred 
     */  
    static int tcp_tso_should_defer (struct sock *sk, struct sk_buff *skb)  
    {  
        struct tcp_sock *tp = tcp_sk(sk);  
        const struct inet_connection_sock *icsk = inet_csk(sk);  
        u32 in_flight, send_win, cong_win, limit;  
        int win_divisor;  

        /* 如果此skb包含结束标志，则马上发送*/  
        if (TCP_SKB_CB(skb)-&gt;flags &amp; TCPHDR_FIN)  
            goto send_now;  

        /* 如果此时不处于Open态，则马上发送*/  
        if (icsk-&gt;icsk_ca_state != TCP_CA_Open)  
            goto send_now;  

        /* Defer for less than two clock ticks. 
         * 上个skb被延迟了，且超过现在1ms以上，则不再延迟。 
         * 也就是说，TSO延迟不能超过2ms！ 
         */  
        if (tp-&gt;tso_deferred &amp;&amp; (((u32)jiffies &lt;&lt;1) &gt;&gt; 1) - (tp-&gt;tso_deferred &gt;&gt; 1) &gt; 1)  
            goto send_now;  

        in_flight = tcp_packets_in_flight(tp);  
        /* 如果此数据段不用分片，或者受到拥塞窗口的限制不能发包，则报错*/  
        BUG_ON(tcp_skb_pcount(skb) &lt;= 1 || (tp-&gt;snd_cwnd &lt;= in_flight));  
        /* 通告窗口的剩余大小*/  
        send_win = tcp_wnd_end(tp) - TCP_SKB_CB(skb)-&gt;seq;  
        /* 拥塞窗口的剩余大小*/  
        cong_win = (tp-&gt;snd_cwnd - in_flight) * tp-&gt;mss_cache;  
        /* 取其小者作为最终的发送限制*/  
        limit = min(send_win, cong_win);  

        /*If a full-sized TSO skb can be sent, do it. 
         * 一般来说是64KB 
         */  
        if (limit &gt;= sk-&gt;sk_gso_max_size)  
            goto send_now;  

        /* Middle in queue won't get any more data, full sendable already ? */  
        if ((skb != tcp_write_queue_tail(sk)) &amp;&amp; (limit &gt;= skb-&gt;len))  
            goto send_now;  

        win_divisor = ACCESS_ONCE(sysctl_tcp_tso_win_divisor);  
        if (win_divisor) {  
            /* 一个RTT内允许发送的最大字节数*/  
            u32 chunk = min(tp-&gt;snd_wnd, tp-&gt;snd_cwnd * tp-&gt;mss_cache);  
            chunk /= win_divisor; /* 单个TSO段可消耗的发送量*/  

            /* If at least some fraction of a window is available, just use it. */  
            if (limit &gt;= chunk)  
                goto send_now;  
        } else {  
            /* Different approach, try not to defer past a single ACK. 
             * Receiver should ACK every other full sized frame, so if we have space for 
             * more than 3 frames then send now. 
             */  
            if (limit &gt; tcp_max_burst(tp) * tp-&gt;mss_cache)  
                goto send_now;  
        }  

        /* OK, it looks like it is advisable to defer. */  
        tp-&gt;tso_deferred = 1 | (jiffies &lt;&lt; 1); /* 记录此次defer的时间戳*/  

        return 1;  

    send_now:  
        tp-&gt;tso_deferred = 0;  
        return 0;  
    }  

    /* Returns end sequence number of the receiver's advertised window */  
    static inline u32 tcp_wnd_end (const struct tcp_sock *tp)  
    {  
        /* snd_wnd的单位为字节*/  
        return tp-&gt;snd_una + tp-&gt;snd_wnd;  
    }
</code></pre>

<p>tcp_tso_win_divisor：单个TSO段可消耗拥塞窗口的比例，默认值为3。</p>

<h5>符合以下任意条件，不会TSO延迟，可马上发送：</h5>

<p>(1) 数据包带有FIN标志。传输快结束了，不宜延迟。<br/>
(2) 发送方不处于Open拥塞状态。处于异常状态时，不宜延迟。<br/>
(3) 上一次skb被延迟了，且距离现在大于等于2ms。延迟不能超过2ms。<br/>
(4) min(send_win, cong_win) > full-sized TSO skb。允许发送的数据量超过TSO一次能处理的最大值，没必要再defer。<br/>
(5) skb处于发送队列中间，且允许整个skb一起发送。处于发送队列中间的skb不能再获得新的数据，没必要再defer。<br/>
(6) tcp_tso_win_divisor有设置时，limit > 单个TSO段可消耗的数据量，即min(snd_wnd, snd_cwnd * mss_cache) / tcp_tso_win_divisor。<br/>
(7) tcp_tso_win_divisor没有设置时，limit > tcp_max_burst(tp) * mss_cache，一般是3个数据包。</p>

<p>条件4、5、6/7，都是limit > 某个阈值，就可以马上发送。这个因为通过这几个条件，可以确定此时发送是受到应用程序的限制，而不是通告窗口或者拥塞窗口。在应用程序发送的数据量很少的情况下，不宜采用TSO Nagle，因为这会影响此类应用。</p>

<p>我们注意到tcp_is_cwnd_limited()中的注释说：<br/>
&ldquo; This is the inverse of cwnd check in tcp_tso_should_defer"，所以可以认为在tcp_tso_should_defer()中包含判断
tcp_is_not_cwnd_limited (或者tcp_is_application_limited) 的条件。</p>

<h5>符合以下所有条件，才会进行TSO延迟：</h5>

<p>(1) 数据包不带有FIN标志。<br/>
(2) 发送方处于Open拥塞状态。<br/>
(3) 距离上一次延迟的时间在2ms以内。<br/>
(4) 允许发送的数据量小于sk_gso_max_size。<br/>
(5) skb处于发送队列末尾，或者skb不能整个发送出去。<br/>
(6) tcp_tso_win_divisor有设置时，允许发送的数据量不大于单个TSO段可消耗的。<br/>
(7) tcp_tso_win_divisor没有设置时，允许发送的数据量不大于3个包。</p>

<p>可以看到TSO的触发条件并不苛刻，所以被调用时并没有加unlikely。</p>

<h4>应用</h4>

<h5>(1) 禁用TSO</h5>

<pre><code>    ethtool -K ethX tso off
</code></pre>

<h5>(2) 启用TSO</h5>

<p>TSO是默认启用的。
<code>
    ethtool -K ethX tso on
</code></p>

<h4>Reference</h4>

<p>[1] <a href="http://en.wikipedia.org/wiki/Large_segment_offload">http://en.wikipedia.org/wiki/Large_segment_offload</a></p>

<p>[2] <a href="http://tejparkash.wordpress.com/2010/03/06/tso-explained/">http://tejparkash.wordpress.com/2010/03/06/tso-explained/</a></p>

<p>[3] <a href="http://www.linuxfoundation.org/collaborate/workgroups/networking/tso">http://www.linuxfoundation.org/collaborate/workgroups/networking/tso</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TSO/GSO]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/03/19/kernel-net-tso1/"/>
    <updated>2015-03-19T18:24:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/03/19/kernel-net-tso1</id>
    <content type="html"><![CDATA[<p><a href="http://book.51cto.com/art/201206/344985.htm">http://book.51cto.com/art/201206/344985.htm</a></p>

<p>TSO是通过网络设备进行TCP段的分割，从而来提高网络性能的一种技术。较大的数据包（超过标准1518B的帧）可以使用该技术，使操作系统减少必须处理的数据数量以提高性能。通常，当请求大量数据时，TCP发送方必须将数据拆分为MSS大小的数据块，然后进一步将其封装为数据包形式，以便最终可以在网络中进行传输。而当启用了TSO技术之后，TCP发送方可以将数据拆分为MSS整数倍大小的数据块，然后将大块数据的分段直接交给网络设备处理，操作系统需要创建并传输的数据包数量更少，因此性能会有较大的提高。图1-3所示为标准帧和TSO技术特性比较。</p>

<p><img src="/images/kernel/2015-03-19-3.jpg" alt="" /></p>

<p> 图是标准帧和TSO的处理过程<br/>
a) 不支持TSO  b) 启用TSO后</p>

<p>从前面有关TSO的论述可以看出，TSO只是针对TCP协议的，使TCP协议在硬件上得到了有力的支持。事实上，这种概念也可以应用于其他的传输层协议，如TCPv6，UDP，甚至DCCP等，这就是GSO(Generic Segmentation Offload)。</p>

<p>性能提高的关键在于尽可能地推迟分段的时机，这样才能有效地降低成本。最理想的是在网络设备驱动里进行分段，在网络设备驱动里把大包进行拆分，组成分段列表，或在一块预先分配好的内存中重组各段，然后交给网络设备。这样，就要在网络设备的驱动里边来实现它，那么就需要修改每一个网络设备的驱动程序。事实上，这样做不大现实。</p>

<p>然而似乎有另一种更容易的解决办法来支持GSO，那就是在把数据报文提交给网络设备驱动之前进行聚合/分散操作。Linux目前支持GSO框架已经支持的传输层的其他协议。有关GSO方面的代码，参见后续章节。</p>

<p>应用层可以使用ethtool -K eth0 tso off|on命令对支持TSO特性的网络设备进行TSO功能的关闭和启用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[拥塞窗口cwnd的理解]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/03/19/kernel-net-cwnd/"/>
    <updated>2015-03-19T18:15:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/03/19/kernel-net-cwnd</id>
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/linweixuan/article/details/4353015">http://blog.csdn.net/linweixuan/article/details/4353015</a></p>

<p>开始的时候拥塞窗口是1，发一个数据包等ACK回来 cwnd++即2,这个时候可以发送两个包,发送间隔几乎没有, 对方回的ACK到达发送方几乎是同时到达的.一个RTT来回,cwnd就翻倍,cwnd++,cwnd++即4了.如此下去,cwnd是指数增加.</p>

<p><img src="/images/kernel/2015-03-19-2.jpg" alt="" /></p>

<p>snd_cwnd_clamp这个变量我们可以不管,假定是一个大值.窗口到了我们设置的门限,snd_cwnd不在增加 而通过snd_cwnd_cnt变量来计数增加,一直增加到大过cwnd值,cwnd才加1,然后snd_cwnd_cnt重新计数, 通过snd_cwnd_cnt延缓cwnd计数,由于TCP是固定大小报文,每一个snd_cwnd代表了一个报文段的增加,snd_cwnd_cnt则看成byte的增加
<code>
    void tcp_cong_avoid(struct send_queue* sq)
    {
        /* In saft area, increase*/
        if (sq-&gt;snd_cwnd &lt;= sq-&gt;snd_ssthresh){
            if (sq-&gt;snd_cwnd &lt; sq-&gt;snd_cwnd_clamp)
                sq-&gt;snd_cwnd++;
        }
        else{
            /* In theory this is tp-&gt;snd_cwnd += 1 / tp-&gt;snd_cwnd */
            if (sq-&gt;snd_cwnd_cnt &gt;= sq-&gt;snd_cwnd) {
                if (sq-&gt;snd_cwnd &lt; sq-&gt;snd_cwnd_clamp)
                    sq-&gt;snd_cwnd++;
                sq-&gt;snd_cwnd_cnt = 0;
            } else
                sq-&gt;snd_cwnd_cnt++;
        }
    }
</code></p>

<p>snd_cwnd 还没到达门限不断增加snd_cwnd++<br/>
snd_cwnd++                      | &lt;&ndash;snd_ssthresh
                                ^</p>

<p>到达了snd_ssthresh转入拥塞避免，这个阶段由变量snd_cwnd_cnt来控制</p>

<p>转入拥塞,由于snd_cwnd_cnt从0开始小于snd_ssthresh，即从snd_ssthresh那个点开始计数, 一旦计数达到snd_cwnd拥塞窗口的值，但是还小过牵制snd_cwnd_clamp值</p>

<pre><code>                              snd_cwnd_clamp
                                     ^
        snd_cwnd++                   |            | &lt;--snd_ssthresh
                                                  ^
                                        snd_cwnd++        
                                                              snd_cwnd_clamp
                                                                     ^
                                    snd_cwnd_cnt++                   |            | &lt;--snd_ssthresh
                                                                                  ^
                                                   0      ---&gt;       snd_cwnd_cnt++


                   &lt;------                       时间                      -------&gt;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TCP接收窗口的调整算法]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/03/19/kernel-net-rcv_wnd/"/>
    <updated>2015-03-19T17:42:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/03/19/kernel-net-rcv_wnd</id>
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/zhangskd/article/details/8588202">TCP接收窗口的调整算法（上）</a><br/>
<a href="http://blog.csdn.net/zhangskd/article/details/8602493">TCP接收窗口的调整算法（中）</a><br/>
<a href="http://blog.csdn.net/zhangskd/article/details/8603099">TCP接收窗口的调整算法（下）</a></p>

<hr />

<h3>TCP接收窗口的调整算法（上）</h3>

<p>我们知道TCP首部中有一个16位的接收窗口字段，它可以告诉对端：我现在能接收多少数据。TCP的流控制主要就是通过调整接收窗口的大小来进行的。</p>

<p>本文内容：分析TCP接收窗口的调整算法，包括一些相关知识和初始接收窗口的取值。</p>

<p>内核版本：3.2.12</p>

<h4>数据结构</h4>

<p>以下是涉及到的数据结构。
<code>
    struct tcp_sock {  
        ...  
        /* 最早接收但未确认的段的序号，即当前接收窗口的左端*/  
        u32 rcv_wup; /* rcv_nxt on last window update sent */  
        u16 advmss; /* Advertised MSS. 本端能接收的MSS上限，建立连接时用来通告对端*/  
        u32 rcv_ssthresh; /* Current window clamp. 当前接收窗口大小的阈值*/  
        u32 rcv_wnd; /* Current receiver window，当前的接收窗口大小*/  
        u32 window_clamp; /* 接收窗口的最大值，这个值也会动态调整*/  
        ...  
    }
</code></p>

<pre><code>    struct tcp_options_received {  
        ...  
            snd_wscale : 4, /* Window scaling received from sender, 对端接收窗口扩大因子 */  
            rcv_wscale : 4; /* Window scaling to send to receiver, 本端接收窗口扩大因子 */  
        u16 user_mss; /* mss requested by user in ioctl */  
        u16 mss_clamp; /* Maximal mss, negotiated at connection setup，对端的最大mss */  
    }
</code></pre>

<pre><code>    /** 
     * struct sock - network layer representation of sockets 
     * @sk_rcvbuf: size of receive buffer in bytes 
     * @sk_receive_queue: incoming packets 
     * @sk_write_queue: packet sending queue 
     * @sk_sndbuf: size of send buffer in bytes 
     */  
    struct sock {  
        ...  
        struct sk_buff_head sk_receive_queue;  
        /* 表示接收队列sk_receive_queue中所有段的数据总长度*/  
    #define sk_rmem_alloc sk_backlog.rmem_alloc  

        int sk_rcvbuf; /* 接收缓冲区长度的上限*/  
        int sk_sndbuf; /* 发送缓冲区长度的上限*/  

        struct sk_buff_head sk_write_queue;  
        ...  
    }  

    struct sk_buff_head {  
        /* These two members must be first. */  
        struct sk_buff *next;  
        struct sk_buff *prev;  
        __u32 qlen;  
        spinlock_t lock;  
    };
</code></pre>

<!-- more -->


<p>在慢速路径中，有可能只带有TIMES
<code>
    /**
     * inet_connection_sock - INET connection oriented sock
     * @icsk_ack: Delayed ACK control data
     */  
    struct inet_connection_sock {  
        ...  
        struct {  
            ...  
            /* 在快速发送确认模式中，可以快速发送ACK段的数量*/  
            __u8 quick; /* Scheduled number of quick acks */  
            /* 由最近接收到的段计算出的对端发送MSS */  
            __16 rcv_mss; /* MSS used for delayed ACK decisions */  
        } icsk_ack;  
        ...  
    }
</code></p>

<pre><code>    struct tcphdr {  
        __be16 source;  
        __be16 dest;  
        __be32 seq;  
        __be32 ack_seq;  

    #if defined (__LITTLE_ENDIAN_BITFIELD)  
        __u16 resl : 4,  
              doff : 4,  
              fin : 1,  
              syn : 1,  
              rst : 1,  
              psh : 1,  
              ack : 1,  
              urg : 1,  
              ece : 1,  
              cwr : 1;  

    #elif defined (__BIG_ENDIAN_BITFIELD)  
        __u16 doff : 4,  
              resl : 4,  
              cwr : 1,  
              ece : 1,  
              urg : 1,  
              ack : 1,  
              psh : 1,  
              rst : 1,  
              syn : 1,  
              fin : 1;  
    #else  
    #error "Adjust your &lt;asm/byteorder.h&gt; defines"  
    #endif  
        __be16 window; /* 接收窗口，在这边呢 */  
        __sum16 check;  
        __be16 urg_ptr;  
    }
</code></pre>

<p>发送窗口和接收窗口的更新：</p>

<p><img src="/images/kernel/2015-03-19-1.jpg" alt="" /></p>

<h4>MSS</h4>

<p>先来看下MSS，它在接收窗口的调整中扮演着重要角色。<br/>
通过MSS (Max Segment Size)，数据被分割成TCP认为合适发送的数据块，称为段(Segment)。<br/>
注意：这里说的段(Segment)不包括协议首部，只包含数据！</p>

<p>与MSS最为相关的一个参数就是网络设备接口的MTU(Max Transfer Unit)。<br/>
两台主机之间的路径MTU并不一定是个常数，它取决于当时所选的路由。而选路不一定是对称的(从A到B的路由和从B到A的路由不同)。因此路径MTU在两个方向上不一定是对称的。<br/>
所以，从A到B的有效MSS、从B到A的有效MSS是动态变化的，并且可能不相同。</p>

<p>每个端同时具有几个不同的MSS：<br/>
（1）tp->advmss<br/>
本端在建立连接时使用的MSS，是本端能接收的MSS上限。<br/>
这是从路由缓存中获得的(dst->metrics[RTAX_ADVMSS - 1])，一般是1460。</p>

<p>（2）tp->rx_opt.mss_clamp<br/>
对端的能接收的MSS上限，min(tp->rx_opt.user_mss, 对端在建立连接时通告的MSS)。</p>

<p>（3）tp->mss_cache<br/>
本端当前有效的发送MSS。显然不能超过对端接收的上限，tp->mss_cache &lt;= tp->mss_clamp。</p>

<p>（4）tp->rx_opt.user_mss<br/>
用户通过TCP_MAXSEG选项设置的MSS上限，用于决定本端和对端的接收MSS上限。</p>

<p>（5）icsk->icsk_ack.rcv_mss<br/>
对端有效的发送MSS的估算值。显然不能超过本端接收的上限，icsk->icsk_ack.rcv_mss &lt;= tp->advmss。</p>

<h4>Receive buffer</h4>

<p>接收缓存sk->sk_rcvbuf分为两部分：<br/>
（1） network buffer，一般占3/4，这部分是协议能够使用的。<br/>
（2）application buffer，一般占1/4。</p>

<p>我们在计算连接可用接收缓存的时候，并不会使用整个的sk_rcvbuf，防止应用程序读取数据的速度比网络数据包到达的速度慢时，接收缓存被耗尽的情况。</p>

<p>以下是详细的说明：<br/>
The idea is not to use a complete receive buffer space to calculate the receive buffer.<br/>
We reserve some space as an application buffer, and the rest is used to queue incoming data segments.<br/>
An application buffer corresponds to the space that should compensate for the delay in time it takes for an application to read from the socket buffer.</p>

<p>If the application is reading more slowly than the rate at which data are arriving, data will be queued in the receive buffer. In order to avoid queue getting full, we advertise less receive window so that the sender can slow down the rate of data transmission and by that time the application gets a chance to read data from the receiver buffer.</p>

<p>一个包含X字节数据的skb的最小真实内存消耗(truesize)：
<code>
    /* return minimum truesize of one skb containing X bytes of data，这里的X包含协议头 */  
    #define SKB_TRUESIZE(X) ((X) +  \  
                        SKB_DATA_ALIGN(sizeof(struct sk_buff)) + \  
                        SKB_DATA_ALIGN(sizeof(struct skb_shared_info)))
</code></p>

<h4>接收窗口的初始化</h4>

<p>从最简单的开始，先来看下接收窗口的初始值、接收窗口扩大因子是如何取值的。
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
<span class='line-number'>206</span>
<span class='line-number'>207</span>
<span class='line-number'>208</span>
<span class='line-number'>209</span>
<span class='line-number'>210</span>
<span class='line-number'>211</span>
<span class='line-number'>212</span>
<span class='line-number'>213</span>
<span class='line-number'>214</span>
<span class='line-number'>215</span>
<span class='line-number'>216</span>
<span class='line-number'>217</span>
<span class='line-number'>218</span>
<span class='line-number'>219</span>
<span class='line-number'>220</span>
<span class='line-number'>221</span>
<span class='line-number'>222</span>
<span class='line-number'>223</span>
<span class='line-number'>224</span>
<span class='line-number'>225</span>
<span class='line-number'>226</span>
<span class='line-number'>227</span>
<span class='line-number'>228</span>
<span class='line-number'>229</span>
<span class='line-number'>230</span>
<span class='line-number'>231</span>
<span class='line-number'>232</span>
<span class='line-number'>233</span>
<span class='line-number'>234</span>
<span class='line-number'>235</span>
<span class='line-number'>236</span>
<span class='line-number'>237</span>
<span class='line-number'>238</span>
<span class='line-number'>239</span>
<span class='line-number'>240</span>
<span class='line-number'>241</span>
<span class='line-number'>242</span>
<span class='line-number'>243</span>
<span class='line-number'>244</span>
<span class='line-number'>245</span>
<span class='line-number'>246</span>
<span class='line-number'>247</span>
<span class='line-number'>248</span>
<span class='line-number'>249</span>
<span class='line-number'>250</span>
<span class='line-number'>251</span>
<span class='line-number'>252</span>
<span class='line-number'>253</span>
<span class='line-number'>254</span>
<span class='line-number'>255</span>
<span class='line-number'>256</span>
<span class='line-number'>257</span>
<span class='line-number'>258</span>
<span class='line-number'>259</span>
<span class='line-number'>260</span>
<span class='line-number'>261</span>
<span class='line-number'>262</span>
<span class='line-number'>263</span>
<span class='line-number'>264</span>
<span class='line-number'>265</span>
<span class='line-number'>266</span>
<span class='line-number'>267</span>
<span class='line-number'>268</span>
<span class='line-number'>269</span>
<span class='line-number'>270</span>
<span class='line-number'>271</span>
<span class='line-number'>272</span>
<span class='line-number'>273</span>
<span class='line-number'>274</span>
<span class='line-number'>275</span>
<span class='line-number'>276</span>
<span class='line-number'>277</span>
<span class='line-number'>278</span>
<span class='line-number'>279</span>
<span class='line-number'>280</span>
<span class='line-number'>281</span>
<span class='line-number'>282</span>
<span class='line-number'>283</span>
<span class='line-number'>284</span>
<span class='line-number'>285</span>
<span class='line-number'>286</span>
<span class='line-number'>287</span>
<span class='line-number'>288</span>
<span class='line-number'>289</span>
<span class='line-number'>290</span>
<span class='line-number'>291</span>
<span class='line-number'>292</span>
<span class='line-number'>293</span>
<span class='line-number'>294</span>
<span class='line-number'>295</span>
<span class='line-number'>296</span>
<span class='line-number'>297</span>
<span class='line-number'>298</span>
<span class='line-number'>299</span>
<span class='line-number'>300</span>
<span class='line-number'>301</span>
<span class='line-number'>302</span>
<span class='line-number'>303</span>
<span class='line-number'>304</span>
<span class='line-number'>305</span>
<span class='line-number'>306</span>
<span class='line-number'>307</span>
<span class='line-number'>308</span>
<span class='line-number'>309</span>
<span class='line-number'>310</span>
<span class='line-number'>311</span>
<span class='line-number'>312</span>
<span class='line-number'>313</span>
<span class='line-number'>314</span>
<span class='line-number'>315</span>
<span class='line-number'>316</span>
<span class='line-number'>317</span>
<span class='line-number'>318</span>
<span class='line-number'>319</span>
<span class='line-number'>320</span>
<span class='line-number'>321</span>
<span class='line-number'>322</span>
<span class='line-number'>323</span>
<span class='line-number'>324</span>
<span class='line-number'>325</span>
<span class='line-number'>326</span>
<span class='line-number'>327</span>
<span class='line-number'>328</span>
<span class='line-number'>329</span>
<span class='line-number'>330</span>
<span class='line-number'>331</span>
<span class='line-number'>332</span>
<span class='line-number'>333</span>
<span class='line-number'>334</span>
<span class='line-number'>335</span>
<span class='line-number'>336</span>
<span class='line-number'>337</span>
<span class='line-number'>338</span>
<span class='line-number'>339</span>
<span class='line-number'>340</span>
<span class='line-number'>341</span>
<span class='line-number'>342</span>
<span class='line-number'>343</span>
<span class='line-number'>344</span>
<span class='line-number'>345</span>
<span class='line-number'>346</span>
<span class='line-number'>347</span>
<span class='line-number'>348</span>
<span class='line-number'>349</span>
<span class='line-number'>350</span>
<span class='line-number'>351</span>
<span class='line-number'>352</span>
<span class='line-number'>353</span>
<span class='line-number'>354</span>
<span class='line-number'>355</span>
<span class='line-number'>356</span>
<span class='line-number'>357</span>
<span class='line-number'>358</span>
<span class='line-number'>359</span>
<span class='line-number'>360</span>
<span class='line-number'>361</span>
<span class='line-number'>362</span>
<span class='line-number'>363</span>
<span class='line-number'>364</span>
<span class='line-number'>365</span>
<span class='line-number'>366</span>
<span class='line-number'>367</span>
<span class='line-number'>368</span>
<span class='line-number'>369</span>
<span class='line-number'>370</span>
<span class='line-number'>371</span>
<span class='line-number'>372</span>
<span class='line-number'>373</span>
<span class='line-number'>374</span>
<span class='line-number'>375</span>
<span class='line-number'>376</span>
<span class='line-number'>377</span>
<span class='line-number'>378</span>
<span class='line-number'>379</span>
<span class='line-number'>380</span>
<span class='line-number'>381</span>
<span class='line-number'>382</span>
<span class='line-number'>383</span>
<span class='line-number'>384</span>
<span class='line-number'>385</span>
<span class='line-number'>386</span>
<span class='line-number'>387</span>
<span class='line-number'>388</span>
<span class='line-number'>389</span>
<span class='line-number'>390</span>
<span class='line-number'>391</span>
<span class='line-number'>392</span>
<span class='line-number'>393</span>
<span class='line-number'>394</span>
<span class='line-number'>395</span>
<span class='line-number'>396</span>
<span class='line-number'>397</span>
<span class='line-number'>398</span>
<span class='line-number'>399</span>
<span class='line-number'>400</span>
<span class='line-number'>401</span>
<span class='line-number'>402</span>
<span class='line-number'>403</span>
<span class='line-number'>404</span>
<span class='line-number'>405</span>
<span class='line-number'>406</span>
<span class='line-number'>407</span>
<span class='line-number'>408</span>
<span class='line-number'>409</span>
<span class='line-number'>410</span>
<span class='line-number'>411</span>
<span class='line-number'>412</span>
<span class='line-number'>413</span>
<span class='line-number'>414</span>
<span class='line-number'>415</span>
<span class='line-number'>416</span>
<span class='line-number'>417</span>
<span class='line-number'>418</span>
<span class='line-number'>419</span>
<span class='line-number'>420</span>
<span class='line-number'>421</span>
<span class='line-number'>422</span>
<span class='line-number'>423</span>
<span class='line-number'>424</span>
<span class='line-number'>425</span>
<span class='line-number'>426</span>
<span class='line-number'>427</span>
<span class='line-number'>428</span>
<span class='line-number'>429</span>
<span class='line-number'>430</span>
<span class='line-number'>431</span>
<span class='line-number'>432</span>
<span class='line-number'>433</span>
<span class='line-number'>434</span>
<span class='line-number'>435</span>
<span class='line-number'>436</span>
<span class='line-number'>437</span>
<span class='line-number'>438</span>
<span class='line-number'>439</span>
<span class='line-number'>440</span>
<span class='line-number'>441</span>
<span class='line-number'>442</span>
<span class='line-number'>443</span>
<span class='line-number'>444</span>
<span class='line-number'>445</span>
<span class='line-number'>446</span>
<span class='line-number'>447</span>
<span class='line-number'>448</span>
<span class='line-number'>449</span>
<span class='line-number'>450</span>
<span class='line-number'>451</span>
<span class='line-number'>452</span>
<span class='line-number'>453</span>
<span class='line-number'>454</span>
<span class='line-number'>455</span>
<span class='line-number'>456</span>
<span class='line-number'>457</span>
<span class='line-number'>458</span>
<span class='line-number'>459</span>
<span class='line-number'>460</span>
<span class='line-number'>461</span>
<span class='line-number'>462</span>
<span class='line-number'>463</span>
<span class='line-number'>464</span>
<span class='line-number'>465</span>
<span class='line-number'>466</span>
<span class='line-number'>467</span>
<span class='line-number'>468</span>
<span class='line-number'>469</span>
<span class='line-number'>470</span>
<span class='line-number'>471</span>
<span class='line-number'>472</span>
<span class='line-number'>473</span>
<span class='line-number'>474</span>
<span class='line-number'>475</span>
<span class='line-number'>476</span>
<span class='line-number'>477</span>
<span class='line-number'>478</span>
<span class='line-number'>479</span>
<span class='line-number'>480</span>
<span class='line-number'>481</span>
<span class='line-number'>482</span>
<span class='line-number'>483</span>
<span class='line-number'>484</span>
<span class='line-number'>485</span>
<span class='line-number'>486</span>
<span class='line-number'>487</span>
<span class='line-number'>488</span>
<span class='line-number'>489</span>
<span class='line-number'>490</span>
<span class='line-number'>491</span>
<span class='line-number'>492</span>
<span class='line-number'>493</span>
<span class='line-number'>494</span>
<span class='line-number'>495</span>
<span class='line-number'>496</span>
<span class='line-number'>497</span>
<span class='line-number'>498</span>
<span class='line-number'>499</span>
<span class='line-number'>500</span>
<span class='line-number'>501</span>
<span class='line-number'>502</span>
<span class='line-number'>503</span>
<span class='line-number'>504</span>
<span class='line-number'>505</span>
<span class='line-number'>506</span>
<span class='line-number'>507</span>
<span class='line-number'>508</span>
<span class='line-number'>509</span>
<span class='line-number'>510</span>
<span class='line-number'>511</span>
<span class='line-number'>512</span>
<span class='line-number'>513</span>
<span class='line-number'>514</span>
<span class='line-number'>515</span>
<span class='line-number'>516</span>
<span class='line-number'>517</span>
<span class='line-number'>518</span>
<span class='line-number'>519</span>
<span class='line-number'>520</span>
<span class='line-number'>521</span>
<span class='line-number'>522</span>
<span class='line-number'>523</span>
<span class='line-number'>524</span>
<span class='line-number'>525</span>
<span class='line-number'>526</span>
<span class='line-number'>527</span>
<span class='line-number'>528</span>
<span class='line-number'>529</span>
<span class='line-number'>530</span>
<span class='line-number'>531</span>
<span class='line-number'>532</span>
<span class='line-number'>533</span>
<span class='line-number'>534</span>
<span class='line-number'>535</span>
<span class='line-number'>536</span>
<span class='line-number'>537</span>
<span class='line-number'>538</span>
<span class='line-number'>539</span>
<span class='line-number'>540</span>
<span class='line-number'>541</span>
<span class='line-number'>542</span>
<span class='line-number'>543</span>
<span class='line-number'>544</span>
<span class='line-number'>545</span>
<span class='line-number'>546</span>
<span class='line-number'>547</span>
<span class='line-number'>548</span>
<span class='line-number'>549</span>
<span class='line-number'>550</span>
<span class='line-number'>551</span>
<span class='line-number'>552</span>
<span class='line-number'>553</span>
<span class='line-number'>554</span>
<span class='line-number'>555</span>
<span class='line-number'>556</span>
<span class='line-number'>557</span>
<span class='line-number'>558</span>
<span class='line-number'>559</span>
<span class='line-number'>560</span>
<span class='line-number'>561</span>
<span class='line-number'>562</span>
<span class='line-number'>563</span>
<span class='line-number'>564</span>
<span class='line-number'>565</span>
<span class='line-number'>566</span>
<span class='line-number'>567</span>
<span class='line-number'>568</span>
<span class='line-number'>569</span>
<span class='line-number'>570</span>
<span class='line-number'>571</span>
<span class='line-number'>572</span>
<span class='line-number'>573</span>
<span class='line-number'>574</span>
<span class='line-number'>575</span>
<span class='line-number'>576</span>
<span class='line-number'>577</span>
<span class='line-number'>578</span>
<span class='line-number'>579</span>
<span class='line-number'>580</span>
<span class='line-number'>581</span>
<span class='line-number'>582</span>
<span class='line-number'>583</span>
<span class='line-number'>584</span>
<span class='line-number'>585</span>
<span class='line-number'>586</span>
<span class='line-number'>587</span>
<span class='line-number'>588</span>
<span class='line-number'>589</span>
<span class='line-number'>590</span>
<span class='line-number'>591</span>
<span class='line-number'>592</span>
<span class='line-number'>593</span>
<span class='line-number'>594</span>
<span class='line-number'>595</span>
<span class='line-number'>596</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/&lt;em&gt; Determine a window scaling and initial window to offer.
</span><span class='line'> * Based on the assumption that the given amount of space will be offered.
</span><span class='line'> * Store the results in the tp structure.
</span><span class='line'> * NOTE: for smooth operation initial space offering should be a multiple of mss
</span><span class='line'> * if possible. We assume here that mss &gt;= 1. This MUST be enforced by all calllers.
</span><span class='line'> &lt;/em&gt;/&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;void tcp_select_initial_window (int __space, __u32 mss, __u32 *rcv_wnd, __u32 *window_clamp,  
</span><span class='line'>                            int wscale_ok, __u8 *rcv_wscale, __u32 init_rcv_wnd)  
</span><span class='line'>{  
</span><span class='line'>unsigned int space = (__space &lt; 0 ? 0 : __space); /* 接收缓存不能为负*/  
</span><span class='line'>
</span><span class='line'>/* If no clamp set the clamp to the max possible scaled window。 
</span><span class='line'> * 如果接收窗口上限的初始值为0，则把它设成最大。 
</span><span class='line'> */  
</span><span class='line'>if (*window_clamp == 0)  
</span><span class='line'>    (*window_clamp) = (65535 &lt;&lt; 14); /*这是接收窗口的最大上限*/  
</span><span class='line'>
</span><span class='line'>/* 接收窗口不能超过它的上限 */  
</span><span class='line'>space = min(*window_clamp, space);   
</span><span class='line'>
</span><span class='line'>/* Quantize space offering to a multiple of mss if possible. 
</span><span class='line'> * 接收窗口大小最好是mss的整数倍。 
</span><span class='line'> */  
</span><span class='line'>if (space &gt; mss)  
</span><span class='line'>    space = (space / mss) * mss; /* 让space为mss的整数倍*/  
</span><span class='line'>
</span><span class='line'>/* NOTE: offering an initial window larger than 32767 will break some 
</span><span class='line'> * buggy TCP stacks. If the admin tells us it is likely we could be speaking 
</span><span class='line'> * with such a buggy stack we will truncate our initial window offering to 
</span><span class='line'> * 32K - 1 unless the remote has sent us a window scaling option, which 
</span><span class='line'> * we interpret as a sign the remote TCP is not misinterpreting the window 
</span><span class='line'> * field as a signed quantity. 
</span><span class='line'> */  
</span><span class='line'>/* 当协议使用有符号的接收窗口时，则接收窗口大小不能超过32767*/  
</span><span class='line'>if (sysctl_tcp_workaround_signed_windows)  
</span><span class='line'>    (*rcv_wnd) = min(space, MAX_TCP_WINDOW);  
</span><span class='line'>esle  
</span><span class='line'>    (*rcv_wnd) = space;  
</span><span class='line'>
</span><span class='line'>(*rcv_wscale) = 0;  
</span><span class='line'>/* 计算接收窗口扩大因子rcv_wscale，需要多大才能表示本连接的最大接收窗口大小？*/  
</span><span class='line'>if (wscale_ok) {  
</span><span class='line'>    /* Set window scaling on max possible window 
</span><span class='line'>     * See RFC1323 for an explanation of the limit to 14 
</span><span class='line'>     * tcp_rmem[2]为接收缓冲区长度上限的最大值，用于调整sk_rcvbuf。 
</span><span class='line'>      * rmem_max为系统接收窗口的最大大小。 
</span><span class='line'>      */  
</span><span class='line'>    space = max_t(u32, sysctl_tcp_rmem[2], sysctl_rmem_max);  
</span><span class='line'>    space = min_t(u32, space, *window_clamp); /*受限于具体连接*/  
</span><span class='line'>
</span><span class='line'>    while (space &gt; 65535 &amp;&amp; (*rcv_wscale) &lt; 14) {  
</span><span class='line'>        space &gt;&gt;= 1;  
</span><span class='line'>        (*rcv_wscale)++;  
</span><span class='line'>    }  
</span><span class='line'>   }  
</span><span class='line'>
</span><span class='line'>/* Set initial window to a value enough for senders starting with initial 
</span><span class='line'> * congestion window of TCP_DEFAULT_INIT_RCVWND. Place a limit on the  
</span><span class='line'> * initial window when mss is larger than 1460. 
</span><span class='line'> * 
</span><span class='line'> * 接收窗口的初始值在这里确定，一般是10个数据段大小左右。 
</span><span class='line'> */  
</span><span class='line'>if (mss &gt; (1 &lt;&lt; *rcv_wscale)) {  
</span><span class='line'>    int init_cwnd = TCP_DEFAULT_INIT_RCVWND; /* 10 */  
</span><span class='line'>    if (mss &gt; 1460)  
</span><span class='line'>        init_cwnd = max_t(u32, 1460 * TCP_DEFAULT_INIT_RCVWND) / mss, 2);  
</span><span class='line'>
</span><span class='line'>    /* when initializing use the value from init_rcv_wnd rather than the  
</span><span class='line'>     * default from above. 
</span><span class='line'>     * 决定初始接收窗口时，先考虑路由缓存中的，如果没有，再考虑系统默认的。 
</span><span class='line'>      */  
</span><span class='line'>    if (init_rcv_wnd) /* 如果路由缓存中初始接收窗口大小不为0*/  
</span><span class='line'>        *rcv_wnd = min(*rcv_wnd, init_rcv_wnd * mss);  
</span><span class='line'>    else   
</span><span class='line'>        *rcv_wnd = min(*rcv_wnd, init_cwnd *mss);  
</span><span class='line'>}  
</span><span class='line'>
</span><span class='line'>/* Set the clamp no higher than max representable value */  
</span><span class='line'>(*window_clamp) = min(65535 &lt;&lt; (*rcv_wscale), *window_clamp);  
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>初始的接收窗口的取值(mss的整数倍)：  
</span><span class='line'>（1）先考虑路由缓存中的RTAX_INITRWND  
</span><span class='line'>（2）在考虑系统默认的TCP_DEFAULT_INIT_RCVWND(10)  
</span><span class='line'>（3）最后考虑min(3/4 * sk_rcvbuf, window_clamp)，如果这个值很低  
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>窗口扩大因子的取值：  
</span><span class='line'>接收窗口取最大值为max(tcp_rmem[2], rmem_max)，本连接接收窗口的最大值为 min(max(tcp_rmem[2], rmem_max), window_clamp)。  
</span><span class='line'>那么我们需要多大的窗口扩大因子，才能用16位来表示最大的接收窗口呢？  
</span><span class='line'>如果接收窗口的最大值受限于tcp_rmem[2] = 4194304，那么rcv_wscale = 7，窗口扩大倍数为128。  
</span><span class='line'>
</span><span class='line'>发送SYN/ACK时的调用路径：tcp_v4_send_synack -&gt; tcp_make_synack -&gt; tcp_select_initial_window。
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;/* Prepare a SYN-ACK. */  
</span><span class='line'>struct sk_buff *tcp_make_synack (struct sock *sk, struct dst_entry *dst,   
</span><span class='line'>                             struct request_sock *req, struct request_values *rvp)  
</span><span class='line'>{  
</span><span class='line'>struct inet_request_sock *ireq = inet_rsk(req);  
</span><span class='line'>struct tcp_sock *tp = tcp_sk(sk);  
</span><span class='line'>struct tcphdr *th;  
</span><span class='line'>struct sk_buff *skb;  
</span><span class='line'>...  
</span><span class='line'>mss = dst_metric_advmss(dst); /*路由缓存中的mss*/  
</span><span class='line'>/*如果用户有特别设置，则取其小者*/  
</span><span class='line'>if (tp-&gt;rx_opt.user_mss &amp;&amp; tp-&gt;rx_opt.user_mss &lt; mss)  
</span><span class='line'>    mss = tp-&gt;rx_opt.user_mss;  
</span><span class='line'>
</span><span class='line'>if (req-&gt;rcv_wnd == 0) { /* ignored for retransmitted syns */  
</span><span class='line'>    __u8 rcv_wscale;  
</span><span class='line'>
</span><span class='line'>    /* Set this up on the first call only */  
</span><span class='line'>    req-&gt;window_clamp = tp-&gt;window_clamp ? : dst_metric(dst, RTAX_WINDOW);  
</span><span class='line'>
</span><span class='line'>    /* limit the window selection if the user enforce a smaller rx buffer */  
</span><span class='line'>    if (sk-&gt;sk_userlocks &amp; SOCK_RCVBUF_LOCK &amp;&amp;   
</span><span class='line'>        (req-&gt;window_clamp &gt; tcp_full_space(sk) || req-&gt;window_clamp == 0))  
</span><span class='line'>        req-&gt;window_clamp = tcp_full_space(sk);  
</span><span class='line'>
</span><span class='line'>    /* tcp_full_space because it is guaranteed to be the first packet */  
</span><span class='line'>    tcp_select_initial_window(tcp_full_space(sk),   
</span><span class='line'>                        mss - (ireq-&gt;tstamp_ok ? TCPOLEN_TSTAMP_ALIGNED : 0),  
</span><span class='line'>                        &amp;req-&gt;rcv_wnd,  
</span><span class='line'>                        &amp;req-&gt;window_clamp,  
</span><span class='line'>                        ireq-&gt;wscale_ok,  
</span><span class='line'>                        &amp;rcv_wscale,  
</span><span class='line'>                        dst_metric(dst, RTAX_INITRWND));  
</span><span class='line'>
</span><span class='line'>    ireq-&gt;rcv_wscale = rcv_wscale;  
</span><span class='line'>}  
</span><span class='line'>...  
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>-----------
</span><span class='line'>
</span><span class='line'>### TCP接收窗口的调整算法（中）
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>本文内容：分析TCP接收窗口的调整算法，主要是接收窗口当前阈值的调整算法。
</span><span class='line'>
</span><span class='line'>内核版本：3.2.12
</span><span class='line'>
</span><span class='line'>#### 接收窗口当前阈值的调整算法
</span><span class='line'>我们知道，在拥塞控制中，有个慢启动阈值，控制着拥塞窗口的增长。在流控制中，也有个接收窗口的当前阈值，控制着接收窗口的增长。可见TCP的拥塞控制和流控制，在某些地方有异曲同工之处。
</span><span class='line'>
</span><span class='line'>接收窗口当前阈值tp-&gt;rcv_ssthresh的主要功能：  
</span><span class='line'>On reception of data segment from the sender, this value is recalculated based on the size of the segment, and later on this value is used as upper limit on the receive window to be advertised.
</span><span class='line'>
</span><span class='line'>可见，接收窗口当前阈值对接收窗口的大小有着重要的影响。
</span><span class='line'>
</span><span class='line'>接收窗口当前阈值调整算法的基本思想：  
</span><span class='line'>When we receive a data segment, we need to calculate a receive window that needs to be advertised to the sender, depending on the segment size received.  
</span><span class='line'>
</span><span class='line'>The idea is to avoid filling the receive buffer with too many small segments when an application is reading very slowly and packets are transmitted at a very high rate.
</span><span class='line'>
</span><span class='line'>在接收窗口当前阈值的调整算法中，收到数据报的负荷是个关键因素，至于它怎么影响接收窗口当前阈值的增长，来看下代码吧。
</span><span class='line'>
</span><span class='line'>当接收到一个报文段时，调用处理函数：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static void tcp_event_data_recv (struct sock *sk, struct sk_buff *skb)  
</span><span class='line'>{  
</span><span class='line'>struct tcp_sock *tp = tcp_sk(sk);  
</span><span class='line'>struct inet_connection_sock *icsk = inet_csk(sk);  
</span><span class='line'>u32 now;  
</span><span class='line'>...  
</span><span class='line'>/* 当报文段的负荷不小于128字节时，考虑增大接收窗口当前阈值rcv_ssthresh */  
</span><span class='line'>if (skb-&gt;len &gt;= 128)  
</span><span class='line'>    tcp_grow_window(sk, skb);  
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>下面这个函数决定是否增长rcv_ssthresh，以及增长多少。
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static void tcp_grow_window (struct sock *sk, const struct sk_buff *skb)  
</span><span class='line'>{  
</span><span class='line'>struct tcp_sock *tp = tcp_sk(sk);  
</span><span class='line'>
</span><span class='line'>/* Check #1,关于这三个判断条件的含义可见下文分析 */  
</span><span class='line'>if (tp-&gt;rcv_ssthresh &lt; tp-&gt;window_clamp &amp;&amp;   
</span><span class='line'>     (int) tp-&gt;rcv_ssthresh &lt; tcp_space(sk) &amp;&amp; ! tcp_memory_pressure) {  
</span><span class='line'>    int incr;  
</span><span class='line'>
</span><span class='line'>    /* Check #2. Increase window, if skb with such overhead will fit to rcvbuf in future.  
</span><span class='line'>     * 如果应用层数据占这个skb总共消耗内存的75%以上，则说明这个数据报是大的数据报， 
</span><span class='line'>      * 内存的额外开销较小。这样一来我们可以放心的增长rcv_ssthresh了。 
</span><span class='line'>      */  
</span><span class='line'>    if (tcp_win_from_space(skb-&gt;truesize) &lt;= skb-&gt;len)  
</span><span class='line'>        incr = 2 * tp-&gt;advmss; /* 增加两个本端最大接收MSS */  
</span><span class='line'>    else  
</span><span class='line'>        /* 可能增大rcv_ssthresh，也可能不增大，具体视额外内存开销和剩余缓存而定*/  
</span><span class='line'>        incr = __tcp_grow_window(sk, skb);  
</span><span class='line'>
</span><span class='line'>    if (incr) {  
</span><span class='line'>        /* 增加后不能超过window_clamp */  
</span><span class='line'>        tp-&gt;rcv_ssthresh = min(tp-&gt;rcv_ssthresh + incr, tp-&gt;window_clamp);  
</span><span class='line'>        inet_csk(sk)-&gt;icsk_ack.quick |= 1; /* 允许快速ACK */  
</span><span class='line'>    }  
</span><span class='line'>}  
</span><span class='line'>}  
</span><span class='line'>
</span><span class='line'>/* Slow part of check#2. */  
</span><span class='line'>static int __tcp_grow_window (const struct sock *sk, const struct sk_buff *skb)  
</span><span class='line'>{  
</span><span class='line'>struct tcp_sock *tp = tcp_sk(sk);  
</span><span class='line'>/* Optimize this! */  
</span><span class='line'>int truesize = tcp_win_from_space(skb-&gt;truesize) &gt;&gt; 1;  
</span><span class='line'>int window = tcp_win_from_space(sysctl_tcp_rmem[2]) &gt;&gt; 1; /* 接收缓冲区长度上限的一半*/  
</span><span class='line'>
</span><span class='line'>/* rcv_ssthresh不超过一半的接收缓冲区上限才有可能*/  
</span><span class='line'>while (tp-&gt;rcv_ssthresh &lt;= window) {  
</span><span class='line'>    if (truesize &lt;= skb-&gt;len)  
</span><span class='line'>        return 2 * inet_csk(sk)-&gt;icsk_ack.rcv_mss; /* 增加两个对端发送MSS的估计值*/  
</span><span class='line'>
</span><span class='line'>    truesize &gt;&gt;= 1;  
</span><span class='line'>    window &gt;&gt;= 1;  
</span><span class='line'>}  
</span><span class='line'>
</span><span class='line'>return 0;/*不增长*/  
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>这个算法可能不太好理解，我们来分析一下。
</span><span class='line'>
</span><span class='line'>只有当数据段长度大于128字节时才会考虑增长rcv_ssthresh，并且有以下大前提(就是check #1)：  
</span><span class='line'>a. 接收窗口当前阈值不能超过接收窗口的上限。  
</span><span class='line'>b. 接收窗口当前阈值不能超过剩余接收缓存的3/4，即network buffer。  
</span><span class='line'>c.  没有内存压力。TCP socket系统总共使用的内存过大。  
</span><span class='line'>
</span><span class='line'>check#2是根据额外开销的内存占的比重，来判断是否允许增长。额外的内存开销(overhead)指的是：  
</span><span class='line'>sk_buff、skb_shared_info结构体，以及协议头。有效的内存开销指的是数据段的长度。
</span><span class='line'>
</span><span class='line'>（1） 额外开销小于25%，则rcv_ssthresh增长两个本端最大接收MSS。  
</span><span class='line'>（2）额外开销大于25%，分为两种情况。  
</span><span class='line'>
</span><span class='line'>算法如下：  
</span><span class='line'>把3/4的剩余接收缓存，即剩余network buffer均分为2^n块。把额外开销均分为2^n份。  
</span><span class='line'>如果均分后每块缓存的大小大于rcv_ssthresh，且均分后的每份开销小于数据段的长度，则： 
</span><span class='line'>允许rcv_ssthresh增大2个对端发送MSS的估计值。  
</span><span class='line'>否则，不允许增大rcv_ssthresh。  
</span><span class='line'>
</span><span class='line'>我们注意到在(1)和(2)中，rcv_ssthresh的增长幅度是不同的。在(1)中，由于收到大的数据段，额外开销较低，所以增长幅度较大(2 * tp-&gt;advmss)。在(2)中，由于收到中等数据段，额外开销较高，所以增长幅度较小(2 * icsk-&gt;icsk_ack.rcv_mss)。这样做是为了防止额外开销过高，而耗尽接收窗口。
</span><span class='line'>
</span><span class='line'>rcv_ssthresh增长算法的基本思想：  
</span><span class='line'>This algorithm works on the basis that we do not want to increase the advertised window if we receive lots of small segments (i.e. interactive data flow), as the per-segment overhead (headers and the buffer control block) is very high.
</span><span class='line'>
</span><span class='line'>额外开销大小，取决于数据段的大小。我们从这个角度来分析下当接收到一个数据报时，rcv_ssthresh的增长情况：
</span><span class='line'>（1）Small segment (len &lt; 128)  
</span><span class='line'>如果接收到的数据段很小，这时不允许增大rcv_ssthresh，防止额外内存开销过大。
</span><span class='line'>
</span><span class='line'>（2）Medium segment (128 &lt;= len &lt;= 647)  
</span><span class='line'>如果接收到中等长度的数据段，符合条件时，rcv_ssthresh += 2 * rcv_mss。
</span><span class='line'>
</span><span class='line'>（3）Large segment (len &gt; 647)  
</span><span class='line'>如果接收到数据段长度较大的报文，符合条件时(rcv_ssthresh不超过window_clamp和3/4剩余接收缓存等)，rcv_ssthresh += 2 * advmss。这是比较常见的情况，这时接收窗口阈值一般增加2 * 1460 = 2920字节。
</span><span class='line'>
</span><span class='line'>这个值还可能有细微波动，这是由于对齐窗口扩大因子的关系。
</span><span class='line'>
</span><span class='line'>----------
</span><span class='line'>
</span><span class='line'>### TCP接收窗口的调整算法（下）
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>本文内容：分析TCP接收窗口的调整算法，主要是接收窗口的调整算法和总结。
</span><span class='line'>
</span><span class='line'>内核版本：3.2.12
</span><span class='line'>
</span><span class='line'>#### 接收窗口的调整算法
</span><span class='line'>经过一系列的前奏，我们终于到了最关键的地方。接下来我们可以看到，接收窗口的大小主要取决于剩余的接收缓存，以及接收窗口当前阈值。决定接收窗口大小的函数tcp_select_window()在tcp_transmit_skb()中调用，也就是说每次我们要发送数据包时，都要使用tcp_select_window()来决定通告的接收窗口大小。
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static int tcp_transmit_skb (struct sock *sk, struct sk_buff *skb, int clone_it,   
</span><span class='line'>                         gfp_t gfp_mask)  
</span><span class='line'>{  
</span><span class='line'>const struct inet_connection_sock *icsk = inet_csk(sk);  
</span><span class='line'>struct inet_sock *inet;  
</span><span class='line'>struct tcp_sock *tp;  
</span><span class='line'>struct tcp_skb_cb *tcb;  
</span><span class='line'>struct tcphdr *th;  
</span><span class='line'>...  
</span><span class='line'>/* Build TCP header and checksum it，以下是TCP头的赋值*/  
</span><span class='line'>th = tcp_hdr(skb); /* skb-&gt;transport_header */  
</span><span class='line'>th-&gt;source = inet-&gt;inet_sport;  
</span><span class='line'>th-&gt;dest = inet-&gt;inet_dport;  
</span><span class='line'>th-&gt;seq = htonl(tcb-&gt;seq);  
</span><span class='line'>th-&gt;ack_seq = htonl(tp-&gt;rcv_nxt);  
</span><span class='line'>/* 这个语句可以看出C语言的强大*/  
</span><span class='line'>*(((__be16 *) th) + 6) = htons(((tcp_header_size &gt;&gt; 2) &lt;&lt; 12) | tcb-&gt;tcp_flags);  
</span><span class='line'>
</span><span class='line'>if (unlikely(tcb-&gt;tcp_flags &amp; TCPHDR_SYN)) {  
</span><span class='line'>    /* RFC1323: The window in SYN &amp; SYN/ACK segments in never scaled. 
</span><span class='line'>     * 从这里我们可以看到，在三次握手阶段，接收窗口并没有按扩大因子缩放。 
</span><span class='line'>      */  
</span><span class='line'>    th-&gt;window = htons(min(tp-&gt;rcv_wnd, 65535U));  
</span><span class='line'>
</span><span class='line'>} else {  
</span><span class='line'>    th-&gt;window = htons(tcp_select_window(sk)); /* 更新接收窗口的大小*/  
</span><span class='line'>}  
</span><span class='line'>th-&gt;check = 0;  
</span><span class='line'>th-&gt;urg_ptr = 0;  
</span><span class='line'>...  
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>来看下tcp_select_window()。
</span><span class='line'>
</span><span class='line'>注意，接收窗口的返回值只有16位，所以如果不使用窗口扩大选项，那么接收窗口的最大值为65535。
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;static u16 tcp_select_window(struct sock *sk)  
</span><span class='line'>{  
</span><span class='line'>struct tcp_sock *tp = tcp_sk(sk);  
</span><span class='line'>
</span><span class='line'>u32 cur_win = tcp_receive_window(tp); /* 当前接收窗口的剩余大小*/  
</span><span class='line'>u32 new_win = __tcp_select_window(sk); /*根据剩余的接收缓存，计算新的接收窗口的大小 */  
</span><span class='line'>
</span><span class='line'>/* Never shrink the offered window，不允许缩小已分配的接收窗口*/  
</span><span class='line'>if (new_win &lt; cur_win) {  
</span><span class='line'>    /* Danger Will Robinson! 
</span><span class='line'>     * Don't update rcv_wup/rcv_wnd here or else 
</span><span class='line'>     * we will not be able to advertise a zero window in time. --DaveM 
</span><span class='line'>     * Relax Will Robinson. 
</span><span class='line'>     */  
</span><span class='line'>    new_win = ALIGN(cur_win, 1 &lt;&lt; tp-&gt;rx_opt.rcv_wscale);  
</span><span class='line'>}  
</span><span class='line'>
</span><span class='line'>/* 更新接收窗口大小。个人觉得这句代码应该后移，因为此时接收窗口的大小还未最终确定！*/  
</span><span class='line'>tp-&gt;rcv_wnd = new_win;  
</span><span class='line'>tp-&gt;rcv_wup = tp-&gt;rcv_nxt; /* 更新接收窗口的左边界，把未确认的数据累积确认*/  
</span><span class='line'>
</span><span class='line'>/* 确保接收窗口大小不超过规定的最大值。 
</span><span class='line'>  * Make sure we do not exceed the maximum possible scaled window. 
</span><span class='line'> */  
</span><span class='line'>if (! tp-&gt;rx_opt.rcv_wscale &amp;&amp; sysctl_tcp_workaround_signed_windows)  
</span><span class='line'>    /* 不能超过32767，因为一些奇葩协议采用有符号的接收窗口大小*/  
</span><span class='line'>    new_win = min(new_win, MAX_TCP_WINDOW);   
</span><span class='line'>
</span><span class='line'>else  
</span><span class='line'>    new_win = min(new_win, (65535U &lt;&lt; tp-&gt;rx_opt.rcv_wscale));  
</span><span class='line'>
</span><span class='line'>/* RFC1323 scaling applied. 按比例因子缩小接收窗口，这样最多能表示30位*/  
</span><span class='line'>new_win &gt;&gt;= tp-&gt;rx_opt.rcv_wscale;  
</span><span class='line'>
</span><span class='line'>/* If we advertise zero window, disable fast path. */  
</span><span class='line'>if (new_win == 0)  
</span><span class='line'>    tp-&gt;pred_flags = 0;  
</span><span class='line'>
</span><span class='line'>return new_win; /* 返回最终的接收窗口大小*/  
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>每次发送一个TCP数据段，都要构建TCP首部，这时会调用tcp_select_window选择接收窗口大小。  
</span><span class='line'>窗口大小选择的基本算法：  
</span><span class='line'>1. 计算当前接收窗口的剩余大小cur_win。  
</span><span class='line'>2. 计算新的接收窗口大小new_win，这个值为剩余接收缓存的3/4，且不能超过rcv_ssthresh。  
</span><span class='line'>3. 取cur_win和new_win中值较大者作为接收窗口大小。  
</span><span class='line'>
</span><span class='line'>##### tcp_workaround_signed_windows
</span><span class='line'>标识在未启用窗口扩大因子选项时，是否使用初始值不超过32767的TCP窗口，默认值为0(不启用)。  
</span><span class='line'>我们知道在不启用窗口扩大因子选项时，接收窗口有16位，最大值为65535。但是有些很糟糕的协议  
</span><span class='line'>采用的是有符号的窗口大小，所以最大值只能为32767。当然，这种协议并不多见：）。  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;@include/net/tcp.h：  
</span><span class='line'>/* 
</span><span class='line'> * Never offer a window over 32767 without using window scaling. 
</span><span class='line'> * Some poor stacks do signed 16bit maths!  
</span><span class='line'> */  
</span><span class='line'>#define MAX_TCP_WINDOW 32767U
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>计算当前接收窗口的剩余大小cur_win。
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;/*  
</span><span class='line'> * Compute the actual receive window we are currently advertising. 
</span><span class='line'> * rcv_nxt can be after the window if our peer push more data than 
</span><span class='line'> * the offered window. 
</span><span class='line'> */  
</span><span class='line'>static inline u32 tcp_receive_window (const struct tcp_sock *tp)  
</span><span class='line'>{  
</span><span class='line'>s32 win = tp-&gt;rcv_wup + tp-&gt;rcv_wnd - tp-&gt;rcv_nxt;  
</span><span class='line'>
</span><span class='line'>if (win &lt; 0)  
</span><span class='line'>    win = 0;  
</span><span class='line'>
</span><span class='line'>return (u32) win;  
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>详细说明：  
</span><span class='line'>This is calculated as the last advertised window minus unacknowledged data length:  
</span><span class='line'>tp-&gt;rcv_wnd - (tp-&gt;rcv_nxt - tp-&gt;rcv_wup)  
</span><span class='line'>tp-&gt;rcv_wup is synced with next byte to be received (tp-&gt;rcv_nxt) only when we are sending ACK in tcp_select_window(). If there is no unacknowledged bytes, the routine returns the exact receive window advertised last.
</span><span class='line'>
</span><span class='line'>计算新的接收窗口大小new_win，这个是关键函数，我们将看到rcv_ssthresh所起的作用。
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;/*  
</span><span class='line'> * calculate the new window to be advertised. 
</span><span class='line'> */  
</span><span class='line'>u32 __tcp_select_window(struct sock *sk)  
</span><span class='line'>{  
</span><span class='line'>struct inet_connection_sock *icsk = inet_csk(sk);  
</span><span class='line'>struct tcp_sock *tp = tcp_sk(sk);  
</span><span class='line'>
</span><span class='line'>/* MSS for the peer's data. Previous versions used mss_clamp here. 
</span><span class='line'> * I don't know if the value based on our guesses of peer's MSS is better 
</span><span class='line'> * for the performance. It's more correct but may be worse for the performance 
</span><span class='line'> * because of rcv_mss fluctuations. —— SAW 1998/11/1 
</span><span class='line'> */  
</span><span class='line'>int mss = icsk-&gt;icsk_ack.rcv_mss;/*这个是估计目前对端有效的发送mss，而不是最大的*/    
</span><span class='line'>int free_space = tcp_space(sk); /* 剩余接收缓存的3/4 */  
</span><span class='line'>int full_space = min_t(int, tp-&gt;window_clamp, tcp_full_space(sk)); /* 总的接收缓存 */  
</span><span class='line'>int window;  
</span><span class='line'>
</span><span class='line'>if (mss &gt; full_space)  
</span><span class='line'>    mss = full_space; /* 减小mss，因为接收缓存太小了*/  
</span><span class='line'>
</span><span class='line'>/* receive buffer is half full，接收缓存使用一半以上时要小心了 */  
</span><span class='line'>if (free_space &lt; (full_space &gt;&gt; 1)) {  
</span><span class='line'>    icsk-&gt;icsk_ack.quick = 0; /* 可以快速发送ACK段的数量置零*/  
</span><span class='line'>
</span><span class='line'>    if (tcp_memory_pressure)/*有内存压力时，把接收窗口限制在5840字节以下*/  
</span><span class='line'>        tp-&gt;rcv_ssthresh = min(tp-&gt;rcv_ssthresh, 4U * tp-&gt;advmss);  
</span><span class='line'>
</span><span class='line'>    if (free_space &lt; mss) /* 剩余接收缓存不足以接收mss的数据*/  
</span><span class='line'>        return 0;  
</span><span class='line'>}  
</span><span class='line'>
</span><span class='line'>if (free_space &gt; tp-&gt;rcv_ssthresh)  
</span><span class='line'>    /* 看！不能超过当前接收窗口阈值，这可以达接收窗口平滑增长的效果*/  
</span><span class='line'>    free_space = tp-&gt;rcv_ssthresh;    
</span><span class='line'>
</span><span class='line'>/* Don't do rounding if we are using window scaling, since the scaled window will 
</span><span class='line'> * not line up with the MSS boundary anyway. 
</span><span class='line'> */  
</span><span class='line'>window = tp-&gt;rcv_wnd;  
</span><span class='line'>if (tp-&gt;rx_opt.rcv_wscale) { /* 接收窗口扩大因子不为零*/  
</span><span class='line'>    window = free_space;  
</span><span class='line'>
</span><span class='line'>    /* Advertise enough space so that it won't get scaled away. 
</span><span class='line'>     * Import case: prevent zero window announcement if 1 &lt;&lt; rcv_wscale &gt; mss. 
</span><span class='line'>     * 防止四舍五入造通告的接收窗口偏小。 
</span><span class='line'>      */  
</span><span class='line'>    if (((window &gt;&gt; tp-&gt;rx_opt.rcv_wscale) &lt;&lt; tp-&gt;rx_opt.rcv_wscale) != window)  
</span><span class='line'>        window =(((window &gt;&gt; tp-&gt;rx_opt.rcv_wscale) + 1) &lt;&lt; tp-&gt;rx_opt.rcv_wscale);  
</span><span class='line'>
</span><span class='line'>} else {  
</span><span class='line'>    /* Get the largest window that is a nice multiple of mss. 
</span><span class='line'>     * Window clamp already applied above. 
</span><span class='line'>     * If our current window offering is within 1 mss of the free space we just keep it. 
</span><span class='line'>     * This prevents the divide and multiply from happening most of the time. 
</span><span class='line'>     * We also don't do any window rounding when the free space is too small. 
</span><span class='line'>     */  
</span><span class='line'>    /* 截取free_space中整数个mss，如果rcv_wnd和free_space的差距在一个mss以上*/  
</span><span class='line'>    if (window &lt;= free_space - mss || window &gt; free_space)   
</span><span class='line'>        window = (free_space / mss) * mss;  
</span><span class='line'>    /* 如果free space过小，则直接取free space值*/  
</span><span class='line'>    else if (mss = full_space &amp;&amp; free_space &gt; window + (full_space &gt;&gt; 1))  
</span><span class='line'>        window = free_space;  
</span><span class='line'>    /* 当free_space -mss &lt; window &lt; free_space时，直接使用rcv_wnd，不做修改*/  
</span><span class='line'>}      
</span><span class='line'>
</span><span class='line'>return window;  
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;/* 剩余接收缓存的3/4。 
</span><span class='line'> * Note: caller must be prepared to deal with negative returns. 
</span><span class='line'> */  
</span><span class='line'>static inline int tcp_space (const struct sock *sk)  
</span><span class='line'>{  
</span><span class='line'>return tcp_win_from_space(sk-&gt;sk_rcvbuf - atomic_read(&amp;sk-&gt;sk_rmem_alloc));  
</span><span class='line'>}  
</span><span class='line'>
</span><span class='line'>static inline int tcp_win_from_space(int space)  
</span><span class='line'>{  
</span><span class='line'>return sysctl_tcp_adv_win_scale &lt;= 0 ? (space &gt;&gt; (-sysctl_tcp_adv_win_scale)) :  
</span><span class='line'>    space - (space &gt;&gt; sysctl_tcp_adv_win_scale);  
</span><span class='line'>}  
</span><span class='line'>
</span><span class='line'>/* 最大的接收缓存的3/4 */  
</span><span class='line'>static inline int tcp_full_space(const struct sock *sk)  
</span><span class='line'>{  
</span><span class='line'>return tcp_win_from_space(sk-&gt;sk_rcvbuf);  
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;总体来说，新的接收窗口大小值为：剩余接收缓存的3/4，但不能超过接收缓存的阈值。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;小结&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;接收窗口的调整算法主要涉及：&lt;br/&gt;
</span><span class='line'>（1）window_clamp和sk_rcvbuf的调整，在之前的blog《TCP接收缓存大小的动态调整》中有分析。&lt;br/&gt;
</span><span class='line'>（2）rcv_ssthresh接收窗口当前阈值的动态调整，一般增长2*advmss。&lt;br/&gt;
</span><span class='line'>（3）rcv_wnd接收窗口的动态调整，一般为min(&frac34; free space in sk_rcvbuf, rcv_ssthresh)。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;如果剩余的接收缓存够大，rcv_wnd受限于rcv_ssthresh。这个时候每收到一个大的数据包，rcv_wnd就增大2920字节(由于缩放原因这个值可能波动)。这就像慢启动一样，接收窗口指数增长。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;接收窗口当然不能无限制增长，当它增长到一定大小时，就会受到一系列因素的限制，比如window_clamp和sk_rcvbuf，或者剩余接收缓存区大小。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;当应用程序读取接收缓冲区数据不够快时，或者发生了丢包时，接收窗口会变小，这主要受限于剩余的接收缓存的大小。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;总的来说，接收窗口的调整算法涉及到一些变量，由于这些变量本身又是动态变化的，所以分析起来比较复杂，笔者也还需要再进行深入了解：）&lt;/p&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[TCP的核心系列 — SACK和DSACK的实现]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2015/03/19/kernel-net-sack-dsack/"/&gt;
</span><span class='line'>&lt;updated&gt;2015-03-19T16:27:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2015/03/19/kernel-net-sack-dsack&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;p&gt;&lt;a href="http://blog.csdn.net/zhangskd/article/details/9613347"&gt;TCP的核心系列 — SACK和DSACK的实现（一）&lt;/a&gt;&lt;br/&gt;
</span><span class='line'>&lt;a href="http://blog.csdn.net/zhangskd/article/details/8979718"&gt;TCP的核心系列 — SACK和DSACK的实现（二）&lt;/a&gt;&lt;br/&gt;
</span><span class='line'>&lt;a href="http://blog.csdn.net/zhangskd/article/details/9706113"&gt;TCP的核心系列 — SACK和DSACK的实现（三）&lt;/a&gt;&lt;br/&gt;
</span><span class='line'>&lt;a href="http://blog.csdn.net/zhangskd/article/details/9766895"&gt;TCP的核心系列 — SACK和DSACK的实现（四）&lt;/a&gt;&lt;br/&gt;
</span><span class='line'>&lt;a href="http://blog.csdn.net/zhangskd/article/details/9768315"&gt;TCP的核心系列 — SACK和DSACK的实现（五）&lt;/a&gt;&lt;br/&gt;
</span><span class='line'>&lt;a href="http://blog.csdn.net/zhangskd/article/details/9768519"&gt;TCP的核心系列 — SACK和DSACK的实现（六）&lt;/a&gt;&lt;br/&gt;
</span><span class='line'>&lt;a href="http://blog.csdn.net/zhangskd/article/details/9698901"&gt;TCP的核心系列 — SACK和DSACK的实现（七）&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;hr /&gt;
</span><span class='line'>
</span><span class='line'>&lt;h3&gt;TCP的核心系列 — SACK和DSACK的实现（一）&lt;/h3&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;TCP的实现中，SACK和DSACK是比较重要的一部分。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;SACK和DSACK的处理部分由Ilpo Järvinen (&lt;a href="&#109;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#x69;&#108;&#112;&#x6f;&#46;&#x6a;&#x61;&#114;&#x76;&#x69;&#110;&#x65;&#x6e;&#x40;&#x68;&#101;&#108;&#x73;&#105;&#x6e;&#107;&#105;&#x2e;&#102;&#105;"&gt;&#x69;&#x6c;&#112;&#111;&#x2e;&#106;&#97;&#x72;&#x76;&#x69;&#x6e;&#101;&#x6e;&#64;&#x68;&#101;&#108;&#115;&#105;&#x6e;&#107;&#105;&#46;&#x66;&#105;&lt;/a&gt;) 维护。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;tcp_ack()处理接收到的带有ACK标志的数据段时，如果此ACK处于慢速路径，且此ACK的记分牌不为空，则调用&lt;br/&gt;
</span><span class='line'>tcp_sacktag_write_queue()来根据SACK选项标记发送队列中skb的记分牌状态。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;笔者主要分析18和37这两个版本的实现。&lt;br/&gt;
</span><span class='line'>相对而言，18版本的逻辑清晰，但效率较低；37版本的逻辑复杂，但效率较高。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;本文主要内容：18版tcp_sacktag_write_queue()的实现，也即18版SACK和DSACK的实现。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;18版数据结构&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    /* 这就是一个SACK块 */  
</span><span class='line'>struct tcp_sack_block {  
</span><span class='line'>    u32 start_seq; /* 起始序号 */  
</span><span class='line'>    u32 end_seq; /* 结束序号 */  
</span><span class='line'>};
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    struct tcp_sock {  
</span><span class='line'>    ...  
</span><span class='line'>    /* Options received (usually on last packet, some only on SYN packets). */  
</span><span class='line'>    struct tcp_options_received rx_opt;  
</span><span class='line'>    ...  
</span><span class='line'>    struct tcp_sack_block recv_sack_cache[4]; /* 保存收到的SACK块，用于提高效率*/  
</span><span class='line'>    ...  
</span><span class='line'>    /* 快速路径中使用，上次第一个SACK块的结束处，现在直接从这里开始处理 */  
</span><span class='line'>    struct sk_buff *fastpath_skb_hint;       
</span><span class='line'>    int fastpath_cnt_hint;  /* 快速路径中使用，上次记录的fack_count，现在继续累加 */  
</span><span class='line'>    ...  
</span><span class='line'>
</span><span class='line'>};
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    struct tcp_options_received {  
</span><span class='line'>    ...  
</span><span class='line'>    u16 saw_tstamp : 1, /* Saw TIMESTAMP on last packet */  
</span><span class='line'>            tstamp_ok : 1, /* TIMESTAMP seen on SYN packet */  
</span><span class='line'>            dsack : 1, /* D-SACK is scheduled, 下一个发送段是否存在D-SACK */  
</span><span class='line'>            sack_ok : 4, /* SACK seen on SYN packet, 接收方是否支持SACK */  
</span><span class='line'>            ...  
</span><span class='line'>    u8 num_sacks; /* Number of SACK blocks, 下一个发送段中SACK块数 */  
</span><span class='line'>    ...  
</span><span class='line'>};
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;!-- more --&gt;
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;18版本实现&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;18版本的逻辑较清晰，我们先来看看。</span></code></pre></td></tr></table></div></figure>
    static int tcp_sacktag_write_queue(struct sock <em>sk, struct sk_buff </em>ack_skb, u32 prior_snd_una)<br/>
    {<br/>
        const struct inet_connection_sock <em>icsk = inet_csk(sk);<br/>
        struct tcp_sock </em>tp = tcp_sk(sk);</p>

<pre><code>    /* SACK选项的起始地址，sacked为SACK选项在TCP首部的偏移 */  
    unsigned char *ptr = ack_skb-&gt;h.raw + TCP_SKB_CB(ack_skb)-&gt;sacked;  

    struct tcp_sack_block *sp = (struct tcp_sack_block *) (ptr + 2); /* 指向第一个sack块 */  
    int num_sacks = (ptr[1] - TCPOLEN_SACK_BASE) &gt;&gt; 3; /* sack的块数 */  

    int reord = tp-&gt;packets_out; /* 乱序的起始包位置，一开始设为最大 */  
    int prior_fackets; /* 上次的fackets_out */  
    u32 lost_retrans = 0; /* 重传包可能丢失时SACK块结束序号，表示需要遍历到的最高序号 */  
    int flag = 0; /* 有两种用途：先表示是否为快速路径，后用于返回标志 */  
    int dup_sack = 0; /* 有没有DSACK */  
    int i;  

     /* 如果之前没有SACKed的数据 */  
    if (! tp-&gt;sacked_out)  
        tp-&gt;fackets_out = 0;  /* FACK是根据最新的SACK来计算的，所以也要为0 */  
    prior_fackets = tp-&gt;fackets_out; /* 处理前先保存上次的fackets_out */  

    /* SACK fastpath: 
     * if the only SACK change is the increase of the end_seq of the first block then only 
     * apply that SACK block and use retrans queue hinting otherwise slowpath. 
     * 什么是快速路径：就是只有第一个SACK块的结束序号发生变化，其它的都不变。 
      */  
    flag = 1; /* 为1的话为快速路径，0为慢速路径 */  

    for (i = 0; i &lt; num_sacks; i++) {  
        __u32 start_seq = ntohl(sp[i].start_seq); /* 块的起始序号 */  
        __u32 end_seq = ntohl(sp[i].end_seq); /* 块的结束序号 */  

       /* 判断是否进入快速路径。 
         * 对第一个块：只要求起始序号相同 
         * 对于非第一个块：要求起始序号和结束序号都相同 
         * 也就是说，快速路径指的是只有第一个块的结束序号增加的情况 
         */  
        if (i == 0) {  
            if (tp-&gt;recv_sack_cache[i].start_seq != start_seq)  
                flag = 0;  

        } else {  
            if ((tp-&gt;recv_sack_cache[i].start_seq != start_seq) ||  
                (tp-&gt;recv_sack_cache[i].end_seq != end_seq))  
                flag = 0;  
        }  

        /* 更新，保存这次收到的SACK块 */  
        tp-&gt;recv_sack_cache[i].start_seq = start_seq;  
        tp-&gt;recv_sack_cache[i].end_seq = end_seq;  

        /* Check for D-SACK.  
         * 检测是否有DSACK ，DSACK块如果有，只能在第一个块 
          */  
        if (i == 0) {  
            u32 ack = TCP_SKB_CB(ack_skb)-&gt;ack_seq;  

            /* 如果第一个SACK块的起始序号小于它的确认序号，说明此SACK块包含了确认过的数据 */  
            if (before(start_seq, ack)) {  
                dup_sack = 1;  
                tp-&gt;rx_opt.sack_ok |= 4;   
                NET_INC_STATS_BH(LINUX_MIB_TCPDSACKRECV);  

            /* 如果第一个SACK块包含在第二个SACK块中，也说明第一个SACK块是重复的，即DSACK */  
            } else if (num_sacks &gt; 1 &amp;&amp;  
                !after(end_seq, ntohl(sp[1].end_seq)) &amp;&amp;  
                !before(start_seq, ntohl(sp[1].start_seq))) {  
                    dup_sack = 1;  
                    tp-&gt;rx_opt.sack_ok |= 4;  
                    NET_INC_STATS_BH(LINUX_MIB_TCPDSACKOFORECV);  
            }  
        }  

        /* D-SACK for already forgotten data... 
         * Do dumb counting. 
         * undo_retrans记录重传数据包的个数，如果undo_retrans降到0， 
          * 就说明之前的重传都是不必要的，进行拥塞调整撤销。 
          * 条件：DSACK、undo_marker &lt; end_seq &lt;= prior_snd_una 
         */  
        if (dup_sack &amp;&amp; !after(end_seq, prior_snd_una) &amp;&amp;  
            after(end_seq, tp-&gt;undo_marker))  
            tp-&gt;undo_retrans--;  

        /* Eliminate too old ACKs, but take into account more or less fresh ones, 
         * they can contain valid SACK info. 
         * tp-&gt;max_window为接收方通告过的最大接收窗口。 
          * 如果SACK信息是很早以前的，直接丢弃。 
          */  
        if (before(ack, prior_snd_una - tp-&gt;max_window))  
            return 0;  
    }  

    if (flag)  
        num_sacks = 1; /* 快速路径时只有第一个块有变化，处理第一个块即可 */  
    else {  
        int j;  
        /* 上次第一个SACK块的结束处，也是这次快速路径的开始点，慢速路径中重置了 */  
        tp-&gt;fastpath_skb_hint = NULL;  

        /* order SACK blocks to allow in order walk of the retrans queue. 
         * 对SACK块按起始序号，从小到大冒泡排序，以便与接下来的顺序遍历。 
          */  
        for (i = num_sacks - 1; i &gt; 0; i--) {  
            for (j = 0; j &lt; i; j++) {  
                if (after(ntohl(sp[j].start_seq), ntohl(sp[j+1].start_seq))) {  
                    sp[j].start_seq = htonl(tp-&gt;recv_sack_cache[j+1].start_seq);  
                    sp[j].end_seq = htonl(tp-&gt;recv_sack_cache[j+1].end_seq);  
                    sp[j+1].start_seq = htonl(tp-&gt;recv_sack_cache[j].start_seq);  
                    sp[j+1].end_seq = htonl(tp-&gt;recv_sack_cache[j].end_seq);  
                }  
            }      
        }  
    }  

    /* clear flag as used for different purpose in following code */  
    flag = 0; /* 用于返回一些标志 */  

    /* 逐个处理SACK块，可能只有一个，也可能多个 */  
    for (i = 0; i &lt; num_sacks; i++, sp++) {  
        struct sk_buff *skb;  
        __u32 start_seq = ntohl(sp-&gt;start_seq); /* SACK块起始序号 */  
        __u32 end_seq = ntohl(sp-&gt;end_seq); /* SACK块结束序号 */  
        int fack_count; /* 用于更新fackets_out */  

        /* Use SACK fastpath hint if valid. 
         * 如果处于快速路径，那么可以不用从头遍历发送队列。 
          */  
        if (tp-&gt;fastpath_skb_hint) {  
            skb = tp-&gt;fastpath_skb_hint; /* 从这个段开始处理 */  
            fack_count = tp-&gt;fastpath_cnt_hint; /* 已有的fackets_out */  

        } else { /* 否则慢速路径，从头开始处理 */  
            skb = sk-&gt;sk_write_queue.next; /* 发送队列头 */  
            fack_count = 0;  
        }  

        /* Event B in the comment above. 
         * high_seq是进入Recovery或Loss时的snd_nxt，如果high_seq被SACK了，那么很可能有数据包 
          * 丢失了，不然就可以ACK掉high_seq返回Open态了。 
          */  
        if (after(end_seq, tp-&gt;high_seq))  
            flag |= FLAG_DATA_LOST;  

        /* 从skb开始遍历发送队列 */  
        sk_stream_for_retrans_queue_from(skb, sk) {  
            int in_sack, pcount;  
            u8 sacked;  

            /* 记录最后一个正在处理的段，下次进入快速路径时，可以直接从这里 
               * 开始处理，而不用从头遍历发送队列。 
               */  
            tp-&gt;fastpath_skb_hint = skb;  
            tp-&gt;fastpath_cnt_hint = fack_count;  

            /* The retransmission queue is always in order, so we can short-circuit 
             * the walk early. 
             * 当前skb段的序号超过SACK块的右端时，说明这个SACK块已经处理好了。 
               */  
            if (! before(TCP_SKB_CB(skb)-&gt;seq, end_seq))  
                break;  

            /* 这个段是否完全包含在SACK块中 */  
            in_sack = ! after(start_seq, TCP_SKB_CB(skb)-&gt;seq) &amp;&amp;  
                               ! before(end_seq, TCP_SKB_CB(skb)-&gt;end_seq);  
            pcount = tcp_skb_pcount(skb); /* 这个段分为多少个包 */  

           /* 如果当前的段是TSO段，且它的一部份包含在SACK块中。 
              * 那么那些已经被SACK的部分就不用再重传了，所以需要重新分割TSO段。 
              */  
            if (pcount &gt; 1 &amp;&amp; ! in_sack &amp;&amp;   
                after(TCP_SKB_CB(skb)-&gt;end_seq, start_seq)) {  
                unsigned int pkt_len;  

                /* 表示TSO段的后半部在SACK块之外 */  
                in_sack = ! after(start_seq, TCP_SKB_CB(skb)-&gt;seq);  

                if (! in_sack) /* 如果TSO段的前半部在SACK块之外 */  
                    pkt_len = (start_seq - TCP_SKB_CB(skb)-&gt;seq); /* SACK块之外段的长度 */  
                else  
                    pkt_len = (end_seq - TCP_SKB_CB(skb)-&gt;seq); /* SACK块之内段的长度 */  

                /* 把TSO段分为两部分 */  
                if (tcp_fragment(sk, skb, pkt_len, skb_shinfo(skb)-&gt;gso_size))  
                    break;  

                pcount += tcp_skb_pcount(skb); /* skb缩减了，需要重新计算 */  
            }  

            fack_count += pcount; /* 累加fackets_out */  

            sacked = TCP_SKB_CB(skb)-&gt;sacked; /* 这就是记分板scoreboard */  

            /* Account D-SACK for retransmitted packet. 
             * 如果此skb属于DSACK块，且skb被重传过。 
               * 这里in_sack指的是：全部包含在SACK块中，还有前半部包含也算，因为分割了：） 
               */  
            if ((dup_sack &amp;&amp; in_sack) &amp;&amp; (sacked &amp; TCPCB_RETRANS) &amp;&amp;  
                after(TCP_SKB_CB(skb)-&gt;end_seq, tp-&gt;undo_marker))  
                tp-&gt;undo_retrans--; /* 如果减为0，那么说明之前重传都是不必要的，进行拥塞控制调整撤销 */  

            /* The frame is ACKed. 当这个skb被确认了*/  
            if (! after(TCP_SKB_CB(skb)-&gt;end_seq, tp-&gt;snd_una)) {  
                /* 乱序情况1：R|S标志，收到DSACK */  
                if (sacked &amp; TCPCB_RETRANS) {  
                    if ((dup_sack &amp;&amp; in_sack) &amp;&amp; (sacked &amp; TCPCB_SACKED_ACKED))  
                        reord = min(fack_count, reord); /* 更新乱序的起始位置 */  

                } else {  
                   /* 乱序情况2：一个包落在highest_sack之前，它既没被SACK过，也不是重传的， 
                       * 现在才到达了，那么它就是乱序了。就是前面的洞自动填满了：） 
                       */  
                    if (fack_count &lt; prior_fackets &amp;&amp; ! (sacked &amp; TCPCB_SACKED_ACKED))  
                        reord = min(fack_count, reord);  
                }  

                /* Nothing to do; acked frame is about to be dropped. 
                 * 这个skb已经被正常确认了，不用再处理了，它即将被丢弃。 
                    */  
                continue;  
            }  

           /* 如果这个包是重传包，并且它的snd_nxt小于此块的结束序号， 
             * 那么这个重传包可能是丢失了，我们记录这个块的结束序号， 
             * 作为接下来遍历的最高序号。 
             */  
            if ((sacked &amp; TCPCB_SACKED_RETRANS) &amp;&amp;   
                after(end_seq, TCP_SKB_CB(skb)-&gt;ack_seq) &amp;&amp;  
                (! lost_retrans || after(end_seq, lost_retrans)))  
                lost_retrans = end_seq;  

            /* 如果这个包不包含在SACK块中，即在SACK块之外，则不用继续处理 */  
            if (! in_sack)  
                continue;  

            /* 如果skb还没有被标志为SACK，那么进行处理 */  
            if (! (sacked &amp; TCPCB_SACKED_ACKED)) {  
                /* 有R标志，表示被重传过 */  
                if (sacked &amp; TCPCB_SACKED_RETRANS) {  
                    /* If the segment is not tagged as lost, we do not clear RETRANS, believing 
                     * that retransmission is still in flight. 
                     * 如果之前的标志是：R | L，那么好，现在收到包了，可以清除R和L。 
                        * 如果之前的标志是：R，那么认为现在收到的是orig，重传包还在路上，所以不用干活：） 
                        */  
                    if (sacked &amp; TCPCB_LOST) {  
                        TCP_SKB_CB(skb)-&gt;sacked &amp;= ~(TCPCB_LOST | TCPCB_SACKED_RETRANS); /* 取消L和R标志 */  
                        tp-&gt;lost_out -= tcp_skb_pcount(skb); /* 更新LOST包个数 */  
                        tp-&gt;retrans_out -= tcp_skb_pcount(skb); /* 更新RETRANS包个数 */  
                        /* clear lost hint */  
                        tp-&gt;retransmit_skb_hint = NULL;  
                    }  

                } else {  
                    /* New sack for not retransmitted frame, which was in hole. It is reordering. 
                     * 如果一个包落在highest_sack之前，它即没被SACK过，也不是重传的，那么 
                        * 它肯定是乱序了，到现在才被SACK。 
                        */  
                    if (! (sacked &amp; TCPCB_RETRANS) &amp;&amp; fack_count &lt; prior_fackets)  
                        reord = min(fack_count, reord); /* 记录乱序的起始 */  

                    /* 如果有L标志 */  
                    if (sacked &amp; TCPCB_LOST) {  
                        TCP_SKB_CB(skb)-&gt;sacked &amp;= ~TCPCB_LOST; /* 清除L标志 */  
                        tp-&gt;lost_out -= tcp_skb_pcount(skb); /* 更新lost_out */  
                        /* clear lost hint */  
                        tp-&gt;retransmit_skb_hint = NULL;  
                    }  
                }  

                TCP_SKB_CB(skb)-&gt;sacked |= TCPCB_SACKED_ACKED; /* 打上S标志 */  
                flag |= FLAG_DATA_SACKED; /* New SACK */  
                tp-&gt;sacked_out += tcp_skb_pcount(skb); /* 更新sacked_out */  

                if (fack_count &gt; tp-&gt;fackets_out)  
                    tp-&gt;fackets_out = fack_count; /* 更新fackets_out */  

            } else { /* 已经有S标志 */  
                /* 如果之前是R|S标志，且这个包被DSACK了，说明是乱序 */  
                if (dup_sack &amp;&amp; (sacked &amp; TCPCB_RETRANS))  
                    reord = min(fack_count, reord);  
            }  

            /* D-SACK. We can detect redundant retransmission in S|R and plain R frames 
             * and clear it.  
             * undo_retrans is decreased above, L|R frames are accounted above as well. 
             * 如果skb被D-SACK，并且它的重传标志还未被清除，那么现在清除。 
               */  
            if (dup_sack &amp;&amp; (TCP_SKB_CB(skb)-&gt;sacked &amp; TCPCB_SACKED_RETRANS)) {  
                TCP_SKB_CB(skb)-&gt;sacked &amp;= ~TCPCB_SACKED_RETRANS;  
                tp-&gt;retrans_out -= tcp_skb_pcount(skb);  
                tp-&gt;retransmit_skb_hint = NULL;  
            }  
        }  
    }  

    /* Check for lost retransmit. This superb idea is borrowed from "ratehalving." Event C. 
     * 如果lost_retrans不为0，且处于Recovery状态，说明有重传包丢失，进行处理。 
     */  
    if (lost_retrans &amp;&amp; icsk-&gt;icsk_ca_state == TCP_CA_Recovery) {  
        struct sk_buff *skb;  

        /* 从头开始遍历发送队列 */  
        sk_stream_for_retrans_queue(skb, sk) {  
            /* lost_retrans记录的是SACK块结束序号，并且只在小于lost_retrans内有发现重传包丢失 */  
            if (after(TCP_SKB_CB(skb)-&gt;seq, lost_retrans))  
                break;  

            /* 不关心成功确认过的包 */  
            if (! after(TCP_SKB_CB(skb)-&gt;end_seq, tp-&gt;snd_una)  
                continue;  

            /* 现在判断这个重传包是否丢失。 
              * 这个包要是重传包，并且它的snd_nxt小于lost_retrans 
             */  
            if ((TCP_SKB_CB(skb)-&gt;sacked &amp; TCPCB_SACKED_RETRANS) &amp;&amp;  
                after(lost_retrans, TCP_SKB_CB(skb)-&gt;ack_seq) &amp;&amp;  (IsFack(tp) ||  
                !before(lost_retrans, TCP_SKB_CB(skb)-&gt;ack_seq + tp-&gt;reordering * tp-&gt;mss_cache))) {  
                TCP_SKB_CB(skb)-&gt;sacked &amp;= ~TCPCB_SACKED_RETRANS; /* 清除R标志 */  
                tp-&gt;retrans_out -= tcp_skb_pcount(skb); /* 更新retrans_out */  
                /* clear lost hint */  
                tp-&gt;retransmit_skb_hint = NULL;  

                /* 给这个包重新打上L标志 */  
                if (! (TCP_SKB_CB(skb)-&gt;sacked &amp; (TCPCB_LOST | TCPCB_SACKED_ACKED))) {  
                    tp-&gt;lost_out += tcp_skb_pcount(skb); /* 更新lost_out */  
                    TCP_SKB_CB(skb)-&gt;sacked |= TCPCB_LOST; /* 打上L标志 */  
                    /* 这个弄错了吧？应该是FLAG_DATA_LOST才对 */  
                    flag |= FLAG_DATA_SACKED;  
                    NET_INC_STATS_BH(LINUX_MIB_TCPLOSTRETRANSMIT);  
                }  
            }   
        }  
    }  

    tp-&gt;left_out = tp-&gt;sacked_out + tp-&gt;lost_out;  
    /* 更新乱序队列长度。 
     * 乱序队列的长度 = fackets_out - reord + 1，reord记录从第几个包开始乱序 
     */  
    if ((reord &lt; tp-&gt;fackets_out) &amp;&amp; icsk-&gt;icsk_ca_state != TCP_CA_Loss)  
        tcp_update_reordering(sk, ((tp-&gt;fackets_out + 1) - reord), 0);  

#if FASTRETRANS_DEBUG &gt; 0  
    BUG_TRAP((int) tp-&gt;sacked_out &gt;= 0);  
    BUG_TRAP((int) tp-&gt;lost_out &gt;= 0);  
    BUG_TRAP((int) tp-&gt;retrans_out &gt;= 0);  
    BUG_TRAP((int) tcp_packets_in_flight(tp) &gt;= 0);  
#endif  

    return flag;  
}
</code></pre>

<pre><code>
Q: 为什么说18版的实现效率不高呢？  
A: 我们收到num_sacks个SACK块，如果符合快速路径，那么遍历一次发送队列就可以了；  
但是如果不符合快速路径，那么对于每个SACK块，都要遍历一次发送队列，而且都是从头开始遍历，  
这样就做了很多重复工作，复杂度为O(num_sacks * cwnd)。如果cwnd很大的话，CPU消耗会较高。  
37版本在这一方面做了一些优化。

对于18版本中的一些细节，接下来会对照37版本的实现进行详细分析，比如：  
SACK选项的地址在接收时是如何保存起来的，这是在tcp_rcv_established中处理的。  
DSACK的原理和实现，这部分在37中独立出来。  
检测重传包是否丢失的原理和实现，这部分在37中独立出来。  
乱序是如何检测的，它的原理和实现。

##### Reference
RFC 2018  
RFC 2883  

----------------

### TCP的核心系列 — SACK和DSACK的实现（二）


和18版本相比，37版本的SACK和DSACK的实现做了很多改进，最明显的就是需要遍历的次数少了，  
减少了CPU的消耗。37版的性能提升了，代码有大幅度的改动，逻辑也更加复杂了。

本文主要内容：37版tcp_sacktag_write_queue()的实现，也即37版SACK和DSACK的实现。
</code></pre>

<pre><code>/* This defines a selective acknowledgement block. */  
struct tcp_sack_block_wire {  
    __be32 start_seq;  
    __be32 end_seq;  
};  

/* 这就是一个SACK块 */  
struct tcp_sack_block {  
    u32 start_seq; /* 起始序号 */  
    u32 end_seq; /* 结束序号 */  
};  

/* 用于处理SACK块时保存一些信息 */  
struct tcp_sacktag_state {  
    int reord; /* 乱序的位置 */  
    int fack_count; /* 累加fackets_out */  
    int flag; /* 返回标志 */  
};
</code></pre>

<pre><code></code></pre>

<pre><code>struct tcp_sock {  
    ...  
    /* Options received (usually on last packet, some only on SYN packets). */  
    struct tcp_options_received rx_opt;  
    ...  
    /* SACKs data, these 2 need to be together (see tcp_build_and_update_options) 
     * 收到乱序包时填入信息，用于回复 
     */  
    struct tcp_sack_block duplicate_sack[1]; /* D-SACK block */      
    struct tcp_sack_block selective_acks[4]; /* The SACKS themselves */  

    struct tcp_sack_block recv_sack_cache[4]; /* 保存收到的SACK块，用于提高效率*/  
    struct sk_buff *highest_sack; /* highest skb with SACK received 
                                   * (validity guaranteed only if sacked_out &gt; 0) */  
    ...  
};
</code></pre>

<pre><code></code></pre>

<pre><code>struct tcp_options_received {  
    ...  
    u16 saw_tstamp : 1, /* Saw TIMESTAMP on last packet */  
            tstamp_ok : 1, /* TIMESTAMP seen on SYN packet */  
            dsack : 1, /* D-SACK is scheduled, 下一个发送段是否存在D-SACK */  
            sack_ok : 4, /* SACK seen on SYN packet, 接收方是否支持SACK */  
            ...  
    u8 num_sacks; /* Number of SACK blocks, 下一个发送段中SACK块数 */  
    ...  
};
</code></pre>

<pre><code>
#### 37版本实现
37版本做了一些改进，主要是为了提升效率，减少重复工作。
</code></pre>

<pre><code>static int tcp_sacktag_write_queue (struct sock *sk, const struct sk_buff *ack_skb, u32 prior_snd_una)  
{  
    const struct inet_connection_sock *icsk = inet_csk(sk);  
    struct tcp_sock *tp = tcp_sk(sk);  

    /* SACK选项的起始地址，sacked为SACK选项在TCP首部的偏移 */  
    const unsigned char *ptr = (skb_transport_header(ack_skb) + TCP_SKB_CB(ack_skb)-&gt;sacked);  

    struct tcp_sack_block_wire *sp_wire = (struct tcp_sack_block_wire *) (ptr + 2); /* 指向第一个sack块 */  
    struct tcp_sack_block sp[TCP_NUM_SACKS];  
    struct tcp_sack_block *cache;  
    struct tcp_sacktag_state state;  
    struct sk_buff *skb;  
    int num_sacks = min(TCP_NUM_SACKS, (ptr[1] - TCPOLEN_SACK_BASE) &gt;&gt; 3); /* sack的块数 */  
    int used_sacks;  
    int found_dup_sack = 0;  
    int i, j;  
    int first_sack_index;  

    state.flag = 0;  
    state.reord = tp-&gt;packets_out; /* 乱序的起始位置一开始设为最大 */  

    /* 如果之前没有SACKed的数据 */  
    if (! tp-&gt;sacked_out) {  
        if (WARN_ON(tp-&gt;fackets_out))  
            tp-&gt;fackets_out = 0; /* FACK是根据最新的SACK来计算的，也要为0 */  
        tcp_highest_sack_reset(sk); /* tp-&gt;highest_sack置为发送队列的第一个数据包，因为没有SACK块 */  
    }  

    /* 检查第一个SACK块是否为DSACK */  
    found_dup_sack = tcp_check_dsack(sk, ack_skb, sp_wire, num_sacks, prior_snd_una);  
    if (found_dup_sack)  
        state.flag |= FLAG_DSACKING_ACK; /* SACK blocks contained D-SACK info */  

    /* Eliminate too old ACKs, but take into account more or less fresh ones, 
     * they can contain valid SACK info. 
     * tp-&gt;max_window为接收方通告过的最大接收窗口。 
     * 如果SACK信息是很早以前的，直接丢弃。 
     */  
    if (before(TCP_SKB_CB(ack_skb)-&gt;ack_seq, prior_snd_una - tp-&gt;max_window))  
        return 0;  

    if (! tp-&gt;packets_out) /* 如果我们并没有发送数据到网络中，错误 */  
        goto out;  

    used_sacks = 0;  
    first_sack_index = 0;  

    /* 进行SACK块的合法性检查，并确定要使用哪些SACK块 */  
    for (i = 0; i &lt; num_sacks; i++) {  
        int dup_sack = ! i &amp;&amp; found_dup_sack; /* 是否为DSACK块，DSACK块只能是第一个块 */  

        sp[used_sacks].start_seq = get_unaligned_be32(&amp;sp_wire[i].start_seq);  
        sp[used_sacks].end_seq = get_unaligned_be32(&amp;sp_wire[i].end_seq);  

        /* 检查这个SACK块是否为合法的 */  
        if (! tcp_is_sackblock_valid(tp, dup_sack, sp[used_sacks].start_seq,  
                 sp[used_sacks].end_seq)) {  

            /* 不合法的话进行处理 */  
            int mib_idx;  

            if (dup_sack) { /* 如果是DSACK块 */  
                if (! tp-&gt;undo_marker) /* 之前没有进入Recovery或Loss状态 */  
                    mib_idx = LINUX_MIB_TCPDSACKINGOREDNOUNDO; /* TCPSACKIgnoredNoUndo */  
                else  
                    mib_idx = LINUX_MIB_TCPDSACKINGNOREDOLD; /* TCPSACKIgnoredOld */  

            } else { /* 不是DSACK块 */  
                /* Don't count olds caused by ACK reordering，不处理ACK乱序 */  
                if ((TCP_SKB_CB(ack_skb)-&gt;ack_seq != tp-&gt;snd_una) &amp;&amp;  
                    ! after(sp[used_sacks].end_seq, tp-&gt;snd_una))  
                    continue;  
                mib_idx = LINUX_MIB_TCPSACKDISCARD;  
            }  

            NET_INC_STATS_BH(sock_net(sk), mib_idx);  

            if (i == 0)  
                first_sack_index = -1; /* 表示第一个块无效 */  

            continue;  
        }  

        /* Ignore very old stuff early，忽略已确认过的块 */  
        if (! after(sp[used_sacks].end_seq, prior_snd_una))  
            continue;  

        used_sacks++; /* 实际要使用的SACK块数，忽略不合法和已确认过的 */  
    }  

    /* order SACK blocks to allow in order walk of the retrans queue. 
     * 对实际使用的SACK块，按起始序列号，从小到大进行冒泡排序。 
     */  
    for (i = used_sacks - 1; i &gt; 0; i--) {  
        for (j = 0; j &lt; i; j++) {  
            if (after(sp[j].start_seq, sp[j+1].start_seq)) {  
                swap(sp[j], sp[j+1]); /* 交换SACK块 */  

                /* Track where the first SACK block goes to，跟踪第一个SACK块 */  
                if (j == first_sack_index)  
                    first_sack_index = j + 1;  
            }  
        }  
    }  

    skb = tcp_write_queue_head(sk); /* 发送队列的第一个包 */  
    state.fack_count = 0;  
    i = 0;  

   /* 接下来使cache指向之前的SACK块，即recv_sack_cache */  
    if (! tp-&gt;sacked_out) {  /* 如果之前没有SACK块 */  
        /* It's already past, so skip checking against it. 
         * cache指向recv_sack_cache数组的末尾 
         */  
        cache = tp-&gt;recv_sack_cache + ARRAY_SIZE(tp-&gt;recv_sack_cache);  

    } else {  
        cache = tp-&gt;recv_sack_cache;  
        /* Skip empty blocks in at head of the cache. 跳过空的块 */  
        while(tcp_sack_cache_ok(tp, cache) &amp;&amp; ! cache-&gt;start_seq &amp;&amp; ! cache-&gt;end_seq)  
            cache++;  
    }  

    /* 遍历实际用到的SACK块 */  
    while (i &lt; used_sacks) {  
        u32 start_seq = sp[i].start_seq;  
        u32 end_seq = sp[i].end_seq;  
        int dup_sack = (found_dup_sack &amp;&amp; (i == first_sack_index)); /* 这个SACK块是否为DSACK块 */  
        struct tcp_sack_block *next_dup = NULL;  

        /* 如果下一个SACK块是DSACK块，则next_dup指向DSACK块 */  
        if (found_dup_sack &amp;&amp; ((i + 1) == first_sack_index))  
            next_dup = &amp;sp[i + 1];  

        /* Event B in the comment above. 
         * high_seq是进入Recovery或Loss时的snd_nxt，如果high_seq被SACK了，那么很可能有数据包 
         * 丢失了，不然就可以ACK掉high_seq返回Open态了。 
         */  
        if (after(end_seq, tp-&gt;high_seq))  
            state.flag |= FLAG_DATA_LOST;  

        /* Skip too early cached blocks. 
         * 如果cache块的end_seq &lt; SACK块的start_seq，那说明cache块在当前块之前，不用管它了。 
         */  
        while (tcp_sack_cache_ok(tp, cache) &amp;&amp; ! before(start_seq, cache-&gt;end_seq))  
            cache++;  

        /* Can skip some work by looking recv_sack_cache? 
         * 查看当前SACK块和cache块有无交集，避免重复工作。 
         */  
        if (tcp_sack_cache_ok(tp, cache) &amp;&amp; ! dup_sack &amp;&amp;  
            after(end_seq, cache-&gt;start_seq)) {  

            /* Head todo? 处理start_seq到cache-&gt;start_seq之间的段 */  
            if (before(start_seq, cache-&gt;start_seq)) {  
                /* 找到start_seq对应的数据段 */  
                skb = tcp_sacktag_skip(skb, sk, &amp;state, start_seq);  
                /* 遍历start_seq到cache-&gt;start_seq之间的段，为其间的skb更新记分牌 */  
                skb = tcp_sacktag_walk(skb, sk, next_dup, &amp;state, start_seq, cache-&gt;start_seq, dup_sack);  
            }  

            /* Rest of the block already fully processed? 
             * 如果此块剩下的部分都包含在cache块中，那么就不用再处理了。 
             */  
            if (! after(end_seq, cache-&gt;end_seq))  
                goto advance_sp;  

            /* 如果cache-&gt;start_seq &lt; next_dup-&gt;start_seq &lt; cache-&gt;end_seq，那么处理next_dup。 
             * 注意，如果start_seq &lt; next_dup-&gt;start_seq &lt; cache-&gt;start_seq，那么next_dup落在 
             * (start_seq, cache-&gt;start_seq) 内的部分已经被上面的处理过了：）现在处理的next_dup的剩余部分。 
             */  
            skb = tcp_maybe_skipping_dsack(skb, sk, next_dup, &amp;state, cache-&gt;end_seq);  

            /* 处理(cache-&gt;end_seq, end_seq) ...tail remains todo... */  
            if (tcp_highest_sack_seq(tp) == cache-&gt;end_seq) {  
                skb = tcp_highest_sack(sk);  
                /* 如果已经到了snd_nxt了，那么直接退出SACK块的遍历 */  
                if (skb == NULL)  
                    break;  
                state.fack_count = tp-&gt;fackets_out;  
                cache++; /* 此cache已经用完了 */  
                goto walk; /* 继续SACK块还没处理完的部分 */  
            }  

            /* 找到end_seq &gt; cache-&gt;end_seq的skb */  
             skb = tcp_sacktag_skip(skb, sk, &amp;state, cache-&gt;end_seq);  

            /* Check overlap against next cached too (past this one already) */  
            cache++;  

            continue;  
        }  

        /* 这个块没有和cache块重叠，是新的 */  
        if (! before(start_seq, tcp_highest_sack_seq(tp))) {  
            skb = tcp_highest_sack(sk);  
            if (skb == NULL)  
                break;  
            state.fack_count = tp-&gt;fackets_out;  
        }  

        skb = tcp_sacktag_skip(skb, sk, &amp;state, start_seq); /* skb跳到start_seq处，下面会walk遍历此块 */  

walk:  
        /* 从skb开始遍历，标志块间的包 */  
        skb = tcp_sacktag_walk(skb, sk, next_dup, &amp;state, start_seq, end_seq, dup_sack);  

advance_sp:  
        /* SACK enhanced FRTO (RFC4138, Appendix B): Clearing correct due to 
         * in-order walk. 
         */  
        if (after(end_seq, tp-&gt;frto_highmark))  
            state.flag &amp;= ~FLAG_ONLY_ORIG_SACKED; /* 清除这个标志 */  

        i++; /* 接下来处理下一个SACK块 */  
    }  

    /* Clear the head of the cache sack blocks so we can skip it next time. 
    * 两个循环用于清除旧的SACK块，保存新的SACK块 
    */  
    for (i = 0; i &lt; ARRAY_SIZE(tp-&gt;recv_sack_cache) - used_sacks; i++) {  
        tp-&gt;recv_sack_cache[i].start_seq = 0;  
        tp-&gt;recv_sack_cache[i].end_seq = 0;  
    }  

    for (j = 0; j &lt; used_sacks; j++)  
        tp-&gt;recv_sack_cache[i++] = sp[j];  

    /* 检查重传包是否丢失，这部分独立出来 */  
    tcp_mark_lost_retrans(sk);  

    tcp_verify_left_out(tp);  

    if ((state.reord &lt; tp-&gt;fackets_out) &amp;&amp; ((icsk-&gt;icsk_ca_state != TCP_CA_Loss) || tp-&gt;undo_marker) &amp;&amp;  
        (! tp-&gt;frto_highmark || after(tp-&gt;snd_una, tp-&gt;frto_highmark)))  
        tcp_update_reordering(sk, tp-&gt;fackets_out - state.reord, 0); /* 更新乱序长度 */  

out:  
#if FASTRETRANS_DEBUG &gt; 0  
    WARN_ON((int) tp-&gt;sacked_out &lt; 0);  
    WARN_ON((int) tp-&gt;lost_out &lt; 0);  
    WARN_ON((int) tp-&gt;retrans_out &lt; 0);  
    WARN_ON((int) tcp_packets_in_flight(tp) &lt; 0);  
#endif  

    return state.flag;  
}
</code></pre>

<pre><code></code></pre>

<pre><code>/* 
 * swap - swap value of @a and @b 
 */  
#define swap(a, b) \  
    do { typeof(a) __tmp = (a); (a) = (b); (b) = __tmp; } while (0)  

static int tcp_sack_cache_ok(struct tcp_sock *tp, struct tcp_sack_block *cache)  
{  
    return cache &lt; tp-&gt;recv_sack_cache + ARRAY_SIZE(tp-&gt;recv_sack_cache);  
}  

/* 被SACK过的包的最大初始序列号 
 * Start sequence of the highest skb with SACKed bit, valid only if sacked &gt; 0 
 * or when the caller has ensured validity by itself. 
 */  
static inline u32 tcp_highest_sack_seq(struct tcp_sock *tp)  
{  
    if (! tp-&gt;sacked_out)  /* 没有包被SACK过，则设置成snd_una */  
        return tp-&gt;snd_una;  

    if (tp-&gt;highest_sack == NULL) /* 已经是发送队列的最后一个包了 */  
        return tp-&gt;snd_nxt;  

    return TCP_SKB_CB(tp-&gt;highest_sack)-&gt;seq;  
}  

static inline void tcp_advance_highest_sack(struct sock *sk, struct sk_buff *skb)  
{  
    tcp_sk(sk)-&gt;highest_sack = tcp_skb_is_last(sk, skb) ? NULL : tcp_write_queue_next(sk, skb);  
}
</code></pre>

<pre><code>
#### 使用cache
37版本利用上次缓存的tp-&gt;recv_sack_cache块来避免重复工作，提高处理效率。  
主要思想就是，处理sack块时，和cache块作比较，如果它们有交集，说明交集部分已经处理过了，  
不用再重复处理。

##### （1）忽略cache块
如果cache块完全在sack块的前面，即cache-&gt;end_seq &lt; start_seq，那么忽略此cache块。

##### （2）没有交集
如果sack块完全在cache块前面，即end_seq &lt; cache-&gt;start_seq，那么跳到walk处理，不考虑cache块。

##### （3）有交集
case 1： end_seq&lt;=cache-&gt;end_seq，只需处理(start_seq, cache-&gt;start_seq)这部分，交集不必处理。处理完后直接跳到advance_sp。  
case 2： start_seq&gt;=cache-&gt;start_seq，只需处理(cache-&gt;end_seq, end_seq)这部分，交集不必处理。先skip到cache-&gt;end_seq，cache++，再continue。  
case 3： sack块完全包含在cache块中，那么什么都不用做，直接跳到advance_sp，处理下一个sack块。  
case 4： cache块完全包含在sack块中，这时候需要处理两部分：(start_seq, cache-&gt;start_seq)，(cache-&gt;end_seq, end_seq)。  

-------------

### TCP的核心系列 — SACK和DSACK的实现（三）


不论是18版，还是37版，一开始都会从TCP的控制块中取出SACK选项的起始地址。  
SACK选项的起始地址是保存在tcp_skb_cb结构的sacked项中的，那么这是在什么时候做的呢？  
SACK块并不是总是合法的，非法的SACK块可能会引起处理错误，所以还需要进行SACK块的合法性检查。

本文主要内容：TCP首部中SACK选项的解析和地址的获取，SACK块的合法性检查。

#### SACK选项的地址
TCP_SKB_CB(skb)-&gt;sacked is initialized to offset corresponding to the start of the SACK option in the  
TCP header for the segment received.

处理时机为：
</code></pre>

<pre><code>tcp_rcv_established()，进入慢速路径时调用
    | --&gt; tcp_validate_incoming()
            | --&gt; tcp_fast_parse_options()
                    | --&gt; tcp_parse_options()
</code></pre>

<pre><code>
在慢速路径中，有可能只带有TIMESTAMP选项，因此先用tcp_fast_parse_options()快速解析。
</code></pre>

<pre><code>/* Fast parse options. This hopes to only see timestamps. 
 * If it is wrong it falls back on tcp_parse_options(). 
 */  
static int tcp_fast_parse_options(struct sk_buff *skb, struct tcphdr *th, struct tcp_sock *tp, u8 **hvpp)  
{  
    /* In the spirit of fast parsing, compare doff directly to constant values. 
     * Because equality is used, short doff can be ignored here. 
     */  
    if (th-&gt;doff == (sizeof(*th) / 4)) { /* 没有带选项 */  
        tp-&gt;rx_opt.saw_tstamp = 0;  
        return 0;  

    } else if (tp-&gt;rx_opt.tstamp_ok &amp;&amp;  
        th-&gt;doff == ((sizeof(*th) + TCPOLEN_TSTAMP_ALIGNED) / 4)) { /* 只带有时间戳选项 */  
        if (tcp_parse_aligned_timestamp(tp, th))  
            return 1;  
    }  

    /* 如果以上的快速解析失败，则进行全面解析 */  
    tcp_parse_options(skb, &amp;tp-&gt;rx_opt, hvpp, 1);  

    return 1;  
}
</code></pre>

<pre><code></code></pre>

<pre><code>static int tcp_parse_aligned_timestamp(struct tcp_sock *tp, struct tcphdr *th)  
{  
    __be32 *ptr = (__be32 *) (th + 1); /* 指向选项部分 */  

    /* 如果选项部分的前4个字节分别为：0x 01 01 08 0A */  
    if (*ptr == htonl((TCPOPT_NOP &lt;&lt; 24) | (TCPOPT_NOP &lt;&lt; 16)  
         | (TCPOPT_TIMESTAMP &lt;&lt; 8) | TCPOLEN_TIMESTAMP)) {  

        tp-&gt;rx_opt.saw_tstamp = 1;  
        ++ptr;  

        tp-&gt;rx_opt.rcv_tsval = ntohl(*ptr); /* 提取接收包的时间戳*/  
        ++ptr;  

        tp-&gt;rx_opt.rcv_tsecr = ntohl(*ptr); /* 提取接收包的回显值*/  
        return 1;  
    }  

    return 0;  
}
</code></pre>

<pre><code>
在慢速路径中，如果tcp_fast_parse_options()失败，则调用tcp_parse_options()全面解析TCP选项。
</code></pre>

<pre><code>/* Look for tcp options. Normally only called on SYN and SYNACK packets. 
 * But, this can also be called on packets in the established flow when the fast version 
 * below fails. 
 */  
void tcp_parse_options(struct sk_buff *skb, struct tcp_options_received *opt_rx, u8 **hvpp, int estab)  
{  
    unsigned char *ptr;  
    struct tcphdr *th = tcp_hdr(skb);  
    int length = (th-&gt;doff * 4) - sizeof(struct tcphdr); /* 选项总长度 */  

    ptr = (unsigned char *) (th + 1); /* 选项起始地址 */  
    opt_rx-&gt;saw_tstamp = 0; /* 此ACK有没有带时间戳接下来才知道 */  

    while (length &gt; 0) {  
        int opcode = *ptr++; /* 选项kind */  
        int opsize;  

        switch (opcode) {  
            case TCPOPT_EOL: /* 结束选项，不常见到 */  
                return;  

            case TCPOPT_NOP: /* 填充选项 */  
                length--; /* 此选项只占一个字节 */  
                continue;  

            default:  
                opsize = *ptr++; /* 此选项长度 */  

                if (opsize &lt; 2) /* "silly options" */  
                    return; /* 选项长度过小 */  

                if (opsize &gt; length)  
                    return; /* don't parse partial options */  

                switch (opcode) {  
                    ...  
                    case TCPOPT_SACK_PERM:   
                        if (opsize == TCPOLEN_SACK_PERM &amp;&amp; th-&gt;syn &amp;&amp;   
                             !estab &amp;&amp; sysctl_tcp_sack) {  

                            opt_rx-&gt;sack_ok = 1; /* SYN包中显示支持SACK */  
                             tcp_sack_reset(opt_rx); /* 清空dsack和num_sacks */  
                        }  
                        break;  

                        case TCPOPT_SACK:  
                            if ((opsize &gt;= (TCPOLEN_SACK_BASE + TCPOLEN_SACK_PERBLOCK)) &amp;&amp;  
                               !((opsize - TCPOLEN_SACK_BASE) % TCPOLEN_SACK_PERBLOCK) &amp;&amp;  
                               opt_rx-&gt;sack_ok) {  

                                /*保存SACK选项的起始地址偏移*/  
                                TCP_SKB_CB(skb)-&gt;sacked = (ptr - 2) - (unsigned char *) th;   
                            }  
                            break;  
                        ...  
                }  
        }  
    }  
}
</code></pre>

<pre><code></code></pre>

<pre><code>/* TCP options */  
#define TCPOPT_NOP 1 /* Padding */  
#define TCPOPT_EOL 0 /* End of options */  
#define TCPOPT_MSS 2 /* Segment size negotiating */  
#define TCPOPT_WINDOW 3 /* Window Scaling */  
#define TCPOPT_SACK_PERM 4 /* SACK Permitted */  
#define TCPOPT_SACK 5 /* SACK Block */  
#define TCPOPT_TIMESTAMP 8 /* Better RTT estimations/PAWS */  

static inline void tcp_sack_reset(struct tcp_options_received *rx_opt)  
{  
    rx_opt-&gt;dsack = 0;  
    rx_opt-&gt;num_sacks = 0;  
}  

/* This is the max number of SACKS that we'll generate and process. 
 * It's safe to increase this, although since: 
 * size = TCPOLEN_SACK_BASE_ALIGNED(4) + n * TCPOLEN_SACK_PERBLOCK(8) 
 * only four options will fit in a standard TCP header 
 */  
#define TCP_NUM_SACKS 4 /* SACK块数最多为4 */
</code></pre>

<pre><code>
#### SACK块合法性检查
检查SACK块或者DSACK块是否合法。  
2.6.24之前的版本没有检查SACK块的合法性，而某些非法的SACK块可能会触发空指针的引用。  
在3.1版本之前有一个小bug，处理DSACK时会产生问题，修复非常简单：  
@if (! after(end_seq, tp-&gt;snd_una))，把非去掉。

符合以下任一条件的SACK块是合法的：  
1. sack块和dsack块：snd_una &lt; start_seq &lt; end_seq &lt;= snd_nxt  
2. dsack块：undo_marker &lt;= start_seq &lt; end_seq &lt;= snd_una  
3. dsack块：start_seq &lt; undo_marker &lt; end_seq &lt;= snd_una 且 end_seq - start_seq &lt;= max_window  
</code></pre>

<pre><code>/* SACK block range validation checks that the received SACK block fits to the  
 * expected sequence limits, i.e., it is between SND.UNA and SND.NXT. 
 */  
static int tcp_is_sackblock_valid(struct tcp_sock *tp, int is_dsack, u32 start_seq, u32 end_seq)  
{  
    /* Too far in future, or reversed (interpretation is ambiguous) 
     * end_seq超过了snd_nxt，或者start_seq &gt;= end_seq，那么不合法 
     */  
    if (after(end_seq, tp-&gt;snd_nxt) || ! before(start_seq, end_seq))  
        return 0;  

    /* Nasty start_seq wrap-around check (see comments above) */  
     * start_seq超过了snd_nxt  
     */  
    if (! before(start_seq, tp-&gt;snd_nxt))  
        return 0;  

    /* In outstanding window? This is valid exit for D-SACKs too. 
     * start_seq == snd_una is non-sensical (see comments above) 
     */  
    if (after(start_seq, tp-&gt;snd_una))  
        return 1; /* 合法 */  

    if (! is_dsack || ! tp-&gt;undo_marker)  
        return 0;  

    /* Then it's D-SACK, and must reside below snd_una completely. 
     * 注意在3.1以前这里是：! after(end_seq, tp-&gt;snd_una)，是一个bug 
     */  
    if (after(end_seq, tp-&gt;snd_una))  
        return 0;   

    if (! before(start_seq, tp-&gt;undo_marker))  
        return 1; /* dsack块合法 */  

    /* Too old，DSACK块太旧了*/  
    if (! after(end_seq, tp-&gt;undo_marker))  
        return 0;  

    /* Undo_marker boundary crossing */  
    return !before(start_seq, end_seq - tp-&gt;max_window);  
}
</code></pre>

<pre><code>
------------------

### TCP的核心系列 — SACK和DSACK的实现（四）


和18版本不同，37版本把DSACK的检测部分独立出来，可读性更好。  
37版本在DSACK的处理中也做了一些优化，对DSACK的两种情况分别进行处理。

本文主要内容：DSACK的检测、DSACK的处理。

#### dsack检测
根据RFC 2883，DSACK的处理流程如下：  
1）look at the first SACK block :  
—If the first SACK block is covered by the Cumulative Acknowledgement field, then it is a D-SACK block, and is reporting duplicate data.  
—Else, if the first SACK block is covered by the second SACK block, then the first SACK block is a D-SACK block, and is reporting duplicate data.
2）otherwise, interpret the SACK blocks using the normal SACK procedures.  

简单来说，符合以下任一情况的，就是DSACK：  
1）第一个SACK块的起始序号小于它的确认序号，说明此SACK块包含了确认过的数据。  
2）第一个SACK块包含在第二个SACK块中，说明第一个SACK块是重复的。  
</code></pre>

<pre><code>static int tcp_check_dsack(struct sock *sk, struct sk_buff *ack_skb,   
        struct tcp_sack_block_wire *sp, int num_sacks, u32 prior_snd_una)  
{  
    struct tcp_sock *tp = tcp_sk(sk);  
    u32 start_seq_0 = get_unaligned_be32(&amp;sp[0].start_seq); /* 第一个SACK块的起始 */  
    u32 end_seq_0 = get_unaligned_be32(&amp;sp[0].end_seq); /* 第一个SACK块的结束 */  
    int dup_sack = 0; /* 是否有DSACK */  

    /* 如果第一个SACK块的起始序号小于它的确认序号，说明此SACK块包含了确认过的数据， 
     * 所以第一个SACK块是DSACK。 
     */  
    if (before(start_seq_0, TCP_SKB_CB(ack_skb)-&gt;ack_seq)) {  
        dup_sack = 1;  
        tcp_dsack_seen(tp);  
        NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPDSACKRECV);  

    } else if (num_sacks &gt; 1) {  
        u32 end_seq_1 = get_unaligned_be32(&amp;sp[1].end_seq); /* 第二个块的结束序号 */  
        u32 start_seq_1 = get_unaligned_be32(&amp;sp[1].start_seq); /* 第二个块的起始序号 */  

        /* 如果第一个SACK块包含在第二个SACK块中，说明第一个SACK块是重复的，即为DSACK */  
        if (! after(end_seq_0, end_seq_1) &amp;&amp; ! before(start_seq_0, start_seq_1)) {  
            dup_sack = 1;  
            tcp_dsack_seen(tp);  
            NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPDSACKOFORECV);  
        }  
    }  

    /* D-SACK for already forgotten data... Do dumb counting. 
     * undo_retrans记录重传数据包的个数，如果undo_retrans降到0， 
     * 就说明之前的重传都是不必要的，进行拥塞调整撤销。 
     */  
    if (dup_sack &amp;&amp; ! after(end_seq_0, prior_snd_una) &amp;&amp;  
        after(end_seq_0, tp-&gt;undo_marker))  
        tp-&gt;undo_retrans--;  

    return dup_sack;  
}
</code></pre>

<pre><code></code></pre>

<pre><code>/* Take a notice that peer is sending D-SACKs */  
static void tcp_dsack_seen(struct tcp_sock *tp)  
{  
    tp-&gt;rx_opt.sack_ok |= 4;  
}
</code></pre>

<pre><code>
在以上函数中，undo_marker为进入Recovery或FRTO状态时记录的snd_una，prior_snd_una为根据该ACK更新窗口前的snd_una。如果回复的DSACK在这块中间，说明是超时重传或FRTO后进行的重传，因此需要减少undo_retrans。当undo_retrans减小到0，说明之前的重传都是不必要的，网络并没有拥塞，因此要进行拥塞调整撤销。

#### dsack处理
当处理一个块时，会检查下一个块是不是DSACK块，如果是则用next_dup指向该DSACK块。  
为什么在处理当前SACK块的时候，还要考虑到下个DSACK块呢？  
我们知道DSACK有两种情况，一种是DSACK块小于snd_una，另一种情况是DSACK块大于snd_una且包含在第一个块中，我们来分别分析下。

（1）DSACK块大于snd_una且包含在第一个SACK块中
两个块需要同时处理。不然等SACK块处理完后，再处理DSACK块，就需要做一些重复的工作。

当DSACK包含在第一个SACK块中，那么处理DSACK块在cache中的部分。
</code></pre>

<pre><code>static struct sk_buff *tcp_maybe_skipping_dsack(struct sk_buff *skb, struct sock *sk,  
                                                struct tcp_sack_block *next_dup,  
                                                struct tcp_sacktag_state *state,  
                                                u32 skip_to_seq)  
{  
    /* 如果下个SACK块不是DSACK块，那么不用进行dsack处理 */  
    if (next_dup == NULL)  
        return skb;  

    /* 如果在(cache-&gt;start_seq, cache-&gt;end_seq)中包含dsack */  
    if (before(next_dup-&gt;start_seq, skip_to_seq)) {  

        /* 找到next_dup-&gt;start_seq之后的skb */  
        skb = tcp_sacktag_skip(skb, sk, state, next_dup-&gt;start_seq);  

        /* 处理next_dup-&gt;start_seq之后的skb */  
        skb = tcp_sacktag_walk(skb, sk, NULL, state, next_dup-&gt;start_seq, next_dup-&gt;end_seq, 1);  
    }  
}
</code></pre>

<pre><code>
（2）DSACK块小于snd_una
这时候DSACK排序后也是第一个块，会被直接处理，next_dup在这里就没有意义了。  
DSACK的两种情况都在tcp_sacktag_walk()中处理，第一种时next_dup不为空、dup_sack_in为0；第二种时next_dup为空，dup_sack_in为1。

##### Reference
RFC 2883

-------------

### TCP的核心系列 — SACK和DSACK的实现（五）


18版本对于每个SACK块，都是从重传队列头开始遍历。37版本则可以选择性的遍历重传队列的某一部分，忽略SACK块间的间隙、或者已经cache过的部分。这主要是通过tcp_sacktag_skip()和tcp_sacktag_walk()完成的。  
tcp_sacktag_skip()可以直接找到包含某个序号的skb，通常用于定位SACK块的开头。  
tcp_sacktag_walk()则遍历两个序号之间的skb，通常用于遍历一个SACK块。  

本文主要内容：SACK的遍历函数tcp_sacktag_skip()和tcp_sacktag_walk()。

#### tcp_sacktag_skip
从当前skb开始遍历，查找skip_to_seq序号对应的skb，同时统计fackets_out。  
这样可以从当前包，直接遍历到某个块的start_seq，而不用从头开始遍历，也可以跳过块间的间隙。  
</code></pre>

<pre><code>/* Avoid all extra work that is being done by sacktag while walking in a normal way */  
static struct sk_buff *tcp_sacktag_skip(struct sk_buff *skb, struct sock *sk,  
                               struct tcp_sacktag_state *state, u32 skip_to_seq)  
{  
    tcp_for_write_queue_from(skb, sk) {  
        if (skb == tcp_send_head(sk)) /* 到了发送队列头，即下一个将要发送的数据包 */  
            break;  

        if (after(TCP_SKB_CB(skb)-&gt;end_seq, skip_to_seq)) /* 找到包含skip_to_seq序号的数据包了 */  
            break;  

        state-&gt;fack_count += tcp_skb_pcount(skb); /* 统计fackets_out个数 */  
    }  

    return skb; /* 返回包含skip_to_seq的skb */  
}
</code></pre>

<pre><code>
#### tcp_sacktag_walk
遍历一个SACK块，如果SACK块包含了多个连续的skb，那么先尝试合并这些段。  
为什么要合并呢？因为下次遍历的时候，要遍历的包个数就减少了，能提高效率。  
如果skb完全包含在块中，则调用tcp_sacktag_one更新该段的记分牌。  
</code></pre>

<pre><code>static struct sk_buff *tcp_sacktag_walk(struct sk_buff *skb, struct sock *sk,  
                                        struct tcp_sack_block *next_dup,  
                                        struct tcp_sacktag_state *state,  
                                        u32 start_seq, u32 end_seq,  
                                        int dup_sack_in)  
{  
    struct tcp_sock *tp = tcp_sk(sk);  
    struct sk_buff *tmp;  

    tcp_for_write_queue_from(skb, sk) {  
        int in_sack = 0;  
        int dup_sack = dup_sack_in;  

        if (skb == tcp_send_head(sk)) /* 遍历到发送队列头了 */  
            break;  

        if (! before(TCP_SKB_CB(skb)-&gt;seq, end_seq)) /* skb序号超过SACK块了 */  
            break;  

        /* 如果下一个块是DSACK，且此skb可能包含在其中 */  
        if ((next_dup != NULL) &amp;&amp;   
            before(TCP_SKB_CB(skb)-&gt;seq, next_dup-&gt;end_seq)) {  

            /* 此skb是否完全包含在DSACK块中 */  
            in_sack = tcp_match_skb_to_sack(sk, skb, next_dup-&gt;start_seq, next_dup-&gt;end_seq);  

            if (in_sack &gt; 0)  
                dup_sack = 1; /* 表示这个skb被DSACK */  
        }  

        if (in_sack &lt;= 0) {  
            /* 一个SACK块可能包括多个skb，尝试把这些连续的skb合并 */  
            tmp = tcp_shift_skb_data(sk, skb, state, start_seq, end_seq, dup_sack);  

            if (tmp != NULL) { /* 合并成功 */  
                if (tmp != skb) { /* tmp和当前段地址不同，则跳到合并后的段处理 */  
                    skb = tmp;  
                    continue;  
                }  
                in_sack = 0;  

            } else { /* 合并不成功，单独处理这个段 */  
                in_sack = tcp_match_skb_to_sack(sk, skb, start_seq, end_seq); /* 段是否完全包含在块中 */  
            }  
        }  

        if (unlikely(in_sack &lt; 0))  
            break;  

        /* 如果这个段完全包含在块中，进行处理 */  
        if (in_sack) {  

            /* 就是在这里：标志这个段的记分牌！*/  
            TCP_SKB_CB(skb)-&gt;sacked = tcp_sacktag_one(skb, sk, state, dup_sack, tcp_skb_pcount(skb));  

            /* 如果当前skb的开始序列号大于被SACK的包的最高初始序列号 */  
            if (! before(TCP_SKB_CB(skb)-&gt;seq, tcp_highest_sack_seq(tp)))  
                tcp_advance_highest_sack(sk, skb); /*把highest_sack设为skb-&gt;next */  
        }  

        state-&gt;fack_count += tcp_skb_pcount(skb); /* 更新fackets_out */  
    }  

    return skb; /* 遍历到此skb退出 */  
}
</code></pre>

<pre><code>
##### tcp_match_skb_to_sack()
用于检查一个数据段是否完全包含在一个SACK块中，主要考虑到GSO分段。
</code></pre>

<pre><code>/* Check if skb is fully within the SACK block. 
 * In presence of GSO skbs, the incoming SACK may not exactly match but we can find smaller MSS 
 * aligned portion of it that matches. Therefore we might need to fragment which may fail and creates 
 * some hassle (caller must handle error case returns). 
 * FIXME: this could be merged to shift decision code 
 */  
static int tcp_match_skb_to_sack(struct sock *sk, struct sk_buff *skb, u32 start_seq, u32 end_seq)  
{  
    int in_sack, err;  
    unsigned int pkt_len;  
    unsigned int mss;  

    /* 如果start_seq &lt;= skb-&gt;seq &lt; skb-&gt;end_seq &lt;= end_seq，说明skb完全包含在SACK块中 */  
    in_sack = ! after(start_seq, TCP_SKB_CB(skb)-&gt;seq) &amp;&amp;  
                       ! before(end_seq, TCP_SKB_CB(skb)-&gt;end_seq);  

    /* 如果有GSO分段，skb可能部分包含在块中 */  
    if (tcp_skb_pcount(skb) &gt; 1 &amp;&amp; ! in_sack &amp;&amp;  
        after(TCP_SKB_CB(skb)-&gt;end_seq, start_seq)) {  

        mss = tcp_skb_mss(skb);  
        in_sack = ! after(start_seq, TCP_SKB_CB(skb)-&gt;seq); /* 前半部在块中 */  

        /* 这里根据skb-&gt;seq和start_seq的大小，分情况处理 */  
        if (! in_sack) { /* 后半部在块中 */  
            pkt_len = start_seq - TCP_SKB_CB(skb)-&gt;seq; /* skb在块之前的部分 */  
            if (pkt_len &lt; mss)  
                pkt_len = mss;  

        } else {  
            pkt_len = end_seq - TCP_SKB_CB(skb)-&gt;seq; /* skb在块内的部分 */  
            if (pkt_len &lt; mss)  
                return -EINVAL;  
        }  

        /* Round if necessary so that SACKs cover only full MSSes and/or the remaining 
         * small portion (if present) 
         */  
        if (pkt_len &gt; mss) {  
            unsigned int new_len = (pkt_len / mss) * mss;  
            if (! in_sack &amp;&amp; new_len &lt; pkt_len) {  
                new_len += mss;  
                if (new_len &gt; skb-&gt;len)  
                    return 0;  
            }  
            pkt_len = new_len;  
        }  

        err = tcp_fragment(sk, skb, pkt_len, mss); /* 把skb分为两个包，SACK块内的和SACK块外的 */  
    }  

    return in_sack;  
}
</code></pre>

<pre><code>
##### tcp_shift_skb_data()
尝试把SACK块内的多个包合成一个，可以提升遍历效率。  
一个SACK块可能包括多个skb，尝试把这些连续的skb合成一个。  
</code></pre>

<pre><code>/* Try to collapsing SACK blocks spanning across multiple skbs to a single skb. */  
static struct sk_buff *tcp_shift_skb_data(struct sock *sk, struct sk_buff *skb,  
                                          struct tcp_sacktag_state *state,  
                                          u32 start_seq, u32 end_seq, int dup_sack)  
{  
    struct tcp_sock *tp = tcp_sk(sk);  
    struct sk_buff *prev;  
    int mss;  
    int pcount = 0;  
    int len;  
    int in_sack;  

    if (! sk_can_gso(sk))  
        goto fallback;  

    ...  

fallback:  
    NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_SACKSHIFTFALLBACK);  
    return NULL;  
}
</code></pre>

<pre><code>
-----------------

### TCP的核心系列 — SACK和DSACK的实现（六）


上篇文章中我们主要说明如何skip到一个SACK块对应的开始段，如何walk这个SACK块包含的段，而没有涉及到  
如何标志一个段的记分牌。37版本把给一个段打标志的内容独立出来，这就是tcp_sacktag_one()。  

本文主要内容：tcp_sacktag_one()，给一个段打上标志。

#### 标志一个包
tcp_sacktag_walk()用于遍历块中的数据包，最终会调用tcp_sacktag_one()来标志一个数据包的记分牌，

即TCP_SKB_CB(skb)-&gt;sacked。

记分牌有哪些标志呢？
</code></pre>

<pre><code>#define TCPCB_SACKED_ACKED 0x01 /* SKB ACK'd by a SACK block， 标志S */
#define TCPCB_SACKED_RETRANS 0x02 /* SKB retransmitted，标志R */
#define TCPCB_LOST 0x04 /* SKB is lot，标志L */
#define TCPCB_TAGBITS 0x07 /* All tag bits，标志位掩码 */
#define TCPCB_EVER_RETRANS 0x08 /* Ever retransmitted frame，曾经重传过 */
#define TCPCB_RETRANS (TCPCB_SACKED_RETRANS | TCPCB_EVER_RETRANS)
</code></pre>

<pre><code>
以上标志的说明如下：  
We have three tag bits: SACKED(S)、RETRANS(R) and LOST(L).  
Packets in queue with these bits set are counted in variables sacked_out、retrans_out and lost_out.

tag标志可能的6种情况：  
</code></pre>

<p>Tag        InFlight             Description
0             1            orig segment is in flight，正常情况
S             0            nothing flies, orig reached receiver.
L             0            nothing flies, orig lost by net.
R             2            both orig and retransmit is in flight.
L|R           1            orig is lost, retransmit is in flight.
S|R           1            orig reached receiver, retrans is still in flight.
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>L|S|R is logically valid, it could occur when L|R is sacked, but it is equivalent to plain S and code short-curcuits it to S.&lt;br/&gt;
</span><span class='line'>L|S is logically invalid, it would mean -1 packet in flight.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;以上6种情况是由以下事件触发的：&lt;br/&gt;
</span><span class='line'>These 6 states form finite state machine, controlled by the following events:
</span><span class='line'>&lt;code&gt;
</span><span class='line'>1. New ACK (+SACK) arrives. (tcp_sacktag_write_queue())
</span><span class='line'>2. Retransmission. (tcp_retransmit_skb(), tcp_xmit_retransmit_queue())
</span><span class='line'>3. Loss detection event of one of three flavors:
</span><span class='line'>    A. Scoreboard estimator decided the packet is lost.
</span><span class='line'>        A'. Reno "three dupacks" marks head of queue lost.
</span><span class='line'>        A''. Its FACK modification, head until snd.fack is lost.
</span><span class='line'>    B. SACK arrives sacking data retransmitted after never retransmitted hole was sent out.
</span><span class='line'>    C. SACK arrives sacking SND.NXT at the moment, when the segment was retransmitted.
</span><span class='line'>4. D-SACK added new rule: D-SACK changes any tag to S.
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    static u8 tcp_sacktag_one(struct sk_buff *skb, struct sock *sk,   
</span><span class='line'>                              struct tcp_sacktag_state *state, int dup_sack, int pcount)  
</span><span class='line'>    {  
</span><span class='line'>        struct tcp_sock *tp = tcp_sk(sk);  
</span><span class='line'>        u8 sacked = TCP_SKB_CB(skb)-&gt;sacked;  
</span><span class='line'>        int fack_count = state-&gt;fack_count;  
</span><span class='line'>
</span><span class='line'>        /* Account D-SACK for retransmitted packet. 
</span><span class='line'>         * 如果此skb属于DSACK块，且skb被重传过。即此前tag为R、或者R|S。 
</span><span class='line'>         */  
</span><span class='line'>        if (dup_sack &amp;&amp; (sacked &amp; TCPCB_RETRANS)) {  
</span><span class='line'>
</span><span class='line'>            /* 位于上次进入Recovery或Loss之后 */  
</span><span class='line'>            if (after(TCP_SKB_CB(skb)-&gt;end_seq, tp-&gt;undo_marker))  
</span><span class='line'>                tp-&gt;undo_retrans--; /* 如果减为0，那么说明之前重传都是不必要的，进行拥塞控制调整撤销 */  
</span><span class='line'>
</span><span class='line'>            if (sacked &amp; TCPCB_SACKED_ACKED) /* 如果这个包已经被SACK过，那么说明是乱序 */  
</span><span class='line'>                state-&gt;reord = min(fack_count, state-&gt;reord); /* 更新乱序队列的起始点 */  
</span><span class='line'>        }  
</span><span class='line'>
</span><span class='line'>        /* Nothing to do; acked frame is about to be dropped (was ACKed). 
</span><span class='line'>         * 这个skb已经被正常确认了，不用再处理了，它即将被丢弃。 
</span><span class='line'>         */  
</span><span class='line'>        if (! after(TCP_SKB_CB(skb)-&gt;end_seq, tp-&gt;snd_una))  
</span><span class='line'>            return sacked;  
</span><span class='line'>
</span><span class='line'>        /* 如果skb还没有被SACK，那么进行处理 */  
</span><span class='line'>        if (! (sacked &amp; TCPCB_SACKED_ACKED)) {  
</span><span class='line'>
</span><span class='line'>            /* 有R标志，表示被重传过 */  
</span><span class='line'>            if (sacked &amp; TCPCB_SACKED_RETRANS) {  
</span><span class='line'>                /* If the segment is not tagged as lost, we do not clear RETRANS, believing 
</span><span class='line'>                 * that retransmission is still in flight. 
</span><span class='line'>                 * 如果之前的标志是：R | L，那么好，现在收到包了，可以清除R和L。 
</span><span class='line'>                 * 如果之前的标志是：R，那么认为现在收到的是orig，重传包还在路上，所以不用干活：） 
</span><span class='line'>                 */  
</span><span class='line'>                if (sacked &amp; TCPCB_LOST) {  
</span><span class='line'>                    sacked &amp;= ~(TCPCB_LOST | TCPCB_SACKED_RETRANS); /* 取消L和R标志 */  
</span><span class='line'>                    tp-&gt;lost_out -= pcount; /* 更新LOST包个数 */  
</span><span class='line'>                    tp-&gt;retrans_out -= pcount; /* 更新RETRANS包个数 */  
</span><span class='line'>                }  
</span><span class='line'>
</span><span class='line'>            } else { /* 没有R标志 */  
</span><span class='line'>                if (! (sacked &amp; TCPCB_RETRANS)) {  
</span><span class='line'>                    /* New sack for not retransmitted frame, which was in hole. It is reordering. 
</span><span class='line'>                     * 如果一个包落在highest_sack之前，它即没被SACK过，也不是重传的，那么 
</span><span class='line'>                     * 它肯定是乱序了，到现在才被SACK。 
</span><span class='line'>                     */  
</span><span class='line'>                    if (before(TCP_SKB_CB(skb)-&gt;seq, tcp_highest_sack_seq(tp)))  
</span><span class='line'>                        state-&gt;reord = min(fack_count, state-&gt;reord); /* 记录乱序的起始位置 */  
</span><span class='line'>
</span><span class='line'>                    /* SACK enhanced F-RTO (RFC4138; Appendix B) */  
</span><span class='line'>                    if (! after(TCP_SKB_CB(skb)-&gt;end_seq, tp-&gt;frto_highmark))  
</span><span class='line'>                        state-&gt;flag |= FLAG_ONLY_ORIG_SACKED; /* SACKs only non-rexmit sent before RTO */  
</span><span class='line'>                }  
</span><span class='line'>
</span><span class='line'>                /* 如果它有LOST标志，既然收到了，那么要撤销了 */  
</span><span class='line'>                if (sacked &amp; TCPCB_LOST) {  
</span><span class='line'>                    sacked &amp;= ~TCPCB_LOST; /* 撤销LOST标志 */  
</span><span class='line'>                    tp-&gt;lost_out -= pcount; /* 更新LOST包个数 */  
</span><span class='line'>                }  
</span><span class='line'>            }  
</span><span class='line'>
</span><span class='line'>            sacked |= TCPCB_SACKED_ACKED; /* 给skb打上SACK标志，就是这里：） */  
</span><span class='line'>            state-&gt;flag |= FLAG_DATA_SACKED;  
</span><span class='line'>            tp-&gt;sacked_out += pcount; /* 更新SACK包个数 */  
</span><span class='line'>            fack_count += pcount; /* fackets_out =sacked_out + lost_out，也跟着更新 */  
</span><span class='line'>
</span><span class='line'>            /* 没有使用FACK时 */  
</span><span class='line'>            if (! tcp_is_fack(tp) &amp;&amp; (tp-&gt;lost_skb_hint != NULL) &amp;&amp;  
</span><span class='line'>                before(TCP_SKB_CB(skb)-&gt;seq, TCP_SKB_CB(tp-&gt;lost_skb_hint)-&gt;seq))  
</span><span class='line'>                tp-&gt;lost_cnt_hint += pcount;  
</span><span class='line'>
</span><span class='line'>            if (fack_count &gt; tp-&gt;fackets_out)  
</span><span class='line'>                tp-&gt;fackets_out = fack_count; /* 更新tp-&gt;fackets_out */  
</span><span class='line'>        }  
</span><span class='line'>
</span><span class='line'>        /* D-SACK. We can detect redundant retransmission in S|R and plain R frames and clear it. 
</span><span class='line'>         * undo_retrans is decreased above, L|R frames are accounted above as well. 
</span><span class='line'>         * 如果skb被D-SACK，并且它的重传标志还未被清除，那么现在清除。 
</span><span class='line'>         */  
</span><span class='line'>        if (dup_sack &amp;&amp; (sacked &amp; TCPCB_SACKED_RETRANS)) {  
</span><span class='line'>            sacked &amp;= ~TCPCB_SACKED_RETRANS; /* 清除重传标志 */  
</span><span class='line'>            tp-&gt;retrans_out -= pcount; /* 更新重传包个数 */  
</span><span class='line'>        }  
</span><span class='line'>
</span><span class='line'>        return sacked; /* 返回此skb的记分牌 */  
</span><span class='line'>    }
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;hr /&gt;
</span><span class='line'>
</span><span class='line'>&lt;h3&gt;TCP的核心系列 — SACK和DSACK的实现（七）&lt;/h3&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;我们发送重传包时，重传包也可能丢失，如果没有检查重传包是否丢失的机制，那么只能依靠超时来恢复了。&lt;br/&gt;
</span><span class='line'>37版本把检查重传包是否丢失的部分独立出来，这就是tcp_mark_lost_retrans()。&lt;br/&gt;
</span><span class='line'>在处理SACK块的同时，会检测是否有出现乱序，如果有乱序，那么会计算乱序的长度并更新。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;本文主要内容：检查重传包是否丢失，以及乱序的检测和更新。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h4&gt;检查重传包是否丢失&lt;/h4&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;tcp_mark_lost_retrans()用于检查重传的包是否丢失，2.6.22内核在检查重传包是否丢失时是有Bug的，&lt;br/&gt;
</span><span class='line'>具体可见：&lt;a href="http://projects.itri.aist.go.jp/gnet/sack-bug.html"&gt;http://projects.itri.aist.go.jp/gnet/sack-bug.html&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Q: 怎么检查重传包是否丢失呢？&lt;br/&gt;
</span><span class='line'>A: 我们知道，要发送数据时，是先发送重传包，之后才发送新包的。&lt;br/&gt;
</span><span class='line'>    如果重传包顺利到达接收端，当新包到达时，服务器端会收到一个对新包的正常确认。&lt;br/&gt;
</span><span class='line'>    如果重传包丢失了，当新包到达时，服务器端会收到一个对新包的选择性确认。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;基于这个事实：  
</span><span class='line'>当重传一个包时，我们记录当时要发送的下一新包的序列号(当时的tp-&gt;snd_nxt)。  
</span><span class='line'>当我们收到SACK时，就检查新包是被正常ACK，还是被SACK。如果新包被SACK，  
</span><span class='line'>但是重传包还没有，就说明当时重传的包已经丢失了。  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;重传一个包时，会记录当时要发送的下一个新包的序号，即tp-&gt;snd_nxt。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    int tcp_retransmit_skb(struct sock *sk, struct sk_buff *skb)  
</span><span class='line'>    {  
</span><span class='line'>        ...  
</span><span class='line'>
</span><span class='line'>        /* 如果之前网络中没有重传包 */  
</span><span class='line'>        if (! tp-&gt;retrans_out)   
</span><span class='line'>            tp-&gt;lost_retrans_low = tp-&gt;snd_nxt;  
</span><span class='line'>
</span><span class='line'>        TCP_SKB_CB(skb)-&gt;sacked |= TCPCB_RETRANS; /* 打上R标记 */  
</span><span class='line'>        tp-&gt;retrans_out += tcp_skb_pcount(skb); /* 更新retrans_out */  
</span><span class='line'>
</span><span class='line'>        /* Save stamp of the first retransmit. */  
</span><span class='line'>        if (! tp-&gt;retrans_stamp)  
</span><span class='line'>            tp-&gt;retrans_stamp = TCP_SKB_CB(skb)-&gt;when;  
</span><span class='line'>
</span><span class='line'>        tp-&gt;undo_retrans++;  
</span><span class='line'>
</span><span class='line'>        /* snd_nxt is stored to detect loss of retransmitted segment, 
</span><span class='line'>         * see tcp_input.c tcp_sacktag_write_queue(). 
</span><span class='line'>         * 就是在这里！把这时的snd_nxt保存到重传包的ack_seq。 
</span><span class='line'>         */  
</span><span class='line'>        TCP_SKB_CB(skb)-&gt;ack_seq = tp-&gt;snd_nxt;  
</span><span class='line'>
</span><span class='line'>        ...  
</span><span class='line'>    }
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;检查重传包是否丢失，如果丢失了，重新打L标志。</span></code></pre></td></tr></table></div></figure>
    /<em> Check for lost retransmit. </em>/<br/>
    static void tcp_mark_lost_retrans(struct sock <em>sk)<br/>
    {<br/>
        const struct inet_connection_sock </em>icsk = inet_csk(sk);<br/>
        struct tcp_sock <em>tp = tcp_sk(sk);<br/>
        struct sk_buff </em>skb;<br/>
        int cnt = 0;<br/>
        u32 new_low_seq = tp->snd_nxt; /<em> 下一个要发送的新包序列号 </em>/<br/>
        u32 received_upto = tcp_highest_sack_seq(tp); /<em> 被SACK过的最大序列号 </em>/</p>

<pre><code>    /* 使用这个方法的条件： 
     * 使用FACK；有重传包；上次的最低snd_nxt被SACK；处于Recovery状态 
     */  
    if (! tcp_is_fack(tp) || ! tp-&gt;retrans_out || ! after(received_upto, tp-&gt;lost_retrans_low)  
        || icsk-&gt;icsk_ca_state != TCP_CA_Recovery)  
    return;  

    tcp_for_write_queue(skb, sk) {  
        /* 注意了：对于重传包来说，ack_seq其实是当时的snd_nxt */  
        u32 ack_seq = TCP_SKB_CB(skb)-&gt;ack_seq;  

        if (skb == tcp_send_head(sk)) /* 发送队列头了 */  
            break;  

        /* 我们关注的是重传的包，如果遍历完了，就退出 */  
        if (cnt == tp-&gt;retrans_out)  
            break;  

        /* 不关心成功确认过的包 */  
        if (! after(TCP_SKB_CB(skb)-&gt;end_seq, tp-&gt;snd_una))  
            continue;  

        /* 只关注重传包，必须有R标志才处理 */  
        if (! (TCP_SKB_CB(skb)-&gt;sacked &amp; TCPCB_SACKED_RETRANS))  
            continue;  

        /*  
         * 如果重传包记录的snd_nxt被SACK了，那说明重传包丢了；否则应该在新包之前被确认才对。 
         */  
        if (after(received_upto, ack_seq)) {  
            TCP_SKB_CB(skb)-&gt;sacked &amp;= ~TCPCB_SACKED_RETRANS; /* 取消R标志 */  
            tp-&gt;retrans_out -= tcp_skb_pcount(skb); /* 更新网络中重传包数量 */  
            tcp_skb_mark_lost_uncond_verify(tp, skb); /* 给重传包打上LOST标志，并更新相关变量 */  
            NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPLOSTRETRANSMIT);  

        } else { /* 如果重传包对应的snd_nxt在最高SACK序列号之后 */  
            if (before(ack_seq, new_low_seq))  
                new_low_seq = ack_seq; /* 更新未检测的重传包对应的最小snd_nxt */  
            cnt += tcp_skb_pcount(skb); /* 用于判断重传包是否检查完了 */  
        }  
    }  

    /* 如果还有未检查完的重传包，那么更新未检测的重传包对应的最小snd_nxt */  
    if (tp-&gt;retrans_out)  
        tp-&gt;lost_retrans_low = new_low_seq;  

}
</code></pre>

<pre><code>
给数据包打上LOST标志，更新相关变量。
</code></pre>

<pre><code>static void tcp_skb_mark_lost_uncond_verify(struct tcp_sock *tp, struct sk_buff *skb)  
{  
    /* 更新重传过的包的最低、最高序号 */  
    tcp_verfiy_retransmit_hint(tp, skb);  

    /* 如果这个包还未打上L标志，且没有S标志 */  
    if (! (TCP_SKB_CB(skb)-&gt;sacked &amp; (TCP_LOST | TCPCB_SACKED_ACKED))) {  
        tp-&gt;lost_out += tcp_skb_pcount(skb); /* 更新网络中丢失包数量 */  
        TCP_SKB_CB(skb)-&gt;sacked |= TCPCB_LOST; /* 打上L标志 */  
    }  
}  

/* This must be called before lost_out is incremented 
 * 记录重传过的包的最低序号、最高序号。 
 */  
static void tcp_verify_retransmit_hint(struct tcp_sock *tp, struct sk_buff *skb)  
{  
    if ((tp-&gt;retransmit_skb_hint == NULL) || before(TCP_SKB_CB(skb)-&gt;seq,  
        TCP_SKB_CB(tp-&gt;retransmit_skb_hint)-&gt;seq))  
        tp-&gt;retransmit_skb_hint = skb;  

    if (! tp-&gt;lost_out || after(TCP_SKB_CB(skb)-&gt;end_seq, tp-&gt;retransmit_high))  
        tp-&gt;retransmit_high = TCP_SKB_CB(skb)-&gt;end_seq;  
}
</code></pre>

<pre><code>
#### 乱序处理
说明  
Reordering metric is maximal distance, which a packet can be displaced in packet stream.  
With SACKs we can estimate it:  
1. SACK fills old hole and the corresponding segment was not ever retransmitted -&gt; reordering.  
    Alas, we cannot use it when segment was retransmitted.  
2. The last flaw it solved with D-SACK. D-SACK arrives for retransmitted and already SACKed segment  
    -&gt; reordering..   
Both of these heuristics are not used in Loss state, when we cannot account for retransmits accurately.

对于乱序，我们主要关注如何检测乱序，以及计算乱序的长度。  
在tcp_sacktag_one()中有进行乱序的检测，那么在收到SACK或DSACK时怎么判断有乱序呢？  

（1）skb的记分牌为S|R，然后它被DSACK。  
我们想象一下，一个数据包乱序了，它滞留在网络的某个角落里。我们收到后续包的SACK，认为这个包丢失了，进行重传。之后原始包到达接收端了，这个数据包被SACK了。最后重传包也到达接收端了，这个包被DSACK了。  

（2）如果一个包落在highest_sack之前，它既没被SACK过，也不是重传的，那么它肯定是乱序了，到现在才被SACK。

如果检测到了乱序，那么乱序队列的长队为：tp-&gt;fackets_out - state.reord。
</code></pre>

<pre><code>static void tcp_update_reordering(struct sock *sk, const int metric,  
                                       const int ts)  
{  
    struct tcp_sock *tp = tcp_sk(sk);  

    if (metric &gt; tp-&gt;reordering) {  
        int mib_idx;  
        /* 更新reordering的值，取其小者*/  
        tp-&gt;reordering = min(TCP_MAX_REORDERING, metric);  

        if (ts)  
            mib_idx = LINUX_MIB_TCPTSREORDER;  
        else if (tcp_is_reno(tp))  
            mib_idx = LINUX_MIB_TCPRENOREORDER;  
        else if (tcp_is_fack(tp))  
            mib_idx = LINUX_MIB_TCPFACKREORDER;  
        else   
            mib_idx = LINUX_MIB_TCPSACKREORDER;  

        NET_INC_STATS_BH(sock_net(sk), mib_idx);  
#if FASTRETRANS_DEBUG &gt; 1  
        printk(KERN_DEBUG "Disorder%d %d %u f%u s%u rr%d\n",  
                   tp-&gt;rx_opt.sack_ok, inet_csk(sk)-&gt;icsk_ca_state,  
                   tp-&gt;reordering, tp-&gt;fackets_out, tp-&gt;sacked_out,  
                   tp-&gt;undo_marker ? tp-&gt;undo_retrans : 0);  
#endif  
        tcp_disable_fack(tp); /* 出现了reorder，再用fack就太激进了*/  
    }  
}
</code></pre>

<pre><code></code></pre>

<pre><code>/* Packet counting of FACK is based on in-order assumptions, therefore 
 * TCP disables it when reordering is detected. 
 */  
static void tcp_disable_fack(struct tcp_sock *tp)  
{  
    /* RFC3517 uses different metric in lost marker =&gt; reset on change */  
    if (tcp_is_fack(tp))  
        tp-&gt;lost_skb_hint = NULL;  
    tp-&gt;rx_opt.sack_ok &amp;= ~2; /* 取消FACK选项*/  
}
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
</feed>
