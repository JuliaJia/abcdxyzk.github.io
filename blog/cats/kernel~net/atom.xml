<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: kernel~net | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/kernel~net/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2014-12-11T01:25:43+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[linux内核网络分层结构]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/08/01/net-struct/"/>
    <updated>2014-08-01T16:52:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/08/01/net-struct</id>
    <content type="html"><![CDATA[<p><a href="http://liucw.blog.51cto.com/6751239/1221140">http://liucw.blog.51cto.com/6751239/1221140</a></p>

<h4>内核网络结构</h4>

<p>  在Linux内核中，对网络部分按照网络协议层、网络设备层、设备驱动功能层和网络媒介层的分层体系设计。</p>

<p>  网络驱动功能层主要通过网络驱动程序实现。</p>

<p>  在Linux内核，所有的网络设备都被抽象为一个接口处理，该接口提供了所有的网络操作。</p>

<p>  net_device结构表示网络设备在内核中的情况，也就是网络设备接口。网络设备接口既包括软件虚拟的网络设备接口，如环路设备，也包括了网络硬件设备，如以太网卡。</p>

<p>  Linux内核有一个dev_base的全局指针，指向一个设备链表，包括了系统内的所有网络设备。该设备链表每个节点是一个网络设备。</p>

<p>  在net_device结构中提供了许多供系统访问和协议层调用的设备方法，包括初始化、打开关闭设备、数据包发送和接收等。</p>

<h4>与网络有关的数据结构</h4>

<p>  内核对网络数据包的处理都是基于sk_buff结构的，该结构是内核网络部分最重要的数据结构。</p>

<p>  网络协议栈中各层协议都可以通过对该结构的操作实现本层协议数据的添加或者删除。使用sk_buff结构避免了网络协议栈各层来回复制数据导致的效率低下。</p>

<p><img src="/images/kernel/20140801-1.png" alt="" /></p>

<p>  sk_buff结构可以分为两个部分，一部分是存储数据包缓存，在图中表示为PackertData，另一部分是由一组用于内核管理的指针组成。<br/>
  sk_buff管理的指针最主要的是下面4个：</p>

<blockquote><p>head指向数据缓冲(PackertData)的内核首地址；<br/>
data指向当前数据包的首地址；<br/>
tail指向当前数据包的尾地址；<br/>
end 指向数据缓冲的内核尾地址。<br/>
  数据包的大小在内核网络协议栈的处理过程中会发生改变，因此data和tail指针也会不断变化，而head和tail指针是不会发生改变的。</p></blockquote>

<p>  对于一个TCP数据包为例，sk_buff还提供了几个指针直接指向各层协议头。mac指针指向数据的mac头；nh指针指向网络协议头，一般是IP协议头；h指向传输层协议头，在本例中是TCP协议头。</p>

<p>  对各层设置指针的是方便了协议栈对数据包的处理。</p>

<h4>net_device结构</h4>

<p>  Linux内核中网络设备最重要的数据结构就是net_device结构了，它是网络驱动程序最重要的部分。<br/>
  net_device结构保存在include/linux/netdevices.h头文件，理解该结构对理解网络设备驱动有很大帮助。<br/>
  内核中所有网络设备的信息和操作都在net_device设备中，无论是注册网络设备，还是设置网络设备参数，都用到该结构。<br/>
  下面是主要数据成员。</p>

<blockquote><p>设备名称<br/>
总线参数<br/>
协议参数<br/>
链接层变量<br/>
接口标志</p></blockquote>

<h4>数据包接收流程</h4>

<p>  在Linux内核中，一个网络数据包从网卡接收到用户空间需要经过链路层、传输层和socket的处理，最终到达用户空间。<br/>
<img src="/images/kernel/20140801-2.png" alt="" /><br/>
  以DM9000网卡为例，当网卡收到数据包以后，调用中断处理函数 dm9000_interrupt()，该函数检查中断处理类型，如果是接收数据包中断，则调用 dm9000_rx()函数接收数据包到内核空间。</p>

<p>  dm9000_rx()函数收到数据包完成后，内核会继续调用 netif_rx()函数，函数的作用是把网卡接收到数据提交给协议栈处理。</p>

<p>  协议栈使用 net_rx_action()函数处理接收数据包队列，该函数处理数据包后如果是 IP数据包则提交给 ip_recv()函数处理。ip_recv()函数主要是检查一个数据包IP头的合法性，检查通过后交给 ip_local_deliver()和 ip_local_deliver_finish()函数处理，之所以分开处理是因为内核中有防火墙相关的代码需要动态加载到此处。</p>

<p>  IP头处理完毕后，以UDP数据包为例将交由 udp_recv()函数处理，与 ip_recv()函数类亿，该函数检查 UDP头的合法性，然后交给 udp_queue_recv()函数处理，最后提交给 sock_queue_recv()函数处理。</p>

<p>  数据包进入 socket部分的第一个函数是 skb_recv_datagram()，该函数从内核的 socket队列取出数据包，交给 socket部分的 udp_recvmsg()函数，该函数负责处理UDP的数据，sock_recvmsg()处理提交给 sock_read()函数。</p>

<p>  sock_read()函数读取接收到的数据缓冲，把数据返回给 sys_read()系统调用。sys_read()函数调用最终把数据复制到用户空间，供用户使得。</p>

<h4>数据包发送流程</h4>

<p>  以UDP数据包发送流程为例，在DM9000网卡上如何发送一个数据包。</p>

<p><img src="/images/kernel/20140801-3.png" alt="" /></p>

<p>  当用户空间的应用程序通过 socket函数 sento()发送一个UDP数据后，会调用内核空间的 sock_writev()函数，然后通过 sock_sendmsg()函数处理。sock_sendmsg()函数调用 inet_sendmsg()函数处理，inet_sendmsg()函数会把要发送的数据交给传输层的 udp_sendmsg()函数处理。</p>

<p>  udp_sendmsg()函数在数据前加入UDP头，然后把数据交给 ip_build_xmit()函数处理，该函数根据 socket提供的目的 IP和端口信息构造IP头，然后调用 output_maybe_reroute()函数处理。out_maybe_reroute()函数检查数据包是否需要经过路由，最后交给 ip_output()函数写入到发送队列，写入完成后由 ip_finish_output()函数处理后续工作。</p>

<p>  链路层的 dev_queue_xmit()函数处理发送队列，调用 DM9000网卡的发送数据包函数 dm9000_xmit()发送数据包，发送完毕后，调用 dm9000_xmit_done函数处理发送结果。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux 内核发包]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/07/31/net-sendmsg/"/>
    <updated>2014-07-31T11:28:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/07/31/net-sendmsg</id>
    <content type="html"><![CDATA[<pre><code>    #include &lt;linux/module.h&gt;
    #include &lt;linux/kernel.h&gt;
    #include &lt;linux/init.h&gt;
    #include &lt;linux/workqueue.h&gt;
    #include &lt;linux/timer.h&gt;
    #include &lt;linux/in.h&gt;
    #include &lt;linux/inet.h&gt;
    #include &lt;linux/socket.h&gt;
    #include &lt;net/sock.h&gt;

    struct socket       *sock;

    unsigned char buffer[10]=
    { 1,2,3,4,5,6,7,8,9,0,};

    static int ker_send_udp(char* ip_addr, unsigned char * data, size_t len )
    {
        int ret;
        u32 remote_ip = in_aton(ip_addr);

        struct sockaddr_in sin = {
            .sin_family = AF_INET,
            .sin_port = htons(65530),
            .sin_addr = {.s_addr = remote_ip}
        };

        struct kvec iov = {.iov_base = (void *)data, .iov_len = len};
        struct msghdr udpmsg;

        udpmsg.msg_name = (void *)&amp;sin;
        udpmsg.msg_namelen = sizeof(sin);
        udpmsg.msg_control = NULL;
        udpmsg.msg_controllen = 0;
        udpmsg.msg_flags=0;

        ret = kernel_sendmsg(sock, &amp;udpmsg, &amp;iov, 1, len);
        printk("rets = %d\n",ret);

        return 0;
    }

    static int socket_init (void)
    {
        int ret;
        ret = sock_create_kern (PF_INET, SOCK_DGRAM,IPPROTO_UDP, &amp;sock);
        printk("retc = %d\n",ret);

        ker_send_udp("192.168.1.253", buffer, 10);
        return 0;
    }

    static void socket_exit (void)
    {   
        sock_release (sock);
    }

    module_init (socket_init);
    module_exit (socket_exit);
    MODULE_LICENSE ("GPL");
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[解析pcap数据包格式(code)]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/08/26/kernel-pcap-decode-code/"/>
    <updated>2013-08-26T11:17:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/08/26/kernel-pcap-decode-code</id>
    <content type="html"><![CDATA[<pre><code>    #include &lt;stdio.h&gt;
    #include &lt;arpa/inet.h&gt;
    #include &lt;stdlib.h&gt;
    #include &lt;string.h&gt;
    #include &lt;linux/types.h&gt;

    typedef unsigned int  bpf_u_int32;
    typedef unsigned short  u_short;
    typedef int bpf_int32;
    typedef struct pcap_file_header {
        bpf_u_int32 magic;
        u_short version_major;
        u_short version_minor;
        bpf_int32 thiszone;
        bpf_u_int32 sigfigs;   
        bpf_u_int32 snaplen;   
        bpf_u_int32 linktype;  
    }pcap_file_header;

    typedef struct  timestamp{
        bpf_u_int32 timestamp_s;
        bpf_u_int32 timestamp_ms;
    }timestamp;

    typedef struct pcap_header{
        timestamp ts;
        bpf_u_int32 capture_len;
        bpf_u_int32 len;

    }pcap_header;


    #define ETH_ALEN 6
    #define __LITTLE_ENDIAN_BITFIELD 1
    #define NIPQUAD(addr) \
            ((unsigned char *)&amp;addr)[0], \
            ((unsigned char *)&amp;addr)[1], \
            ((unsigned char *)&amp;addr)[2], \
            ((unsigned char *)&amp;addr)[3]


    struct ethhdr {
        unsigned char   h_dest[ETH_ALEN];       /* destination eth addr */
        unsigned char   h_source[ETH_ALEN];     /* source ether addr    */
        unsigned short  h_proto;                /* packet type ID field */
    };

    struct iphdr {
    #if defined(__LITTLE_ENDIAN_BITFIELD)
        __u8    ihl:4,
                version:4;
    #elif defined (__BIG_ENDIAN_BITFIELD)
        __u8    version:4,
                ihl:4;
    #endif
        __u8    tos;
        __be16  tot_len;
        __be16  id;
        __be16  frag_off;
        __u8    ttl;
        __u8    protocol;
        __u16   check;
        __be32  saddr;
        __be32  daddr;
        /*The options start here. */
    };

    struct tcphdr {
        __u16   source;
        __u16   dest;
        __u32   seq;
        __u32   ack_seq;
    #if defined(__LITTLE_ENDIAN_BITFIELD)
        __u16   res1:4,
                doff:4,
                fin:1,
                syn:1,
                rst:1,
                psh:1,
                ack:1,
                urg:1,
                ece:1,
                cwr:1;
    #elif defined(__BIG_ENDIAN_BITFIELD)
        __u16   doff:4,
                res1:4,
                cwr:1,
                ece:1,
                urg:1,
                ack:1,
                psh:1,
                rst:1,
                syn:1,
                fin:1;
    #endif  
        __u16   window;
        __u16   check;
        __u16   urg_ptr;
    };

    struct udphdr {
        __u16   source;
        __u16   dest;
        __u16   len;
        __u16   check;
    };

    struct icmphdr {
        __u8    type;
        __u8    code;
        __u16   checksum;
        union {
            struct {
                __u16   id;
                __u16   sequence;
            } echo;
            __u32   gateway;
            struct {
                __u16   __unused;
                __u16   mtu;
            } frag;
        } un;
    };

    FILE *fp1, *fp2;
    __u32 flag1, flag2, seq1, seq2, ip1, ip2;
    long long stime;

    void printPcap(int count, void * data, struct pcap_header *ph)
    {
        size_t size = ph-&gt;capture_len;
        unsigned  short iPos = 0;
        struct ethhdr *eth;
        struct iphdr *iph;
        struct tcphdr *tcph;
        struct udphdr *udph;
        struct icmphdr *icmph;
        __u8 op1, op2, type, len;
        void * data1;
        int i;
        long long dt;

        if (data==NULL) {
            return;
        }
        eth = (struct ethhdr*)(data);
        eth-&gt;h_proto = ntohs(eth-&gt;h_proto);
        //printf("Ether:\tproto = 0x%x\n", eth-&gt;h_proto);
        if (eth-&gt;h_proto == 0x0800) { // IP
            iph = (struct iphdr*)(data+sizeof(struct ethhdr));
            if (iph-&gt;protocol == IPPROTO_TCP) { // tcp
                tcph = (struct tcphdr*)(data+sizeof(struct ethhdr)+sizeof(struct iphdr));
                if (tcph-&gt;ack == 0 &amp;&amp; tcph-&gt;syn == 1) {
                    seq1 = ntohl(tcph-&gt;seq);
                    ip1 = iph-&gt;saddr;
                    flag1 = 1;
                    stime = 1000000LL*ph-&gt;ts.timestamp_s + ph-&gt;ts.timestamp_ms;
                } else if (tcph-&gt;ack == 1 &amp;&amp; tcph-&gt;syn == 1) {
                    seq2 = ntohl(tcph-&gt;seq);
                    ip2 = iph-&gt;saddr;
                    flag2 = 1;
                }

                if (flag1 == 0) {
                    flag1 = 1;
                    seq1 = ntohl(tcph-&gt;seq)-1;
                    ip1 = iph-&gt;saddr;
                    stime = 1000000LL*ph-&gt;ts.timestamp_s + ph-&gt;ts.timestamp_ms;
                }
                if (flag2 == 0 &amp;&amp; iph-&gt;saddr != ip1) {
                    flag2 = 1;
                    seq2 = ntohl(tcph-&gt;seq)-1;
                    ip2 = iph-&gt;saddr;
                }

                dt = (1000000LL*ph-&gt;ts.timestamp_s+ph-&gt;ts.timestamp_ms) - stime;
                fprintf(fp1, "%d\t%llu\t", count, dt/1000);
                fprintf(fp1, "%d.%d.%d.%d\t%d.%d.%d.%d\t%u\t%u\t%d\t",
                            NIPQUAD(iph-&gt;saddr), NIPQUAD(iph-&gt;daddr),
                            (iph-&gt;saddr==ip1?ntohl(tcph-&gt;seq)-seq1:ntohl(tcph-&gt;seq)-seq2),
                            (iph-&gt;saddr==ip1?ntohl(tcph-&gt;ack_seq)-seq2:ntohl(tcph-&gt;ack_seq)-seq1),
                            ntohs(iph-&gt;tot_len)-iph-&gt;ihl*4-tcph-&gt;doff*4 + tcph-&gt;syn + tcph-&gt;fin);
                fprintf(fp1, "%d\t%d\t%d\t%d\t", ntohs(iph-&gt;tot_len), iph-&gt;ihl*4, tcph-&gt;doff*4, iph-&gt;ttl);
                fprintf(fp1, "%u\t%u\t%d\t%d\t%d\t",
                            ntohl(tcph-&gt;seq), ntohl(tcph-&gt;ack_seq),
                            tcph-&gt;ack, tcph-&gt;syn, ntohs(tcph-&gt;window));

                if (tcph-&gt;doff &gt; 5) {
                    data1 = data + sizeof(struct ethhdr)+sizeof(struct iphdr)+sizeof(struct tcphdr);
                    op1 = *(__u8*)(data1);
                    op2 = *(__u8*)(data1+1);
                    type = *(__u8*)(data1+2);
                    len = *(__u8*)(data1+3);
                    //fprintf(fp1, "%u\t%u\t%u\t%u\n", op1, op2, type, len);
                    if (op1 == 1 &amp;&amp; op2 == 1 &amp;&amp; type == 5) { // sack
                        i = 4;
                        while (i &lt; len+2) {
                            if (i &gt; 4) fprintf(fp1, " ");
                            fprintf(fp1, "%u-%u", ntohl(*(__u32*)(data1+i))-seq2, ntohl(*(__u32*)(data1+i+4))-seq2);
                            i += 8;
                        }
                    }
                }
                fprintf(fp1, "\n");

            } else if (iph-&gt;protocol == IPPROTO_UDP) { // udp
                udph = (struct udphdr*)(data+sizeof(struct ethhdr)+sizeof(struct iphdr));
                //printf("UDP:\tsource=%u\tdest=%u\tlen=%d\n", ntohs(udph-&gt;source), ntohs(udph-&gt;dest), ntohs(udph-&gt;len));
            } else if (iph-&gt;protocol == IPPROTO_ICMP) { // ICMP
                icmph = (struct icmphdr*)(data+sizeof(struct ethhdr)+sizeof(struct iphdr));
                //printf("ICMP:\ttype=%u\tcode=%u\n", icmph-&gt;type, icmph-&gt;code);
            }
        }
    }

    #define MAX_ETH_FRAME 1514000
    int main (int argc, const char * argv[])
    {
        pcap_file_header  pfh;
        pcap_header  ph;
        int count=0;
        void * buff = NULL;
        int readSize=0;
        int ret = 0;

         if (argc != 2) {
             printf("uage: ./a.out pcap_filename\n");
             return -1;
         }
        FILE *fp = fopen(argv[1], "r");
        if (fp==NULL) {
            fprintf(stderr, "Open file %s error.", argv[1]);
            return -1;
        }
        fread(&amp;pfh, sizeof(pcap_file_header), 1, fp);

        fp1 = fopen("out", "w");
        fprintf(fp1, "#ID\tTIME\tsaddr\tdaddr\tseq\tack_seq\tpayload\ttot_len\tihl\tdoff\tttl\tseq\tack_seq\tack\tsyn\twin\tSACK\n");
        buff = (void *)malloc(MAX_ETH_FRAME);
        flag1 = flag2 = 0;

        for (count=1; ; count++) {
            memset(buff,0,MAX_ETH_FRAME);
            readSize=fread(&amp;ph, sizeof(pcap_header), 1, fp);
            if (readSize&lt;=0) {
                break;
            }
            if (buff==NULL) {
                fprintf(stderr, "malloc memory failed.\n");
                return -1;
            }

            readSize=fread(buff,1,ph.capture_len, fp);
            if (readSize != ph.capture_len) {
                free(buff);
                fprintf(stderr, "pcap file parse error.\n");
                return -1;
            }
            printPcap(count, buff, &amp;ph);

            if (feof(fp) || readSize &lt;=0 ) {
                break;
            }
        }
        fclose(fp);
        fclose(fp1);
        return ret;
    }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[解析pcap数据包格式]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/08/26/kernel-pcap-decode/"/>
    <updated>2013-08-26T11:17:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/08/26/kernel-pcap-decode</id>
    <content type="html"><![CDATA[<p>  协议是一个比较复杂的协议集，有很多专业书籍介绍。在此，我仅介绍其与编程密切相关的部分：以太网上TCP/IP协议的分层结构及其报文格式。<br/>
我们知道TCP/IP协议采用分层结构，其分层模型及协议如下表：<br/>
应　用　层 (Application) HTTP、Telnet、FTP、SMTP、SNMP<br/>
传　输　层 (Transport) TCP、UDP<br/>
网 间 网层  (Internet) IP【ARP、RARP、ICMP】<br/>
网络接口层 (Network) Ethernet、X.25、SLIP、PPP</p>

<p>  协议采用分层结构，因此，数据报文也采用分层封装的方法。下面以应用最广泛的以太网为例说明其数据报文分层封装，如下图所示：</p>

<p><img src="/images/kernel/2013-08-26-1.png" alt="" /></p>

<p>  任何通讯协议都有独特的报文格式，TCP/IP协议也不例外。对于通讯协议编程，我们首先要清楚其报文格式。由于TCP/IP协议采用分层模型，各层都有专用的报头，以下就简单介绍以太网下TCP/IP各层报文格式。</p>

<p><img src="/images/kernel/2013-08-26-2.png" alt="" /></p>

<p>  8字节的前导用于帧同步，CRC域用于帧校验。这些用户不必关心其由网卡芯片自动添加。目的地址和源地址是指网卡的物理地址，即MAC地址，具有唯一性。帧类型或协议类型是指数据包的高级协议，如 0x0806表示ARP协议，0x0800表示IP协议等。</p>

<p>　　ARP/RARP（地址解析/反向地址解析）报文格式如下图：</p>

<p><img src="/images/kernel/2013-08-26-3.png" alt="" /></p>

<p> “硬件类型”域指发送者本机网络接口类型（值“1”代表以太网）。“协议类型”域指发送者所提供/请求的高级协议地址类型（“0x0800”代表 IP协议）。“操作”域指出本报文的类型（“1”为ARP请求，“2”为ARP响应，“3”为RARP请求，“4”为RARP响应）。</p>

<p>　　IP数据报头格式如下图：</p>

<p><img src="/images/kernel/2013-08-26-4.png" alt="" /></p>

<p>　　我们用单片机实现TCP/IP协议要作一些简化，不考虑数据分片和优先权。因此，在此我们不讨论服务类型和标志偏移域，只需填“0” 即可。协议“版本”为4，“头长度”单位为32Bit，“总长度”以字节为单位，表示整个IP数据报长度。“标识”是数据包的ID号，用于识别不同的IP 数据包。“生存时间” TTL是个数量及的概念，防止无用数据包一直存在网络中。一般每经过路由器时减一，因此通过TTL 可以算出数据包到达目的地所经过的路由器个数。“协议”域表示创建该数据包的高级协议类型。如 1表示ICMP协议，6表示TCP协议，17表示 UDP协议等。IP数据包为简化数据转发时间，仅采用头校验的方法，数据正确性由高层协议保证。</p>

<p>　　ICMP（网间网控制报文协议）协议 应用广泛。在此仅给出最常见的回应请求与应答报文格式，用户命令ping便是利用此报文来测试信宿机的可到达性。报文格式如下图所示：</p>

<p><img src="/images/kernel/2013-08-26-5.png" alt="" /></p>

<p>　　类型0 为回应应答报文，8 为回应请求报文。整个数据包均参与检验。注意ICMP封装在IP数据包里传送。</p>

<p>　　UDP报文格式如下图：</p>

<p><img src="/images/kernel/2013-08-26-6.png" alt="" /></p>

<p>　　TCP报文格式如下图：</p>

<p><img src="/images/kernel/2013-08-26-7.png" alt="" /></p>

<hr />

<p>WireShark捕获的数据</p>

<p><img src="/images/kernel/2013-08-26-8.jpg" alt="" /></p>

<pre><code>                            以下为物理层的数据帧概况

Frame 1 (62 bytes on wire, 62 bytes captured)           1号帧，线路62字节，实际捕获62字节
Arrival Time: Jan 21, 2008 15:17:33.910261000           捕获日期和时间
[Time delta from previous packet:0.00000 seconds]       此包与前一包的时间间隔
[Time since reference or first frame: 0.00 seconds]     此包与第1帧的间隔时间
Frame Number: 1                                         帧序号
Packet Length: 62 bytes                                 帧长度
Capture Length: 62 bytes                                捕获长度
[Frame is marked: False]                                此帧是否做了标记：否
[Protocols in frame: eth:ip:tcp]                        帧内封装的协议层次结构
[Coloring Rule Name: HTTP]                              用不同颜色染色标记的协议名称：HTTP
[Coloring Rule String: http || tcp.port == 80]          染色显示规则的字符串：


                    以下为数据链路层以太网帧头部信息
Ethernet II, Src: AcerTech_5b:d4:61 (00:00:e2:5b:d4:61), Dst: Jetcell_e5:1d:0a (00:d0:2b:e5:1d:0a)
以太网协议版本II，源地址：厂名_序号（网卡地址），目的：厂名_序号（网卡地址）
 Destination: Jetcell_e5:1d:0a (00:d0:2b:e5:1d:0a)       目的：厂名_序号（网卡地址）
 Source: AcerTech_5b:d4:61 (00:00:e2:5b:d4:61)           源：厂名_序号（网卡地址）
 Type: IP (0x0800)                                       帧内封装的上层协议类型为IP（十六进制码0800）看教材70页图3.2

                          以下为互联网层IP包头部信息
Internet Protocol, Src: 202.203.44.225 (202.203.44.225), Dst: 202.203.208.32 (202.203.208.32)
互联网协议，源IP地址，目的IP地址
Version: 4                                                       互联网协议IPv4
Header length: 20 bytes                                          IP包头部长度
Differentiated Services Field:0x00(DSCP 0x00:Default;ECN:0x00)   差分服务字段
Total Length: 48                                                 IP包的总长度
Identification:0x8360 (33632)                                    标志字段
Flags:                                                           标记字段（在路由传输时，是否允许将此IP包分段）
Fragment offset: 0                                               分段偏移量（将一个IP包分段后传输时，本段的标识）
Time to live: 128                                                生存期TTL
Protocol: TCP (0x06)                                             此包内封装的上层协议为TCP
Header checksum: 0xe4ce [correct]                                头部数据的校验和
Source: 202.203.44.225 (202.203.44.225)                          源IP地址
Destination: 202.203.208.32 (202.203.208.32)                     目的IP地址

                        以下为传输层TCP数据段头部信息
Transmission Control Protocol, Src Port: 2764 (2764), Dst Port: http (80), Seq: 0, Len: 0   传输控制协议TCP的内容
Source port: 2764 (2764）                              源端口名称（端口号）
Destination port: http (80)                            目的端口名http（端口号80）
Sequence number: 0    (relative sequence number)       序列号（相对序列号）
Header length: 28 bytes                                头部长度
Flags: 0x02 (SYN)                                      TCP标记字段（本字段是SYN，是请求建立TCP连接）
Window size: 65535                                     流量控制的窗口大小
Checksum: 0xf73b [correct]                             TCP数据段的校验和
Options: (8 bytes)                                     可选项
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Netfilter HOOK]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/07/08/kernel-net-hook/"/>
    <updated>2013-07-08T11:26:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/07/08/kernel-net-hook</id>
    <content type="html"><![CDATA[<p>下图是Netfilter的IPV4下的结构</p>

<p><img src="/images/kernel/2013-07-08.jpg" alt="" /></p>

<p>可以看到这是基于早期版本内核的，如今内核挂载点的宏定义发生了变化，从NF_IP_XXX => NF_INET_XXX</p>

<p>每个注册的钩子函数经过处理后都将返回下列值之一，告知Netfilter核心代码处理结果，以便对报文采取相应的动作：<br/>
NF_ACCEPT：继续正常的报文处理；<br/>
NF_DROP：将报文丢弃；<br/>
NF_STOLEN：由钩子函数处理了该报文，不要再继续传送；<br/>
NF_QUEUE：将报文入队，通常交由用户程序处理；<br/>
NF_REPEAT：再次调用该钩子函数。</p>

<p>// code
```
    #include &lt;linux/module.h>
    #include &lt;linux/init.h>
    #include &lt;linux/kernel.h>
    #include &lt;linux/net.h>
    #include &lt;net/tcp.h>
    #include &lt;linux/skbuff.h>
    #include &lt;linux/netfilter.h>
    #include &lt;linux/netfilter_ipv4.h>
    #include &lt;net/ip_vs.h>
    #include &lt;net/sock.h>
    #include &lt;linux/gfp.h>
    #include &lt;linux/kallsyms.h>
    #include &lt;linux/version.h></p>

<pre><code>static unsigned int test_runit(unsigned int hooknum,
#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2, 6, 32)
        truct sk_buff **skb,
#else
        struct sk_buff *skb,
#endif
        const struct net_device *in,
        const struct net_device *out,
        int (*okfn)(struct sk_buff *))
{
    ...
    return NF_ACCEPT;
}

static struct nf_hook_ops hook_test = {
    .hook    = test_runit,
    .owner    = THIS_MODULE,
    .pf    = PF_INET,
#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2, 6, 32)
    .hooknum        = NF_IP_LOCAL_OUT,
#else
    .hooknum        = NF_INET_LOCAL_OUT,
#endif
    .priority       = 100,
};

static int  __init test_start_init(void)
{
    printk("Hi test pre\n");
    nf_register_hook(&amp;hook_test);
    return 0;
}

static void __exit test_start_exit(void)
{
    nf_unregister_hook(&amp;hook_test);
    printk("Bye test pre\n");
}
module_init(test_start_init);
module_exit(test_start_exit);
MODULE_LICENSE("GPL");
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
</feed>
