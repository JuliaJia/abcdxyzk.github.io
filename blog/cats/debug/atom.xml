<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: debug | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/debug/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2014-12-31T11:32:20+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[高精度定时器 high-cpu-load]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/11/06/debug-mark-sleep/"/>
    <updated>2014-11-06T14:30:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/11/06/debug-mark-sleep</id>
    <content type="html"><![CDATA[<p><a href="http://stackoverflow.com/questions/1125297/nanosleep-high-cpu-usage">http://stackoverflow.com/questions/1125297/nanosleep-high-cpu-usage</a></p>

<p>I noticed that a little test program which calls nanosleep is showing a huge difference in CPU usage when run on Linux machines with a kernel newer than 2.6.22.
<code>
    #include &lt;time.h&gt;
    int main (void)
    {
        struct timespec sleepTime;
        struct timespec returnTime;
        sleepTime.tv_sec = 0;
        sleepTime.tv_nsec = 1000;
        while (1)
        {
            nanosleep(&amp;sleepTime, &amp;returnTime); // usleep(1); 同样异常
        }
        return 0;
    }
</code>
(Yes, I realise this program does nothing)</p>

<p>  If I compile this and run it on an openSUSE 10.3 machine (2.6.22.19-0.2-default), the program does not even show up on the process list generated by &ldquo;top&rdquo;, indicating to me that it is using very little CPU time.  If I run it on an openSUSE 11.1 machine (2.6.27.23-0.1-default), top shows the program taking 40% of the CPU time.  Running on Fedora 9 (2.6.25-14.fc9.i686) and Fedora 10 also showed the same high CPU usage in &ldquo;top&rdquo;.</p>

<p>Has there been a change in the kernel that affects this?</p>

<hr />

<h4>Answers</h4>

<p>This is due to the introduction of NO_HZ into the mainline scheduler.</p>

<p>Previously, your 1,000 ns sleep was usually sleeping for a whole tick - 1,000,000 ns.  Now, when the machine is otherwise idle, it&rsquo;s actually only sleeping for what you asked for.  So it&rsquo;s running the while() loop and syscall around 1,000 times more frequently - hence a lot more CPU usage.  If you increase tv_nsec you should see a reduction in the CPU usage.</p>

<hr />

<pre><code>    int nanosleep(const struct timespec *req, struct timespec *rem);

    struct timespec
    {
        time_t  tv_sec;         /* seconds */
        long    tv_nsec;        /* nanoseconds */
    };
</code></pre>

<p> 这个函数功能是暂停某个进程直到你规定的时间后恢复，参数req就是你要暂停的时间，其中req->tv_sec是以秒为单位，而tv_nsec以毫 微秒为单位（10的-9次方秒）。由于调用nanosleep是是进程进入TASK_INTERRUPTIBLE,这种状态是会相应信号而进入 TASK_RUNNING状态的，这就意味着有可能会没有等到你规定的时间就因为其它信号而唤醒，此时函数返回-1，切还剩余的时间会被记录在rem中。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[crash vs gdb work]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/11/06/debug-crash-work/"/>
    <updated>2014-11-06T10:51:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/11/06/debug-crash-work</id>
    <content type="html"><![CDATA[<p><a href="https://www.redhat.com/archives/crash-utility/2014-October/msg00002.html">贴自https://www.redhat.com/archives/crash-utility/2014-October/msg00002.html</a><br/>
Yes, sure. GDB works very differently from crash. There main conceptual<br/>
difference is that GDB only handles with VIRTUAL addresses, while the<br/>
crash utility first translates everything to PHYSICAL addresses.<br/>
Consequently, GDB ignores the PhysAddr field in ELF program headers,<br/>
and crash ignores the VirtAddr field.</p>

<p>I have looked at some of my ELF dump files, and it seems to me that<br/>
VirtAddr is not filled correctly, except for kernel text and static<br/>
data (address range 0xffffffff80000000-0xffffffff9fffffff). Your linked<br/>
list is most likely allocated in the direct mapping<br/>
(0xffff880000000000-0xffffc7ffffffffff). However, I found out that the<br/>
virtual addresses for the direct mapping segments are wrong, e.g. my<br/>
dump file specifies it at 0xffff810000000000 (hypervisor area). This is<br/>
most likely a bug in the kernel code that implements /proc/vmcore.</p>

<p>But that&rsquo;s beside the point. Why?  The Linux kernel maps many physical<br/>
pages more than once into the virtual address space. It would be waste<br/>
of space if you saved it multiple times (for each virtual address that<br/>
maps to it). The crash utility can translate each virtual address to<br/>
the physical address and map it onto ELF segments using PhysAddr.<br/>
Incidentally, the PhysAddr fields are correct in my dump files&hellip;</p>

<p>I&rsquo;m glad you&rsquo;re interested in using GDB to read kernel dump files,<br/>
especially if you&rsquo;re willing to make it work for real. I have proposed<br/>
more than once that the crash utility be re-implemented in pure gdb.<br/>
Last time I looked (approx. 1.5 years ago) the main missing pieces were:</p>

<ol>
<li> Use of physical addresses (described above)</li>
<li> Support for multiple virtual address spaces (for different process<br/>
 contexts)</li>
<li> Ability to read compressed kdump files</li>
<li> Ability to use 64-bit files on 32-bit platforms (to handle PAE)</li>
</ol>


<p>HTH,<br/>
Petr Tesarik</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[静态编译crash + xbt + bt -H]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/11/04/debug-crash-static/"/>
    <updated>2014-11-04T18:23:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/11/04/debug-crash-static</id>
    <content type="html"><![CDATA[<h5>要在centos6上编译，为了能在centos5用，用静态编译</h5>

<h5>有两个显示函数参数的patch，但是不一定能起作用</h5>

<h5>patch1:</h5>

<p><a href="https://github.com/jhammond/xbt">https://github.com/jhammond/xbt</a>
<a href="https://www.redhat.com/archives/crash-utility/2013-September/msg00010.html">https://www.redhat.com/archives/crash-utility/2013-September/msg00010.html</a></p>

<h5>patch2:</h5>

<p><a href="https://github.com/hziSot/crash-stack-parser">https://github.com/hziSot/crash-stack-parser</a>
<a href="https://github.com/hziSot/crash-stack-parser/blob/master/crash-parse-stack-7.0.1.patch">https://github.com/hziSot/crash-stack-parser/blob/master/crash-parse-stack-7.0.1.patch</a></p>

<h4>一、依赖包：</h4>

<p>yum install bison zlib zlib-static glibc-static elfutils-devel elfutils-devel-static elfutils-libelf-devel-static ncurses ncurses-static crash-devel</p>

<h4>二、patch1: xbt 显示参数</h4>

<p>patch: <a href="https://github.com/hziSot/crash-stack-parser  ">https://github.com/hziSot/crash-stack-parser  </a>
make CFLAGS+=&ndash;static LDFLAGS+=&ndash;static</p>

<h4>三、patch2: bt -H 显示参数</h4>

<pre><code>    依赖：有些没有静态包，要自己编译安装：
    liblzma.a: http://tukaani.org/xz/xz-5.0.7.tar.bz2
    libbz2.a:  http://www.bzip.org/1.0.6/bzip2-1.0.6.tar.gz
    下载代码：git clone https://github.com/jhammond/xbt.git xbt.git
    把xbt.git/xbt_crash.c中函数xbt_func前的static删了
    把xbt.git/xbt_crash.c中函数xmod_init的register_extension删了
    把 xbt 命令加到global_data.c        函数x86_64_exception_frame已经在其他库中定义了，所以要换个名字
    编译xbt代码：make   ==  rm -rf *.so
    把 xbt.git/xbt_crash.o  xbt.git/xbt_dwarf.o  xbt.git/xbt_dwfl.o  xbt.git/xbt_eval.o  xbt.git/xbt_frame_print.o 加到 Makefile 的 OBJECT_FILES= 中
    make CFLAGS+=--static LDFLAGS+="--static -lc  -lm -ldl -ldw -lebl -lelf -lbz2 -llzma"


    注意:-lelf -lebl要放在-ldw后面。
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[修改elf文件标记的源码路径debugedit，find-debuginfo]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/11/03/debug-debugedit/"/>
    <updated>2014-11-03T18:10:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/11/03/debug-debugedit</id>
    <content type="html"><![CDATA[<pre><code>    yum install rpm-build
    sudo apt-get install rpm
</code></pre>

<p>/usr/lib/rpm/debugedit 用来改变源码查找路径。
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ /usr/lib/rpm/debugedit
</span><span class='line'>Usage: debugedit [OPTION&hellip;]
</span><span class='line'>  -b, &ndash;base-dir=STRING      base build directory of objects
</span><span class='line'>  -d, &ndash;dest-dir=STRING      directory to rewrite base-dir into
</span><span class='line'>  -l, &ndash;list-file=STRING     file where to put list of source and header file
</span><span class='line'>                         names
</span><span class='line'>  -i, &ndash;build-id             recompute build ID note and print ID on stdout&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;Help options:
</span><span class='line'>  -?, --help                 Show this help message
</span><span class='line'>  --usage                    Display brief usage message
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;base-dir 长度要大等于 dest-dir  
</span><span class='line'>-i 输出build-id  
</span><span class='line'>-l 输出源编译文件位置，便于有需要的人打包
</span><span class='line'>
</span><span class='line'>debugedit 会在.debug_info .debug_abbrev .debug_line .debug_str中将base_dir目录替换为dest_dir目录。  
</span><span class='line'>* 需要注意，如果base_dir是路径中除文件名的部分，则.debug_line中的The Directory Table的目录和.debug_info中的DW_AT_comp_dir(指向.debug_str的内容)不会替换。  
</span><span class='line'>如：  
</span><span class='line'>.debug_line中的Table中有一个目录为`/root/Desktop`，如果用 `-b /root/Desktop`则匹配不上这条。  
</span><span class='line'>* 因为：debugedit在匹配的时候在base_dir后面加了一个'/'  
</span><span class='line'>其他部分能替换是因为他们存的是文件路径，不是文件夹路径  
</span><span class='line'>
</span><span class='line'>--------
</span><span class='line'>
</span><span class='line'>.debug_str段保存着所有全局变量的名字，以0x00作为每一个全局变量名的结束。  
</span><span class='line'>在其它段来调用名字时，是以其在.debug_str段的偏移量来实现的  
</span><span class='line'>gcc -g /root/Desktop/a.c -o /root/Desktop/a.out  
</span><span class='line'>用绝对路径编译，在.debug_str段中就会存下源文件路径，.debug_info的DW_TAG_compile_unit中的DW_AT_name对应.debug_str中的偏移。  
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;$ objdump &ndash;dwarf=str a.out
</span><span class='line'>&hellip;.
</span><span class='line'>  0x00000000 474e5520 4320342e 342e3720 32303132 GNU C 4.4.7 2012
</span><span class='line'>  0x00000010 30333133 20285265 64204861 7420342e 0313 (Red Hat 4.
</span><span class='line'>  0x00000020 342e372d 3429006c 6f6e6720 756e7369 4.7-4).long unsi
</span><span class='line'>  0x00000030 676e6564 20696e74 002f726f 6f742f44 gned int./root/D
</span><span class='line'>  0x00000040 65736b74 6f702f61 2e630075 6e736967 esktop/a.c.unsig
</span><span class='line'>  0x00000050 6e656420 63686172 006d6169 6e006c6f ned char.main.lo
</span><span class='line'>  0x00000060 6e672069 6e74002f 726f6f74 2f446573 ng int./root/Des
</span><span class='line'>  0x00000070 6b746f70 0073686f 72742075 6e736967 ktop.short unsig
</span><span class='line'>  0x00000080 6e656420 696e7400 73686f72 7420696e ned int.short in
</span><span class='line'>  0x00000090 7400                                t.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;$ objdump &ndash;dwarf=info a.out
</span><span class='line'>&hellip;..
</span><span class='line'> &lt;0&gt;&lt;b&gt;: Abbrev Number: 1 (DW_TAG_compile_unit)
</span><span class='line'>&lt; c&gt;   DW_AT_producer    : (indirect string, offset: 0x0): GNU C 4.4.7 20120313 (Red Hat 4.4.7-4)
</span><span class='line'>&lt;10&gt;   DW_AT_language    : 1        (ANSI C)
</span><span class='line'>&lt;11&gt;   DW_AT_name        : (indirect string, offset: 0x39): /root/Desktop/a.c
</span><span class='line'>&lt;15&gt;   DW_AT_comp_dir    : (indirect string, offset: 0x67): /root/Desktop
</span><span class='line'>&lt;19&gt;   DW_AT_low_pc      : 0x4004c4
</span><span class='line'>&lt;21&gt;   DW_AT_high_pc     : 0x40051c
</span><span class='line'>&lt;29&gt;   DW_AT_stmt_list   : 0x0&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;-----------------------------------------
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;$ /usr/lib/rpm/debugedit -b /root/Desktop -d /usr/src /root/Desktop/a.out</span></code></pre></td></tr></table></div></figure></p>

<hr />

<pre><code>$ objdump --dwarf=str a.out
...
  0x00000000 474e5520 4320342e 342e3720 32303132 GNU C 4.4.7 2012
  0x00000010 30333133 20285265 64204861 7420342e 0313 (Red Hat 4.
  0x00000020 342e372d 3429006c 6f6e6720 756e7369 4.7-4).long unsi
  0x00000030 676e6564 20696e74 002f7573 722f7372 gned int./usr/sr
  0x00000040 632f612e 63002f61 2e630075 6e736967 c/a.c./a.c.unsig
  0x00000050 6e656420 63686172 006d6169 6e006c6f ned char.main.lo
  0x00000060 6e672069 6e74002f 726f6f74 2f446573 ng int./root/Des
  0x00000070 6b746f70 0073686f 72742075 6e736967 ktop.short unsig
  0x00000080 6e656420 696e7400 73686f72 7420696e ned int.short in
  0x00000090 7400                                t.


$ objdump --dwarf=info a.out

...
 &lt;0&gt;&lt;b&gt;: Abbrev Number: 1 (DW_TAG_compile_unit)
    &lt; c&gt;   DW_AT_producer    : (indirect string, offset: 0x0): GNU C 4.4.7 20120313 (Red Hat 4.4.7-4)
    &lt;10&gt;   DW_AT_language    : 1        (ANSI C)
    &lt;11&gt;   DW_AT_name        : (indirect string, offset: 0x39): /usr/src/a.c
    &lt;15&gt;   DW_AT_comp_dir    : (indirect string, offset: 0x67): /root/Desktop
    &lt;19&gt;   DW_AT_low_pc      : 0x4004c4
    &lt;21&gt;   DW_AT_high_pc     : 0x40051c
    &lt;29&gt;   DW_AT_stmt_list   : 0x0
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[libdwarf 安装使用]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/10/15/debug-libdwarf/"/>
    <updated>2014-10-15T18:16:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/10/15/debug-libdwarf</id>
    <content type="html"><![CDATA[<p>下载<a href="http://www.prevanders.net/dwarf.html">http://www.prevanders.net/dwarf.html</a></p>

<p>依赖<a href="http://directory.fsf.org/wiki/Libelf">http://directory.fsf.org/wiki/Libelf</a></p>

<p>dwarf格式文档<a href="http://www.dwarfstd.org/Home.php">http://www.dwarfstd.org/Home.php</a></p>

<p>使用
<code>
./dwarfdump2/dwarfdump -Wc -S match=dev_queue_xmit /tmp/vmlinux
</code>
获取vmlinux中dev_queue_xmit函数的.debug信息</p>
]]></content>
  </entry>
  
</feed>
