<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 2011~03 | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/2011~03/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2014-12-14T16:05:16+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[dancing links]]></title>
    <link href="http://abcdxyzk.github.io/blog/2011/03/24/alg-dancing-links/"/>
    <updated>2011-03-24T23:12:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2011/03/24/alg-dancing-links</id>
    <content type="html"><![CDATA[<p>Knuth Dancing_Links 中文版 <a href="http://www.docin.com/p-31928825.html">http://www.docin.com/p-31928825.html</a></p>

<p><a href="http://acm.fzu.edu.cn/problem.php?pid=1686">http://acm.fzu.edu.cn/problem.php?pid=1686</a></p>

<p><a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3209">http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3209</a></p>

<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3529">http://acm.hdu.edu.cn/showproblem.php?pid=3529</a></p>

<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3663">http://acm.hdu.edu.cn/showproblem.php?pid=3663</a></p>

<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2295">http://acm.hdu.edu.cn/showproblem.php?pid=2295</a></p>

<p><a href="http://poj.org/problem?id=3074">http://poj.org/problem?id=3074</a></p>

<p><a href="http://poj.org/problem?id=3076">http://poj.org/problem?id=3076</a></p>

<h5>// fzu 1686</h5>

<pre><code>    #include&lt;stdio.h&gt;
    #include&lt;algorithm&gt;

    using namespace std;

    const int MAXN = 225;
    int L[MAXN*MAXN], R[MAXN*MAXN], U[MAXN*MAXN], D[MAXN*MAXN];
    int S[MAXN];
    int Col[MAXN*MAXN];
    int limit;

    void Remove(int x) {
        for (int i = D[x]; i != x; i = D[i]) {
        L[R[i]] = L[i];
        R[L[i]] = R[i];
        }
    }
    void Resume(int x) {
        for (int i = U[x]; i != x; i = U[i]) {
        L[R[i]] = R[L[i]] = i;
        }
    }
    int Hash() {
        int ans = 0;
        bool hash[MAXN] = {0};
        for (int c = R[0]; c != 0; c = R[c])
        if (! hash[c]) {
            hash[c] = true;
            ans ++;
            for (int i = D[c]; i != c; i = D[i])
            for (int j = R[i]; j != i; j = R[j])
            hash[Col[j]] = true;
        }
        return ans;
    }

    bool dfs(int depth) {
        if (depth + Hash() &gt; limit) return false;
        if (R[0] == 0) return true;
        int i, j, c, minnum = INT_MAX;
        for (i = R[0]; i != 0; i = R[i]) {
            if (S[i] &lt; minnum) {
                minnum = S[i];
                c = i;
            }
        }
        for (i = U[c]; i != c; i = U[i]) {
                Remove(i);
                for (j = R[i]; j != i; j = R[j]) Remove(j);
                if (dfs(depth + 1)) {
                for (j = L[i]; j != i; j = L[j]) Resume(j);
                Resume(i);
                return true;
            }
            for (j = L[i]; j != i; j = L[j]) Resume(j);
            Resume(i);
        }
        return false;
    }

    int solve(int n, int m, int DL[][MAXN], int maxdepth) {
        if (maxdepth &gt; n) maxdepth = n;
        for (int i = 0; i &lt;= m; i ++) {
            L[i] = i - 1;
            R[i] = i + 1;
            U[i] = D[i] = i;
        }
        L[0] = m;
        R[m] = 0;
        int cnt = m + 1;
        memset(S, 0, sizeof (S));
        for (int i = 1; i &lt;= n; i ++) {
            int head = cnt, tail = cnt;
            for (int c = 1; c &lt;= m; c ++) if (DL[i][c]) {
                S[c] ++;
                Col[cnt] = c;
                U[D[c]] = cnt;
                D[cnt] = D[c];
                U[cnt] = c;
                D[c] = cnt;
                L[cnt] = tail;
                R[tail] = cnt;
                R[cnt] = head;
                L[head] = cnt;
                tail = cnt;
                cnt ++;
            }
        }
        int best = 0, worst = maxdepth;
        while (best &lt;= worst) {
            limit = (worst + best) &gt;&gt; 1;
            if (dfs(0)) worst = limit - 1;
            else best = limit + 1;
        }
        return best;
    }

    int main()
    {
        int i,j,k,l,row,col,n,m,n1,m1,mark[MAXN][MAXN],a[33][33],id[33][33];

        while(scanf("%d %d",&amp;n,&amp;m) != EOF)
        {
            col = 0;
            for(i=1;i&lt;=n;i++)
                for(j=1;j&lt;=m;j++)
                {
                    scanf("%d",&amp;a[i][j]);
                    id[i][j] = -1;
                    if(a[i][j] == 1) { col++; id[i][j] = col; }
                }
            scanf("%d %d",&amp;n1,&amp;m1);

            row = 0;
            for(i=1;i&lt;=n-n1+1;i++)
                for(j=1;j&lt;=m-m1+1;j++)
                {
                    row++;
                    for(k=1;k&lt;=col;k++)mark[row][k] = 0;

                    for(k=i;k&lt;i+n1;k++)
                        for(l=j;l&lt;j+m1;l++)
                        if(id[k][l] &gt; 0)
                            mark[row][id[k][l]] = 1;
                }

            printf("%d\n",solve(row, col, mark, row));
        }
        return 0;
    }
</code></pre>

<h5>// hdu 2295</h5>

<pre><code>    #include&lt;stdio.h&gt;
    #include&lt;algorithm&gt;
    #include&lt;math.h&gt;
    #include&lt;string.h&gt;

    using namespace std;

    const int MAXN = 225;
    int L[MAXN*MAXN], R[MAXN*MAXN], U[MAXN*MAXN], D[MAXN*MAXN];
    int S[MAXN];
    int Col[MAXN*MAXN];
    int limit;

    void Remove(int x) {
        for (int i = D[x]; i != x; i = D[i]) {
        L[R[i]] = L[i];
        R[L[i]] = R[i];
        }
    }
    void Resume(int x) {
        for (int i = U[x]; i != x; i = U[i]) {
        L[R[i]] = R[L[i]] = i;
        }
    }
    int Hash() {
        int ans = 0;
        bool hash[MAXN] = {0};
        for (int c = R[0]; c != 0; c = R[c])
        if (! hash[c]) {
            hash[c] = true;
            ans ++;
            for (int i = D[c]; i != c; i = D[i])
            for (int j = R[i]; j != i; j = R[j])
            hash[Col[j]] = true;
        }
        return ans;
    }

    bool dfs(int depth) {
        if (depth + Hash() &gt; limit) return false;
        if (R[0] == 0) return true;
        int i, j, c, minnum = 2000000000;
        for (i = R[0]; i != 0; i = R[i]) {
            if (S[i] &lt; minnum) {
                minnum = S[i];
                c = i;
            }
        }
        for (i = U[c]; i != c; i = U[i]) {
                Remove(i);
                for (j = R[i]; j != i; j = R[j]) Remove(j);
                if (dfs(depth + 1)) {
                for (j = L[i]; j != i; j = L[j]) Resume(j);
                Resume(i);
                return true;
            }
            for (j = L[i]; j != i; j = L[j]) Resume(j);
            Resume(i);
        }
        return false;
    }

    int solve(int n, int m, int DL[][MAXN], int maxdepth) {
        if (maxdepth &gt; n) maxdepth = n;
        for (int i = 0; i &lt;= m; i ++) {
            L[i] = i - 1;
            R[i] = i + 1;
            U[i] = D[i] = i;
        }
        L[0] = m;
        R[m] = 0;
        int cnt = m + 1;
        memset(S, 0, sizeof (S));
        for (int i = 1; i &lt;= n; i ++) {
            int head = cnt, tail = cnt;
            for (int c = 1; c &lt;= m; c ++) if (DL[i][c]) {
                S[c] ++;
                Col[cnt] = c;
                U[D[c]] = cnt;
                D[cnt] = D[c];
                U[cnt] = c;
                D[c] = cnt;
                L[cnt] = tail;
                R[tail] = cnt;
                R[cnt] = head;
                L[head] = cnt;
                tail = cnt;
                cnt ++;
            }
        }
        int best = 0, worst = maxdepth;
        /*while (best &lt;= worst) {
            limit = (worst + best) &gt;&gt; 1;
            if (dfs(0)) worst = limit - 1;
            else best = limit + 1;
        }*/
        limit = maxdepth;
        if(dfs(0))best = maxdepth;
        else
            best = maxdepth+1;
        return best;
    }

    int x[155],y[155];

    int dij(int i, int j)
    {
        int d1 = (x[i]-x[j])*(x[i]-x[j]);
        int d2 = (y[i]-y[j])*(y[i]-y[j]);
        return d1+d2;
    }

    int main()
    {
        int i,j,k,l,row,col,n,m,low,up,mid,mark[MAXN][MAXN],d[55][55],T,b[3000],top;


        scanf("%d",&amp;T);
        while(T--)
        {
            scanf("%d %d %d",&amp;n,&amp;row,&amp;m);

            for(i=1;i&lt;=n+row;i++)
                scanf("%d %d",&amp;x[i],&amp;y[i]);

            low = 1; up = 1000000000;

            while(low &lt; up)
            {
                for(i=1;i&lt;=row;i++)
                    for(j=1;j&lt;=n;j++)mark[i][j] = 0;

                mid = (low + up)&gt;&gt;1;
                for(i=1;i&lt;=row;i++)
                    for(j=1;j&lt;=n;j++)if(dij(i+n,j) &lt;= mid)mark[i][j] = 1;

                if(solve(row, n, mark, m) &gt; m)low = mid+1; else up = mid;
            }
            mid = (low + up)&gt;&gt;1;
            printf("%.6lf\n",sqrt(1.0*mid));
        }
        return 0;
    }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[划分树--查询区间k-th number]]></title>
    <link href="http://abcdxyzk.github.io/blog/2011/03/23/alg-ds-div-tree/"/>
    <updated>2011-03-23T23:10:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2011/03/23/alg-ds-div-tree</id>
    <content type="html"><![CDATA[<h4>划分树 &ndash; 查询区间 k-th number</h4>

<p><a href="http://poj.org/problem?id=2104">http://poj.org/problem?id=2104</a><br/>
<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2665">http://acm.hdu.edu.cn/showproblem.php?pid=2665</a><br/>
<a href="http://acm.hdu.edu.cn/showproblem.php?pid=3727">http://acm.hdu.edu.cn/showproblem.php?pid=3727</a><br/>
<a href="http://acm.hdu.edu.cn/showproblem.php?pid=3473">http://acm.hdu.edu.cn/showproblem.php?pid=3473</a></p>

<pre><code>tr[ log(N) ][ N ]
1. 先对原来的数 稳定排序 ，tr[0][i] = 原先的数 a[i] 在排序后的位置。
2. dep = 0; s = 1; t = n;
3. 递归建树 
build_tree(dep, s, t)
{
    if(s &gt;= t) return;
    mid = (s+t)/2;  j = s;  k = mid+1;
    for(i=s;i&lt;=t;i++) if( tr[dep][i] &lt;= mid )  tr[dep+1][j++] = tr[dep][i]; else tr[dep+1][k++] = tr[dep][i];
    //  把s 到 t 一分为二， s 到 t 的每个数 如果排序后它排在该区间的前半部分就移到下一层的前半部。
    //  如果要计算小于和大于 k-th number 的数的和要多算 sum[dep][x] 即 dep+1 层中 s 到 x(x&lt;=mid) 的和 或 mid+1 到 x(x&gt;mid) 的和。
    tr[dep][i] = j-1;  // s 到 t 区间， tr[dep][i] 记录 s 到 i 分到前半部分的最后位置
    build_tree(dep+1, s, mid);  build_tree(dep+1, mid+1, t);
}
4. 查找区间 [i,j] 中的 k-th number ，其中 1&lt;=k&lt;=j-i+1;
find_tree(dep, s, t, i, j, k)
{
    if(s == t) return s;
    v = i 到 j 中分到左边的数
    if(v &gt;= k) return find_tree(dep+1, s, mid, ci, cj, k); // ci, cj 对应 i, j 分到前半部分的位置。 分到右半部分的和加到大于k-th number 上
    else    return find_tree(dep+1, mid+1, t, ci, cj, k-v); // 分到左半部分的和加到小于k-th number 上
 }

时间复杂度 O( n*log(n) 预处理， log(n) 查询 ) ，空间大小 n*log(n)

序列 ： 2 5 9 8 4 3 1
排序后  1 2 3 4 5 8 9
所以 原序列对应的最终位置为 2 5 7 6 4 3 1

        按最终位置分                                   指向分到前半部分的最后位置
tr[0][] = 2 5 7 6 4 3 1                        处理后 tr[0][] = 1 1 1 1 2 3 4
tr[1][] = 2 4 3 1 || 5 7 6                            tr[1][] = 1 1 1 2 || 5 5 6
tr[2][] = 2 1 || 4 3 || 5 6 || 7                      tr[2][] = 0 1 || 2 3 || 5 5 || 7
tr[3][] = 1 || 2 || 3 || 4 || 5 || 6   
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[插头 DP]]></title>
    <link href="http://abcdxyzk.github.io/blog/2011/03/17/alg-mdp/"/>
    <updated>2011-03-17T23:07:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2011/03/17/alg-mdp</id>
    <content type="html"><![CDATA[<p>陈丹琦的大作  <a href="http://www.docin.com/p-46797997.html">http://www.docin.com/p-46797997.html</a></p>

<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1964">http://acm.hdu.edu.cn/showproblem.php?pid=1964</a></p>

<p><a href="http://acm.timus.ru/problem.aspx?space=1&amp;num=1519">http://acm.timus.ru/problem.aspx?space=1&amp;num=1519</a></p>

<p><a href="http://poj.org/problem?id=1739">http://poj.org/problem?id=1739</a></p>

<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3377">http://acm.hdu.edu.cn/showproblem.php?pid=3377</a></p>

<p><a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3256">http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3256</a></p>

<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1693">http://acm.hdu.edu.cn/showproblem.php?pid=1693</a></p>

<p><a href="http://acm.fzu.edu.cn/problem.php?pid=1977">http://acm.fzu.edu.cn/problem.php?pid=1977</a></p>

<p><a href="http://poj.org/problem?id=3133">http://poj.org/problem?id=3133</a></p>

<p>// timus_1519  有效状态间转移
```
    #include&lt;stdio.h></p>

<pre><code>long long dp[60000],pre[60000];
int all,r[60000],e[1600000];
int p[60000][13];

class DP {

public:
    int n,m,can[33][33],last;
    int val[33],LL,UU,sta,next;
    int a[33],b[33],d[33],c[33];

    void input()
    {
        int i,j;
        char ch[15];
        last = 0;
        for(i=1;i&lt;=n;i++)
        {
            scanf("%s",ch);
            for(j=1;j&lt;=m;j++)
            {
                can[i][j] = ch[j-1]=='.'?(++last):-1;
            }
        }
    }

    int ok()
    {
        int i,l;
        l = 0;
        for(i=1;i&lt;=m+1;i++)
        {
            b[i] = d[i] = -1;
            if(a[i] == 1) c[++l] = i;
            else
            if(a[i] == 2)
            {
                if(l == 0) return 0;
                b[c[l]] = i; d[i] = c[l];
                l--;
            }
        }
        if(l != 0) return 0;
        return 1;
    }

    void init()
    {
        int i,j,k;

        val[1] = 1;
        for(i=2;i&lt;=m+2;i++) val[i] = val[i-1]*3;;

        for(i=0;i&lt;=m+2;i++) a[i] = 0;
        a[1] = -1;

        all = 0;

        for(i=0;i&lt;=val[m+2];i++)
        {
            a[1]++;
            k = 1; while(k &lt;= m+1 &amp;&amp; a[k]&gt;2) { a[k]%=3; a[k+1]++; k++; }

            e[i] = -1;

            if(ok() == 0) continue;

            r[all] = i; e[i] = all;

            for(j=1;j&lt;=m+1;j++) {
                p[all][j] = -1;
                if(b[j] != -1) p[all][j] = b[j];
                if(d[j] != -1) p[all][j] = d[j];
            }

            all++;
        }
    }

    void abc()
    {
        int i,j,k,l;

        input();
        init();

        for(i=0;i&lt;all;i++) dp[i] = 0;

        dp[r[0]] = 1;

        for(i=1;i&lt;=n;i++)
            for(j=1;j&lt;=m;j++)
            {
                if(j == 1)
                {
                    for(k=all-1;k&gt;=0;k--)
                    {
                        l = r[k]; l = l/3; l = e[l];

                        if(l != -1)
                        {
                            dp[k] = dp[l];
                            if(r[k]%3 != 0) dp[k] = 0;
                        }
                        else
                            dp[k] = 0;
                    }
                }

                for(k=0;k&lt;all;k++)
                {
                    pre[k] = dp[k]; dp[k] = 0;
                }

                for(k=0;k&lt;all;k++)
                if(pre[k] &gt; 0)
                {
                    LL = r[k]/val[j]%3;
                    UU = r[k]/val[j+1]%3;

                    if(can[i][j] == -1)
                    {
                        if(LL == 0 &amp;&amp; UU == 0)
                        {
                            dp[k] += pre[k];
                        }
                        continue;
                    }

                    if(UU == 0 &amp;&amp; LL == 0)
                    {
                        sta = r[k]+val[j]+val[j+1]+val[j+1];

                        dp[e[sta]] += pre[k];
                    }
                    else
                    if(LL == 0)
                    {
                        sta = r[k];
                        dp[e[sta]] += pre[k];

                        sta = r[k]+r[k]/val[j+1]%3*(val[j]-val[j+1]);
                        dp[e[sta]] += pre[k];
                    }
                    else
                    if(UU == 0)
                    {
                        sta = r[k];
                        dp[e[sta]] += pre[k];

                        sta = r[k]+r[k]/val[j]%3*(-val[j]+val[j+1]);
                        dp[e[sta]] += pre[k];
                    }
                    else
                    if(LL == 2 &amp;&amp; UU == 1)
                    {
                        sta = r[k]-val[j]-val[j]-val[j+1];
                        dp[e[sta]] += pre[k];
                    }
                    else
                    if(LL == 1 &amp;&amp; UU == 1)
                    {
                        if(p[k][j+1] &gt; 0 &amp;&amp; p[k][j+1] &lt;= m+1)
                        {
                            sta = r[k]-val[j]-val[j+1]-val[p[k][j+1]];
                            dp[e[sta]] += pre[k];
                        }
                    }
                    else
                    if(LL == 2 &amp;&amp; UU == 2)
                    {
                        if(p[k][j] &gt; 0)
                        {
                            sta = r[k]-val[j]-val[j]-val[j+1]-val[j+1]+val[p[k][j]];
                            dp[e[sta]] += pre[k];
                        }
                    }
                    else
                    if(LL == 1 &amp;&amp; UU == 2)
                    {
                        if(can[i][j] == last)
                        {
                            sta = r[k]-val[j]-val[j+1]-val[j+1];
                            dp[e[sta]] += pre[k];
                        }
                    }
                }
            }
        printf("%lld\n",dp[r[0]]);
    }

    void solve()
    {
        while(scanf("%d %d",&amp;n,&amp;m) != EOF)
        {
            abc();
        }
    }
};

int main() {
    DP dp;
    dp.solve();
    return 0;
}
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
</feed>
