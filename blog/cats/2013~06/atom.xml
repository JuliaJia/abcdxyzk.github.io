<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 2013~06 | kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/blog/cats/2013~06/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2014-12-05T20:05:46+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Makefile与Shell的问题]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/06/21/compiler-makefile-shell/"/>
    <updated>2013-06-21T18:28:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/06/21/compiler-makefile-shell</id>
    <content type="html"><![CDATA[<p>  大概只要知 道Makefile的人，都知道Makefile可以调用Shell脚本。但是在实际使用时，并不那么简单，一些模棱两可的地方可能会让你抓狂。你若不信，可以先看几个例子，想象一下这些这些例子会打印什么内容，记下你想象的结果，然后在计算机上运行这些例子，对照看一下。</p>

<p>示例一：
<code>
    if [ "$(BUILD)" = "debug" ]; then
        echo "build debug";
    else
        echo "build release";
    fi
    all:
        echo "done"
</code>
示例二：<br/>
<code>
    all:
        @CC=arm-linux-gcc
        @echo $(CC)
   </code>
    示例三：<br/>
    <code>
    CC=arm-linux-gcc
    all:
        @echo $(CC)
</code>
示例四：<br/>
<code>
    SUBDIR=src example
    all:
        @for subdir in $(SUBDIR);
        do
            echo "building " $(subdir);
        done
</code></p>

<h4>说明：</h4>

<ol>
<li>Shell脚本在target里才有效，其它地方都被忽略掉了。所以示例一中，”build debug”之类的字符串根本打印不出来。示例一的正确写法是：
示例一：
<code>
 all:
     if [ "$(BUILD)" = "debug" ]; then
         echo "build debug";
     else
         echo "build release";
     fi
     echo "done"
</code></li>
<li>make把每一行Shell脚本当作一个独立的单元，它们在单独的进程中运行。示例二中，两行Shell脚本在两个莫不相干的进程里运行，第一个进程把 CC设置为arm-linux-gcc，第二个进程是不知道的，所以打印的结果自然不是arm-linux-gcc了。示例二的正确写法是：<br/>
示例二：
<code>
 all:
     @CC=arm-linux-gcc; echo $(CC)
 或者：
 all:
     @CC=arm-linux-gcc;
     echo $(CC)
</code></li>
<li><p>make在调用Shell之前先进行预处理，即展开所有Makefile的变量和函数。这些变量和函数都以$开头。示例三中，Shell拿的脚本实际上是echo arm-linux-gcc，所以打印结果正确。</p></li>
<li><p>make预处理时，所有以$开头的，它都不会放过。要想引用Shell自己的变量，应该以$$开头。另外要注意，Shell自己的变量是不需要括号的。示例四的正确写法是：<br/>
示例四：
<code>
 SUBDIR=src example
 all:
     @for subdir in $(SUBDIR);
     do
         echo "building " $$subdir;
     done
</code></p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[字节序和比特序]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/06/20/lang-c-B_b_byte/"/>
    <updated>2013-06-20T18:23:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/06/20/lang-c-B_b_byte</id>
    <content type="html"><![CDATA[<p>字节序和比特序，因为比特序对所有代码（包括汇编）是透明的，所以对于小端系统，有说是用大端比特序，也有说是用小端比特序。<br/>
下面是copy一部分觉得靠谱的内容：<br/>
大小端
我们对"endianness"这个名词估计都很熟悉了。它首先被Danny Cohen于1980引入，用来表述计算机系统表示多字节整数的方式。
endianness分为两种：大端和小端。(从字节序的角度来看)大端方式是将整数中最高位byte存放在最低地址中。而小端方式则相反，将整数中的最高位byte存放在最高地址中。
对于某个确定的计算机系统，比特序通常与字节序保持一致。换言之，在大端系统中，每个byte中最高位bit存放在内存最低位；在小端系统中，最低位bit存放在内存最低位。
正如大部分人是按照从左至右的顺序书写数字，一个多字节整数的内存布局也应该遵循同样的方式，即从左至右为数值的最高位至最低位。正如我们在下面的例子中所看到的，这是书写整数最清晰的方式。</p>

<p>根据上述规则，我们按以下方式分别在大端和小端系统中值为0x0a0b0c0d的整数。
在大端系统中书写整数：
byte  addr  0   1   2   3
bit offset  01234567 01234567 01234567 01234567</p>

<pre><code>binary  00001010 00001011 00001100 00001101
  hex      0a       0b       0c       0d
</code></pre>

<p>在小端系统中书写整数(认真看)
byte  addr  0   1   2   3
bit offset  01234567 01234567 01234567 01234567</p>

<pre><code>binary  10110000 00110000 11010000 01010000
  hex      d0       c0       b0       a0
</code></pre>

<p>说明字节序：
<code>
    #include &lt;stdio.h&gt;  
    int main (void)  
    {  
        union b  
        {  
            short k;  //测试环境short占2字节  
            char i[2];  //测试环境char占1字节  
        }*s,a;  
        s=&amp;a;  
        s-&gt;i[0]=0x41;  
        s-&gt;i[1]=0x52;  
        printf("%x\n",s-&gt;k);  
        return 0;  
    }
</code>
输出：5241</p>

<hr />

<p>self code:
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>union W
</span><span class='line'>{
</span><span class='line'>    struct Y
</span><span class='line'>    {
</span><span class='line'>        unsigned int s1:4;
</span><span class='line'>        unsigned int s2:8;
</span><span class='line'>        unsigned int s3:20;
</span><span class='line'>    } y;
</span><span class='line'>    unsigned int c;
</span><span class='line'>} w;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;union V 
</span><span class='line'>{
</span><span class='line'>struct X
</span><span class='line'>{
</span><span class='line'>    unsigned char s1:3;
</span><span class='line'>    unsigned char s2:3;
</span><span class='line'>    unsigned char s3:2;
</span><span class='line'>} x;
</span><span class='line'>unsigned char c;
</span><span class='line'>} v;
</span><span class='line'>
</span><span class='line'>int main()
</span><span class='line'>{
</span><span class='line'>w.c = 0x12345678;
</span><span class='line'>printf("%x %x %x %x\n", w.c, w.y.s1, w.y.s2, w.y.s3); 
</span><span class='line'>
</span><span class='line'>v.c = 100;
</span><span class='line'>printf("%d %x %x %x\n", v.c, v.x.s1, v.x.s2, v.x.s3); 
</span><span class='line'>return 0;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;输出：&lt;br/&gt;
</span><span class='line'>12345678 8 67 12345&lt;br/&gt;
</span><span class='line'>100 4 4 1&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;100 = （01100100）2&lt;br/&gt;
</span><span class='line'>因为字节序是小端的所以第一行输出说明：位域变量从左到右分配位，所以第二行的输出的位域变量也应该从左到右分配位。所以&lt;br/&gt;
</span><span class='line'>100 = 001 001 10  （小端比特序二进制）&lt;br/&gt;
</span><span class='line'>对应:  s1  s2  s3  （位域变量从左到右分配位）&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;符合。&lt;/p&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[内核编译模块]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2013/06/06/kernel-mod-compiler/"/&gt;
</span><span class='line'>&lt;updated&gt;2013-06-06T14:28:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2013/06/06/kernel-mod-compiler&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;pre&gt;&lt;code&gt;    /*filename: test.c*/
</span><span class='line'>#include &lt;linux/init.h&gt;
</span><span class='line'>#include &lt;linux/kernel.h&gt;
</span><span class='line'>#include &lt;linux/module.h&gt;
</span><span class='line'>
</span><span class='line'>staticintdummy_init(void)
</span><span class='line'>{
</span><span class='line'>    printk("hello,world.\n");
</span><span class='line'>    return0;
</span><span class='line'>}
</span><span class='line'>staticvoiddummy_exit(void)
</span><span class='line'>{
</span><span class='line'>    return;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>module_init(dummy_init);
</span><span class='line'>module_exit(dummy_exit);
</span><span class='line'>
</span><span class='line'>MODULE_LICENSE("GPL")
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;执行如下命令：
</span><span class='line'>&lt;code&gt;
</span><span class='line'>$ gcc -c -O2 -DMODULE -D__KERNEL__ -I/usr/src/linux test.c
</span><span class='line'>$ insmod test.o
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>No module found in object&lt;br/&gt;
</span><span class='line'>insmod: error inserting &lsquo;test.o&rsquo;: -1 Invalid module format&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;正确的做法是写一个Makefile,由内核的Kbuild来帮你编译。&lt;br/&gt;
</span><span class='line'>&lt;code&gt;
</span><span class='line'>$ cat Makefile
</span><span class='line'>obj-m :=test.o
</span><span class='line'>KDIR :=/lib/modules/$(shell uname -r)/build
</span><span class='line'>PWD :=$(shell pwd)
</span><span class='line'>default:
</span><span class='line'>    $(MAKE)-C $(KDIR)SUBDIRS=$(PWD)modules
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>执行如下命令：
</span><span class='line'>&lt;code&gt;
</span><span class='line'>$make
</span><span class='line'>make -C /lib/modules/2.6.5-1.358/build SUBDIRS=/test modules
</span><span class='line'>make[1]:Entering directory `/lib/modules/2.6.5-1.358/build'
</span><span class='line'>  CC [M]  /test/modinject/test.o
</span><span class='line'>  Building modules, stage 2.
</span><span class='line'>  MODPOST
</span><span class='line'>  CC      /test/modinject/test.mod.o
</span><span class='line'>  LD [M]  /test/modinject/test.ko
</span><span class='line'>make[1]: Leaving directory `/lib/modules/2.6.5-1.358/build'
</span><span class='line'>$ls -l
</span><span class='line'>-rw-r--r--1 root root   268 Jan  7 08:31 test.c
</span><span class='line'>-rw-r--r--1 root root  2483 Jan  8 09:19 test.ko
</span><span class='line'>-rw-r--r--1 root root   691 Jan  8 09:19 test.mod.c
</span><span class='line'>-rw-r--r--1 root root  1964 Jan  8 09:19 test.mod.o
</span><span class='line'>-rw-r--r--1 root root  1064 Jan  8 09:19 test.o
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>其实上边的test.o就是用gcc生成的test.o,而test.ko是使用下列命令来生成的。
</span><span class='line'>&lt;code&gt;
</span><span class='line'>$ld -m elf_i386  -r -o test.ko test.o  test.mod.o
</span><span class='line'>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;再来看看test.mod.c，它是由/usr/src/linux/scripts/modpost.c来生成的。</span></code></pre></td></tr></table></div></figure>
    $ cat test.mod.c
    #include &lt;linux/module.h>
    #include &lt;linux/vermagic.h>
    #include &lt;linux/compiler.h></p>

<pre><code>MODULE_INFO(vermagic,VERMAGIC_STRING);
#undef unix

struct module __this_module
__attribute__((section(".gnu.linkonce.this_module")))={
.name =__stringify(KBUILD_MODNAME),
.init =init_module,
#ifdef CONFIG_MODULE_UNLOAD

.exit=cleanup_module,
#endif

};
static const struct modversion_info ____versions[]
__attribute_used__
__attribute__((section("__versions")))={
    {0,"cleanup_module"},
    {0,"init_module"},
    {0,"struct_module"},
    {0,"printk"},
};
static const char __module_depends[]
__attribute_used__
__attribute__((section(".modinfo")))=
"depends=";
</code></pre>

<pre><code>可见，test.mod.o只是产生了几个ELF的节，分别是modinfo,  .gun.linkonce.this_module(用于重定位，引进了rel.gnu.linkonce.this_module),  __versions。而test.ko是test.o和test.mod.o合并的结果。

通常我们安装一个新的模块,先是编译出相应的ko文件，然后移动
</code></pre>

<p>/lib/modules/<code>uname -r</code>/
<code>
目录或者某个子目录下，locate xxx.ko确定该模块确实在上面提到的目录下面，执行depmod -a，depmod将会检查
</code>
/lib/modules/<code>uname -r</code>/
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>目录及其子目录中的所有模块文件，并根据相依性生成新的modules.dep文件，这时我们执行modprobe xxx.ko，该模块就会被正常加载了。&lt;/p&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>    &lt;title type="html"&gt;&lt;![CDATA[查看注册的kprobe列表]]&gt;&lt;/title&gt;
</span><span class='line'>    &lt;link href="http://abcdxyzk.github.io/blog/2013/06/06/kprobe-list/"/&gt;
</span><span class='line'>    &lt;updated&gt;2013-06-06T10:45:00+08:00&lt;/updated&gt;
</span><span class='line'>    &lt;id&gt;http://abcdxyzk.github.io/blog/2013/06/06/kprobe-list&lt;/id&gt;
</span><span class='line'>    &lt;content type="html"&gt;&lt;![CDATA[&lt;pre&gt;&lt;code&gt;sudo mount -t debugfs none mount_dir/
</span><span class='line'>
</span><span class='line'>#cat mount_dir/kprobes/list
</span><span class='line'>c015d71a  k  vfs_read+0x0
</span><span class='line'>c011a316  j  do_fork+0x0
</span><span class='line'>c03dedc5  r  tcp_v4_rcv+0x0
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;第一列表示探测点插入的内核地址，第二列表示内核探测的类型，k表示kprobe，r表示kretprobe，j表示jprobe，第三列指定探测点的"符号+偏移"。如果被探测的函数属于一个模块，模块名也被指定。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;打开和关闭kprobe的方法列出如下：</span></code></pre></td></tr></table></div></figure></p>

<h1>echo ‘1’ mount_dir/kprobes/enabled</h1>

<h1>echo ‘0’ mount_dir/kprobes/enabled</h1>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Makefile预定义变量、自动变量]]></title>
    <link href="http://abcdxyzk.github.io/blog/2013/06/03/compiler-makefile-vars/"/>
    <updated>2013-06-03T15:22:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2013/06/03/compiler-makefile-vars</id>
    <content type="html"><![CDATA[<h4>Makefile中常见自动变量</h4>

<pre><code>    命令格式        含     义
    $*      不包含扩展名的目标文件名称
    $+      所有的依赖文件，以空格分开，并以出现的先后为序，可能包含重复的依赖文件
    $&lt;      第一个依赖文件的名称
    $?      所有时间戳比目标文件晚的依赖文件，并以空格分开 
    $@      目标文件的完整名称
    $^      所有不重复的依赖文件，以空格分开
    $%      如果目标是归档成员，则该变量表示目标的归档成员名称
</code></pre>

<h4>Makefile中常见预定义变量</h4>

<pre><code>    命 令 格 式 含     义
    AR              库文件维护程序的名称，默认值为ar
    AS              汇编程序的名称，默认值为as
    CC              C编译器的名称，默认值为cc
    CPP             C预编译器的名称，默认值为$(CC) –E
    CXX             C++编译器的名称，默认值为g++
    FC              FORTRAN编译器的名称，默认值为f77
    RM              文件删除程序的名称，默认值为rm –f
    ARFLAGS         库文件维护程序的选项，无默认值
    ASFLAGS         汇编程序的选项，无默认值
    CFLAGS          C编译器的选项，无默认值
    CPPFLAGS        C预编译的选项，无默认值
    CXXFLAGS        C++编译器的选项，无默认值
    FFLAGS          FORTRAN编译器的选项，无默认值
</code></pre>

<h5>在Makefile中我们可以通过宏定义来控制源程序的编译。</h5>

<p>只要在Makefile中的CFLAGS中通过选项-D来指定你于定义的宏即可。<br/>
如:<br/>
CFLAGS += -D <strong>KK</strong><br/>
或<br/>
CFLAGS += -D <strong>KK</strong>=<strong>XX</strong></p>
]]></content>
  </entry>
  
</feed>
