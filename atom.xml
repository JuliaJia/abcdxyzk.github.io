<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[kk Blog —— 通用基础]]></title>
  <link href="http://abcdxyzk.github.io/atom.xml" rel="self"/>
  <link href="http://abcdxyzk.github.io/"/>
  <updated>2015-04-10T16:02:28+08:00</updated>
  <id>http://abcdxyzk.github.io/</id>
  <author>
    <name><![CDATA[kk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[sk_buff详解]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/04/10/kernel-net-skbuff/"/>
    <updated>2015-04-10T15:46:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/04/10/kernel-net-skbuff</id>
    <content type="html"><![CDATA[<p><a href="http://abcdxyzk.github.io/download/kernel/sk_buff%E8%AF%A6%E8%A7%A3.pdf">sk_buff详解</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux TCP数据包接收处理 tcp_recvmsg]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/04/10/kernel-net-rcvmsg/"/>
    <updated>2015-04-10T15:29:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/04/10/kernel-net-rcvmsg</id>
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/mrpre/article/details/33347221">http://blog.csdn.net/mrpre/article/details/33347221</a></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
<span class='line-number'>206</span>
<span class='line-number'>207</span>
<span class='line-number'>208</span>
<span class='line-number'>209</span>
<span class='line-number'>210</span>
<span class='line-number'>211</span>
<span class='line-number'>212</span>
<span class='line-number'>213</span>
<span class='line-number'>214</span>
<span class='line-number'>215</span>
<span class='line-number'>216</span>
<span class='line-number'>217</span>
<span class='line-number'>218</span>
<span class='line-number'>219</span>
<span class='line-number'>220</span>
<span class='line-number'>221</span>
<span class='line-number'>222</span>
<span class='line-number'>223</span>
<span class='line-number'>224</span>
<span class='line-number'>225</span>
<span class='line-number'>226</span>
<span class='line-number'>227</span>
<span class='line-number'>228</span>
<span class='line-number'>229</span>
<span class='line-number'>230</span>
<span class='line-number'>231</span>
<span class='line-number'>232</span>
<span class='line-number'>233</span>
<span class='line-number'>234</span>
<span class='line-number'>235</span>
<span class='line-number'>236</span>
<span class='line-number'>237</span>
<span class='line-number'>238</span>
<span class='line-number'>239</span>
<span class='line-number'>240</span>
<span class='line-number'>241</span>
<span class='line-number'>242</span>
<span class='line-number'>243</span>
<span class='line-number'>244</span>
<span class='line-number'>245</span>
<span class='line-number'>246</span>
<span class='line-number'>247</span>
<span class='line-number'>248</span>
<span class='line-number'>249</span>
<span class='line-number'>250</span>
<span class='line-number'>251</span>
<span class='line-number'>252</span>
<span class='line-number'>253</span>
<span class='line-number'>254</span>
<span class='line-number'>255</span>
<span class='line-number'>256</span>
<span class='line-number'>257</span>
<span class='line-number'>258</span>
<span class='line-number'>259</span>
<span class='line-number'>260</span>
<span class='line-number'>261</span>
<span class='line-number'>262</span>
<span class='line-number'>263</span>
<span class='line-number'>264</span>
<span class='line-number'>265</span>
<span class='line-number'>266</span>
<span class='line-number'>267</span>
<span class='line-number'>268</span>
<span class='line-number'>269</span>
<span class='line-number'>270</span>
<span class='line-number'>271</span>
<span class='line-number'>272</span>
<span class='line-number'>273</span>
<span class='line-number'>274</span>
<span class='line-number'>275</span>
<span class='line-number'>276</span>
<span class='line-number'>277</span>
<span class='line-number'>278</span>
<span class='line-number'>279</span>
<span class='line-number'>280</span>
<span class='line-number'>281</span>
<span class='line-number'>282</span>
<span class='line-number'>283</span>
<span class='line-number'>284</span>
<span class='line-number'>285</span>
<span class='line-number'>286</span>
<span class='line-number'>287</span>
<span class='line-number'>288</span>
<span class='line-number'>289</span>
<span class='line-number'>290</span>
<span class='line-number'>291</span>
<span class='line-number'>292</span>
<span class='line-number'>293</span>
<span class='line-number'>294</span>
<span class='line-number'>295</span>
<span class='line-number'>296</span>
<span class='line-number'>297</span>
<span class='line-number'>298</span>
<span class='line-number'>299</span>
<span class='line-number'>300</span>
<span class='line-number'>301</span>
<span class='line-number'>302</span>
<span class='line-number'>303</span>
<span class='line-number'>304</span>
<span class='line-number'>305</span>
<span class='line-number'>306</span>
<span class='line-number'>307</span>
<span class='line-number'>308</span>
<span class='line-number'>309</span>
<span class='line-number'>310</span>
<span class='line-number'>311</span>
<span class='line-number'>312</span>
<span class='line-number'>313</span>
<span class='line-number'>314</span>
<span class='line-number'>315</span>
<span class='line-number'>316</span>
<span class='line-number'>317</span>
<span class='line-number'>318</span>
<span class='line-number'>319</span>
<span class='line-number'>320</span>
<span class='line-number'>321</span>
<span class='line-number'>322</span>
<span class='line-number'>323</span>
<span class='line-number'>324</span>
<span class='line-number'>325</span>
<span class='line-number'>326</span>
<span class='line-number'>327</span>
<span class='line-number'>328</span>
<span class='line-number'>329</span>
<span class='line-number'>330</span>
<span class='line-number'>331</span>
<span class='line-number'>332</span>
<span class='line-number'>333</span>
<span class='line-number'>334</span>
<span class='line-number'>335</span>
<span class='line-number'>336</span>
<span class='line-number'>337</span>
<span class='line-number'>338</span>
<span class='line-number'>339</span>
<span class='line-number'>340</span>
<span class='line-number'>341</span>
<span class='line-number'>342</span>
<span class='line-number'>343</span>
<span class='line-number'>344</span>
<span class='line-number'>345</span>
<span class='line-number'>346</span>
<span class='line-number'>347</span>
<span class='line-number'>348</span>
<span class='line-number'>349</span>
<span class='line-number'>350</span>
<span class='line-number'>351</span>
<span class='line-number'>352</span>
<span class='line-number'>353</span>
<span class='line-number'>354</span>
<span class='line-number'>355</span>
<span class='line-number'>356</span>
<span class='line-number'>357</span>
<span class='line-number'>358</span>
<span class='line-number'>359</span>
<span class='line-number'>360</span>
<span class='line-number'>361</span>
<span class='line-number'>362</span>
<span class='line-number'>363</span>
<span class='line-number'>364</span>
<span class='line-number'>365</span>
<span class='line-number'>366</span>
<span class='line-number'>367</span>
<span class='line-number'>368</span>
<span class='line-number'>369</span>
<span class='line-number'>370</span>
<span class='line-number'>371</span>
<span class='line-number'>372</span>
<span class='line-number'>373</span>
<span class='line-number'>374</span>
<span class='line-number'>375</span>
<span class='line-number'>376</span>
<span class='line-number'>377</span>
<span class='line-number'>378</span>
<span class='line-number'>379</span>
<span class='line-number'>380</span>
<span class='line-number'>381</span>
<span class='line-number'>382</span>
<span class='line-number'>383</span>
<span class='line-number'>384</span>
<span class='line-number'>385</span>
<span class='line-number'>386</span>
<span class='line-number'>387</span>
<span class='line-number'>388</span>
<span class='line-number'>389</span>
<span class='line-number'>390</span>
<span class='line-number'>391</span>
<span class='line-number'>392</span>
<span class='line-number'>393</span>
<span class='line-number'>394</span>
<span class='line-number'>395</span>
<span class='line-number'>396</span>
<span class='line-number'>397</span>
<span class='line-number'>398</span>
<span class='line-number'>399</span>
<span class='line-number'>400</span>
<span class='line-number'>401</span>
<span class='line-number'>402</span>
<span class='line-number'>403</span>
<span class='line-number'>404</span>
<span class='line-number'>405</span>
<span class='line-number'>406</span>
<span class='line-number'>407</span>
<span class='line-number'>408</span>
<span class='line-number'>409</span>
<span class='line-number'>410</span>
<span class='line-number'>411</span>
<span class='line-number'>412</span>
<span class='line-number'>413</span>
<span class='line-number'>414</span>
<span class='line-number'>415</span>
<span class='line-number'>416</span>
<span class='line-number'>417</span>
<span class='line-number'>418</span>
<span class='line-number'>419</span>
<span class='line-number'>420</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* 
</span><span class='line'> *    This routine copies from a sock struct into the user buffer.
</span><span class='line'> *
</span><span class='line'> *    Technical note: in 2.3 we work on _locked_ socket, so that
</span><span class='line'> *    tricks with *seq access order and skb-&gt;users are not required.
</span><span class='line'> *    Probably, code can be easily improved even more.
</span><span class='line'> */
</span><span class='line'>
</span><span class='line'>int tcp_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
</span><span class='line'>        size_t len, int nonblock, int flags, int *addr_len)
</span><span class='line'>{
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>    int copied = 0;
</span><span class='line'>    u32 peek_seq;
</span><span class='line'>    u32 *seq;
</span><span class='line'>    unsigned long used;
</span><span class='line'>    int err;
</span><span class='line'>    int target;    /* Read at least this many bytes */
</span><span class='line'>    long timeo;
</span><span class='line'>    struct task_struct *user_recv = NULL;
</span><span class='line'>    int copied_early = 0;
</span><span class='line'>    struct sk_buff *skb;
</span><span class='line'>    u32 urg_hole = 0;
</span><span class='line'>
</span><span class='line'>    //功能：“锁住sk”，并非真正的加锁，而是执行sk-&gt;sk_lock.owned = 1 
</span><span class='line'>    //目的：这样软中断上下文能够通过owned ，判断该sk是否处于进程上下文。
</span><span class='line'>    //提供一种同步机制。
</span><span class='line'>    lock_sock(sk);
</span><span class='line'>
</span><span class='line'>    TCP_CHECK_TIMER(sk);
</span><span class='line'>
</span><span class='line'>    err = -ENOTCONN;
</span><span class='line'>    if (sk-&gt;sk_state == TCP_LISTEN)
</span><span class='line'>        goto out;
</span><span class='line'>
</span><span class='line'>    //获取延迟，如果用户设置为非阻塞，那么timeo ==0000 0000 0000 0000
</span><span class='line'>    //如果用户使用默认recv系统调用
</span><span class='line'>    //则为阻塞，此时timeo ==0111 1111 1111 1111
</span><span class='line'>    //timeo 就2个值
</span><span class='line'>    timeo = sock_rcvtimeo(sk, nonblock);
</span><span class='line'>
</span><span class='line'>    /* Urgent data needs to be handled specially. */
</span><span class='line'>    if (flags & MSG_OOB)
</span><span class='line'>        goto recv_urg;
</span><span class='line'>
</span><span class='line'>    //待拷贝的下一个序列号
</span><span class='line'>    seq = &tp-&gt;copied_seq;
</span><span class='line'>
</span><span class='line'>    //设置了MSG_PEEK，表示不让数据从缓冲区移除，目的是下一次调用recv函数
</span><span class='line'>    //仍然能够读到相同数据
</span><span class='line'>    if (flags & MSG_PEEK) {
</span><span class='line'>        peek_seq = tp-&gt;copied_seq;
</span><span class='line'>        seq = &peek_seq;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    //如果设置了MSG_WAITALL，则target  ==len，即recv函数中的参数len
</span><span class='line'>    //如果没设置MSG_WAITALL，则target  == 1
</span><span class='line'>    target = sock_rcvlowat(sk, flags & MSG_WAITALL, len);
</span><span class='line'>
</span><span class='line'>    //大循环
</span><span class='line'>    do {
</span><span class='line'>        u32 offset;
</span><span class='line'>
</span><span class='line'>        /* Are we at urgent data? Stop if we have read anything or have SIGURG pending. */
</span><span class='line'>        if (tp-&gt;urg_data && tp-&gt;urg_seq == *seq) {
</span><span class='line'>            if (copied)
</span><span class='line'>                break;
</span><span class='line'>            if (signal_pending(current)) {
</span><span class='line'>                copied = timeo ? sock_intr_errno(timeo) : -EAGAIN;
</span><span class='line'>                break;
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        /* Next get a buffer. */
</span><span class='line'>
</span><span class='line'>        //小循环
</span><span class='line'>        skb_queue_walk(&sk-&gt;sk_receive_queue, skb) {
</span><span class='line'>            /* Now that we have two receive queues this
</span><span class='line'>                * shouldn't happen.
</span><span class='line'>                */
</span><span class='line'>            if (WARN(before(*seq, TCP_SKB_CB(skb)-&gt;seq),
</span><span class='line'>                                KERN_INFO "recvmsg bug: copied %X "
</span><span class='line'>                                          "seq %X rcvnxt %X fl %X\n", *seq,
</span><span class='line'>                                          TCP_SKB_CB(skb)-&gt;seq, tp-&gt;rcv_nxt,
</span><span class='line'>                                          flags))
</span><span class='line'>                break;
</span><span class='line'>
</span><span class='line'>            //如果用户的缓冲区(即用户malloc的buf)长度够大，offset一般是0。
</span><span class='line'>            //即 “下次准备拷贝数据的序列号”==此时获取报文的起始序列号
</span><span class='line'>            //什么情况下offset &gt;0呢？很简答，如果用户缓冲区12字节，而这个skb有120字节
</span><span class='line'>            //那么一次recv系统调用，只能获取skb中的前12个字节，下一次执行recv系统调用
</span><span class='line'>            //offset就是12了，offset表示从第12个字节开始读取数据，前12个字节已经读取了。
</span><span class='line'>            //那这个"已经读取12字节"这个消息，存在哪呢？
</span><span class='line'>            //在*seq = &tp-&gt;copied_seq;中
</span><span class='line'>            offset = *seq - TCP_SKB_CB(skb)-&gt;seq;
</span><span class='line'>            if (tcp_hdr(skb)-&gt;syn)
</span><span class='line'>                offset--;
</span><span class='line'>            if (offset &lt; skb-&gt;len)
</span><span class='line'>                goto found_ok_skb;
</span><span class='line'>            if (tcp_hdr(skb)-&gt;fin)
</span><span class='line'>                goto found_fin_ok;
</span><span class='line'>            WARN(!(flags & MSG_PEEK), KERN_INFO "recvmsg bug 2: "
</span><span class='line'>                    "copied %X seq %X rcvnxt %X fl %X\n",
</span><span class='line'>                    *seq, TCP_SKB_CB(skb)-&gt;seq,
</span><span class='line'>                    tp-&gt;rcv_nxt, flags);
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        //执行到了这里，表明小循环中break了，既然break了，说明sk_receive_queue中
</span><span class='line'>        //已经没有skb可以读取了
</span><span class='line'>        //如果没有执行到这里说明前面的小循环中执行了goto，读到有用的skb，或者读到fin都会goto。
</span><span class='line'>        //没有skb可以读取，说明什么？
</span><span class='line'>        //可能性1：当用户第一次调用recv时，压根没有数据到来
</span><span class='line'>        //可能性2：skb-&gt;len一共20字节，假设用户调用一次 recv，读取12字节，再调用recv，
</span><span class='line'>        //读取12字节，此时skb由于上次已经被读取了12字节，只剩下8字节。
</span><span class='line'>        //于是代码的逻辑上，再会要求获取skb，来读取剩下的8字节。
</span><span class='line'>
</span><span class='line'>        //可能性1的情况下，copied == 0，肯定不会进这个if。后续将执行休眠
</span><span class='line'>        //可能性2的情况下，情况比较复杂。可能性2表明数据没有读够用户想要的len长度
</span><span class='line'>        //虽然进程上下文中，没有读够数据，但是可能我们在读数据的时候
</span><span class='line'>        //软中断把数据放到backlog队列中了，而backlog对队列中的数据或许恰好让我们读够数
</span><span class='line'>        //据。
</span><span class='line'>
</span><span class='line'>        //copied了数据的，copied肯定&gt;=1，而target 是1或者len
</span><span class='line'>        //copied只能取0(可能性1)，或者0~len(可能性2)
</span><span class='line'>        //copied &gt;= target 表示我们取得我们想要的数据了，何必进行休眠，直接return
</span><span class='line'>        //如果copied 没有达到我们想要的数据，则看看sk_backlog是否为空
</span><span class='line'>        //空的话，尽力了，只能尝试休眠
</span><span class='line'>        //非空的话，还有一线希望，我们去sk_backlog找找数据，看看是否能够达到我们想要的
</span><span class='line'>        //数据大小
</span><span class='line'>
</span><span class='line'>        //我觉得copied == target是会出现的，但是出现的话，也不会进现在这个流程
</span><span class='line'>        //，如有不对，请各位大神指正，告诉我
</span><span class='line'>        //说明情况下copied == target
</span><span class='line'>
</span><span class='line'>        /* Well, if we have backlog, try to process it now yet. */
</span><span class='line'>        if (copied &gt;= target && !sk-&gt;sk_backlog.tail)
</span><span class='line'>            break;
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>        if (copied) {
</span><span class='line'>            //可能性2，拷贝了数据，但是没有拷贝到指定大小
</span><span class='line'>            if (sk-&gt;sk_err ||
</span><span class='line'>                            sk-&gt;sk_state == TCP_CLOSE ||
</span><span class='line'>                            (sk-&gt;sk_shutdown & RCV_SHUTDOWN) ||
</span><span class='line'>                            !timeo ||
</span><span class='line'>                            signal_pending(current))
</span><span class='line'>                break;
</span><span class='line'>        } else {
</span><span class='line'>            //可能性1
</span><span class='line'>            if (sock_flag(sk, SOCK_DONE))
</span><span class='line'>                break;
</span><span class='line'>
</span><span class='line'>            if (sk-&gt;sk_err) {
</span><span class='line'>                copied = sock_error(sk);
</span><span class='line'>                break;
</span><span class='line'>            }
</span><span class='line'>
</span><span class='line'>            if (sk-&gt;sk_shutdown & RCV_SHUTDOWN)
</span><span class='line'>                break;
</span><span class='line'>
</span><span class='line'>            if (sk-&gt;sk_state == TCP_CLOSE) {
</span><span class='line'>                if (!sock_flag(sk, SOCK_DONE)) {
</span><span class='line'>                    /* This occurs when user tries to read
</span><span class='line'>                        * from never connected socket.
</span><span class='line'>                        */
</span><span class='line'>                    copied = -ENOTCONN;
</span><span class='line'>                    break;
</span><span class='line'>                }
</span><span class='line'>                break;
</span><span class='line'>            }
</span><span class='line'>
</span><span class='line'>            //是否是阻塞的，不是，就return了。
</span><span class='line'>            if (!timeo) {
</span><span class='line'>                copied = -EAGAIN;
</span><span class='line'>                break;
</span><span class='line'>            }
</span><span class='line'>
</span><span class='line'>            if (signal_pending(current)) {
</span><span class='line'>                copied = sock_intr_errno(timeo);
</span><span class='line'>                break;
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        tcp_cleanup_rbuf(sk, copied);
</span><span class='line'>
</span><span class='line'>        //sysctl_tcp_low_latency 默认0tp-&gt;ucopy.task == user_recv肯定也成立
</span><span class='line'>
</span><span class='line'>        if (!sysctl_tcp_low_latency && tp-&gt;ucopy.task == user_recv) {
</span><span class='line'>            /* Install new reader */
</span><span class='line'>            if (!user_recv && !(flags & (MSG_TRUNC | MSG_PEEK))) {
</span><span class='line'>                user_recv = current;
</span><span class='line'>                tp-&gt;ucopy.task = user_recv;
</span><span class='line'>                tp-&gt;ucopy.iov = msg-&gt;msg_iov;
</span><span class='line'>            }
</span><span class='line'>
</span><span class='line'>            tp-&gt;ucopy.len = len;
</span><span class='line'>
</span><span class='line'>            WARN_ON(tp-&gt;copied_seq != tp-&gt;rcv_nxt &&
</span><span class='line'>                !(flags & (MSG_PEEK | MSG_TRUNC)));
</span><span class='line'>
</span><span class='line'>            /* Ugly... If prequeue is not empty, we have to
</span><span class='line'>                * process it before releasing socket, otherwise
</span><span class='line'>                * order will be broken at second iteration.
</span><span class='line'>                * More elegant solution is required!!!
</span><span class='line'>                *
</span><span class='line'>                * Look: we have the following (pseudo)queues:
</span><span class='line'>                *
</span><span class='line'>                * 1. packets in flight
</span><span class='line'>                * 2. backlog
</span><span class='line'>                * 3. prequeue
</span><span class='line'>                * 4. receive_queue
</span><span class='line'>                *
</span><span class='line'>                * Each queue can be processed only if the next ones
</span><span class='line'>                * are empty. At this point we have empty receive_queue.
</span><span class='line'>                * But prequeue _can_ be not empty after 2nd iteration,
</span><span class='line'>                * when we jumped to start of loop because backlog
</span><span class='line'>                * processing added something to receive_queue.
</span><span class='line'>                * We cannot release_sock(), because backlog contains
</span><span class='line'>                * packets arrived _after_ prequeued ones.
</span><span class='line'>                *
</span><span class='line'>                * Shortly, algorithm is clear --- to process all
</span><span class='line'>                * the queues in order. We could make it more directly,
</span><span class='line'>                * requeueing packets from backlog to prequeue, if
</span><span class='line'>                * is not empty. It is more elegant, but eats cycles,
</span><span class='line'>                * unfortunately.
</span><span class='line'>                */
</span><span class='line'>
</span><span class='line'>            if (!skb_queue_empty(&tp-&gt;ucopy.prequeue))
</span><span class='line'>                goto do_prequeue;
</span><span class='line'>
</span><span class='line'>            /* __ Set realtime policy in scheduler __ */
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        if (copied &gt;= target) {
</span><span class='line'>            /* Do not sleep, just process backlog. */
</span><span class='line'>            release_sock(sk);
</span><span class='line'>            lock_sock(sk);
</span><span class='line'>        } else
</span><span class='line'>                    sk_wait_data(sk, &timeo); 
</span><span class='line'>        //在此处睡眠了，将在tcp_prequeue函数中调用wake_up_interruptible_poll唤醒
</span><span class='line'>        
</span><span class='line'>        //软中断会判断用户是正在读取检查并且睡眠了，如果是的话，就直接把数据拷贝
</span><span class='line'>        //到prequeue队列，然后唤醒睡眠的进程。因为进程睡眠，表示没有读到想要的字节数
</span><span class='line'>        //此时，软中断有数据到来，直接给进程，这样进程就能以最快的速度被唤醒。
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>        if (user_recv) {
</span><span class='line'>            int chunk;
</span><span class='line'>
</span><span class='line'>            /* __ Restore normal policy in scheduler __ */
</span><span class='line'>
</span><span class='line'>            if ((chunk = len - tp-&gt;ucopy.len) != 0) {
</span><span class='line'>                NET_ADD_STATS_USER(sock_net(sk), LINUX_MIB_TCPDIRECTCOPYFROMBACKLOG, chunk);
</span><span class='line'>                len -= chunk;
</span><span class='line'>                copied += chunk;
</span><span class='line'>            }
</span><span class='line'>
</span><span class='line'>            if (tp-&gt;rcv_nxt == tp-&gt;copied_seq &&
</span><span class='line'>                            !skb_queue_empty(&tp-&gt;ucopy.prequeue)) {
</span><span class='line'>do_prequeue:
</span><span class='line'>                tcp_prequeue_process(sk);
</span><span class='line'>
</span><span class='line'>                if ((chunk = len - tp-&gt;ucopy.len) != 0) {
</span><span class='line'>                    NET_ADD_STATS_USER(sock_net(sk), LINUX_MIB_TCPDIRECTCOPYFROMPREQUEUE, chunk);
</span><span class='line'>                    len -= chunk;
</span><span class='line'>                    copied += chunk;
</span><span class='line'>                }
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>        if ((flags & MSG_PEEK) &&
</span><span class='line'>                        (peek_seq - copied - urg_hole != tp-&gt;copied_seq)) {
</span><span class='line'>            if (net_ratelimit())
</span><span class='line'>                printk(KERN_DEBUG "TCP(%s:%d): Application bug, race in MSG_PEEK.\n",
</span><span class='line'>                                          current-&gt;comm, task_pid_nr(current));
</span><span class='line'>            peek_seq = tp-&gt;copied_seq;
</span><span class='line'>        }
</span><span class='line'>        continue;
</span><span class='line'>
</span><span class='line'>    found_ok_skb:
</span><span class='line'>        /* Ok so how much can we use? */
</span><span class='line'>        //skb中还有多少聚聚没有拷贝。
</span><span class='line'>        //正如前面所说的，offset是上次已经拷贝了的，这次从offset开始接下去拷贝
</span><span class='line'>                used = skb-&gt;len - offset;
</span><span class='line'>        //很有可能used的大小，即skb剩余长度，依然大于用户的缓冲区大小(len)。所以依然
</span><span class='line'>        //只能拷贝len长度。一般来说，用户还得执行一次recv系统调用。直到skb中的数据读完
</span><span class='line'>        if (len &lt; used)
</span><span class='line'>            used = len;
</span><span class='line'>
</span><span class='line'>        /* Do we have urgent data here? */
</span><span class='line'>        if (tp-&gt;urg_data) {
</span><span class='line'>            u32 urg_offset = tp-&gt;urg_seq - *seq;
</span><span class='line'>            if (urg_offset &lt; used) {
</span><span class='line'>                if (!urg_offset) {
</span><span class='line'>                    if (!sock_flag(sk, SOCK_URGINLINE)) {
</span><span class='line'>                        ++*seq;
</span><span class='line'>                        urg_hole++;
</span><span class='line'>                        offset++;
</span><span class='line'>                        used--;
</span><span class='line'>                        if (!used)
</span><span class='line'>                            goto skip_copy;
</span><span class='line'>                    }
</span><span class='line'>                } else
</span><span class='line'>                    used = urg_offset;
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        if (!(flags & MSG_TRUNC)) {
</span><span class='line'>            {
</span><span class='line'>                //一般都会进这个if，进行数据的拷贝，把能够读到的数据，放到用户的缓冲区
</span><span class='line'>                err = skb_copy_datagram_iovec(skb, offset,
</span><span class='line'>                        msg-&gt;msg_iov, used);
</span><span class='line'>                if (err) {
</span><span class='line'>                    /* Exception. Bailout! */
</span><span class='line'>                    if (!copied)
</span><span class='line'>                        copied = -EFAULT;
</span><span class='line'>                    break;
</span><span class='line'>                }
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        //更新标志位，seq 是指针，指向了tp-&gt;copied_seq
</span><span class='line'>        //used是我们有能力拷贝的数据大小，即已经拷贝到用户缓冲区的大小
</span><span class='line'>        //正如前面所说，如果用户的缓冲区很小，一次recv拷贝不玩skb中的数据，
</span><span class='line'>        //我们需要保存已经拷贝了的大小，下次recv时，从这个大小处继续拷贝。
</span><span class='line'>        //所以需要更新copied_seq。
</span><span class='line'>        *seq += used;
</span><span class='line'>        copied += used;
</span><span class='line'>        len -= used;
</span><span class='line'>
</span><span class='line'>        tcp_rcv_space_adjust(sk);
</span><span class='line'>
</span><span class='line'>skip_copy:
</span><span class='line'>        if (tp-&gt;urg_data && after(tp-&gt;copied_seq, tp-&gt;urg_seq)) {
</span><span class='line'>            tp-&gt;urg_data = 0;
</span><span class='line'>            tcp_fast_path_check(sk);
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        //这个就是判断我们是否拷贝完了skb中的数据，如果没有continue
</span><span class='line'>        //这种情况下，len经过 len -= used; ，已经变成0，所以continue的效果相当于
</span><span class='line'>        //退出了这个大循环。可以理解，你只能拷贝len长度，拷贝完之后，那就return了。
</span><span class='line'>
</span><span class='line'>        //还有一种情况used + offset ==  skb-&gt;len，表示skb拷贝完了。这时我们只需要释放skb
</span><span class='line'>        //下面会讲到
</span><span class='line'>        if (used + offset &lt; skb-&gt;len)
</span><span class='line'>            continue;
</span><span class='line'>
</span><span class='line'>        //看看这个数据报文是否含有fin，含有fin，则goto到found_fin_ok
</span><span class='line'>        if (tcp_hdr(skb)-&gt;fin)
</span><span class='line'>            goto found_fin_ok;
</span><span class='line'>
</span><span class='line'>        //执行到这里，标明used + offset ==  skb-&gt;len，报文也拷贝完了，那就把skb摘链释放
</span><span class='line'>        if (!(flags & MSG_PEEK)) {
</span><span class='line'>            sk_eat_skb(sk, skb, copied_early);
</span><span class='line'>            copied_early = 0;
</span><span class='line'>        }
</span><span class='line'>        //这个cintinue不一定是退出大循环，可能还会执行循环。
</span><span class='line'>        //假设用户设置缓冲区12字节，你skb-&gt;len长度20字节。
</span><span class='line'>        //第一次recv读取了12字节，skb剩下8，下一次调用recv再想读取12，
</span><span class='line'>        //但是只能读取到这8字节了。
</span><span class='line'>        //此时len 变量长度为4，那么这个continue依旧在这个循环中，
</span><span class='line'>        //函数还是再次从do开始，使用skb_queue_walk，找skb
</span><span class='line'>        //如果sk_receive_queue中skb仍旧有，那么继续读，直到len == 0
</span><span class='line'>        //如果没有skb了，我们怎么办？我们的len还有4字节怎么办？
</span><span class='line'>        //这得看用户设置的recv函数阻塞与否，即和timeo变量相关了。
</span><span class='line'>        continue;
</span><span class='line'>
</span><span class='line'>    found_fin_ok:
</span><span class='line'>        /* Process the FIN. */
</span><span class='line'>        ++*seq;
</span><span class='line'>        if (!(flags & MSG_PEEK)) {
</span><span class='line'>            //把skb从sk_receive_queue中摘链
</span><span class='line'>            sk_eat_skb(sk, skb, copied_early);
</span><span class='line'>            copied_early = 0;
</span><span class='line'>        }
</span><span class='line'>        break;
</span><span class='line'>    } while (len &gt; 0);
</span><span class='line'>
</span><span class='line'>    //到这里是大循环退出
</span><span class='line'>    //休眠过的进程，然后退出大循环 ，才满足 if (user_recv) 条件
</span><span class='line'>    if (user_recv) {
</span><span class='line'>        if (!skb_queue_empty(&tp-&gt;ucopy.prequeue)) {
</span><span class='line'>            int chunk;
</span><span class='line'>
</span><span class='line'>            tp-&gt;ucopy.len = copied &gt; 0 ? len : 0;
</span><span class='line'>
</span><span class='line'>            tcp_prequeue_process(sk);
</span><span class='line'>
</span><span class='line'>            if (copied &gt; 0 && (chunk = len - tp-&gt;ucopy.len) != 0) {
</span><span class='line'>                NET_ADD_STATS_USER(sock_net(sk), LINUX_MIB_TCPDIRECTCOPYFROMPREQUEUE, chunk);
</span><span class='line'>                len -= chunk;
</span><span class='line'>                copied += chunk;
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        //数据读取完毕，清零
</span><span class='line'>        tp-&gt;ucopy.task = NULL;
</span><span class='line'>        tp-&gt;ucopy.len = 0;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /* According to UNIX98, msg_name/msg_namelen are ignored
</span><span class='line'>        * on connected socket. I was just happy when found this 8) --ANK
</span><span class='line'>        */
</span><span class='line'>
</span><span class='line'>    /* Clean up data we have read: This will do ACK frames. */
</span><span class='line'>    //很重要，将更新缓存，并且适当的时候发送ack
</span><span class='line'>    tcp_cleanup_rbuf(sk, copied);
</span><span class='line'>
</span><span class='line'>    TCP_CHECK_TIMER(sk);
</span><span class='line'>    release_sock(sk);
</span><span class='line'>    return copied;
</span><span class='line'>
</span><span class='line'>out:
</span><span class='line'>    TCP_CHECK_TIMER(sk);
</span><span class='line'>    release_sock(sk);
</span><span class='line'>    return err;
</span><span class='line'>
</span><span class='line'>recv_urg:
</span><span class='line'>    err = tcp_recv_urg(sk, msg, len, flags);
</span><span class='line'>    goto out;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux TCP数据包接收处理 tcp_v4_rcv]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/04/10/kernel-net-v4rcv/"/>
    <updated>2015-04-10T15:23:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/04/10/kernel-net-v4rcv</id>
    <content type="html"><![CDATA[<p><a href="http://blog.sina.com.cn/s/blog_52355d840100b6sd.html">http://blog.sina.com.cn/s/blog_52355d840100b6sd.html</a></p>

<h4>tcp_v4_rcv函数</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int tcp_v4_rcv(struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>    const struct iphdr *iph;
</span><span class='line'>    struct tcphdr *th;
</span><span class='line'>    struct sock *sk;
</span><span class='line'>    int ret;
</span><span class='line'>      
</span><span class='line'>    //如果不是发往本地的数据包，则直接丢弃
</span><span class='line'>    if (skb-&gt;pkt_type != PACKET_HOST)
</span><span class='line'>        goto discard_it;
</span><span class='line'>
</span><span class='line'>    TCP_INC_STATS_BH(TCP_MIB_INSEGS);
</span><span class='line'>
</span><span class='line'>    //包长是否大于TCP头的长度
</span><span class='line'>    if (!pskb_may_pull(skb, sizeof(struct tcphdr)))
</span><span class='line'>        goto discard_it;
</span><span class='line'>
</span><span class='line'>    //取得TCP首部
</span><span class='line'>    th = tcp_hdr(skb);
</span><span class='line'>
</span><span class='line'>    //检查TCP首部的长度和TCP首部中的doff字段是否匹配
</span><span class='line'>    if (th-&gt;doff &lt; sizeof(struct tcphdr) / 4)
</span><span class='line'>        goto bad_packet;
</span><span class='line'>
</span><span class='line'>    //检查TCP首部到TCP数据之间的偏移是否越界
</span><span class='line'>    if (!pskb_may_pull(skb, th-&gt;doff * 4))
</span><span class='line'>        goto discard_it;
</span><span class='line'>
</span><span class='line'>    if (!skb_csum_unnecessary(skb) && tcp_v4_checksum_init(skb))
</span><span class='line'>        goto bad_packet;
</span><span class='line'>
</span><span class='line'>     th = tcp_hdr(skb);
</span><span class='line'>    iph = ip_hdr(skb);
</span><span class='line'>    TCP_SKB_CB(skb)-&gt;seq = ntohl(th-&gt;seq);
</span><span class='line'>
</span><span class='line'>    //计算end_seq,实际上，end_seq是数据包的结束序列号，实际上是期待TCP确认
</span><span class='line'>    //包中ACK的数值，在数据传输过程中，确认包ACK的数值等于本次数据包SEQ
</span><span class='line'>    //号加上本数据包的有效载荷，即skb-&gt;len - th-&gt;doff * 4,但是在处理SYN报文或者
</span><span class='line'>    //FIN报文的时候，确认包的ACK等于本次处理数据包的SEQ+1,考虑到这种情况，
</span><span class='line'>    //期待下一个数据包的ACK就变成了TCP_SKB_CB(skb)-&gt;seq + th-&gt;syn + th-&gt;fin +
</span><span class='line'>    //skb-&gt;len - th-&gt;doff * 4
</span><span class='line'>
</span><span class='line'>    // TCP_SKB_CB宏会返回skb-&gt;cb[0],一个类型为tcp_skb_cb的结构指针，这个结
</span><span class='line'>    //构保存了TCP首部选项和其他的一些状态信息
</span><span class='line'>
</span><span class='line'>    TCP_SKB_CB(skb)-&gt;end_seq = (TCP_SKB_CB(skb)-&gt;seq + th-&gt;syn + th-&gt;fin +
</span><span class='line'>                    skb-&gt;len - th-&gt;doff * 4);
</span><span class='line'>    TCP_SKB_CB(skb)-&gt;ack_seq = ntohl(th-&gt;ack_seq);
</span><span class='line'>    TCP_SKB_CB(skb)-&gt;when   = 0;
</span><span class='line'>    TCP_SKB_CB(skb)-&gt;flags    = iph-&gt;tos;
</span><span class='line'>    TCP_SKB_CB(skb)-&gt;sacked = 0;
</span><span class='line'>
</span><span class='line'>    //根据四元组查找相应连接的sock结构，大体有两个步骤，
</span><span class='line'>    //首先用__inet_lookup_established函数查找已经处于establish状态的连接，
</span><span class='line'>    //如果查找不到的话，就调用__inet_lookup_listener函数查找是否存在四元组相
</span><span class='line'>    //匹配的处于listen状态的sock,这个时候实际上是被动的接收来自其他主机的连接
</span><span class='line'>    //请求
</span><span class='line'>
</span><span class='line'>    //如果查找不到匹配的sock,则直接丢弃数据包
</span><span class='line'>    sk = __inet_lookup(&tcp_hashinfo, iph-&gt;saddr, th-&gt;source,
</span><span class='line'>               iph-&gt;daddr, th-&gt;dest, inet_iif(skb));
</span><span class='line'>    if (!sk)
</span><span class='line'>        goto no_tcp_socket;
</span><span class='line'>
</span><span class='line'>    //检查sock是否处于半关闭状态
</span><span class='line'>    process:
</span><span class='line'>    if (sk-&gt;sk_state == TCP_TIME_WAIT)
</span><span class='line'>        goto do_time_wait;
</span><span class='line'> 
</span><span class='line'>    //检查IPSEC规则
</span><span class='line'>    if (!xfrm4_policy_check(sk, XFRM_POLICY_IN, skb))
</span><span class='line'>        goto discard_and_relse;
</span><span class='line'>    nf_reset(skb);
</span><span class='line'>
</span><span class='line'>    //检查BPF规则
</span><span class='line'>    if (sk_filter(sk, skb))
</span><span class='line'>        goto discard_and_relse;
</span><span class='line'>
</span><span class='line'>    skb-&gt;dev = NULL;
</span><span class='line'>
</span><span class='line'>    //这里主要是和release_sock函数实现互斥，release_sock中调用了
</span><span class='line'>    // spin_lock_bh(&sk-&gt;sk_lock.slock);
</span><span class='line'>    bh_lock_sock_nested(sk);
</span><span class='line'>    ret = 0;
</span><span class='line'>
</span><span class='line'>    //查看是否有用户态进程对该sock进行了锁定
</span><span class='line'>    //如果sock_owned_by_user为真，则sock的状态不能进行更改
</span><span class='line'>    if (!sock_owned_by_user(sk)) {
</span><span class='line'>
</span><span class='line'>#ifdef CONFIG_NET_DMA
</span><span class='line'>        struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>        if (!tp-&gt;ucopy.dma_chan && tp-&gt;ucopy.pinned_list)
</span><span class='line'>            tp-&gt;ucopy.dma_chan = get_softnet_dma();
</span><span class='line'>        if (tp-&gt;ucopy.dma_chan)
</span><span class='line'>            ret = tcp_v4_do_rcv(sk, skb);
</span><span class='line'>        else
</span><span class='line'>#endif
</span><span class='line'>        {
</span><span class='line'>            //进入预备处理队列
</span><span class='line'>            if (!tcp_prequeue(sk, skb))
</span><span class='line'>                ret = tcp_v4_do_rcv(sk, skb);
</span><span class='line'>        }
</span><span class='line'>    } else
</span><span class='line'>        //如果数据包被用户进程锁定，则数据包进入后备处理队列，并且该进程进入
</span><span class='line'>        //套接字的后备处理等待队列sk-&gt;lock.wq
</span><span class='line'>        sk_add_backlog(sk, skb);
</span><span class='line'>    bh_unlock_sock(sk);
</span><span class='line'>
</span><span class='line'>    sock_put(sk);
</span><span class='line'>    return ret;
</span><span class='line'>
</span><span class='line'>no_tcp_socket:
</span><span class='line'>    if (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb))
</span><span class='line'>        goto discard_it;
</span><span class='line'>
</span><span class='line'>    if (skb-&gt;len &lt; (th-&gt;doff &lt;&lt; 2) || tcp_checksum_complete(skb)) {
</span><span class='line'>bad_packet:
</span><span class='line'>        TCP_INC_STATS_BH(TCP_MIB_INERRS);
</span><span class='line'>    } else {
</span><span class='line'>        tcp_v4_send_reset(NULL, skb);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>discard_it:
</span><span class='line'>    kfree_skb(skb);
</span><span class='line'>    return 0;
</span><span class='line'>
</span><span class='line'>discard_and_relse:
</span><span class='line'>    sock_put(sk);
</span><span class='line'>    goto discard_it;
</span><span class='line'>
</span><span class='line'>do_time_wait:
</span><span class='line'>    if (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb)) {
</span><span class='line'>        inet_twsk_put(inet_twsk(sk));
</span><span class='line'>        goto discard_it;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    if (skb-&gt;len &lt; (th-&gt;doff &lt;&lt; 2) || tcp_checksum_complete(skb)) {
</span><span class='line'>        TCP_INC_STATS_BH(TCP_MIB_INERRS);
</span><span class='line'>        inet_twsk_put(inet_twsk(sk));
</span><span class='line'>        goto discard_it;
</span><span class='line'>    }
</span><span class='line'>    switch (tcp_timewait_state_process(inet_twsk(sk), skb, th)) {
</span><span class='line'>    case TCP_TW_SYN: {
</span><span class='line'>        struct sock *sk2 = inet_lookup_listener(&tcp_hashinfo,
</span><span class='line'>                            iph-&gt;daddr, th-&gt;dest,
</span><span class='line'>                            inet_iif(skb));
</span><span class='line'>        if (sk2) {
</span><span class='line'>            inet_twsk_deschedule(inet_twsk(sk), &tcp_death_row);
</span><span class='line'>            inet_twsk_put(inet_twsk(sk));
</span><span class='line'>            sk = sk2;
</span><span class='line'>            goto process;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    case TCP_TW_ACK:
</span><span class='line'>        tcp_v4_timewait_ack(sk, skb);
</span><span class='line'>        break;
</span><span class='line'>    case TCP_TW_RST:
</span><span class='line'>        goto no_tcp_socket;
</span><span class='line'>    case TCP_TW_SUCCESS:;
</span><span class='line'>    }
</span><span class='line'>    goto discard_it;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SYN cookies机制下连接的建立]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/04/10/kernel-net-syncookie/"/>
    <updated>2015-04-10T14:34:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/04/10/kernel-net-syncookie</id>
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/justlinux2010/article/details/12619761">http://blog.csdn.net/justlinux2010/article/details/12619761</a></p>

<p>  在正常情况下，服务器端接收到客户端发送的SYN包，会分配一个连接请求块（即request_sock结构），用于保存连接请求信息，并且发送SYN+ACK包给客户端，然后将连接请求块添加到半连接队列中。客户端接收到SYN+ACK包后，会发送ACK包对服务器端的包进行确认。服务器端收到客户端的确认后，根据保存的连接信息，构建一个新的连接，放到监听套接字的连接队列中，等待用户层accept连接。这是正常的情况，但是在并发过高或者遭受SYN flood攻击的情况下，半连接队列的槽位数量很快就会耗尽，会导致丢弃新的连接请求，SYN cookies技术可以使服务器在半连接队列已满的情况下仍能处理新的SYN请求。</p>

<p>  如果开启了SYN cookies选项，在半连接队列满时，SYN cookies并不丢弃SYN请求，而是将源目的IP、源目的端口号、接收到的客户端初始序列号以及其他一些安全数值等信息进行hash运算，并加密后得到服务器端的初始序列号，称之为cookie。服务器端在发送初始序列号为cookie的SYN+ACK包后，会将分配的连接请求块释放。如果接收到客户端的ACK包，服务器端将客户端的ACK序列号减1得到的值，与上述要素hash运算得到的值比较，如果相等，直接完成三次握手，构建新的连接。SYN cookies机制的核心就是避免攻击造成的大量构造无用的连接请求块，导致内存耗尽，而无法处理正常的连接请求。</p>

<p>  启用SYN cookies是通过在启动环境中设置以下命令完成：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>echo 1 &gt; /proc/sys/net/ipv4/tcp_syncookies</span></code></pre></td></tr></table></div></figure>


<p>  注意，即使开启该机制并不意味着所有的连接都是用SYN cookies机制来完成连接的建立，只有在半连接队列已满的情况下才会触发SYN cookies机制。由于SYN cookies机制严重违背TCP协议，不允许使用TCP扩展，可能对某些服务造成严重的性能影响（如SMTP转发），对于防御SYN flood攻击的确有效。对于没有收到攻击的高负载服务器，不要开启此选项，可以通过修改tcp_max_syn_backlog、tcp_synack_retries和tcp_abort_on_overflow系统参数来调节。</p>

<p>下面来看看内核中是怎么通过SYN cookie机制来完成连接的建立。</p>

<p>  客户端的连接请求由</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>tcp_v4_do_rcv()
</span><span class='line'>    tcp_rcv_state_process()
</span><span class='line'>        icsk-&gt;icsk_af_ops-&gt;conn_request()
</span><span class='line'>            tcp_v4_conn_request()</span></code></pre></td></tr></table></div></figure>


<p>函数处理。tcp_v4_conn_request()中有一个局部变量want_cookie，用来标识是否使用SYN cookies机制。want_cookie的初始值为0，如果半连接队列已满，并且开启了tcp_syncookies系统参数，则将其值设置为1，如下所示：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int tcp_v4_conn_request(struct sock *sk, struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>#ifdef CONFIG_SYN_COOKIES
</span><span class='line'>    int want_cookie = 0;
</span><span class='line'>#else
</span><span class='line'>#define want_cookie 0 /* Argh, why doesn't gcc optimize this :( */
</span><span class='line'>#endif
</span><span class='line'>
</span><span class='line'>...... 
</span><span class='line'>
</span><span class='line'>    /* TW buckets are converted to open requests without
</span><span class='line'>     * limitations, they conserve resources and peer is
</span><span class='line'>     * evidently real one.
</span><span class='line'>     */
</span><span class='line'>    if (inet_csk_reqsk_queue_is_full(sk) && !isn) {
</span><span class='line'>#ifdef CONFIG_SYN_COOKIES
</span><span class='line'>        if (sysctl_tcp_syncookies) {
</span><span class='line'>            want_cookie = 1;
</span><span class='line'>        } else
</span><span class='line'>#endif
</span><span class='line'>       
</span><span class='line'>        goto drop;
</span><span class='line'>    }
</span><span class='line'>......
</span><span class='line'>
</span><span class='line'>drop:
</span><span class='line'>    return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>  如果没有开启SYN cookies机制，在半连接队列满时，会跳转到drop处，返回0。在调用tcp_v4_conn_request()的tcp_rcv_state_process()中会直接释放SKB包。</p>

<p>  我们前面提高过，造成半连接队列满有两种情况（不考虑半连接队列很小的情况），一种是负载过高，正常的连接数过多；另一种是SYN flood攻击。如果是第一种情况，此时是否继续构建连接，则要取决于连接队列的情况及半连接队列的重传情况，如下所示：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (sk_acceptq_is_full(sk) && inet_csk_reqsk_queue_young(sk) &gt; 1)
</span><span class='line'>    goto drop;</span></code></pre></td></tr></table></div></figure>


<p>  sk_acceptq_is_full()函数很好理解，根据字面意思就可以看出，该函数是检查连接队列是否已满。inet_csk_reqsk_queue_young()函数返回半连接队列中未重传过SYN+ACK段的连接请求块数量。如果连接队列已满并且半连接队列中的连接请求块中未重传的数量大于1，则会跳转到drop处，丢弃SYN包。如果半连接队列中未重传的请求块数量大于1，则表示未来可能有2个完成的连接，这些新完成的连接要放到连接队列中，但此时连接队列已满。如果在接收到三次握手中最后的ACK后连接队列中没有空闲的位置，会忽略接收到的ACK包，连接建立会推迟，所以此时最好丢掉部分新的连接请求，空出资源以完成正在进行的连接建立过程。还要注意，这个判断并没有考虑半连接队列是否已满的问题。从这里可以看出，即使开启了SYN cookies机制并不意味着一定可以完成连接的建立。</p>

<p>  如果可以继续连接的建立，调用inet_reqsk_alloc()分配连接请求块，如下所示：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>req = inet_reqsk_alloc(&tcp_request_sock_ops);
</span><span class='line'>if (!req)
</span><span class='line'>    goto drop;</span></code></pre></td></tr></table></div></figure>


<p>  看到这里可能就有人疑惑，既然开启了SYN cookies机制，仍然分配连接请求块，那和正常的连接构建也没有什么区别了。这里之所以要分配连接请求块是用于发送SYN+ACK包给客户端，发送后会释放掉，并不会加入到半连接队列中。</p>

<p>  接下来就是计算cookie的值，由cookie_v4_init_sequence()函数完成，如下所示：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (want_cookie) {
</span><span class='line'>#ifdef CONFIG_SYN_COOKIES
</span><span class='line'>    syn_flood_warning(skb);
</span><span class='line'>    req-&gt;cookie_ts = tmp_opt.tstamp_ok;
</span><span class='line'>#endif
</span><span class='line'>    isn = cookie_v4_init_sequence(sk, skb, &req-&gt;mss);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>  计算得到的cookie值会保存在连接请求块tcp_request_sock结构的snt_isn成员中，接着会调用__tcp_v4_send_synack()函数发送SYN+ACK包，然后释放前面分配的连接请求块，如下所示：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (__tcp_v4_send_synack(sk, req, dst) || want_cookie)
</span><span class='line'>    goto drop_and_free;</span></code></pre></td></tr></table></div></figure>


<p>  在服务器端发送完SYN+ACK包后，我们看到在服务器端没有保存任何关于这个未完成连接的信息，所以在接收到客户端的ACK包后，只能根据前面发送的SYN+ACK包中的cookie值来决定是否继续构建连接。</p>

<p>  我们接下来看接收到ACK包后的处理情况。ACK包在tcp_v4_do_rcv()函数中调用的tcp_v4_hnd_req()中处理，如下所示：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static struct sock *tcp_v4_hnd_req(struct sock *sk, struct sk_buff *skb)
</span><span class='line'>{
</span><span class='line'>    ......
</span><span class='line'> 
</span><span class='line'>#ifdef CONFIG_SYN_COOKIES
</span><span class='line'>    if (!th-&gt;rst && !th-&gt;syn && th-&gt;ack)
</span><span class='line'>        sk = cookie_v4_check(sk, skb, &(IPCB(skb)-&gt;opt));
</span><span class='line'>#endif
</span><span class='line'>    return sk;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>  由于在服务器端没有保存未完成连接的信息，所以在半连接队列或ehash散列表中都不会找到对应的sock结构。如果开启了SYN cookies机制，则会检查接收到的数据包是否是ACK包，如果是，在cookie_v4_check()中会调用cookie_check()函数检查ACK包中的cookie值是否有效。如果有效，则会分配request_sock结构，并根据ACK包初始化相应的成员，开始构建描述连接的sock结构。创建过程和正常的连接创建过程一样。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SSH端口转发 及 SSH代理]]></title>
    <link href="http://abcdxyzk.github.io/blog/2015/04/09/tools-ssh-lr/"/>
    <updated>2015-04-09T23:06:00+08:00</updated>
    <id>http://abcdxyzk.github.io/blog/2015/04/09/tools-ssh-lr</id>
    <content type="html"><![CDATA[<h4>SSH端口转发</h4>

<p>假设A、B为内网机，C为可登录公网机。那么A连B过程为：</p>

<p>假设 A、B、C 的ssh端口分别为portA、portB、portC。</p>

<h5>1. 远程转发-R, 远程机转发到本地机</h5>

<p>在被连的B上先运行如下命令</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ssh -p portC -f -N -R 9000:localhost:portB userC@hostC-IP</span></code></pre></td></tr></table></div></figure>


<p>这样到C机上9000端口的连接会被转发到B机的portB上。</p>

<h5>2.本地转发-L, 本地机转发到远程机</h5>

<p>在发起连接的A上运行如下命令</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ssh -p portC -f -N -L 9999:localhost:9000 userC@hostC-IP</span></code></pre></td></tr></table></div></figure>


<p>这样到A机9999端口的连接会被转发到C机的9000上。而C的9000又会被转发到B的portB上。<br/>
所以只要在A上运行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ssh -p 9999 userB@127.0.0.1</span></code></pre></td></tr></table></div></figure>


<p>就相当于ssh到了B机的portB上。</p>

<h5>参数</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>f  表示后台用户验证,这个选项很有用,没有shell的不可登陆账号也能使用.
</span><span class='line'>N 表示不执行脚本或命令
</span><span class='line'>-L 本地转发
</span><span class='line'>-R 远程转发</span></code></pre></td></tr></table></div></figure>


<h5>路由器设置省去C机</h5>

<p>在路由器添加转发规则，端口为A机ssh监听端口，ip为A机内网IP。记下路由器公网IP。<br/>
然后只要在B机上直接连路由器公网IP+转发端口</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ssh -p portA -f -N -R 9999:localhost:portB userA@routeA-IP</span></code></pre></td></tr></table></div></figure>


<p>然后在A机上直接</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ssh -p 9999 userB@127.0.0.1</span></code></pre></td></tr></table></div></figure>


<p>A就能连上B</p>

<h4>SSH代理&ndash;网站限制内网IP？代理一下就好了</h4>

<h5>1 远程机有公网IP</h5>

<p>只要在本地运行</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ssh -qTfnN -D 7070 user@sshserver</span></code></pre></td></tr></table></div></figure>


<p>然后在firefox的 首选项->高级->网络->设置 里面改成手动配置代理，只填"SOCKS"这一行即可。</p>

<p><img src="http://abcdxyzk.github.io/images/tools/2015-04-10.png" alt="" /></p>

<h5>2 若远程机为内网机</h5>

<p>先按前面端口转发的方法，在本机映射一个到远程机的端口localport，然后命令改成</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ssh -qTfnN -D localport user@127.0.0.1</span></code></pre></td></tr></table></div></figure>


<p>这样firefox下要填127.0.0.1和localport</p>
]]></content>
  </entry>
  
</feed>
