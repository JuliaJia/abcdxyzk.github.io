
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>kk Blog —— 通用基础</title>

  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="kk Blog —— 通用基础" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script src="/javascripts/category.js" type="text/javascript"></script>

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">kk Blog —— 通用基础</a></h1>
  
    <h2>学习中......</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
<li>
<form action="/search" method="get">
    <input class="search" name="query" id="query" type="text" placeholder="search...">
    <input id="btnSubmit" value="search" type="submit">
</form>
<script type="text/javascript">
var query = GetRequest("query");
if (query != null) {
	document.getElementById("query").value = query;
}
</script>
</li>
  <li><a href="/atom.xml" rel="subscribe-rss">RSS</a></li>
  
</ul>
  
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/download">Download</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2013/09/21/ubuntu-dota2/">ubuntu dota2</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-09-21T23:51:00+08:00'><span class='date'>2013-09-21</span> <span class='time'>23:51:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>ERROR- You are missing the following 32-bit libraries, and Steam may not run:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo ln -s /usr/lib/i386-linux-gnu/mesa/libGL.so.1 /usr/lib</span></code></pre></td></tr></table></div></figure>


<p>无法输入：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>export LC_CTYPE="en_US.UTF-8" && steam</span></code></pre></td></tr></table></div></figure>


<h4>一、集显</h4>

<p>  ubuntu下，如果是intel的核心显卡，mesa低于9.2版本的话，会出现看不见树和看不见英雄的情况
  这时候就要更新mesa到9.2，mesa9.2支持3.6之后的内核版本，如果内核低于3.6，就要先更新内核
  ubuntu的解决办法:
  查看当前mesa版本：glxinfo |grep -i opengl
  查看当前内核版本：uname -a</p>

<p>  sudo add-apt-repository ppa:xorg-edgers/ppa
  sudo apt-get update
  sudo apt-get install linux-generic-lts-raring  (更新内核)
  sudo apt-get dist-upgrade mesa                 (更新mesa)
  然后就是重启系统</p>

<h4>二、独显</h4>

<p>ubuntu 装独显 <a href="/blog/2013/03/26/ubuntu-use-nvidia/">ubuntu 12.04 N卡双显卡</a></p>

<p>如果你想用独显玩dota2, 那么你需要用optirun steam来启动steam客户端，然后再启动游戏，这样游戏就是通过独显来渲染的。你也可以用普通的steam命令来启动steam，然后在dota2 游戏的属性中，加入启动方式optirun %command。 这样只有在启动游戏之后独显才会工作。</p>

<p>用optirun -b primus %command%(记得要装primus)，效果更好。 // 用%command%在启动时画面会显示不全，但是好像用%command好像又不会用独显了</p>

<p>primus默认是有垂直同步的，帧数当然会低，加个vblank_mode=0绝对秒杀virtualgl</p>

<p>不能用vblank_mode=0 optirun -b primus programme做桥接启动程序，这样会拉低许多显卡性能，
使用vblank_mode=0 primusrun programme，性能就上来了，我这里确实比optirun提高30%左右</p>

<hr />

<h5>1打开启动选项输入框</h5>

<h5>2 输入所选命令（使用多个命令是中间用空格隔开，例如 -novid -international -console  ）</h5>

<p>-novid （去除开始动画）<br/>
-console（命令面板）<br/>
-high （使dota2 的cpu和内存使用级为最高,也就是说让dota2 可以优先其他程序使用内存）<br/>
-windowed （窗口模式）</p>

<h5>dota 2 console 命令</h5>

<h6>1首先开启命令面板</h6>

<h6>2输入常用命令</h6>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>net_graph 1 （ 网络状况显示）
</span><span class='line'>    再来就是改变位置，有些人不喜欢显示在左边，这个时候可以输入：
</span><span class='line'>　　net_graphpos 1
</span><span class='line'>　　这样显示的数据就会变到右边
</span><span class='line'>　　
</span><span class='line'>　　net_graphpos 2
</span><span class='line'>　　这样会变成中间
</span><span class='line'>　　
</span><span class='line'>　　net_graphpos 3
</span><span class='line'>　　这样会变成左边
</span><span class='line'>
</span><span class='line'>dota_minimap_hero_size 650 （英雄在小地图上的大小 650 为正常值，可自行更改）
</span><span class='line'>dota_force_right_click_attack 1 (英雄可以右键直接反补）
</span><span class='line'>dota_hud_healthbars 1 （去掉生命条上的分隔）
</span><span class='line'>dota_health_per_vertical_marker 250 （更改每一个分隔代表的血量 默认为250）
</span><span class='line'>dota_disable_range_finder 0  （随时显示你的施法距离）（很有用）
</span><span class='line'>dota_camera_accelerate 49 （任意调整观看视角）（没用过）
</span><span class='line'>
</span><span class='line'>dota2 一共有数百种命令，包括血的颜色，屏蔽某种声音等等，但是比较实际的就是这几种，其他的就不列举了。
</span></code></pre></td></tr></table></div></figure>


<hr />

<h4>Dota2 录像下载失败</h4>

<p>无法打开录像文件,请确保没有其他进程已打开此文件。</p>

<p>在XXX\Steam\SteamApps\common\dota 2 beta\dota目录下新建一个名为replays的文件夹即可</p>

<hr />

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>net_graphheight "64"
</span><span class='line'>这个等于是设置高度位置 大家如果分屏率不同 可以修改数字来决定位置 数字越小 会往下移动 
</span><span class='line'>
</span><span class='line'>net_graphinsetbottom "437"
</span><span class='line'>这个等于是设置地步位置 大家如果分屏率不同 可以修改数字来决定位置 数字越小 会往上移动 
</span><span class='line'>
</span><span class='line'>net_graphinsetleft "0"
</span><span class='line'>因为已经设置右边 这个保持0就OK 但是也记得输入一次 以防万一 
</span><span class='line'>
</span><span class='line'>net_graphinsetright "-83"
</span><span class='line'>设置右边距离 记住这里是"-83" 不是83 负数越高 越往右 大家可以根据自己的需要改变数字 
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>net_graphproportionalfont "0"
</span><span class='line'>这个是关键 字体比例问题 默认是1 设定为0以后 就会变成我图中那样的小字 
</span><span class='line'>
</span><span class='line'>net_graphtext "1"
</span><span class='line'>这个没什么大问题 字体样式</span></code></pre></td></tr></table></div></figure>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2013/09/09/kernel-net-rx/">接收包的主流程</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-09-09T18:10:00+08:00'><span class='date'>2013-09-09</span> <span class='time'>18:10:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int tcp_v4_rcv(struct sk_buff *skb)    linux/net/ipv4/tcp_ipv4.c #1611</span></code></pre></td></tr></table></div></figure>


<p>  //tcp刚刚收到从ipv4发上来的包<br/>
  （struct tcphdr: 定义在/include/net/tcp.h中，即包的tcp首部，不包括options部分）<br/>
  （struct sock ：定义在/include/net/sock.h中，即表示socket）<br/>
  检查skb->pkt_type != PACKET_HOST 则丢弃<br/>
  检查th->doff &lt; sizeof(struct tcphdr) / 4，即首部大小不合理，则丢弃<br/>
  检查checksum</p>

<p>  （TCP_SKB_CB(skb)：定义在tcp.h是获取一个实际指向skb->cb[0]的tcp_skb_cb类型指针；将到达的首部剥离后，从中拷贝一些信息到这个变量，供tcp控制功能使用；tcp_skb_cb是在tcp刚收到时填写在包中的）<br/>
  注意：<br/>
        1. tcp_skb_cb->end_seq = seq + th->fin + th->fin + len-doff*4<br/>
        2. when 和 sacked 没有被赋值</p>

<p>  sk = __inet_lookup(&hellip;) 从一个hash表中获取该收包对应的sock结构，根据源IP地址+端口，目的IP地址+端口，inet_iif检查sk->sk_state == TCP_TIME_WAIT，TCP在该状态下则丢弃任何接收到的包并转入后续的特殊处理（未看，和关闭连接的状态迁移有关需要后续来看$），马上准备进入CLOSED状态了；<br/>
  检查sk_filter(sk,skb)，则被过滤器阻拦，丢弃<br/>
  检查!sock_owned_by_user(sk)，不明白sock->sk_lock的意义是什么，只有检查满足才能进入接收，否则 sk_add_backlog(sk, skb)将该sk_buff记录进sk_backlog队列；（注意这部操作加锁了！）<br/>
（struct tcp_sock *tp = tcp_sk(sk)：tcp_sock定义在tcp.h中，通过tcp_sk直接将sock指针转换为tcp_sock型）</p>

<p>  ret = tcp_v4_do_rcv(sk, skb) 进入进一步接收处理！<br/>
（之后的异常操作未看）</p>

<hr />

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int tcp_v4_do_rcv(struct sock *sk, struct sk_buff *skb)    linux/net/ipv4/tcp_ipv4.c #1542</span></code></pre></td></tr></table></div></figure>


<p>  //在正常状态下由tcp_v4_rcv调用，进一步进行针对接收包的处理<br/>
  检查sk->sk_state == TCP_ESTABLISHED<br/>
    则tcp_rcv_established(sk, skb, skb->h.th, skb->len)，连接已经建立，则进入进一步接收处理！<br/>
  检查sk->sk_state == TCP_LISTEN，<br/>
    则struct sock *nsk = tcp_v4_hnd_req(sk, skb);    //该函数中判断能否找到已有的连接请求，如果有则说明接收到的是一个ack并在其中创建一个新的sock即nsk；如果没有则说明接收到的是 syn，nsk即为sk；<br/>
  if(nsk!=sk) tcp_child_process(sk,nsk,skb)    //当nsk==sk时，接收的是SYN，不进行此步直接进入tcp_rcv_state_process；否则是ack说明已经创建好了的nsk，在 tcp_child_process对nsk进行tcp_rcv_state_process状态转移处理；<br/>
  tcp_rcv_state_process(sk, skb, skb->h.th, skb->len); 非常重要函数！处理tcp的状态转移<br/>
  reset: tcp_v4_send_reset(rsk, skb);    reset，未看$<br/>
  discard: kfree_skb(skb);</p>

<hr />

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int tcp_rcv_established(struct sock *sk, struct sk_buff *skb,struct tcphdr *th, unsigned len)    linux/net/ipv4/tcp_input.c #3881</span></code></pre></td></tr></table></div></figure>


<p>Header Prediction：基于效率的考虑，将包的处理后续阶段分为fast path和slow path两种，前者用于普通的包，后者用于特殊的包；该header prediction即用于区分两种包的流向。<br/>
1.(tcp_flag_word(th) &amp; TCP_HP_BITS) == tp->pred_flags 判断标志位是不是正常情况；tcp_flag_word返回指向tcphdr的第三个32位基址（即length前面），而TCP_HP_BITS是把 PSH标志位给屏蔽掉即该位值不影响流向；所以总的来说pred_flag应该等于0xS?10 &lt;&lt; 16 + snd_wnd（那么pred_flag是在tcp_fast_path_check或tcp_fast_path_on中更新值的）<br/>
2.TCP_SKB_CB(skb)->seq == tp->rcv_nxt 判断所收包是否为我们正想要接收的，非乱序包<br/>
3.*ptr != htonl((TCPOPT_NOP &lt;&lt; 24) | (TCPOPT_NOP &lt;&lt; 16) | (TCPOPT_TIMESTAMP &lt;&lt; 8) | TCPOLEN_TIMESTAMP) 若包中没有正常的timestamp选项则转入slow path
 timestamp选项处理： 从包中的ts选项中获取数据，以此刷新tp->rx_opt的saw_tstamp,rcv_tsval,rcv_tsecr域；ts选项含三个 32bit，其中后两个分别记录着tsval和tsecr；（注意，ts_recent并不在此处更新，在后面的tcp_store_ts_recent 中更新）<br/>
  struct tcp_options_received: 定义在tcp.h中，其中saw_tstamp表明timestamp选项是否有效，ts_recent_stamp是我们最近一次更新 ts_recent的时间，ts_recent是下一次回显的时戳一般等于下次发包中的rcv_tsecr；rcv_tsval是该data从发端发出时的时戳值，rcv_tsecr是回显时间戳（即该ack对应的data或者该data对应的上次ack中的ts_tsval值），（注意两端时钟无需同步；当ack被收端推迟时，所回复的ack中的timestamp指向所回复包群中的第一个确认包 “When an incoming segment belongs to the current window, but arrives out of order (which implies that an earlier segment was lost), the timestamp of the earlier segment is returned as soon as it arrives, rather than the timestamp of the segment that arrived out of order.”这条细节未看明白$）从包中的时间戳选项中记录这两个值</p>

<p>4.PAWS check：(s32)(tp->rx_opt.rcv_tsval - tp->rx_opt.ts_recent) &lt; 0，则转入slow path<br/>
  （PAWS:Protection Against Wrapped Sequence Numbers, SeqNo有可能会有回环交叠（因为它最大只有32bit），两个相同序号的包实际上是不同的两个包，此时判断tsval是否小于ts_recent即判断该包是否是一个过去时间的一个多余的包，然后将其作为一个重复包丢弃）</p>

<h5>Fast Path：</h5>

<p>  1.当len == tcp_header_len，即这是一个纯ack（区别于piggyback），注意这是个纯ack，所以它通过长度来进行判断而不是标识！<br/>
    tcp_store_ts_recent(tp): tp->rx_opt.ts_recent = tp->rx_opt.rcv_tsval;<br/>
    tcp_ack(sk, skb, 0) 处理ack，进一步处理，未看！<br/>
    <code>__kfree_skb(skb)</code> 释放该包<br/>
     tcp_data_snd_check(sk,tp) 检查有无更进一步的data包处理<br/>
  2.当len &lt; tcp_header_len，说明该包的首部太小，清除之；<br/>
  3.当len > tcp_header_len，它是一个data包，tcp_copy_to_iovec函数未看，它决定该payload是否可以直接拷贝给用户空间：<br/>
    可，tcp_store_ts_recent(tp);<br/>
      tcp_rcv_rtt_measure_ts(sk,skb); //计算RTT<br/>
      <code>__skb_pull(skb, tcp_header_len);</code> //剥tcp首部<br/>
       tp->rcv_nxt = TCP_SKB_CB(skb)->end_seq; //更新rcv_next<br/>
($ 那么将data拷贝到用户空间的操作在何处体现？难道是在tcp_copy_to_iovec中？)<br/>
    不可，除了以上的操作之外，还要<br/>
      <code>__skb_queue_tail(&amp;sk-&gt;sk_receive_queue, skb);</code> //将该包加入到接收sk_buff队列尾部<br/>
    tcp_event_data_recv()：management tasks处理<br/>
    若TCP_SKB_CB(skb)->ack_seq != tp->snd_una，说明这是一个有效的ack包<br/>
      tcp_ack(sk, skb, FLAG_DATA); //FLAG_DATA说明这是一个背在data上的ack<br/>
      tcp_data_snd_check(sk, tp); //该函数调用tcp_push_pending_frames函数，如果sk->sk_send_head存在则最终调用 tcp_write_xmit函数发包<br/>
      <code>__tcp_ack_snd_check(sk, 0);</code> //检查基于该收包事件，有无进一步的ack包处理（Delayed ACK，Quick ACK）</p>

<h5>Slow Path：</h5>

<p>  tcp_checksum_complete_user(sk, skb)：checksum检查<br/>
  tcp_fast_parse_options(skb, th, tp)：timestamp选项检查；tcp_paws_discard(sk, skb)：PAWS检查<br/>
  tcp_sequence(tp, TCP_SKB_CB(skb)->seq, TCP_SKB_CB(skb)->end_seq)：检查是否乱序，并在其中激活QuickACK模式<br/>
    上面两行中，都会再检查RST标志，若没激活则tcp_send_dupack，作用不明，貌似是针对该错包回复一个冗余的ack<br/>
  检查RST标志，tcp_reset(sk) 该函数没什么操作，填写一些错误信息后进入tcp_done函数(该函数进行一些关闭tcp连接的收尾操作)<br/>
  tcp_replace_ts_recent(tp, TCP_SKB_CB(skb)->seq)：更新timestamp信息<br/>
  检查SYN标志，在连接已建立的状态下，收到SYN是错误的，因此tcp_reset(sk)<br/>
  检查ACK标志，tcp_ack(sk, skb, FLAG_SLOWPATH)<br/>
  tcp_rcv_rtt_measure_ts(sk, skb)：更新RTT<br/>
  tcp_urg(sk, skb, th)：处理URG标志<br/>
  tcp_data_queue(sk, skb)：处理接收包所含数据，未看<br/>
  tcp_data_snd_check(sk, tp) &amp; tcp_ack_snd_check(sk)：检查有无进一步的data或ack发送</p>

<hr />

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void tcp_event_data_recv(struct sock *sk, struct tcp_sock *tp, struct sk_buff *skb)    linux/net/ipv4/tcp_input.c #502</span></code></pre></td></tr></table></div></figure>


<p>  //
  inet_csk_schedule_ack(sk)：将icsk_pending置为ICSK_ACK_SCHED，但具体意义不明<br/>
  （struct inet_connection_sock：/linux/include/net/inet_connection_sock，面向INET连接的 socket结构，记录着和tcp连接有关的很多变量，比如本函数要处理的ATO（Acknowledgement timeout）信息；tcp_sock是其上的拓展，它的具体意义尚待发掘）<br/>
  tcp_measure_rcv_mss(sk, skb)：更新rcv_mss，说是与delayed ACK有关，但是具体是怎么运作的？<br/>
  tcp_rcv_rtt_measure(tp)：更新RTT，为什么又更新一遍$<br/>
  接下来的一些列操作是更新inet_connection_sock中的ATO信息，具体操作代码中有注释，但这些信息的运作方式还不明</p>

<hr />

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int tcp_ack(struct sock *sk, struct sk_buff *skb, int flag)    /linux/net/ipv4/tcp_input.c #2491</span></code></pre></td></tr></table></div></figure>


<p>  //处理接受到的ack，内容非常复杂
  首先介绍一下ack可以携带的各个FLAG：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>FLAG_DATA：              Incoming frame contained data.
</span><span class='line'>FLAG_WIN_UPDATE：        Incoming ACK was a window update
</span><span class='line'>FLAG_DATA_ACKED：        This ACK acknowledged new data.
</span><span class='line'>FLAG_RETRANS_DATA_ACKED：Some of which was retransmitted.
</span><span class='line'>FLAG_SYN_ACKED：         This ACK acknowledged SYN.
</span><span class='line'>FLAG_DATA_SACKED：       New SACK.
</span><span class='line'>FLAG_ECE：               ECE in this ACK.
</span><span class='line'>FLAG_DATA_LOST：         SACK detected data lossage.
</span><span class='line'>FLAG_SLOWPATH：          Do not skip RFC checks for window update.
</span><span class='line'>FLAG_ACKED：             (FLAG_DATA_ACKED|FLAG_SYN_ACKED)
</span><span class='line'>FLAG_NOT_DUP：           (FLAG_DATA|FLAG_WIN_UPDATE|FLAG_ACKED)
</span><span class='line'>FLAG_CA_ALERT：          (FLAG_DATA_SACKED|FLAG_ECE)
</span><span class='line'>FLAG_FORWARD_PROGRESS： (FLAG_ACKED|FLAG_DATA_SACKED)</span></code></pre></td></tr></table></div></figure>


<p>  prior_snd_una = tp->snd_una;ack_seq = TCP_SKB_CB(skb)->seq; ack = TCP_SKB_CB(skb)->ack_seq;<br/>
  //1记录着上一次被确认的data序号；2记录着所收ack包的序号；3记录着所收ack包确认对象的data序号；<br/>
  首先判断若ack在tp->snd_nxt之后或者在prio_snd_una之前，则说明该ack非法或者过时（在过时的情况下，若sacked打开则还需tcp_sacktag_write_queue处理） 24</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (!(flag&FLAG_SLOWPATH) && after(ack, prior_snd_una))
</span><span class='line'>    tcp_update_wl（即tp-&gt;snd_wl1 = ack_seq）; tp-&gt;snd_una=ack; //为什么此种情况下并不更新窗口？
</span><span class='line'>else
</span><span class='line'>    flag |= tcp_ack_update_window(sk, tp, skb, ack, ack_seq);
</span><span class='line'>    //nwin = ntohs(skb-&gt;h.th-&gt;window)从ack中记录通告窗口
</span><span class='line'>    如果检查需要更新发送窗口，则tp-&gt;snd_wl1 = ack_seq; tp-&gt;snd_wnd = nwin;
</span><span class='line'>    tp-&gt;snd_una = ack;
</span><span class='line'>    if (TCP_SKB_CB(skb)-&gt;sacked) flag |= tcp_sacktag_write_queue(sk, skb, prior_snd_una); //该函数未看
</span><span class='line'>
</span><span class='line'>    tp-&gt;rcv_tstamp = tcp_time_stamp; //rcv_tstamp记录着最近一次收到ack的时戳
</span><span class='line'>    prior_in_flight = tcp_packets_in_flight(tp);
</span><span class='line'>    if(!tp-&gt;packets_out) icsk-&gt;icsk_prbes_out = 0;
</span><span class='line'>    if (sk-&gt;sk_send_head) tcp_ack_probe(sk);    //若此时网络中没有data，直接进入zero-window probe的ack处理;通告窗口的数据已经得到处理，所以tcp_ack_probe中仅仅是重置probe计时器，即 icsk-&gt;icsk_retransmit_timer
</span><span class='line'>
</span><span class='line'>    flag |= tcp_clean_rtx_queue(sk, &seq_rtt);   //从重传队列中移除被确认的data包
</span><span class='line'>
</span><span class='line'>    if (tcp_ack_is_dubious(sk, flag)) { //该函数判断此ack是否可疑，判真情况下具体是flag不为FLAG_NOT_DUP，或flag是FLAG_CA_ALERT，或 icsk_ca_state不为TCP_CA_OPEN状态
</span><span class='line'>    if ((flag & FLAG_DATA_ACKED) && tcp_may_raise_cwnd(sk, flag))
</span><span class='line'>    //如果这个包是一个对新数据包的ack，那么通过tcp_may_raise_cwnd函数来判断是否要进行窗口操作，判真情况下具体是flag不是 FLAG_ECE或snd_cwnd&lt;snd_ssthresh（慢启动？）且icsk_ca_state不为TCP_CA_RECOVERY和 TCP_CA_CWR状态（所以，为什么TCP_CA_LOSS状态可以增窗呢？）
</span><span class='line'>        tcp_cong_avoid(sk, ack, seq_rtt, prior_in_flight, 0);  
</span><span class='line'>    //该函数会调用icsk-&gt;icsk_ca_ops-&gt;cong_avoid(sk, ack, rtt, in_flight, good)， 这是个函数指针；另外会更新snd_cwnd_stamp
</span><span class='line'>    tcp_fastretrans_alert(sk, prior_snd_una, prior_packets, flag); //未看，极其重要的函数
</span><span class='line'>}else{
</span><span class='line'>    if ((flag & FLAG_DATA_ACKED)) tcp_cong_avoid(sk, ack, seq_rtt, prior_in_flight, 1);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>tcp_ack中有很多新的内容，都还未涉及，要注意！！！！！！</p>

<hr />

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void tcp_data_queue(struct sock *sk, struct sk_buff *skb)    /linux/net/ipv4/tcp_input.c #3139</span></code></pre></td></tr></table></div></figure>


<p>  //将数据拷贝至用户空间<br/>
若TCP_SKB_CB(skb)->seq == TCP_SKB_CB(skb)->end_seq 则空包丢弃<br/>
__skb_pull(skb, th->doff*4) //剥离tcp首部</p>

<h5>1.若TCP_SKB_CB(skb)->seq == tp->rcv_nxt且tcp_receive_window(tp)!=0，非乱序且处于接受窗口中，正常的情况</h5>

<p>若tp->ucopy.task == current, tp->copied_seq == tp->rcv_nxt, tp->ucopy.len等条件满足，则可以拷贝至用户空间<br/>
  //current是什么不明？ucopy.len貌似是用户最先设定的数据包的量，每次收包之后减小直至零<br/>
    skb_copy_datagram_iovec(skb, 0, tp->ucopy.iov, chunk) //向ucopy.iov拷贝数据<br/>
    tcp_rcv_space_adjust(sk) //计算TCP接受buffer空间大小，拷贝完<br/>
tp->rcv_nxt = TCP_SKB_CB(skb)->end_seq;<br/>
if(th->fin) tcp_fin(skb, sk, th); //原来fin的处理在这里！<br/>
若!skb_queue_empty(&amp;tp->out_of_order_queue)<br/>
    tcp_ofo_queue(sk); //看out_of_order_queue中有没有可以移到receive_queue中<br/>
    tcp_sack_remove(tp) //RCV.NXT advances, some SACKs should be eaten<br/>
    tcp_fast_path_check(sk,tp)   //tp->pred_flag值的更新<br/>
  清除skb并return</p>

<h5>2.若!after(TCP_SKB_CB(skb)->end_seq, tp->rcv_nxt) 说明这是一个重传的包</h5>

<p>  tcp_dsack_set(tp, TCP_SKB_CB(skb)->seq, TCP_SKB_CB(skb)->end_seq);   //在其中打开并填写dsack信息,在dyokucate_sack[0]中从seq到end_seq，修改dsack和eff_sacks值<br/>
  tcp_enter_quickack_mode(sk); //进入quick ack模式<br/>
  清除skb并return<br/>
若!before(TCP_SKB_CB(skb)->seq, tp->rcv_nxt + tcp_receive_window(tp))<br/>
  清除skb并return<br/>
若before(TCP_SKB_CB(skb)->seq, tp->rcv_nxt) 说明这是一个Partial包，即seq&lt;rcv_next&lt;end_seq<br/>
  tcp_dsack_set(tp, TCP_SKB_CB(skb)->seq, tp->rcv_nxt); //填写dsack信息，从seq到rcv_nxt</p>

<h5>3. 其他情况，说明收到了一个乱序包</h5>

<p>若out_of_order_queue为空，则<br/>
（注：out_of_order_queue是一个sk_buff_head结构，它的prev/next指针分别指向最后一个和第一个sk_buff结构，块的排放顺序对应其序号的大小顺序）<br/>
  初始化sack相关域，num_sacks/eff_sacks为1，dsack为0，selective_acks[0]从seq到end_seq；<br/>
  <code>__skb_queue_head(&amp;tp-&gt;out_of_order_queue,skb);</code> //将收包加入out_of_order_queue的头部</p>

<p>若out_of_order_queue不为空，则首先获取skb1 = tp->out_of_order_queue.prev即最新的一个乱序块<br/>
  若seq == TCP_SKB_CB(skb1)->end_seq，说明收包能够接在最新乱序块的右边<br/>
    <code>__skb_append(skb1, skb, &amp;tp-&gt;out_of_order_queue);</code><br/>
    tp->selective_acks[0].end_seq = end_seq; //将新收包接在skb1的右边，看来第一个selective_acks块对应的是最新的乱序序列<br/>
  循环执行skb1=skb1->prev，直到找到!after(TCP_SKB_CB(skb1)->seq, seq)表明需要将收包插在此块之后，或skb1=(struct sk_buff<em>)&amp;tp->out_of_order_queue表明收包比队列中的所与块的序列都要小<br/>
    循环内需要找到收包与队列已有包中的重复部分，然后tcp_dsack_set设置该部分为dsack内容<br/>
  <code>__skb_insert(skb, skb1, skb1-&gt;next, &amp;tp-&gt;out_of_order_queue);</code> //将收包对应的块插入到队列中<br/>
  再次循环执行skb1=skb1->next，直到找到!after(end_seq, TCP_SKB_CB(skb1)->seq)表明需要将从收包到该包之间的所有包全部从队列中移除，或者skb1=(struct sk_buff</em>)&amp;tp->out_of_order_queue表明需要将收包之后的所有包都移出<br/>
    循环内需要将当前的队列包与收包的交叠部分设置为dsack值（当然随着循环的推进，dsack处于不断更新的状况），还要通过 <code>__skb_unlink(skb1, &amp;tp-&gt;out_of_order_queue)，__kfree_skb(skb1);</code>将当前的队列包移除<br/>
  （该处的两部循环，旨在通过比较队列中块的序号和所收包的序号范围，将队列中的包连续化，即消除孔洞）</p>

<hr />
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2013/09/06/kernel-net-ack/">内核tcp的ack的处理</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-09-06T15:40:00+08:00'><span class='date'>2013-09-06</span> <span class='time'>15:40:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>我们来看tcp输入对于ack，段的处理。</p>

<ul>
<li>先是ack的处理，在内核中，处理ack段是通过tcp_ack来进行的。<br/>
这个函数主要功能是：</li>
<li>update重传队列，并基于sack来设置skb的相关buf。</li>
<li>update发送窗口。</li>
<li>基于sack的信息或者重复ack来决定是否进入拥塞模式。<br/>
在看之前我们要知道tcp是累积确认的。为了解决带来的缺点，我们才需要sack的。</li>
</ul>


<p>  然后我们来看几个很重要的数据结构，先是tcp_skb_cb，它其实就是表示skb中所保存的tcp的控制信息。而他是保存在skb的cb中的(这个域可以看我前面的blog）。所以这里我们经常会用TCP_SKB_CB来存取这个结构。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define TCP_SKB_CB(__skb)   ((struct tcp_skb_cb *)&((__skb)-&gt;cb[0]))</span></code></pre></td></tr></table></div></figure>


<p>这里还有一个inet_skb_parm，这个结构保存了ipoption的一些信息。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct inet_skb_parm
</span><span class='line'>{
</span><span class='line'>    struct ip_options   opt;        /* Compiled IP options      */
</span><span class='line'>    unsigned char       flags;
</span><span class='line'>
</span><span class='line'>    #define IPSKB_FORWARDED           1
</span><span class='line'>    #define IPSKB_XFRM_TUNNEL_SIZE    2
</span><span class='line'>    #define IPSKB_XFRM_TRANSFORMED    4
</span><span class='line'>    #define IPSKB_FRAG_COMPLETE       8
</span><span class='line'>    #define IPSKB_REROUTED            16
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>然后来看tcp_skb_cb：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct tcp_skb_cb {
</span><span class='line'>    union {
</span><span class='line'>        struct inet_skb_parm    h4;
</span><span class='line'>#if defined(CONFIG_IPV6) || defined (CONFIG_IPV6_MODULE)
</span><span class='line'>        struct inet6_skb_parm   h6;
</span><span class='line'>#endif
</span><span class='line'>    } header;   /* For incoming frames      */
</span><span class='line'>//这个表示当前tcp包的序列号
</span><span class='line'>    __u32       seq;
</span><span class='line'>//这个表示结束序列号，也就是SEQ + FIN + SYN + datalen。
</span><span class='line'>    __u32       end_seq;
</span><span class='line'>//主要用来计算rtt
</span><span class='line'>    __u32       when;
</span><span class='line'>//tcp头的flag（比如syn，fin等)，它能取的值，我们下面会介绍。
</span><span class='line'>    __u8        flags;
</span><span class='line'>
</span><span class='line'>//SACK/FACK的状态flag或者是sack option的偏移(相对于tcp头的)。我们下面会介绍
</span><span class='line'>    __u8        sacked;
</span><span class='line'>//ack的序列号。
</span><span class='line'>    __u32       ack_seq;
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>下面就是flags所能取的值，可以看到也就是tcp头的控制位。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define TCPCB_FLAG_FIN      0x01
</span><span class='line'>#define TCPCB_FLAG_SYN      0x02
</span><span class='line'>#define TCPCB_FLAG_RST      0x04
</span><span class='line'>#define TCPCB_FLAG_PSH      0x08
</span><span class='line'>#define TCPCB_FLAG_ACK      0x10
</span><span class='line'>#define TCPCB_FLAG_URG      0x20
</span><span class='line'>#define TCPCB_FLAG_ECE      0x40
</span><span class='line'>#define TCPCB_FLAG_CWR      0x80</span></code></pre></td></tr></table></div></figure>


<p>然后是sack/fack的状态标记：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//有这个域说明当前的tcpcb是被sack块确认的。
</span><span class='line'>#define TCPCB_SACKED_ACKED  0x01
</span><span class='line'>//表示重传的帧
</span><span class='line'>#define TCPCB_SACKED_RETRANS    0x02
</span><span class='line'>//丢失
</span><span class='line'>#define TCPCB_LOST      0x04
</span><span class='line'>#define TCPCB_TAGBITS       0x07
</span><span class='line'>//重传的帧。
</span><span class='line'>#define TCPCB_EVER_RETRANS  0x80
</span><span class='line'>#define TCPCB_RETRANS       (TCPCB_SACKED_RETRANS|TCPCB_EVER_RETRANS)</span></code></pre></td></tr></table></div></figure>


<p>  这里要注意，当我们接收到正确的SACK后，这个域就会被初始化为sack所在的相对偏移(也就是相对于tcp头的偏移值，这样我们就能很容易得到sack option的位置).
然后是tcp_sock，这个结构保存了我们整个tcp层所需要得所有必要的信息（也就是从sock中提取出来).我们分两个部分来看这个结构，这里只看我们关注的两部分，第一部分是窗口相关的一些域。第二部分是拥塞控制的一些相关域。
先来看窗口相关的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//我们期待从另一台设备接收的下一个数据字节的序列号。
</span><span class='line'>u32 rcv_nxt;
</span><span class='line'>//还没有被读取的数据的序列号。
</span><span class='line'>u32 copied_seq;
</span><span class='line'>//当最后一次窗口update被发送之前我们的rcv_nxt.
</span><span class='line'>u32 rcv_wup;
</span><span class='line'>//将要发送给另一台设备的下一个数据字节的序列号。
</span><span class='line'>u32 snd_nxt;
</span><span class='line'>//已经发送但尚未被确认的第一个数据字节的序列号。
</span><span class='line'>u32 snd_una;
</span><span class='line'>//
</span><span class='line'>u32 snd_sml;
</span><span class='line'>//最后一次接收到ack的时间戳，主要用于keepalive
</span><span class='line'>u32 rcv_tstamp;
</span><span class='line'>//最后一次发送数据包的时间戳。
</span><span class='line'>u32 lsndtime;
</span><span class='line'>//发送窗口长度
</span><span class='line'>u32 snd_wnd;
</span><span class='line'>//接收窗口长度。
</span><span class='line'>u32 rcv_wnd
</span><span class='line'>//发送未确认的数据包的个数（或者字节数？）
</span><span class='line'>u32 packets_out;
</span><span class='line'>//重传的数据包的个数
</span><span class='line'>u32 retrans_out;</span></code></pre></td></tr></table></div></figure>


<p>然后是拥塞部分，看这里之前还是需要取熟悉一下tcp拥塞控制的相关概念。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//慢开始的阀值，也就是超过这个我们就要进入拥塞避免的阶段
</span><span class='line'>u32  snd_ssthresh;
</span><span class='line'>//发送的拥塞窗口
</span><span class='line'>u32 snd_cwnd;
</span><span class='line'>//这个应该是拥塞状态下所发松的数据字节数
</span><span class='line'>u32 snd_cwnd_cnt;
</span><span class='line'>//这里也就是cwnd的最大值
</span><span class='line'>u32 snd_cwnd_clamp;
</span><span class='line'>//这两个值不太理解什么意思。
</span><span class='line'>u32 snd_cwnd_used;
</span><span class='line'>u32 snd_cwnd_stamp;
</span><span class='line'>
</span><span class='line'>//接收窗口打消
</span><span class='line'>u32 rcv_wnd;
</span><span class='line'>//tcp的发送buf数据的尾部序列号。
</span><span class='line'>u32 write_seq;
</span><span class='line'>//最后一次push的数据的序列号
</span><span class='line'>u32 pushed_seq;
</span><span class='line'>//丢失的数据包字节数
</span><span class='line'>u32 lost_out;
</span><span class='line'>//sack的数据包的字节数
</span><span class='line'>u32 sacked_out;
</span><span class='line'>//fack处理的数据包的字节数
</span><span class='line'>u32 fackets_out;
</span><span class='line'>u32 tso_deferred;
</span><span class='line'>//计数
</span><span class='line'>u32 bytes_acked;</span></code></pre></td></tr></table></div></figure>


<p>分析完相关的数据结构我们来看函数的实现。<br/>
来看tcp_ack的代码,函数比较大，因此我们分段来看，先来看一开始的一些校验部分。<br/>
这里有一个tcp_abc也就是proc下面的可以设置的东西，这个主要是看要不要每个ack都要进行拥塞控制。</p>

<blockquote><p>Controls Appropriate Byte Count defined in RFC3465. If set to 0 then does congestion avoid once per ACK. 1 is conservative value, and 2 is more aggressive. The default value is 1.</p></blockquote>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct inet_connection_sock *icsk = inet_csk(sk);
</span><span class='line'>struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>//等待ack，也就是发送未确认的序列号。
</span><span class='line'>u32 prior_snd_una = tp-&gt;snd_una;
</span><span class='line'>u32 ack_seq = TCP_SKB_CB(skb)-&gt;seq;
</span><span class='line'>//得到ack的序列号。
</span><span class='line'>u32 ack = TCP_SKB_CB(skb)-&gt;ack_seq;
</span><span class='line'>u32 prior_in_flight;
</span><span class='line'>u32 prior_fackets;
</span><span class='line'>int prior_packets;
</span><span class='line'>int frto_cwnd = 0;
</span><span class='line'>
</span><span class='line'>//如果ack的序列号小于发送未确认的，也就是说可能这个ack只是重传老的ack，因此我们忽略它。
</span><span class='line'>if (before(ack, prior_snd_una))
</span><span class='line'>    goto old_ack;
</span><span class='line'>
</span><span class='line'>//如果ack大于snd_nxt,也就是它确认了我们还没发送的数据段，因此我们discard这个段。
</span><span class='line'>if (after(ack, tp-&gt;snd_nxt))
</span><span class='line'>    goto invalid_ack;
</span><span class='line'>//如果ack大于发送未确认，则设置flag
</span><span class='line'>if (after(ack, prior_snd_una))
</span><span class='line'>    flag |= FLAG_SND_UNA_ADVANCED;
</span><span class='line'>
</span><span class='line'>//是否设置tcp_abc，有设置的话，说明我们不需要每个ack都要拥塞避免，因此我们需要计算已经ack的字节数。
</span><span class='line'>if (sysctl_tcp_abc) {
</span><span class='line'>    if (icsk-&gt;icsk_ca_state &lt; TCP_CA_CWR)
</span><span class='line'>        tp-&gt;bytes_acked += ack - prior_snd_una;
</span><span class='line'>    else if (icsk-&gt;icsk_ca_state == TCP_CA_Loss)
</span><span class='line'>         tp-&gt;bytes_acked += min(ack - prior_snd_una,qtp-&gt;mss_cache);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>//得到fack的数据包的字节数
</span><span class='line'>prior_fackets = tp-&gt;fackets_out;
</span><span class='line'>//计算还在传输的数据段的字节数,下面会详细分析这个函数。
</span><span class='line'>prior_in_flight = tcp_packets_in_flight(tp);</span></code></pre></td></tr></table></div></figure>


<p>packets_out这个表示已经发送还没有ack的数据段的字节数(这个值不会重复加的，比如重传的话不会增加这个值）。<br/>
sakced_out :sack了的字节数。<br/>
lost_out:丢失了的字节数。<br/>
retrans_out:重传的字节数。<br/>
现在我们就对这个函数的返回值很清楚了，它也就是包含了还没有到达对方的数据段的字节数。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline unsigned int tcp_left_out(const struct tcp_sock *tp)
</span><span class='line'>{
</span><span class='line'>    return tp-&gt;sacked_out + tp-&gt;lost_out;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>static inline unsigned int tcp_packets_in_flight(const struct tcp_sock *tp)
</span><span class='line'>{
</span><span class='line'>    return tp-&gt;packets_out - tcp_left_out(tp) + tp-&gt;retrans_out;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>接下来这一段主要是通过判断flag(slow还是fast)来进行一些窗口的操作。有关slow_path和fast_path的区别，可以看我前面的blog。<br/>
fast_path的话很简单，我们就更新相关的域以及snd_wl1(这个域主要是用于update窗口的时候).它这里会被赋值为我们这次的数据包的序列号。然后进行拥塞控制的操作。<br/>
snd_wl1是只要我们需要更新发送窗口的话，这个值是都会被更新的。<br/>
slow_path的话，我们就需要判断要不要update窗口的大小了。以及是否要处理sack等。<br/>
在看下面的代码之前，我们先来看传递进tcp_ack这个函数中的第三个参数flag，这里我们在函数中也还会修改这个值，这个flag也就是当前的skb的类型信息。看了注释后就清楚了。可疑看到好几个都是ack的类型。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//这个说明当前的输入帧包含有数据。
</span><span class='line'>#define FLAG_DATA       0x01
</span><span class='line'>//这个说明当前的ack是一个窗口更新的ack
</span><span class='line'>#define FLAG_WIN_UPDATE     0x02
</span><span class='line'>//这个ack确认了一些数据
</span><span class='line'>#define FLAG_DATA_ACKED     0x04
</span><span class='line'>//这个表示ack确认了一些我们重传的段。
</span><span class='line'>#define FLAG_RETRANS_DATA_ACKED 0x08
</span><span class='line'>//这个表示这个ack是对syn的回复。
</span><span class='line'>#define FLAG_SYN_ACKED      0x10
</span><span class='line'>//新的sack
</span><span class='line'>#define FLAG_DATA_SACKED    0x20
</span><span class='line'>//ack中包含ECE
</span><span class='line'>#define FLAG_ECE        0x40
</span><span class='line'>//sack检测到了数据丢失。
</span><span class='line'>#define FLAG_DATA_LOST      0x80
</span><span class='line'>//当更新窗口的时候不跳过RFC的检测。
</span><span class='line'>#define FLAG_SLOWPATH       0x100
</span><span class='line'>
</span><span class='line'>#define FLAG_ONLY_ORIG_SACKED   0x200
</span><span class='line'>//snd_una被改变了。也就是更新了。
</span><span class='line'>#define FLAG_SND_UNA_ADVANCED   0x400
</span><span class='line'>//包含D-sack
</span><span class='line'>#define FLAG_DSACKING_ACK   0x800
</span><span class='line'>//这个不太理解什么意思。
</span><span class='line'>#define FLAG_NONHEAD_RETRANS_ACKED  0x1000
</span><span class='line'>//
</span><span class='line'>#define FLAG_SACK_RENEGING  0x2000
</span><span class='line'>
</span><span class='line'>//下面也就是一些组合。
</span><span class='line'>#define FLAG_ACKED  (FLAG_DATA_ACKED|FLAG_SYN_ACKED)
</span><span class='line'>#define FLAG_NOT_DUP (FLAG_DATA|FLAG_WIN_UPDATE|FLAG_ACKED)
</span><span class='line'>#define FLAG_CA_ALERT       (FLAG_DATA_SACKED|FLAG_ECE)
</span><span class='line'>#define FLAG_FORWARD_PROGRESS   (FLAG_ACKED|FLAG_DATA_SACKED)
</span><span class='line'>#define FLAG_ANY_PROGRESS   (FLAG_FORWARD_PROGRESS|FLAG_SND_UNA_ADVANCED)</span></code></pre></td></tr></table></div></figure>


<p>然后我们来看代码，下面的代码会设置flag，也就是用上面的宏。<br/>
这里有一个很大的不同就是slow_path中，我们需要update窗口的大小，而在fast模式中，我们不需要，这个详细去看我前面的blog介绍的fast和slow的区别。fast就是最理想的情况，因此我们不需要update窗口。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//如果不是slowpath并且ack确实是正确的序列号(必须大于snd_una).
</span><span class='line'>    if (!(flag & FLAG_SLOWPATH) && after(ack, prior_snd_una)) {
</span><span class='line'>//更新snd_wl1域为ack_seq;
</span><span class='line'>        tcp_update_wl(tp, ack_seq);
</span><span class='line'>//snd_una更新为ack也就是确认的序列号
</span><span class='line'>        tp-&gt;snd_una = ack;
</span><span class='line'>//更新flag域。
</span><span class='line'>        flag |= FLAG_WIN_UPDATE;
</span><span class='line'>//进入拥塞的操作。
</span><span class='line'>        tcp_ca_event(sk, CA_EVENT_FAST_ACK);
</span><span class='line'>................................
</span><span class='line'>    } else {
</span><span class='line'>//这个判断主要是为了判断是否输入帧包含数据。也就是ack还包含了数据，如果有的话，我们设置标记然后后面会处理。
</span><span class='line'>        if (ack_seq != TCP_SKB_CB(skb)-&gt;end_seq)
</span><span class='line'>            flag |= FLAG_DATA;
</span><span class='line'>        else
</span><span class='line'>.....................................
</span><span class='line'>
</span><span class='line'>//然后进入更新窗口的操作。
</span><span class='line'>        flag |= tcp_ack_update_window(sk, skb, ack, ack_seq);
</span><span class='line'>//然后判断是否有sack段，有的话，我们进入sack段的处理。
</span><span class='line'>        if (TCP_SKB_CB(skb)-&gt;sacked)
</span><span class='line'>            flag |= tcp_sacktag_write_queue(sk, skb, prior_snd_una);
</span><span class='line'>//判断是否有ecn标记，如果有的话，设置ecn标记。
</span><span class='line'>        if (TCP_ECN_rcv_ecn_echo(tp, tcp_hdr(skb)))
</span><span class='line'>            flag |= FLAG_ECE;
</span><span class='line'>//进入拥塞的处理。
</span><span class='line'>        tcp_ca_event(sk, CA_EVENT_SLOW_ACK);
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<p>接下来这段主要工作是：<br/>
1 清理重传队列中的已经ack的段。<br/>
2 处理F-RTO。<br/>
3 判断是否是零窗口探测的回复ack。<br/>
4 检测是否要进入拥塞处理。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sk-&gt;sk_err_soft = 0;
</span><span class='line'>icsk-&gt;icsk_probes_out = 0;
</span><span class='line'>tp-&gt;rcv_tstamp = tcp_time_stamp;
</span><span class='line'>//如果发送并且没有ack的数据段的值为0,则说明这个有可能是0窗口探测的回复，因此我们进入no_queue的处理，这个我们紧接着会详细介绍。
</span><span class='line'>prior_packets = tp-&gt;packets_out;
</span><span class='line'>if (!prior_packets)
</span><span class='line'>    goto no_queue;
</span><span class='line'>//清理重传队列中的已经ack的数据段。
</span><span class='line'>flag |= tcp_clean_rtx_queue(sk, prior_fackets, prior_snd_una);
</span><span class='line'>
</span><span class='line'>//处理F-RTO
</span><span class='line'>if (tp-&gt;frto_counter)
</span><span class='line'>    frto_cwnd = tcp_process_frto(sk, flag);
</span><span class='line'>
</span><span class='line'>if (before(tp-&gt;frto_highmark, tp-&gt;snd_una))
</span><span class='line'>    tp-&gt;frto_highmark = 0;
</span><span class='line'>//判断ack是否是可疑的。它主要是检测我们是否进入拥塞状态，或者已经处于拥塞状态。
</span><span class='line'>if (tcp_ack_is_dubious(sk, flag)) {
</span><span class='line'>//检测flag以及是否需要update拥塞窗口的大小。
</span><span class='line'>if ((flag & FLAG_DATA_ACKED) && !frto_cwnd &&
</span><span class='line'>    tcp_may_raise_cwnd(sk, flag))
</span><span class='line'>//如果都为真，则更新拥塞窗口。
</span><span class='line'>    tcp_cong_avoid(sk, ack, prior_in_flight);
</span><span class='line'>//这里进入拥塞状态的处理(这个函数是一个非常关键的函数,等到后面详细分析拥塞的时候，会分析到)。
</span><span class='line'>    tcp_fastretrans_alert(sk, prior_packets - tp-&gt;packets_out,flag);
</span><span class='line'>} else {
</span><span class='line'>//这里可以看到和上面相比，没有tcp_may_raise_cwnd这个，我们紧接着就会分析到。
</span><span class='line'>    if ((flag & FLAG_DATA_ACKED) && !frto_cwnd)
</span><span class='line'>        tcp_cong_avoid(sk, ack, prior_in_flight);
</span><span class='line'>}
</span><span class='line'>//是否更新neigh子系统。
</span><span class='line'>if ((flag & FLAG_FORWARD_PROGRESS) || !(flag & FLAG_NOT_DUP))
</span><span class='line'>    dst_confirm(sk-&gt;sk_dst_cache);
</span><span class='line'>
</span><span class='line'>return 1;
</span><span class='line'>
</span><span class='line'>no_queue:
</span><span class='line'>//这里判断发送缓冲区是否为空，如果不为空，则我们进入判断需要重启keepalive定时器还是关闭定时器
</span><span class='line'>    if (tcp_send_head(sk))
</span><span class='line'>        tcp_ack_probe(sk);
</span><span class='line'>    return 1;</span></code></pre></td></tr></table></div></figure>


<p>ok，，接着来看上面略过的几个函数，先来看tcp_ack_is_dubious，这里的条件我们一个个来看<br/>
1 说明flag不能是 FLAG_NOT_DUP的， FLAG_NOT_DUP表示我们的ack不是重复的。<br/>
2 是flag是CA_ALERT,它的意思是我们是否在我们进入拥塞状态时被alert。<br/>
3 拥塞状态不能为TCP_CA_OPEN不为这个，就说明我们已经进入了拥塞状态。<br/>
可以看下面这几个宏的定义，就比较清楚了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define FLAG_ACKED  (FLAG_DATA_ACKED|FLAG_SYN_ACKED)
</span><span class='line'>#define FLAG_NOT_DUP (FLAG_DATA|FLAG_WIN_UPDATE|FLAG_ACKED)
</span><span class='line'>
</span><span class='line'>//收到sack则说明可能有的段丢失了。而ECE则是路由器提示我们有拥塞了。我们必须处理。
</span><span class='line'>#define FLAG_CA_ALERT       (FLAG_DATA_SACKED|FLAG_ECE)</span></code></pre></td></tr></table></div></figure>


<p>上面的任意一个为真。就说明ack是可疑的。这里起始也可以说我们就必须进入拥塞的处理了(tcp_fastretrans_alert)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline int tcp_ack_is_dubious(const struct sock *sk, const int flag)
</span><span class='line'>{
</span><span class='line'>    return (!(flag & FLAG_NOT_DUP) || (flag & FLAG_CA_ALERT) ||inet_csk(sk)-&gt;icsk_ca_state != TCP_CA_Open);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>然后是 tcp_may_raise_cwnd，这个函数用来判断是否需要增大拥塞窗口。<br/>
1 不能有ECE flag或者发送的拥塞窗口不能大于slow start的阀值。<br/>
3 拥塞状态为RECO或者CWR.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline int tcp_may_raise_cwnd(const struct sock *sk, const int flag)
</span><span class='line'>{
</span><span class='line'>    const struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>    return (!(flag & FLAG_ECE) || tp-&gt;snd_cwnd &lt; tp-&gt;snd_ssthresh) &&!((1 &lt;&lt; inet_csk(sk)-&gt;icsk_ca_state) & (TCPF_CA_Recovery | TCPF_CA_CWR));
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在看tcp_ack_update_window函数之前，我们先来看tcp_may_update_window，这个函数用来判断是否需要更新发送窗口。<br/>
1 新的数据已经被ack了。<br/>
2 当前的数据包的序列号大于当窗口更新的时候那个数据包的序列号。<br/>
3 当前的数据包的序列号等于窗口更新时的序列号并且新的窗口大小大于当前的发送窗口大小。这个说明对端可能已经增加了窗口的大小</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static inline int tcp_may_update_window(const struct tcp_sock *tp,const u32 ack, const u32 ack_seq,const u32 nwin)
</span><span class='line'>{
</span><span class='line'>    return (after(ack, tp-&gt;snd_una) ||
</span><span class='line'>        after(ack_seq, tp-&gt;snd_wl1) ||
</span><span class='line'>        (ack_seq == tp-&gt;snd_wl1 && nwin &gt; tp-&gt;snd_wnd));
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>然后是tcp_ack_update_window函数，这个主要用来更新发送窗口的大小。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int tcp_ack_update_window(struct sock *sk, struct sk_buff *skb, u32 ack, u32 ack_seq)
</span><span class='line'>{
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>    int flag = 0;
</span><span class='line'>    //得到窗口的大小。
</span><span class='line'>    u32 nwin = ntohs(tcp_hdr(skb)-&gt;window);
</span><span class='line'>
</span><span class='line'>    if (likely(!tcp_hdr(skb)-&gt;syn))
</span><span class='line'>        nwin &lt;&lt;= tp-&gt;rx_opt.snd_wscale;
</span><span class='line'>
</span><span class='line'>    //判断是否需要update窗口。
</span><span class='line'>    if (tcp_may_update_window(tp, ack, ack_seq, nwin)) {
</span><span class='line'>        flag |= FLAG_WIN_UPDATE;
</span><span class='line'>    //更新snd_wl1
</span><span class='line'>        tcp_update_wl(tp, ack_seq);
</span><span class='line'>    //如果不等于，则说明我们需要更新窗口。
</span><span class='line'>        if (tp-&gt;snd_wnd != nwin) {
</span><span class='line'>            tp-&gt;snd_wnd = nwin;
</span><span class='line'>    ...................................
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    tp-&gt;snd_una = ack;
</span><span class='line'>    return flag;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>然后是tcp_cong_avoid函数，这个函数用来实现慢开始和快重传的拥塞算法。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void tcp_cong_avoid(struct sock *sk, u32 ack, u32 in_flight)
</span><span class='line'>{
</span><span class='line'>    const struct inet_connection_sock *icsk = inet_csk(sk);
</span><span class='line'>    icsk-&gt;icsk_ca_ops-&gt;cong_avoid(sk, ack, in_flight);
</span><span class='line'>    tcp_sk(sk)-&gt;snd_cwnd_stamp = tcp_time_stamp;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>可以看到它主要是调用cong_avoid回调函数，而这个函数被初始化为tcp_reno_cong_avoid，我们来看这个函数，在看这个函数之前我们要知道一些慢开始和快回复的概念。这些东西随便介绍tcp的书上都有介绍的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void tcp_reno_cong_avoid(struct sock *sk, u32 ack, u32 in_flight)
</span><span class='line'>{
</span><span class='line'>    struct tcp_sock *tp = tcp_sk(sk);
</span><span class='line'>    //是否已经到达拥塞窗口的限制。
</span><span class='line'>    if (!tcp_is_cwnd_limited(sk, in_flight))
</span><span class='line'>        return;
</span><span class='line'>    //如果拥塞窗口还没有到达慢开始的阈值，我们就进入慢开始处理。
</span><span class='line'>    if (tp-&gt;snd_cwnd &lt;= tp-&gt;snd_ssthresh)
</span><span class='line'>        tcp_slow_start(tp);
</span><span class='line'>
</span><span class='line'>    //否则我们就要进入拥塞避免阶段。
</span><span class='line'>    else if (sysctl_tcp_abc) {
</span><span class='line'>    //RFC3465,只有当当前的拥塞窗口的所有段都被ack了，窗口才被允许增加。
</span><span class='line'>    if (tp-&gt;bytes_acked &gt;= tp-&gt;snd_cwnd*tp-&gt;mss_cache) {
</span><span class='line'>        tp-&gt;bytes_acked -= tp-&gt;snd_cwnd*tp-&gt;mss_cache;
</span><span class='line'>            if (tp-&gt;snd_cwnd &lt; tp-&gt;snd_cwnd_clamp)
</span><span class='line'>                tp-&gt;snd_cwnd++;
</span><span class='line'>        }
</span><span class='line'>    } else {
</span><span class='line'>    //和上面处理方式类似。
</span><span class='line'>        tcp_cong_avoid_ai(tp, tp-&gt;snd_cwnd);
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>最后我们来看tcp_clean_rtx_queue函数，这个函数主要用于清理发送队列中已经被ack的数据段。函数比较大，我们来分段看。<br/>
这里有使用karn算法，也就是如果重传的段，则计算rto的话，不采样这次的值。<br/>
还有就是要判断是syn的ack回复，还是数据的ack回复。以及sack的判断。<br/>
首先是遍历部分：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>while ((skb = tcp_write_queue_head(sk)) && skb != tcp_send_head(sk)) {
</span><span class='line'>    struct tcp_skb_cb *scb = TCP_SKB_CB(skb);
</span><span class='line'>    u32 acked_pcount;
</span><span class='line'>    u8 sacked = scb-&gt;sacked;
</span><span class='line'>    //这个说明当前的数据已经在发送未确认的段里面了。
</span><span class='line'>    if (after(scb-&gt;end_seq, tp-&gt;snd_una)) {
</span><span class='line'>        //这边不是很懂。
</span><span class='line'>        if (tcp_skb_pcount(skb) == 1 ||
</span><span class='line'>            !after(tp-&gt;snd_una, scb-&gt;seq))
</span><span class='line'>            break;
</span><span class='line'>        acked_pcount = tcp_tso_acked(sk, skb);
</span><span class='line'>        if (!acked_pcount)
</span><span class='line'>            break;
</span><span class='line'>        fully_acked = 0;
</span><span class='line'>    } else {
</span><span class='line'>        acked_pcount = tcp_skb_pcount(skb);
</span><span class='line'>    }
</span><span class='line'>    //如果sack的状态有被设置重传，则我们会使用karn算法。
</span><span class='line'>    if (sacked & TCPCB_RETRANS) {
</span><span class='line'>        //如果标记为sack了重传段，则更新重传的计数。
</span><span class='line'>        if (sacked & TCPCB_SACKED_RETRANS)
</span><span class='line'>            tp-&gt;retrans_out -= acked_pcount;
</span><span class='line'>        flag |= FLAG_RETRANS_DATA_ACKED;
</span><span class='line'>
</span><span class='line'>        //都为-1，也就是后面计算rtt，不会采样这次值。
</span><span class='line'>        ca_seq_rtt = -1;
</span><span class='line'>        seq_rtt = -1;
</span><span class='line'>            if ((flag & FLAG_DATA_ACKED) || (acked_pcount &gt; 1))
</span><span class='line'>        flag |= FLAG_NONHEAD_RETRANS_ACKED;
</span><span class='line'>    } else {
</span><span class='line'>        //否则根据时间戳得到对应的rtt
</span><span class='line'>        ca_seq_rtt = now - scb-&gt;when;
</span><span class='line'>        last_ackt = skb-&gt;tstamp;
</span><span class='line'>        if (seq_rtt &lt; 0) {
</span><span class='line'>            seq_rtt = ca_seq_rtt;
</span><span class='line'>        }
</span><span class='line'>        if (!(sacked & TCPCB_SACKED_ACKED))
</span><span class='line'>            reord = min(pkts_acked, reord);
</span><span class='line'>    }
</span><span class='line'>    //如果有sack的数据包被ack确认了，则我们需要减小sack的计数
</span><span class='line'>    if (sacked & TCPCB_SACKED_ACKED)
</span><span class='line'>        tp-&gt;sacked_out -= acked_pcount;
</span><span class='line'>    if (sacked & TCPCB_LOST)
</span><span class='line'>        tp-&gt;lost_out -= acked_pcount;
</span><span class='line'>    //总得发送为ack的数据字节计数更新。
</span><span class='line'>    tp-&gt;packets_out -= acked_pcount;
</span><span class='line'>    pkts_acked += acked_pcount;
</span><span class='line'>    //判断是否为syn的ack。
</span><span class='line'>    if (!(scb-&gt;flags & TCPCB_FLAG_SYN)) {
</span><span class='line'>        flag |= FLAG_DATA_ACKED;
</span><span class='line'>    } else {
</span><span class='line'>        //如果是设置标记
</span><span class='line'>        flag |= FLAG_SYN_ACKED;
</span><span class='line'>        tp-&gt;retrans_stamp = 0;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    if (!fully_acked)
</span><span class='line'>        break;
</span><span class='line'>    //从写buf，unlink掉。
</span><span class='line'>    tcp_unlink_write_queue(skb, sk);
</span><span class='line'>    //释放内存。
</span><span class='line'>    sk_wmem_free_skb(sk, skb);
</span><span class='line'>    tp-&gt;scoreboard_skb_hint = NULL;
</span><span class='line'>    if (skb == tp-&gt;retransmit_skb_hint)
</span><span class='line'>        tp-&gt;retransmit_skb_hint = NULL;
</span><span class='line'>    if (skb == tp-&gt;lost_skb_hint)
</span><span class='line'>        tp-&gt;lost_skb_hint = NULL;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>剩下的部分就是计算rtt的部分，这里就不介绍了。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2013/08/29/tools-git-svn-base/">git-svn</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-08-29T14:37:00+08:00'><span class='date'>2013-08-29</span> <span class='time'>14:37:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h4>常用</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1、git-svn clone your_svn_repository
</span><span class='line'>2、git add/commit
</span><span class='line'>3、git-svn rebase    获取中心svn repository的更新；
</span><span class='line'>4、git-svn dcommit   将本地git库的修改同步到中心svn库。</span></code></pre></td></tr></table></div></figure>


<hr />

<p>git-svn默认包含在Git的安装包中，不过在Ubuntu中，git-svn是作为一个独立的Package需要额外安装的(sudo apt-get install git-svn)。安装后你就可以使用git svn xxx命令来操作中心SVN代码库了。当然如果你要使用与git svn等价的git-svn命令的话，你还需要将/usr/lib/git-core配置到你的PATH环境变量中，否则Shell会提示你无法找到 git-svn这个命令。</p>

<ul>
<li><p>检出一个已存在svn repository(类似于svn checkout)<br/>
我们可以通过git-svn clone命令完成这个操作： git-svn clone your_svn_repository_url</p></li>
<li><p>从中心服务器的svn repository获取最新更新<br/>
这个操作可以通过"git-svn rebase"完成。注意这里用的是rebase，而不是update。update命令对于通过git-svn检出的svn repostory的git版本库是不可用的。</p></li>
<li><p>查看提交历史日志<br/>
这个简单，使用"git-svn log"，加上-v选项，还可以提供每次commit操作涉及的相关文件的详细信息。</p></li>
<li><p>将本地代码同步到Svn服务器<br/>
完成这一操作需要通过"git-svn dcommit"命令。这个命令会将你在本地使用git commit提交到本地代码库的所有更改逐一提交到svn库中。加上-n选项，则该命令不会真正执行commit到svn的操作，而是会显示会有哪些本地 变动将被commit到svn服务器。git-svn dcommit似乎不能单独提交某个本地版本的修改，而是一次批量提交所有与svn中心版本库的差异。</p></li>
</ul>


<h5>下面是一个git-svn的一般使用流程：</h5>

<p>1、git-svn clone your_svn_repository；<br/>
2、修改本地代码，使用git add/commit将修改提交到本地git库；<br/>
3、定期使用git-svn rebase获取中心svn repository的更新；<br/>
4、使用git-svn dcommit命令将本地git库的修改同步到中心svn库。</p>

<h5>冲突</h5>

<p>使用git-svn处理代码冲突的步骤有些繁琐，不过瑕不掩瑜吧。这里用一个小例子来说明一下。</p>

<p>假设某svn中心库上的某个项目foo中只有一个源码文件foo.c：<br/>
* 我在使用git-svn clone检出版本时，foo.c当时只有一个commit版本信息："svn v1"；<br/>
* clone出来后，我在本地git库中修改foo.c，并通过git commit提交到本地git库中，版本为"git v1"；<br/>
* 不过与此同时另外一个同事也在修改foo.c这个文件，并已经将他的修改提交到了svn库中，版本为"svn v2"；<br/>
* 此时我使用git-svn dcommit尝试提交我的改动，git-svn提示我：<br/>
  Committing to svn://10.10.1.1:80/foo &hellip;<br/>
  M foo.c<br/>
  事务过时: 过期: ”foo/foo.c“在事务“260-1” at /usr/lib/git-core/git-svn line 570<br/>
* 使用git-svn rebase获取svn服务器上的最新foo.c，导致与foo.c冲突，不过此时svn版本信息已经添加到本地git库中(通过git log可以查看)，git-svn rebase提示你在解决foo.c的冲突后，运行git rebase &ndash;continue完成rebase操作；<br/>
* 打开foo.c，修改代码，解决冲突；<br/>
* 执行git rebase &ndash;continue，git提示我：<br/>
    You must edit all merge conflicts and then<br/>
    mark them as resolved using git add<br/>
* 执行git add foo.c，告知git已完成冲突解决；<br/>
* 再次执行git rebase &ndash;continue，提示"Applying: git v1"，此时"git v1"版本又一次成功加入本地版本库，你可通过git log查看；<br/>
* 执行git-svn dcommit将foo.c的改动同步到svn中心库，到此算是完成一次冲突解决。</p>

<ul>
<li>设置忽略文件<br/>
要忽略某些文件, 需要首先执行如下命令:<br/>
git config &ndash;global core.excludesfile ~/.gitignore<br/>
然后编辑 vi ~/.gitignore.<br/>
例如: 需要忽略vim的临时文件，就写:<br/>
.*.swp</li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h2 class="entry-title"><a href="/blog/2013/08/26/kernel-pcap-decode-code/">解析pcap数据包格式(code)</a></h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-08-26T11:17:00+08:00'><span class='date'>2013-08-26</span> <span class='time'>11:17:00</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
<span class='line-number'>206</span>
<span class='line-number'>207</span>
<span class='line-number'>208</span>
<span class='line-number'>209</span>
<span class='line-number'>210</span>
<span class='line-number'>211</span>
<span class='line-number'>212</span>
<span class='line-number'>213</span>
<span class='line-number'>214</span>
<span class='line-number'>215</span>
<span class='line-number'>216</span>
<span class='line-number'>217</span>
<span class='line-number'>218</span>
<span class='line-number'>219</span>
<span class='line-number'>220</span>
<span class='line-number'>221</span>
<span class='line-number'>222</span>
<span class='line-number'>223</span>
<span class='line-number'>224</span>
<span class='line-number'>225</span>
<span class='line-number'>226</span>
<span class='line-number'>227</span>
<span class='line-number'>228</span>
<span class='line-number'>229</span>
<span class='line-number'>230</span>
<span class='line-number'>231</span>
<span class='line-number'>232</span>
<span class='line-number'>233</span>
<span class='line-number'>234</span>
<span class='line-number'>235</span>
<span class='line-number'>236</span>
<span class='line-number'>237</span>
<span class='line-number'>238</span>
<span class='line-number'>239</span>
<span class='line-number'>240</span>
<span class='line-number'>241</span>
<span class='line-number'>242</span>
<span class='line-number'>243</span>
<span class='line-number'>244</span>
<span class='line-number'>245</span>
<span class='line-number'>246</span>
<span class='line-number'>247</span>
<span class='line-number'>248</span>
<span class='line-number'>249</span>
<span class='line-number'>250</span>
<span class='line-number'>251</span>
<span class='line-number'>252</span>
<span class='line-number'>253</span>
<span class='line-number'>254</span>
<span class='line-number'>255</span>
<span class='line-number'>256</span>
<span class='line-number'>257</span>
<span class='line-number'>258</span>
<span class='line-number'>259</span>
<span class='line-number'>260</span>
<span class='line-number'>261</span>
<span class='line-number'>262</span>
<span class='line-number'>263</span>
<span class='line-number'>264</span>
<span class='line-number'>265</span>
<span class='line-number'>266</span>
<span class='line-number'>267</span>
<span class='line-number'>268</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>#include &lt;arpa/inet.h&gt;
</span><span class='line'>#include &lt;stdlib.h&gt;
</span><span class='line'>#include &lt;string.h&gt;
</span><span class='line'>#include &lt;linux/types.h&gt;
</span><span class='line'>
</span><span class='line'>typedef unsigned int  bpf_u_int32;
</span><span class='line'>typedef unsigned short  u_short;
</span><span class='line'>typedef int bpf_int32;
</span><span class='line'>typedef struct pcap_file_header {
</span><span class='line'>    bpf_u_int32 magic;
</span><span class='line'>    u_short version_major;
</span><span class='line'>    u_short version_minor;
</span><span class='line'>    bpf_int32 thiszone;
</span><span class='line'>    bpf_u_int32 sigfigs;   
</span><span class='line'>    bpf_u_int32 snaplen;   
</span><span class='line'>    bpf_u_int32 linktype;  
</span><span class='line'>}pcap_file_header;
</span><span class='line'> 
</span><span class='line'>typedef struct  timestamp{
</span><span class='line'>    bpf_u_int32 timestamp_s;
</span><span class='line'>    bpf_u_int32 timestamp_ms;
</span><span class='line'>}timestamp;
</span><span class='line'> 
</span><span class='line'>typedef struct pcap_header{
</span><span class='line'>    timestamp ts;
</span><span class='line'>    bpf_u_int32 capture_len;
</span><span class='line'>    bpf_u_int32 len;
</span><span class='line'> 
</span><span class='line'>}pcap_header;
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>#define ETH_ALEN 6
</span><span class='line'>#define __LITTLE_ENDIAN_BITFIELD 1
</span><span class='line'>#define NIPQUAD(addr) \
</span><span class='line'>        ((unsigned char *)&addr)[0], \
</span><span class='line'>        ((unsigned char *)&addr)[1], \
</span><span class='line'>        ((unsigned char *)&addr)[2], \
</span><span class='line'>        ((unsigned char *)&addr)[3]
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>struct ethhdr {
</span><span class='line'>    unsigned char h_dest[ETH_ALEN];       /* destination eth addr */
</span><span class='line'>    unsigned char h_source[ETH_ALEN];     /* source ether addr    */
</span><span class='line'>    unsigned short    h_proto;                /* packet type ID field */
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>struct iphdr {
</span><span class='line'>#if defined(__LITTLE_ENDIAN_BITFIELD)
</span><span class='line'>    __u8  ihl:4,
</span><span class='line'>            version:4;
</span><span class='line'>#elif defined (__BIG_ENDIAN_BITFIELD)
</span><span class='line'>    __u8  version:4,
</span><span class='line'>            ihl:4;
</span><span class='line'>#endif
</span><span class='line'>    __u8    tos;
</span><span class='line'>    __be16  tot_len;
</span><span class='line'>    __be16  id;
</span><span class='line'>    __be16  frag_off;
</span><span class='line'>    __u8    ttl;
</span><span class='line'>    __u8    protocol;
</span><span class='line'>    __u16   check;
</span><span class='line'>    __be32  saddr;
</span><span class='line'>    __be32  daddr;
</span><span class='line'>    /*The options start here. */
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>struct tcphdr {
</span><span class='line'>    __u16   source;
</span><span class='line'>    __u16   dest;
</span><span class='line'>    __u32   seq;
</span><span class='line'>    __u32   ack_seq;
</span><span class='line'>#if defined(__LITTLE_ENDIAN_BITFIELD)
</span><span class='line'>    __u16   res1:4,
</span><span class='line'>            doff:4,
</span><span class='line'>            fin:1,
</span><span class='line'>            syn:1,
</span><span class='line'>            rst:1,
</span><span class='line'>            psh:1,
</span><span class='line'>            ack:1,
</span><span class='line'>            urg:1,
</span><span class='line'>            ece:1,
</span><span class='line'>            cwr:1;
</span><span class='line'>#elif defined(__BIG_ENDIAN_BITFIELD)
</span><span class='line'>    __u16   doff:4,
</span><span class='line'>            res1:4,
</span><span class='line'>            cwr:1,
</span><span class='line'>            ece:1,
</span><span class='line'>            urg:1,
</span><span class='line'>            ack:1,
</span><span class='line'>            psh:1,
</span><span class='line'>            rst:1,
</span><span class='line'>            syn:1,
</span><span class='line'>            fin:1;
</span><span class='line'>#endif  
</span><span class='line'>    __u16   window;
</span><span class='line'>    __u16   check;
</span><span class='line'>    __u16   urg_ptr;
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>struct udphdr {
</span><span class='line'>    __u16   source;
</span><span class='line'>    __u16   dest;
</span><span class='line'>    __u16   len;
</span><span class='line'>    __u16   check;
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>struct icmphdr {
</span><span class='line'>    __u8  type;
</span><span class='line'>    __u8  code;
</span><span class='line'>    __u16 checksum;
</span><span class='line'>    union {
</span><span class='line'>        struct {
</span><span class='line'>            __u16   id;
</span><span class='line'>            __u16   sequence;
</span><span class='line'>        } echo;
</span><span class='line'>        __u32   gateway;
</span><span class='line'>        struct {
</span><span class='line'>            __u16   __unused;
</span><span class='line'>            __u16   mtu;
</span><span class='line'>        } frag;
</span><span class='line'>    } un;
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>FILE *fp1, *fp2;
</span><span class='line'>__u32 flag1, flag2, seq1, seq2, ip1, ip2;
</span><span class='line'>long long stime;
</span><span class='line'>
</span><span class='line'>void printPcap(int count, void * data, struct pcap_header *ph)
</span><span class='line'>{
</span><span class='line'>    size_t size = ph-&gt;capture_len;
</span><span class='line'>    unsigned  short iPos = 0;
</span><span class='line'>    struct ethhdr *eth;
</span><span class='line'>    struct iphdr *iph;
</span><span class='line'>    struct tcphdr *tcph;
</span><span class='line'>    struct udphdr *udph;
</span><span class='line'>    struct icmphdr *icmph;
</span><span class='line'>    __u8 op1, op2, type, len;
</span><span class='line'>    void * data1;
</span><span class='line'>    int i;
</span><span class='line'>    long long dt;
</span><span class='line'>
</span><span class='line'>    if (data==NULL) {
</span><span class='line'>        return;
</span><span class='line'>    }
</span><span class='line'>    eth = (struct ethhdr*)(data);
</span><span class='line'>    eth-&gt;h_proto = ntohs(eth-&gt;h_proto);
</span><span class='line'>    //printf("Ether:\tproto = 0x%x\n", eth-&gt;h_proto);
</span><span class='line'>    if (eth-&gt;h_proto == 0x0800) { // IP
</span><span class='line'>        iph = (struct iphdr*)(data+sizeof(struct ethhdr));
</span><span class='line'>        if (iph-&gt;protocol == IPPROTO_TCP) { // tcp
</span><span class='line'>            tcph = (struct tcphdr*)(data+sizeof(struct ethhdr)+sizeof(struct iphdr));
</span><span class='line'>            if (tcph-&gt;ack == 0 && tcph-&gt;syn == 1) {
</span><span class='line'>                seq1 = ntohl(tcph-&gt;seq);
</span><span class='line'>                ip1 = iph-&gt;saddr;
</span><span class='line'>                flag1 = 1;
</span><span class='line'>                stime = 1000000LL*ph-&gt;ts.timestamp_s + ph-&gt;ts.timestamp_ms;
</span><span class='line'>            } else if (tcph-&gt;ack == 1 && tcph-&gt;syn == 1) {
</span><span class='line'>                seq2 = ntohl(tcph-&gt;seq);
</span><span class='line'>                ip2 = iph-&gt;saddr;
</span><span class='line'>                flag2 = 1;
</span><span class='line'>            }
</span><span class='line'>
</span><span class='line'>            if (flag1 == 0) {
</span><span class='line'>                flag1 = 1;
</span><span class='line'>                seq1 = ntohl(tcph-&gt;seq)-1;
</span><span class='line'>                ip1 = iph-&gt;saddr;
</span><span class='line'>                stime = 1000000LL*ph-&gt;ts.timestamp_s + ph-&gt;ts.timestamp_ms;
</span><span class='line'>            }
</span><span class='line'>            if (flag2 == 0 && iph-&gt;saddr != ip1) {
</span><span class='line'>                flag2 = 1;
</span><span class='line'>                seq2 = ntohl(tcph-&gt;seq)-1;
</span><span class='line'>                ip2 = iph-&gt;saddr;
</span><span class='line'>            }
</span><span class='line'>
</span><span class='line'>            dt = (1000000LL*ph-&gt;ts.timestamp_s+ph-&gt;ts.timestamp_ms) - stime;
</span><span class='line'>            fprintf(fp1, "%d\t%llu\t", count, dt/1000);
</span><span class='line'>            fprintf(fp1, "%d.%d.%d.%d\t%d.%d.%d.%d\t%u\t%u\t%d\t",
</span><span class='line'>                        NIPQUAD(iph-&gt;saddr), NIPQUAD(iph-&gt;daddr),
</span><span class='line'>                        (iph-&gt;saddr==ip1?ntohl(tcph-&gt;seq)-seq1:ntohl(tcph-&gt;seq)-seq2),
</span><span class='line'>                        (iph-&gt;saddr==ip1?ntohl(tcph-&gt;ack_seq)-seq2:ntohl(tcph-&gt;ack_seq)-seq1),
</span><span class='line'>                        ntohs(iph-&gt;tot_len)-iph-&gt;ihl*4-tcph-&gt;doff*4 + tcph-&gt;syn + tcph-&gt;fin);
</span><span class='line'>            fprintf(fp1, "%d\t%d\t%d\t%d\t", ntohs(iph-&gt;tot_len), iph-&gt;ihl*4, tcph-&gt;doff*4, iph-&gt;ttl);
</span><span class='line'>            fprintf(fp1, "%u\t%u\t%d\t%d\t%d\t",
</span><span class='line'>                        ntohl(tcph-&gt;seq), ntohl(tcph-&gt;ack_seq),
</span><span class='line'>                        tcph-&gt;ack, tcph-&gt;syn, ntohs(tcph-&gt;window));
</span><span class='line'>
</span><span class='line'>            if (tcph-&gt;doff &gt; 5) {
</span><span class='line'>                data1 = data + sizeof(struct ethhdr)+sizeof(struct iphdr)+sizeof(struct tcphdr);
</span><span class='line'>                op1 = *(__u8*)(data1);
</span><span class='line'>                op2 = *(__u8*)(data1+1);
</span><span class='line'>                type = *(__u8*)(data1+2);
</span><span class='line'>                len = *(__u8*)(data1+3);
</span><span class='line'>                //fprintf(fp1, "%u\t%u\t%u\t%u\n", op1, op2, type, len);
</span><span class='line'>                if (op1 == 1 && op2 == 1 && type == 5) { // sack
</span><span class='line'>                    i = 4;
</span><span class='line'>                    while (i &lt; len+2) {
</span><span class='line'>                        if (i &gt; 4) fprintf(fp1, " ");
</span><span class='line'>                        fprintf(fp1, "%u-%u", ntohl(*(__u32*)(data1+i))-seq2, ntohl(*(__u32*)(data1+i+4))-seq2);
</span><span class='line'>                        i += 8;
</span><span class='line'>                    }
</span><span class='line'>                }
</span><span class='line'>            }
</span><span class='line'>            fprintf(fp1, "\n");
</span><span class='line'>
</span><span class='line'>        } else if (iph-&gt;protocol == IPPROTO_UDP) { // udp
</span><span class='line'>            udph = (struct udphdr*)(data+sizeof(struct ethhdr)+sizeof(struct iphdr));
</span><span class='line'>            //printf("UDP:\tsource=%u\tdest=%u\tlen=%d\n", ntohs(udph-&gt;source), ntohs(udph-&gt;dest), ntohs(udph-&gt;len));
</span><span class='line'>        } else if (iph-&gt;protocol == IPPROTO_ICMP) { // ICMP
</span><span class='line'>            icmph = (struct icmphdr*)(data+sizeof(struct ethhdr)+sizeof(struct iphdr));
</span><span class='line'>            //printf("ICMP:\ttype=%u\tcode=%u\n", icmph-&gt;type, icmph-&gt;code);
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>#define MAX_ETH_FRAME 1514000
</span><span class='line'>int main (int argc, const char * argv[])
</span><span class='line'>{
</span><span class='line'>    pcap_file_header  pfh;
</span><span class='line'>    pcap_header  ph;
</span><span class='line'>    int count=0;
</span><span class='line'>    void * buff = NULL;
</span><span class='line'>    int readSize=0;
</span><span class='line'>    int ret = 0;
</span><span class='line'> 
</span><span class='line'>     if (argc != 2) {
</span><span class='line'>         printf("uage: ./a.out pcap_filename\n");
</span><span class='line'>         return -1;
</span><span class='line'>     }
</span><span class='line'>    FILE *fp = fopen(argv[1], "r");
</span><span class='line'>    if (fp==NULL) {
</span><span class='line'>        fprintf(stderr, "Open file %s error.", argv[1]);
</span><span class='line'>        return -1;
</span><span class='line'>    }
</span><span class='line'>    fread(&pfh, sizeof(pcap_file_header), 1, fp);
</span><span class='line'> 
</span><span class='line'>    fp1 = fopen("out", "w");
</span><span class='line'>    fprintf(fp1, "#ID\tTIME\tsaddr\tdaddr\tseq\tack_seq\tpayload\ttot_len\tihl\tdoff\tttl\tseq\tack_seq\tack\tsyn\twin\tSACK\n");
</span><span class='line'>    buff = (void *)malloc(MAX_ETH_FRAME);
</span><span class='line'>    flag1 = flag2 = 0;
</span><span class='line'>
</span><span class='line'>    for (count=1; ; count++) {
</span><span class='line'>        memset(buff,0,MAX_ETH_FRAME);
</span><span class='line'>        readSize=fread(&ph, sizeof(pcap_header), 1, fp);
</span><span class='line'>        if (readSize&lt;=0) {
</span><span class='line'>            break;
</span><span class='line'>        }
</span><span class='line'>        if (buff==NULL) {
</span><span class='line'>            fprintf(stderr, "malloc memory failed.\n");
</span><span class='line'>            return -1;
</span><span class='line'>        }
</span><span class='line'> 
</span><span class='line'>        readSize=fread(buff,1,ph.capture_len, fp);
</span><span class='line'>        if (readSize != ph.capture_len) {
</span><span class='line'>            free(buff);
</span><span class='line'>            fprintf(stderr, "pcap file parse error.\n");
</span><span class='line'>            return -1;
</span><span class='line'>        }
</span><span class='line'>        printPcap(count, buff, &ph);
</span><span class='line'>
</span><span class='line'>        if (feof(fp) || readSize &lt;=0 ) {
</span><span class='line'>            break;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    fclose(fp);
</span><span class='line'>    fclose(fp1);
</span><span class='line'>    return ret;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>



</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/31">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/29">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
<h1>Categories</h1>
<head>
</head>
<body>
<div id="menu">
<ul>
<li class='catclass'><a href='/blog/cats/language/'>language</a><a href='##' onmousedown=showDiv('language') id='aexp_language'><span class='exp_style' id='exp_language'>[+]</span></a><span class='right_span'>(38)</span></li>
<div id='language' class='catsub'><li><a href='/blog/cats/language~c/?opendiv=language'>c</a><a href='##' onmousedown=showDiv('language~c') id='aexp_language~c'><span class='exp_style' id='exp_language~c'>[+]</span></a><span class='right_span'>21</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('language~c')) document.getElementById('aexp_language~c').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/language~java/?opendiv=language'>java</a><a href='##' onmousedown=showDiv('language~java') id='aexp_language~java'><span class='exp_style' id='exp_language~java'>[+]</span></a><span class='right_span'>11</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('language~java')) document.getElementById('aexp_language~java').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/language~web/?opendiv=language'>web</a><a href='##' onmousedown=showDiv('language~web') id='aexp_language~web'><span class='exp_style' id='exp_language~web'>[+]</span></a><span class='right_span'>6</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('language')) document.getElementById('aexp_language').style.visibility = 'hidden';
if (!document.getElementById('language~web')) document.getElementById('aexp_language~web').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/compiler/'>compiler</a><a href='##' onmousedown=showDiv('compiler') id='aexp_compiler'><span class='exp_style' id='exp_compiler'>[+]</span></a><span class='right_span'>(14)</span></li>
<div id='compiler' class='catsub'><li><a href='/blog/cats/compiler~base/?opendiv=compiler'>base</a><a href='##' onmousedown=showDiv('compiler~base') id='aexp_compiler~base'><span class='exp_style' id='exp_compiler~base'>[+]</span></a><span class='right_span'>10</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('compiler~base')) document.getElementById('aexp_compiler~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/compiler~make/?opendiv=compiler'>make</a><a href='##' onmousedown=showDiv('compiler~make') id='aexp_compiler~make'><span class='exp_style' id='exp_compiler~make'>[+]</span></a><span class='right_span'>4</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('compiler')) document.getElementById('aexp_compiler').style.visibility = 'hidden';
if (!document.getElementById('compiler~make')) document.getElementById('aexp_compiler~make').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/assembly/'>assembly</a><a href='##' onmousedown=showDiv('assembly') id='aexp_assembly'><span class='exp_style' id='exp_assembly'>[+]</span></a><span class='right_span'>(12)</span></li>
<div id='assembly' class='catsub'><li><a href='/blog/cats/assembly~base/?opendiv=assembly'>base</a><a href='##' onmousedown=showDiv('assembly~base') id='aexp_assembly~base'><span class='exp_style' id='exp_assembly~base'>[+]</span></a><span class='right_span'>12</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('assembly')) document.getElementById('aexp_assembly').style.visibility = 'hidden';
if (!document.getElementById('assembly~base')) document.getElementById('aexp_assembly~base').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/tools/'>tools</a><a href='##' onmousedown=showDiv('tools') id='aexp_tools'><span class='exp_style' id='exp_tools'>[+]</span></a><span class='right_span'>(37)</span></li>
<div id='tools' class='catsub'><li><a href='/blog/cats/tools~base/?opendiv=tools'>base</a><a href='##' onmousedown=showDiv('tools~base') id='aexp_tools~base'><span class='exp_style' id='exp_tools~base'>[+]</span></a><span class='right_span'>13</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~base')) document.getElementById('aexp_tools~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~ci/?opendiv=tools'>ci</a><a href='##' onmousedown=showDiv('tools~ci') id='aexp_tools~ci'><span class='exp_style' id='exp_tools~ci'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~ci')) document.getElementById('aexp_tools~ci').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~command/?opendiv=tools'>command</a><a href='##' onmousedown=showDiv('tools~command') id='aexp_tools~command'><span class='exp_style' id='exp_tools~command'>[+]</span></a><span class='right_span'>7</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~command')) document.getElementById('aexp_tools~command').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~git/?opendiv=tools'>git</a><a href='##' onmousedown=showDiv('tools~git') id='aexp_tools~git'><span class='exp_style' id='exp_tools~git'>[+]</span></a><span class='right_span'>6</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~git')) document.getElementById('aexp_tools~git').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~mysql/?opendiv=tools'>mysql</a><a href='##' onmousedown=showDiv('tools~mysql') id='aexp_tools~mysql'><span class='exp_style' id='exp_tools~mysql'>[+]</span></a><span class='right_span'>6</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('tools~mysql')) document.getElementById('aexp_tools~mysql').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/tools~ssh/?opendiv=tools'>ssh</a><a href='##' onmousedown=showDiv('tools~ssh') id='aexp_tools~ssh'><span class='exp_style' id='exp_tools~ssh'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('tools')) document.getElementById('aexp_tools').style.visibility = 'hidden';
if (!document.getElementById('tools~ssh')) document.getElementById('aexp_tools~ssh').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/system/'>system</a><a href='##' onmousedown=showDiv('system') id='aexp_system'><span class='exp_style' id='exp_system'>[+]</span></a><span class='right_span'>(22)</span></li>
<div id='system' class='catsub'><li><a href='/blog/cats/system~base/?opendiv=system'>base</a><a href='##' onmousedown=showDiv('system~base') id='aexp_system~base'><span class='exp_style' id='exp_system~base'>[+]</span></a><span class='right_span'>9</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~base')) document.getElementById('aexp_system~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~centos/?opendiv=system'>centos</a><a href='##' onmousedown=showDiv('system~centos') id='aexp_system~centos'><span class='exp_style' id='exp_system~centos'>[+]</span></a><span class='right_span'>5</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('system~centos')) document.getElementById('aexp_system~centos').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/system~ubuntu/?opendiv=system'>ubuntu</a><a href='##' onmousedown=showDiv('system~ubuntu') id='aexp_system~ubuntu'><span class='exp_style' id='exp_system~ubuntu'>[+]</span></a><span class='right_span'>8</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('system')) document.getElementById('aexp_system').style.visibility = 'hidden';
if (!document.getElementById('system~ubuntu')) document.getElementById('aexp_system~ubuntu').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/kernel/'>kernel</a><a href='##' onmousedown=showDiv('kernel') id='aexp_kernel'><span class='exp_style' id='exp_kernel'>[+]</span></a><span class='right_span'>(36)</span></li>
<div id='kernel' class='catsub'><li><a href='/blog/cats/kernel~base/?opendiv=kernel'>base</a><a href='##' onmousedown=showDiv('kernel~base') id='aexp_kernel~base'><span class='exp_style' id='exp_kernel~base'>[+]</span></a><span class='right_span'>12</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~base')) document.getElementById('aexp_kernel~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~kexec/?opendiv=kernel'>kexec</a><a href='##' onmousedown=showDiv('kernel~kexec') id='aexp_kernel~kexec'><span class='exp_style' id='exp_kernel~kexec'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~kexec')) document.getElementById('aexp_kernel~kexec').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~mm/?opendiv=kernel'>mm</a><a href='##' onmousedown=showDiv('kernel~mm') id='aexp_kernel~mm'><span class='exp_style' id='exp_kernel~mm'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~mm')) document.getElementById('aexp_kernel~mm').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~net/?opendiv=kernel'>net</a><a href='##' onmousedown=showDiv('kernel~net') id='aexp_kernel~net'><span class='exp_style' id='exp_kernel~net'>[+]</span></a><span class='right_span'>9</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel~net')) document.getElementById('aexp_kernel~net').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/kernel~sched/?opendiv=kernel'>sched</a><a href='##' onmousedown=showDiv('kernel~sched') id='aexp_kernel~sched'><span class='exp_style' id='exp_kernel~sched'>[+]</span></a><span class='right_span'>11</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('kernel')) document.getElementById('aexp_kernel').style.visibility = 'hidden';
if (!document.getElementById('kernel~sched')) document.getElementById('aexp_kernel~sched').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/android/'>android</a><a href='##' onmousedown=showDiv('android') id='aexp_android'><span class='exp_style' id='exp_android'>[+]</span></a><span class='right_span'>(17)</span></li>
<div id='android' class='catsub'><li><a href='/blog/cats/android~base/?opendiv=android'>base</a><a href='##' onmousedown=showDiv('android~base') id='aexp_android~base'><span class='exp_style' id='exp_android~base'>[+]</span></a><span class='right_span'>8</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~base')) document.getElementById('aexp_android~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~i9507v/?opendiv=android'>i9507v</a><a href='##' onmousedown=showDiv('android~i9507v') id='aexp_android~i9507v'><span class='exp_style' id='exp_android~i9507v'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~i9507v')) document.getElementById('aexp_android~i9507v').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~me722/?opendiv=android'>me722</a><a href='##' onmousedown=showDiv('android~me722') id='aexp_android~me722'><span class='exp_style' id='exp_android~me722'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~me722')) document.getElementById('aexp_android~me722').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~nx403a/?opendiv=android'>nx403a</a><a href='##' onmousedown=showDiv('android~nx403a') id='aexp_android~nx403a'><span class='exp_style' id='exp_android~nx403a'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('android~nx403a')) document.getElementById('aexp_android~nx403a').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/android~s5830/?opendiv=android'>s5830</a><a href='##' onmousedown=showDiv('android~s5830') id='aexp_android~s5830'><span class='exp_style' id='exp_android~s5830'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('android')) document.getElementById('aexp_android').style.visibility = 'hidden';
if (!document.getElementById('android~s5830')) document.getElementById('aexp_android~s5830').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/debug/'>debug</a><a href='##' onmousedown=showDiv('debug') id='aexp_debug'><span class='exp_style' id='exp_debug'>[+]</span></a><span class='right_span'>(48)</span></li>
<div id='debug' class='catsub'><li><a href='/blog/cats/debug~base/?opendiv=debug'>base</a><a href='##' onmousedown=showDiv('debug~base') id='aexp_debug~base'><span class='exp_style' id='exp_debug~base'>[+]</span></a><span class='right_span'>16</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~base')) document.getElementById('aexp_debug~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~dwarf/?opendiv=debug'>dwarf</a><a href='##' onmousedown=showDiv('debug~dwarf') id='aexp_debug~dwarf'><span class='exp_style' id='exp_debug~dwarf'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~dwarf')) document.getElementById('aexp_debug~dwarf').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~gdb/?opendiv=debug'>gdb</a><a href='##' onmousedown=showDiv('debug~gdb') id='aexp_debug~gdb'><span class='exp_style' id='exp_debug~gdb'>[+]</span></a><span class='right_span'>6</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~gdb')) document.getElementById('aexp_debug~gdb').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kdump,-crash/?opendiv=debug'>kdump、crash</a><a href='##' onmousedown=showDiv('debug~kdump、crash') id='aexp_debug~kdump、crash'><span class='exp_style' id='exp_debug~kdump、crash'>[+]</span></a><span class='right_span'>7</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kdump、crash')) document.getElementById('aexp_debug~kdump、crash').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kgdb/?opendiv=debug'>kgdb</a><a href='##' onmousedown=showDiv('debug~kgdb') id='aexp_debug~kgdb'><span class='exp_style' id='exp_debug~kgdb'>[+]</span></a><span class='right_span'>3</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kgdb')) document.getElementById('aexp_debug~kgdb').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~kprobe/?opendiv=debug'>kprobe</a><a href='##' onmousedown=showDiv('debug~kprobe') id='aexp_debug~kprobe'><span class='exp_style' id='exp_debug~kprobe'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~kprobe')) document.getElementById('aexp_debug~kprobe').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~mark/?opendiv=debug'>mark</a><a href='##' onmousedown=showDiv('debug~mark') id='aexp_debug~mark'><span class='exp_style' id='exp_debug~mark'>[+]</span></a><span class='right_span'>6</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('debug~mark')) document.getElementById('aexp_debug~mark').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/debug~systemtap/?opendiv=debug'>systemtap</a><a href='##' onmousedown=showDiv('debug~systemtap') id='aexp_debug~systemtap'><span class='exp_style' id='exp_debug~systemtap'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('debug')) document.getElementById('aexp_debug').style.visibility = 'hidden';
if (!document.getElementById('debug~systemtap')) document.getElementById('aexp_debug~systemtap').style.visibility = 'hidden';
</script>
<li><div style="background:#DDD; height:0.3em;"></div></li><li class='catclass'><a href='/blog/cats/algorithm/'>algorithm</a><a href='##' onmousedown=showDiv('algorithm') id='aexp_algorithm'><span class='exp_style' id='exp_algorithm'>[+]</span></a><span class='right_span'>(15)</span></li>
<div id='algorithm' class='catsub'><li><a href='/blog/cats/algorithm~base/?opendiv=algorithm'>base</a><a href='##' onmousedown=showDiv('algorithm~base') id='aexp_algorithm~base'><span class='exp_style' id='exp_algorithm~base'>[+]</span></a><span class='right_span'>8</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~base')) document.getElementById('aexp_algorithm~base').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~dp/?opendiv=algorithm'>dp</a><a href='##' onmousedown=showDiv('algorithm~dp') id='aexp_algorithm~dp'><span class='exp_style' id='exp_algorithm~dp'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~dp')) document.getElementById('aexp_algorithm~dp').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~ds/?opendiv=algorithm'>ds</a><a href='##' onmousedown=showDiv('algorithm~ds') id='aexp_algorithm~ds'><span class='exp_style' id='exp_algorithm~ds'>[+]</span></a><span class='right_span'>4</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm~ds')) document.getElementById('aexp_algorithm~ds').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/algorithm~tc/?opendiv=algorithm'>tc</a><a href='##' onmousedown=showDiv('algorithm~tc') id='aexp_algorithm~tc'><span class='exp_style' id='exp_algorithm~tc'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('algorithm')) document.getElementById('aexp_algorithm').style.visibility = 'hidden';
if (!document.getElementById('algorithm~tc')) document.getElementById('aexp_algorithm~tc').style.visibility = 'hidden';
</script>
<li class='catclass'><a href='/blog/cats/blog/'>blog</a><a href='##' onmousedown=showDiv('blog') id='aexp_blog'><span class='exp_style' id='exp_blog'>[+]</span></a><span class='right_span'>(11)</span></li>
<div id='blog' class='catsub'><li><a href='/blog/cats/blog~hello/?opendiv=blog'>hello</a><a href='##' onmousedown=showDiv('blog~hello') id='aexp_blog~hello'><span class='exp_style' id='exp_blog~hello'>[+]</span></a><span class='right_span'>1</span></li>
<div id='blog~hello' class='catsub2'><li><a href='/blog/cats/blog~hello~hi/?opendiv=blog~hello'>hi</a><span class='right_span'>1</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~hello')) document.getElementById('aexp_blog~hello').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~jekyll/?opendiv=blog'>jekyll</a><a href='##' onmousedown=showDiv('blog~jekyll') id='aexp_blog~jekyll'><span class='exp_style' id='exp_blog~jekyll'>[+]</span></a><span class='right_span'>2</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~jekyll')) document.getElementById('aexp_blog~jekyll').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~markdown/?opendiv=blog'>markdown</a><a href='##' onmousedown=showDiv('blog~markdown') id='aexp_blog~markdown'><span class='exp_style' id='exp_blog~markdown'>[+]</span></a><span class='right_span'>1</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~markdown')) document.getElementById('aexp_blog~markdown').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~octopress/?opendiv=blog'>octopress</a><a href='##' onmousedown=showDiv('blog~octopress') id='aexp_blog~octopress'><span class='exp_style' id='exp_blog~octopress'>[+]</span></a><span class='right_span'>5</span></li>
<script language='javascript' type='text/javascript'>
if (!document.getElementById('blog~octopress')) document.getElementById('aexp_blog~octopress').style.visibility = 'hidden';
</script>
<li><a href='/blog/cats/blog~ruby/?opendiv=blog'>ruby</a><a href='##' onmousedown=showDiv('blog~ruby') id='aexp_blog~ruby'><span class='exp_style' id='exp_blog~ruby'>[+]</span></a><span class='right_span'>2</span></li>
</div><script language='javascript' type='text/javascript'>
if (!document.getElementById('blog')) document.getElementById('aexp_blog').style.visibility = 'hidden';
if (!document.getElementById('blog~ruby')) document.getElementById('aexp_blog~ruby').style.visibility = 'hidden';
</script>

</ul>
</div>
</body>
</html>
</section>

<section>
<h1>Date Categories</h1>
<head>
</head>
<body>
<div id="menu">
<ul>
<li class='catclass'><a href='/blog/cats/2015/'>2015</a><a href='##' onmousedown=showDiv('2015')><span class='exp_style' id='exp_2015'>[+]</span></a><span class='right_span'>(12)</span></li>
<div id='2015' class='catsub'><li><a href='/blog/cats/2015~01/?opendiv=2015'>2015-01</a><span class='right_span'>12</span></li>
</div><li class='catclass'><a href='/blog/cats/2014/'>2014</a><a href='##' onmousedown=showDiv('2014')><span class='exp_style' id='exp_2014'>[+]</span></a><span class='right_span'>(111)</span></li>
<div id='2014' class='catsub'><li><a href='/blog/cats/2014~12/?opendiv=2014'>2014-12</a><span class='right_span'>21</span></li>
<li><a href='/blog/cats/2014~11/?opendiv=2014'>2014-11</a><span class='right_span'>19</span></li>
<li><a href='/blog/cats/2014~10/?opendiv=2014'>2014-10</a><span class='right_span'>13</span></li>
<li><a href='/blog/cats/2014~09/?opendiv=2014'>2014-09</a><span class='right_span'>7</span></li>
<li><a href='/blog/cats/2014~08/?opendiv=2014'>2014-08</a><span class='right_span'>15</span></li>
<li><a href='/blog/cats/2014~07/?opendiv=2014'>2014-07</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2014~06/?opendiv=2014'>2014-06</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2014~05/?opendiv=2014'>2014-05</a><span class='right_span'>6</span></li>
<li><a href='/blog/cats/2014~04/?opendiv=2014'>2014-04</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2014~03/?opendiv=2014'>2014-03</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2014~02/?opendiv=2014'>2014-02</a><span class='right_span'>11</span></li>
<li><a href='/blog/cats/2014~01/?opendiv=2014'>2014-01</a><span class='right_span'>2</span></li>
</div><li class='catclass'><a href='/blog/cats/2013/'>2013</a><a href='##' onmousedown=showDiv('2013')><span class='exp_style' id='exp_2013'>[+]</span></a><span class='right_span'>(59)</span></li>
<div id='2013' class='catsub'><li><a href='/blog/cats/2013~12/?opendiv=2013'>2013-12</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2013~11/?opendiv=2013'>2013-11</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~10/?opendiv=2013'>2013-10</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~09/?opendiv=2013'>2013-09</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2013~08/?opendiv=2013'>2013-08</a><span class='right_span'>5</span></li>
<li><a href='/blog/cats/2013~07/?opendiv=2013'>2013-07</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2013~06/?opendiv=2013'>2013-06</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2013~05/?opendiv=2013'>2013-05</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2013~03/?opendiv=2013'>2013-03</a><span class='right_span'>6</span></li>
<li><a href='/blog/cats/2013~02/?opendiv=2013'>2013-02</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2013~01/?opendiv=2013'>2013-01</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2012/'>2012</a><a href='##' onmousedown=showDiv('2012')><span class='exp_style' id='exp_2012'>[+]</span></a><span class='right_span'>(33)</span></li>
<div id='2012' class='catsub'><li><a href='/blog/cats/2012~12/?opendiv=2012'>2012-12</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2012~11/?opendiv=2012'>2012-11</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2012~10/?opendiv=2012'>2012-10</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2012~08/?opendiv=2012'>2012-08</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2012~05/?opendiv=2012'>2012-05</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2012~04/?opendiv=2012'>2012-04</a><span class='right_span'>9</span></li>
<li><a href='/blog/cats/2012~03/?opendiv=2012'>2012-03</a><span class='right_span'>6</span></li>
<li><a href='/blog/cats/2012~02/?opendiv=2012'>2012-02</a><span class='right_span'>5</span></li>
</div><li class='catclass'><a href='/blog/cats/2011/'>2011</a><a href='##' onmousedown=showDiv('2011')><span class='exp_style' id='exp_2011'>[+]</span></a><span class='right_span'>(26)</span></li>
<div id='2011' class='catsub'><li><a href='/blog/cats/2011~12/?opendiv=2011'>2011-12</a><span class='right_span'>8</span></li>
<li><a href='/blog/cats/2011~11/?opendiv=2011'>2011-11</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2011~08/?opendiv=2011'>2011-08</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2011~07/?opendiv=2011'>2011-07</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2011~06/?opendiv=2011'>2011-06</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~05/?opendiv=2011'>2011-05</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~04/?opendiv=2011'>2011-04</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~03/?opendiv=2011'>2011-03</a><span class='right_span'>3</span></li>
<li><a href='/blog/cats/2011~02/?opendiv=2011'>2011-02</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2011~01/?opendiv=2011'>2011-01</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2010/'>2010</a><a href='##' onmousedown=showDiv('2010')><span class='exp_style' id='exp_2010'>[+]</span></a><span class='right_span'>(1)</span></li>
<div id='2010' class='catsub'><li><a href='/blog/cats/2010~07/?opendiv=2010'>2010-07</a><span class='right_span'>1</span></li>
</div><li class='catclass'><a href='/blog/cats/2009/'>2009</a><a href='##' onmousedown=showDiv('2009')><span class='exp_style' id='exp_2009'>[+]</span></a><span class='right_span'>(8)</span></li>
<div id='2009' class='catsub'><li><a href='/blog/cats/2009~12/?opendiv=2009'>2009-12</a><span class='right_span'>1</span></li>
<li><a href='/blog/cats/2009~10/?opendiv=2009'>2009-10</a><span class='right_span'>4</span></li>
<li><a href='/blog/cats/2009~09/?opendiv=2009'>2009-09</a><span class='right_span'>2</span></li>
<li><a href='/blog/cats/2009~07/?opendiv=2009'>2009-07</a><span class='right_span'>1</span></li>
</div>
</ul>
</div>
</body>
</html>
</section>

<section>
<h1>Tags</h1>
<ul class="tag-cloud">
<a style="font-size: 131%" href="/tags/gdb/">gdb(6)</a>
<a style="font-size: 100%" href="/tags/hello/">hello(1)</a>
<a style="font-size: 150%" href="/tags/koj/">koj(18)</a>
<a style="font-size: 112%" href="/tags/nvidia/">nvidia(2)</a>
<a style="font-size: 100%" href="/tags/patch/">patch(1)</a>
<a style="font-size: 100%" href="/tags/reg-exp/">reg_exp(1)</a>

</ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/01/15/tools-squid/">squid--代理</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/15/tools-cscope/">vim+cscope</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/14/debug-mod-timer/">mod_timer会切换cpu</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/14/debug-softirq-time-count/">中断时间统计</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/14/kernel-sched-alg1/">linux内核分析之调度算法（一）</a>
      </li>
    
  </ul>
</section>
<section>
<h1>Links</h1>
<ul>
	<li>
		<a href=http://hi.baidu.com/abcdxyzk target=_blank>My blog</a>
	</li>
</ul>
</section>

  
<section id="comment_sidebar">
<h1>Recent Comments</h1>

<script type="text/javascript" src="http://abcdxyzk.disqus.com/recent_comments_widget.js?num_items=5&hide_avatars=0&avatar_size=32&excerpt_length=20"></script><a href="http://disqus.com/">Powered by Disqus</a>

</section>


</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - kk -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <a title="Top" href="#" id="scroll2top" style="position: fixed; height: 50px; bottom: 30px; right: 25px; cursor: pointer; z-index: 9999; display: block; opacity: 1;"><img src="/images/scrollup.png"></a>
  <script src="/javascripts/scroll2top.js"></script>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253604690'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1253604690' type='text/javascript'%3E%3C/script%3E"));</script>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'abcdxyzk';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>





</body>
</html>
