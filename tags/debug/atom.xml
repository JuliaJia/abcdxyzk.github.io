<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<title><![CDATA[Tag: debug | kk Blog —— 通用基础]]></title>
<link href="http://abcdxyzk.github.io/tags/debug/atom.xml" rel="self"/>
<link href="http://abcdxyzk.github.io/"/>
<updated>2014-11-22T01:36:23+08:00</updated>
<id>http://abcdxyzk.github.io/</id>
<author>
<name><![CDATA[kk]]></name>

</author>
<generator uri="http://octopress.org/">Octopress</generator>

<entry>
<title type="html"><![CDATA[libdwarf 安装使用]]></title>
<link href="http://abcdxyzk.github.io/blog/2014/10/15/debug-libdwarf/"/>
<updated>2014-10-15T18:16:00+08:00</updated>
<id>http://abcdxyzk.github.io/blog/2014/10/15/debug-libdwarf</id>
<content type="html"><![CDATA[<p>下载<a href="http://www.prevanders.net/dwarf.html">http://www.prevanders.net/dwarf.html</a></p>

<p>依赖<a href="http://directory.fsf.org/wiki/Libelf">http://directory.fsf.org/wiki/Libelf</a></p>

<p>dwarf格式文档<a href="http://www.dwarfstd.org/Home.php">http://www.dwarfstd.org/Home.php</a></p>

<p>使用
<code>
./dwarfdump2/dwarfdump -Wc -S match=dev_queue_xmit /tmp/vmlinux
</code>
获取vmlinux中dev_queue_xmit函数的.debug信息</p>
]]></content>
</entry>

<entry>
<title type="html"><![CDATA[通用寄存器编码表]]></title>
<link href="http://abcdxyzk.github.io/blog/2014/09/25/debug-regs-to-num/"/>
<updated>2014-09-25T18:14:00+08:00</updated>
<id>http://abcdxyzk.github.io/blog/2014/09/25/debug-regs-to-num</id>
<content type="html"><![CDATA[<ul>
<li>来源：systemtap-2.4/runtime/loc2c-runtime.h

<h4>x86_64</h4>

<pre><code>  #define pt_dwarf_register_0(regs)       regs-&gt;rax
  #define pt_dwarf_register_1(regs)       regs-&gt;rdx
  #define pt_dwarf_register_2(regs)       regs-&gt;rcx
  #define pt_dwarf_register_3(regs)       regs-&gt;rbx
  #define pt_dwarf_register_4(regs)       regs-&gt;rsi
  #define pt_dwarf_register_5(regs)       regs-&gt;rdi
  #define pt_dwarf_register_6(regs)       regs-&gt;rbp
  #define pt_dwarf_register_7(regs)       regs-&gt;rsp
  #define pt_dwarf_register_8(regs)       regs-&gt;r8
  #define pt_dwarf_register_9(regs)       regs-&gt;r9
  #define pt_dwarf_register_10(regs)      regs-&gt;r10
  #define pt_dwarf_register_11(regs)      regs-&gt;r11
  #define pt_dwarf_register_12(regs)      regs-&gt;r12
  #define pt_dwarf_register_13(regs)      regs-&gt;r13
  #define pt_dwarf_register_14(regs)      regs-&gt;r14
  #define pt_dwarf_register_15(regs)      regs-&gt;r15
</code></pre></li>
</ul>


<h4>i386</h4>

<pre><code>    #define pt_dwarf_register_0(regs)       regs-&gt;eax
    #define pt_dwarf_register_1(regs)       regs-&gt;ecx
    #define pt_dwarf_register_2(regs)       regs-&gt;edx
    #define pt_dwarf_register_3(regs)       regs-&gt;ebx
    #define pt_dwarf_register_4(regs)       (user_mode(regs) ? regs-&gt;esp : (long)&amp;regs-&gt;esp)
    #define pt_dwarf_register_5(regs)       regs-&gt;ebp
    #define pt_dwarf_register_6(regs)       regs-&gt;esi
    #define pt_dwarf_register_7(regs)       regs-&gt;edi
</code></pre>

<ul>
<li><a href="http://www.mouseos.com/x64/extend64.html">http://www.mouseos.com/x64/extend64.html</a> 这里的是错的，改正后如下
<code>
寄存器编码    8    16    32    64
000    al    ax    eax    rax
001    dl    dx    edx    rdx
010    cl    cx    ecx    rcx
011    bl    bx    ebx    rbx
100    ?    si    esi    rsi
101    ?    di    edi    rdi
110    ?    bp    ebp    rbp
111    ?    sp    esp    rsp
1000    r8b    r8w    r8d    r8
1001    r9b    r9w    r9d    r9
1010    r10b    r10w    r10d    r10
1011    r11b    r11w    r11d    r11
1100    r12b    r12w    r12d    r12
1101    r13b    r13w    r13d    r13
1110    r14b    r14w    r14d    r14
1111    r15b    r15w    r15d    r15
</code></li>
</ul>

]]></content>
</entry>

<entry>
<title type="html"><![CDATA[The meaning of '?' in Linux kernel panic call trace]]></title>
<link href="http://abcdxyzk.github.io/blog/2014/06/12/debug-dumpstack-mean/"/>
<updated>2014-06-12T09:42:00+08:00</updated>
<id>http://abcdxyzk.github.io/blog/2014/06/12/debug-dumpstack-mean</id>
<content type="html"><![CDATA[<ul>
<li>&lsquo;?&rsquo; means that the information about this stack entry is probably not reliable.</li>
</ul>


<p>The stack output mechanism (see the implementation of dump_trace() function) was unable to prove that the address it has found is a valid return address in the call stack.</p>

<p>&lsquo;?&rsquo; itself is output by printk_stack_address().</p>

<p>The stack entry may be valid or not. Sometimes one may simply skip it. It may be helpful to investigate the disassembly of the involved module to see which function is called at ClearFunctionName+0x88 (or, on x86, immediately before that position).</p>

<p>Concerning reliability</p>

<p>On x86, when dump_stack() is called, the function that actually examines the stack is print_context_stack() defined in arch/x86/kernel/dumpstack.c. Take a look at its code, I&rsquo;ll try to explain it below.</p>

<p>I assume DWARF2 stack unwind facilities are not available in your Linux system (most likely, they are not, if it is not OpenSUSE or SLES). In this case, print_context_stack() seems to do the following.</p>

<p>It starts from an address (&lsquo;stack&rsquo; variable in the code) that is guaranteed to be an address of a stack location. It is actually the address of a local variable in dump_stack().</p>

<p>The function repeatedly increments that address (while (valid_stack_ptr &hellip;) { &hellip; stack++}) and checks if what it points to could also be an address in the kernel code (if (__kernel_text_address(addr)) &hellip;). This way it attempts to find the functions&#8217; return addresses pushed on stack when these functions were called.</p>

<p>Of course, not every unsigned long value that looks like a return address is actually a return address. So the function tries to check it. If frame pointers are used in the code of the kernel (%ebp/%rbp registers are employed for that if CONFIG_FRAME_POINTER is set), they can be used to traverse the stack frames of the functions. The return address for a function lies just above the frame pointer (i.e. at %ebp/%rbp + sizeof(unsigned long)). print_context_stack checks exactly that.</p>

<p>If there is a stack frame for which the value &lsquo;stack&rsquo; points to is the return address, the value is considered a reliable stack entry. ops->address will be called for it with reliable == 1, it will eventually call printk_stack_address() and the value will be output as a reliable call stack entry. Otherwise the address will be considered unreliable. It will be output anyway but with &lsquo;?&rsquo; prepended.</p>

<p>[NB] If frame pointer information is not available (e.g. like it was in Debian 6 by default), all call stack entries will be marked as unreliable for this reason.</p>

<p>The systems with DWARF2 unwinding support (and with CONFIG_STACK_UNWIND set) is a whole another story.</p>
]]></content>
</entry>

</feed>
