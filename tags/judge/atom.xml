<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<title><![CDATA[Tag: judge | kk Blog —— 通用基础]]></title>
<link href="http://abcdxyzk.github.io/tags/judge/atom.xml" rel="self"/>
<link href="http://abcdxyzk.github.io/"/>
<updated>2014-12-05T23:32:09+08:00</updated>
<id>http://abcdxyzk.github.io/</id>
<author>
<name><![CDATA[kk]]></name>

</author>
<generator uri="http://octopress.org/">Octopress</generator>

<entry>
<title type="html"><![CDATA[避免僵死进程]]></title>
<link href="http://abcdxyzk.github.io/blog/2012/04/21/lang-c-fork/"/>
<updated>2012-04-21T19:45:00+08:00</updated>
<id>http://abcdxyzk.github.io/blog/2012/04/21/lang-c-fork</id>
<content type="html"><![CDATA[<h4>一 两次fork避免僵死进程</h4>

<p>如果在一个进程A中启动了一个子进程B，但是B的执行时间可能很长，也可能很短。因此，既不希望A调用wait或者waitpid来等待B的完成（如果B执行时间太长，A的时间就耗费在等待B的完成了，虽然waitpid有WNOHANG选项，但免不了多次调用waitpid来看B是否完成）；也不希望如果B执行时间太短了，然后A又不用wait或waitpid去获取B的退出状态，那么B就一直处于僵死状态直到A终止（这样造成了资源的浪费）。</p>

<p>此时，可以使用一个小trick。就是调用两次fork，让B的父进程变成init进程（pid=1的那个进程，所有孤儿进程的父进程）。这样，A进程可以想干嘛干嘛去，B进程也可以想执行多久就执行多久了。
<code>
    #include &lt;unistd.h&gt;
    #include &lt;sys/wait.h&gt;
    int main()
    {
        pid_t pid;
        if((pid=fork())&lt;0)
        {
            printf("fork 1 error\n");
            exit(-1);
        }
        else if(pid==0）//第一个子进程
        {
            if((pid=fork())&lt;0)
            {
                printf("fork 2 error\n");
                exit(-1);
            }
            else if(pid&gt;0)//第二次fork产生的子进程（第二个子进程）的父进程，其实就是第一次fork产生的子进程（第一个子进程）
            {
                exit(0);//第一个子进程结束，那么它的子进程（第二个子进程）将由init进程领养，init进程成为第二个子进程的父进程
            }
            //第二个子进程（就是我们前面说的B进程）可以做他想做的事情了
            ................
        }
        if(waitpid(pid,NULL,0)!=pid)//获取第一个子进程的终止状态，不让它变成僵死进程
        printf("waitpid error\n");
        //父进程（就是我们前面说的A进程）也可以做他想做的事情了
        .........
        return 0;
    }
</code></p>

<h4>二</h4>

<p>父进程可以忽略 SIGCLD 软中断而不必要 wait()。可以这样做到(在支持它的系统上,比如Linux):　
<code>
    main()　　
    {　　
        signal(SIGCLD, SIG_IGN); /* now I don't have to wait()! */　　
        .......　　
        fork();　　
        fork();　　
        fork(); /* Rabbits, rabbits, rabbits! */　　
    ｝
</code></p>
]]></content>
</entry>

<entry>
<title type="html"><![CDATA[设置线程的栈空间]]></title>
<link href="http://abcdxyzk.github.io/blog/2012/04/21/lang-c-set-thread-stack/"/>
<updated>2012-04-21T19:32:00+08:00</updated>
<id>http://abcdxyzk.github.io/blog/2012/04/21/lang-c-set-thread-stack</id>
<content type="html"><![CDATA[<h1>include &lt;pthread.h></h1>

<pre><code>    pthread_attr_t thread_attr;
    size_t stack_size;
    int status;

    status = pthread_attr_init (&amp;thread_attr);
    if (status != 0)
        err_abort (status, "Create attr");

    status = pthread_attr_setdetachstate (&amp;thread_attr, PTHREAD_CREATE_DETACHED);

    if (status != 0)
        err_abort (status, "Set detach");
    //通常出现的问题之一，下面的宏没有定义
    #ifdef _POSIX_THREAD_ATTR_STACKSIZE
        //得到当前的线程栈大小
        status = pthread_attr_getstacksize (&amp;thread_attr, &amp;stack_size);
        if (status != 0)
            err_abort (status, "Get stack size");
        printf ("Default stack size is %u; minimum is %u\n", stack_size, PTHREAD_STACK_MIN);

        //设置当前的线程的大小
        status = pthread_attr_setstacksize (&amp;thread_attr, PTHREAD_STACK_MIN*1024);
        if (status != 0)
            err_abort (status, "Set stack size");

        //得到当前的线程栈的大小
        status = pthread_attr_getstacksize (&amp;thread_attr, &amp;stack_size);
        if (status != 0)
            err_abort (status, "Get stack size");
        printf ("Default stack size is %u; minimum is %u\n", stack_size, PTHREAD_STACK_MIN);
    #endif
</code></pre>
]]></content>
</entry>

<entry>
<title type="html"><![CDATA[jni 编程]]></title>
<link href="http://abcdxyzk.github.io/blog/2012/02/15/lang-java-jni/"/>
<updated>2012-02-15T20:22:00+08:00</updated>
<id>http://abcdxyzk.github.io/blog/2012/02/15/lang-java-jni</id>
<content type="html"><![CDATA[<h4>jni 编译：</h4>

<p>g++ -L /usr/lib/jvm/default-java/jre/lib/amd64/server -o judge judge.cpp -ljvm</p>

<h4>jni 运行：</h4>

<p>以root身份把库路径加入/etc/ld.so.conf或在/etc/ld.so.conf.d中创建特定的.conf文件，然后运行 ldconfig更新/etc/ld.so.cache。例如：在/etc/ld.so.conf.d下创建文件jvm.conf写入
<code>
/usr/lib/jvm/default-java/jre/lib/amd64
/usr/lib/jvm/default-java/jre/lib/amd64/server
</code></p>

<h4>jni</h4>

<p>  GetFieldID是得到java类中的参数ID，GetMethodID得到java类中方法的ID，它们只能调用类中声明为 public的参数或方法。使用如下：
<code>
jfieldID topicFieldId = env-&gt;GetFieldID(objectClass,"name", "Ljava/lang/String;");
jmethodID getcName=env-&gt;GetMethodID(objectClass,"getcatName","()Ljava/lang/String;");
</code>
第一参数是Java 类对象。第二个参数是参数（或方法名），第三个参数是该参数（或方法）的签名。第三个参数由以下方法得到。
有类
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class Cat {
</span><span class='line'>    private int catNumber;
</span><span class='line'>    String catName;
</span><span class='line'>    public Cat(int i,String name){catNumber=i;catName=name;}
</span><span class='line'>    public String getCatName () {
</span><span class='line'>        return this.catName;
</span><span class='line'>    }&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    public void setCatName (String catName) {
</span><span class='line'>    this.catName=catName;
</span><span class='line'>}
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;查看 Cat类进入到Cat所在目录 先用javac Cat.java进行编译 然后输入命令：
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Javap –s Cat
</span><span class='line'>&lt;code&gt;
</span><span class='line'>得到Cat方法getcatName 的签名是()Ljava/lang/String，Cat类中的参数是private 所以它没有签名。
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>options[0].optionString = &ldquo;-Djava.class.path=./tmp/1&rdquo;;</span></code></pre></td></tr></table></div></figure></p>
]]></content>
</entry>

<entry>
<title type="html"><![CDATA[遍历文件函数 dirent]]></title>
<link href="http://abcdxyzk.github.io/blog/2011/12/01/lang-c-dirent/"/>
<updated>2011-12-01T01:34:00+08:00</updated>
<id>http://abcdxyzk.github.io/blog/2011/12/01/lang-c-dirent</id>
<content type="html"><![CDATA[<p>引用头文件#include&lt;dirent.h><br/>
结构体说明<br/>
<code>
    struct dirent {　　
        long d_ino; /* inode number 索引节点号 */　　
        off_t d_off; /* offset to this dirent 在目录文件中的偏移 */　　
        unsigned short d_reclen; /* length of this d_name 文件名长 */　　
        unsigned char d_type; /* the type of d_name 文件类型 */　　
        char d_name [NAME_MAX+1]; /* file name (null-terminated) 文件名，最长255字符 */　　
    }
</code>
相关函数<br/>
opendir()，readdir()，closedir();</p>

<p>使用实例
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>#include &lt;string.h&gt;
</span><span class='line'>#include &lt;dirent.h&gt;
</span><span class='line'>#include &lt;sys/stat.h&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;int main()
</span><span class='line'>{
</span><span class='line'>struct dirent* ent = NULL;
</span><span class='line'>DIR *pDir;
</span><span class='line'>pDir=opendir(".");
</span><span class='line'>
</span><span class='line'>while ((ent=readdir(pDir)) != NULL)
</span><span class='line'>{
</span><span class='line'>    //printf("%d %d\n", ent-&gt;d_reclen, ent-&gt;d_type);
</span><span class='line'>    if (ent-&gt;d_type==8)
</span><span class='line'>    printf("filename: %s\n", ent-&gt;d_name);
</span><span class='line'>}
</span><span class='line'>return 0;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>&lt;/entry&gt;
</span><span class='line'>
</span><span class='line'>&lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[一个简单的 ptrace 例子]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://abcdxyzk.github.io/blog/2011/11/29/tools-ptrace-sample/"/&gt;
</span><span class='line'>&lt;updated&gt;2011-11-29T20:16:00+08:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://abcdxyzk.github.io/blog/2011/11/29/tools-ptrace-sample&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;pre&gt;&lt;code&gt;    // test.cpp
</span><span class='line'>
</span><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>
</span><span class='line'>int main()
</span><span class='line'>{
</span><span class='line'>    printf("---------- test 1 ----------\n");
</span><span class='line'>    printf("---------- test 2 ----------\n");
</span><span class='line'>    printf("---------- test 3 ----------\n");
</span><span class='line'>    return 0;
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;编译 g++ test.cpp -o test &ndash;static</span></code></pre></td></tr></table></div></figure>
    // ptrace.cpp</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/ptrace.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;sys/reg.h&gt;
#include &lt;unistd.h&gt;

int main()
{
    pid_t pid;
    int orig_eax, eax, ebx, ecx, edx;

    pid = fork();
    if(pid == 0)
    {
        ptrace(PTRACE_TRACEME, 0, NULL, NULL);
        printf("execve = %d\n", execve("./test", NULL, NULL));
        exit(0);
    }
    while(1)
    {
        int status;
        wait(&amp;status);
        if(WIFEXITED(status)) break;

        orig_eax = ptrace(PTRACE_PEEKUSER, pid, ORIG_EAX&lt;&lt;2, NULL);
        eax = ptrace(PTRACE_PEEKUSER, pid, EAX&lt;&lt;2, NULL);
        ebx = ptrace(PTRACE_PEEKUSER, pid, EBX&lt;&lt;2, NULL);

        printf("ORIG_EAX = %d,        EAX = %d,        EBX = %d\n", orig_eax, eax, ebx);

        ptrace(PTRACE_SYSCALL, pid, NULL, NULL);
    }
    return 0;
}
</code></pre>

<pre><code>编译 `g++ ptrace.cpp -o ptrace --static`  
测试 `./ptrace` 输出
</code></pre>

<p>ORIG_EAX = 11,        EAX = 0,        EBX = 0
ORIG_EAX = 122,        EAX = -38,        EBX = -1074643290
ORIG_EAX = 122,        EAX = 0,        EBX = -1074643290
ORIG_EAX = 45,        EAX = -38,        EBX = 0
ORIG_EAX = 45,        EAX = 161513472,        EBX = 0
ORIG_EAX = 45,        EAX = -38,        EBX = 161516752
ORIG_EAX = 45,        EAX = 161516752,        EBX = 161516752
ORIG_EAX = 243,        EAX = -38,        EBX = -1074642896
ORIG_EAX = 243,        EAX = 0,        EBX = -1074642896
ORIG_EAX = 45,        EAX = -38,        EBX = 161651920
ORIG_EAX = 45,        EAX = 161651920,        EBX = 161651920
ORIG_EAX = 45,        EAX = -38,        EBX = 161652736
ORIG_EAX = 45,        EAX = 161652736,        EBX = 161652736
ORIG_EAX = 197,        EAX = -38,        EBX = 1
ORIG_EAX = 197,        EAX = 0,        EBX = 1
ORIG_EAX = 192,        EAX = -38,        EBX = 0
ORIG_EAX = 192,        EAX = -1217093632,        EBX = 0
ORIG_EAX = 4,        EAX = -38,        EBX = 1
&mdash;&mdash;&mdash;- test 1 &mdash;&mdash;&mdash;-
ORIG_EAX = 4,        EAX = 29,        EBX = 1
ORIG_EAX = 4,        EAX = -38,        EBX = 1
&mdash;&mdash;&mdash;- test 2 &mdash;&mdash;&mdash;-
ORIG_EAX = 4,        EAX = 29,        EBX = 1
ORIG_EAX = 4,        EAX = -38,        EBX = 1
&mdash;&mdash;&mdash;- test 3 &mdash;&mdash;&mdash;-
ORIG_EAX = 4,        EAX = 29,        EBX = 1
ORIG_EAX = 252,        EAX = -38,        EBX = 0
```
内核 Linux 2.6.32-35-generic</p>

<p>ubuntu 10.04
linux 系统调用号 /usr/include/asm/unistd_32.h<br/>
linux 系统EAX等值 /usr/include/sys/reg.h</p>
]]></content>
</entry>

</feed>
