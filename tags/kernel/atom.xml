<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<title><![CDATA[Tag: kernel | kk Blog —— 通用基础]]></title>
<link href="http://abcdxyzk.github.io/tags/kernel/atom.xml" rel="self"/>
<link href="http://abcdxyzk.github.io/"/>
<updated>2014-11-26T01:22:16+08:00</updated>
<id>http://abcdxyzk.github.io/</id>
<author>
<name><![CDATA[kk]]></name>

</author>
<generator uri="http://octopress.org/">Octopress</generator>

<entry>
<title type="html"><![CDATA[offsetof宏 container_of宏]]></title>
<link href="http://abcdxyzk.github.io/blog/2014/09/15/kernel-offset-container_of/"/>
<updated>2014-09-15T15:57:00+08:00</updated>
<id>http://abcdxyzk.github.io/blog/2014/09/15/kernel-offset-container_of</id>
<content type="html"><![CDATA[<p>Linux内核中，用两个非常巧妙地宏实现了，一个是offsetof宏，另一个是container_of宏，下面讲解一下这两个宏。</p>

<h4>1.  offsetof宏</h4>

<h5>【定义】：</h5>

<pre><code>#define offsetof(TYPE, MEMBER) ((size_t) &amp; ((TYPE *)0)-&gt;MEMBER )
</code></pre>

<h5>【功能】： 获得一个结构体变量成员在此结构体中的偏移量。</h5>

<h5>【例子】：</h5>

<pre><code class="">    struct A 
        { 
        int x ; 
        int y; 
        int z; 
    }; 

    void main() 
    { 
        printf("the offset of z is %d",offsetof( struct A, z )  ); 
    } 
</code></pre>

<p>// 输出结果为 8</p>

<h5>【分析】：</h5>

<p>该宏，TYPE为结构体类型，MEMBER 为结构体内的变量名。<br/>
(TYPE <em>)0) 是欺骗编译器说有一个指向结构TYPE 的指针，其地址值0 <br/>
(TYPE </em>)0)->MEMBER 是要取得结构体TYPE中成员变量MEMBER的地址. 因为基址为0，所以，这时MEMBER的地址当然就是MEMBER在TYPE中的偏移了。</p>

<h4>2. container_of宏（即实现了题目中的功能）</h4>

<h5>【定义】：</h5>

<pre><code>#define container_of(ptr, type, member)   ({const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr); (type *)( (char *)__mptr - offsetof(type,member) );})
</code></pre>

<h5>【功能】：</h5>

<p>从结构体（type）某成员变量（member）指针（ptr）来求出该结构体（type）的首指针。</p>

<h5>【例子】：</h5>

<pre><code>    struct A 
    { 
        int x ; 
        int y; 
        int z; 
    }; 

    struct A myTest; 

    int *pz = &amp;myTest.z; 

    struct A* getHeaderPtr( int *pz ) 
    { 
        return container_of( pz , struct A, z ); 
    } 
</code></pre>

<h5>【分析】：</h5>

<p>（1） typeof( ( (type <em>)0)->member )为取出member成员的变量类型。<br/>
（2） 定义__mptr指针ptr为指向该成员变量的指针(即指向ptr所指向的变量处)<br/>
（3） (char </em>)__mptr - offsetof(type,member)) 用该成员变量的实际地址减去该变量在结构体中的偏移，来求出结构体起始地址。<br/>
（4） ({ })这个扩展返回程序块中最后一个表达式的值。</p>
]]></content>
</entry>

<entry>
<title type="html"><![CDATA[Linux 即时修改 启动级别 启动参数 磁盘满无法进系统 忘记密码]]></title>
<link href="http://abcdxyzk.github.io/blog/2014/08/14/kernel-init-edit-args/"/>
<updated>2014-08-14T17:20:00+08:00</updated>
<id>http://abcdxyzk.github.io/blog/2014/08/14/kernel-init-edit-args</id>
<content type="html"><![CDATA[<h4>1、修改启动级别错误配置的方法</h4>

<p>如果你不小心把级别设成0或6，用下边的方法补救：<br/>
1. 启动系统后，在倒计时结束前按任意键，进入grub引导界面 <br/>
2. 在grub引导界面的输入‘e’，进入下一级，高亮第二行，再输入‘e’<br/>
3. 在最后输入 1[单用户模式] 按回车回到上一级（单用户模式启动不会去读取/etc/inittab）
4. 输入‘b’重启系统</p>

<p>也可以改其他启动参数
进行紧急引导最简单的方法是：<br/>
把 init=/bin/bash 或 init=/bin/sh 选项传递给内核</p>

<h5>2、磁盘满导致无法进入系统</h5>

<p>删除一些文件后重启<br/>
没法删除 说文件系统是只读的 ，重新mount 你的磁盘系统为可读写的。<br/>
<code>
mount -o remount,rw  /
</code></p>

<h5>3、忘记密码</h5>

<p>passwd user</p>
]]></content>
</entry>

<entry>
<title type="html"><![CDATA[内核编译模块]]></title>
<link href="http://abcdxyzk.github.io/blog/2013/06/06/kernel-mod-compiler/"/>
<updated>2013-06-06T14:28:00+08:00</updated>
<id>http://abcdxyzk.github.io/blog/2013/06/06/kernel-mod-compiler</id>
<content type="html"><![CDATA[<pre><code>    /*filename: test.c*/
    #include &lt;linux/init.h&gt;
    #include &lt;linux/kernel.h&gt;
    #include &lt;linux/module.h&gt;

    staticintdummy_init(void)
    {
        printk("hello,world.\n");
        return0;
    }
    staticvoiddummy_exit(void)
    {
        return;
    }

    module_init(dummy_init);
    module_exit(dummy_exit);

    MODULE_LICENSE("GPL")
</code></pre>

<p>执行如下命令：
<code>
    $ gcc -c -O2 -DMODULE -D__KERNEL__ -I/usr/src/linux test.c
    $ insmod test.o
</code>
No module found in object<br/>
insmod: error inserting &lsquo;test.o&rsquo;: -1 Invalid module format</p>

<p>正确的做法是写一个Makefile,由内核的Kbuild来帮你编译。<br/>
<code>
    $ cat Makefile
    obj-m :=test.o
    KDIR :=/lib/modules/$(shell uname -r)/build
    PWD :=$(shell pwd)
    default:
        $(MAKE)-C $(KDIR)SUBDIRS=$(PWD)modules
</code>
执行如下命令：
<code>
    $make
    make -C /lib/modules/2.6.5-1.358/build SUBDIRS=/test modules
    make[1]:Entering directory `/lib/modules/2.6.5-1.358/build'
      CC [M]  /test/modinject/test.o
      Building modules, stage 2.
      MODPOST
      CC      /test/modinject/test.mod.o
      LD [M]  /test/modinject/test.ko
    make[1]: Leaving directory `/lib/modules/2.6.5-1.358/build'
    $ls -l
    -rw-r--r--1 root root   268 Jan  7 08:31 test.c
    -rw-r--r--1 root root  2483 Jan  8 09:19 test.ko
    -rw-r--r--1 root root   691 Jan  8 09:19 test.mod.c
    -rw-r--r--1 root root  1964 Jan  8 09:19 test.mod.o
    -rw-r--r--1 root root  1064 Jan  8 09:19 test.o
</code>
其实上边的test.o就是用gcc生成的test.o,而test.ko是使用下列命令来生成的。
<code>
    $ld -m elf_i386  -r -o test.ko test.o  test.mod.o
</code></p>

<p>再来看看test.mod.c，它是由/usr/src/linux/scripts/modpost.c来生成的。
```
    $ cat test.mod.c
    #include &lt;linux/module.h>
    #include &lt;linux/vermagic.h>
    #include &lt;linux/compiler.h></p>

<pre><code>MODULE_INFO(vermagic,VERMAGIC_STRING);
#undef unix

struct module __this_module
__attribute__((section(".gnu.linkonce.this_module")))={
.name =__stringify(KBUILD_MODNAME),
.init =init_module,
#ifdef CONFIG_MODULE_UNLOAD

.exit=cleanup_module,
#endif

};
static const struct modversion_info ____versions[]
__attribute_used__
__attribute__((section("__versions")))={
    {0,"cleanup_module"},
    {0,"init_module"},
    {0,"struct_module"},
    {0,"printk"},
};
static const char __module_depends[]
__attribute_used__
__attribute__((section(".modinfo")))=
"depends=";
</code></pre>

<p>```
可见，test.mod.o只是产生了几个ELF的节，分别是modinfo,  .gun.linkonce.this_module(用于重定位，引进了rel.gnu.linkonce.this_module),  __versions。而test.ko是test.o和test.mod.o合并的结果。</p>
]]></content>
</entry>

</feed>
