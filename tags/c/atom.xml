<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<title><![CDATA[Tag: c | kk Blog —— 通用基础]]></title>
<link href="http://abcdxyzk.github.io/tags/c/atom.xml" rel="self"/>
<link href="http://abcdxyzk.github.io/"/>
<updated>2014-11-23T17:42:56+08:00</updated>
<id>http://abcdxyzk.github.io/</id>
<author>
<name><![CDATA[kk]]></name>

</author>
<generator uri="http://octopress.org/">Octopress</generator>

<entry>
<title type="html"><![CDATA[强制内联和强制不内联]]></title>
<link href="http://abcdxyzk.github.io/blog/2014/09/11/lang-c-inline-noinline/"/>
<updated>2014-09-11T09:34:00+08:00</updated>
<id>http://abcdxyzk.github.io/blog/2014/09/11/lang-c-inline-noinline</id>
<content type="html"><![CDATA[<h4>1.强制不内联</h4>

<p>一个函数，如果代码量比较少的话，用 -O3优化开关的话，gcc有可能将这个函数强制内联(inline)即使，你在函数前没有写inline助记符。<br/>
如果是一个手写汇编的函数，那样的话很有可能破坏参数。gcc里有强制不内联的，用法如下
<code>
    void foo() __attribute__((noinline));
</code>
但是有的gcc可能会忽略 noinline。<br/>
那么你可以将你实现的这个函数写到调用函数之后，就不会被inline了。这是因为编译器gcc只内联当前函数之前可见(实现代码在前)的函数。</p>

<h4>2.优化时无法识别inline函数中的ASM汇编</h4>

<p>当GCC尝试内联一个函数时，如果该函数中存在内联汇编，则该汇编语句块可能被丢弃；
<code>
    __inline__ __attribute__((always_inline))int Increment(int volatile *add, int inc)
    {
        int res;
        __asm__
        (
        "lock \n\t"
        "xaddl %0,(%1)\n\t"
        :"=r"(res)
        :"r"(add),"0"(inc)
        :"memory"
        );
        return res;
    }
</code></p>
]]></content>
</entry>

<entry>
<title type="html"><![CDATA[字节序和比特序]]></title>
<link href="http://abcdxyzk.github.io/blog/2013/06/20/lang-c-B_b_byte/"/>
<updated>2013-06-20T18:23:00+08:00</updated>
<id>http://abcdxyzk.github.io/blog/2013/06/20/lang-c-B_b_byte</id>
<content type="html"><![CDATA[<p>字节序和比特序，因为比特序对所有代码（包括汇编）是透明的，所以对于小端系统，有说是用大端比特序，也有说是用小端比特序。<br/>
下面是copy一部分觉得靠谱的内容：<br/>
大小端
我们对&#8221;endianness&#8221;这个名词估计都很熟悉了。它首先被Danny Cohen于1980引入，用来表述计算机系统表示多字节整数的方式。
endianness分为两种：大端和小端。(从字节序的角度来看)大端方式是将整数中最高位byte存放在最低地址中。而小端方式则相反，将整数中的最高位byte存放在最高地址中。
对于某个确定的计算机系统，比特序通常与字节序保持一致。换言之，在大端系统中，每个byte中最高位bit存放在内存最低位；在小端系统中，最低位bit存放在内存最低位。
正如大部分人是按照从左至右的顺序书写数字，一个多字节整数的内存布局也应该遵循同样的方式，即从左至右为数值的最高位至最低位。正如我们在下面的例子中所看到的，这是书写整数最清晰的方式。</p>

<p>根据上述规则，我们按以下方式分别在大端和小端系统中值为0x0a0b0c0d的整数。
在大端系统中书写整数：
byte  addr  0   1   2   3
bit offset  01234567 01234567 01234567 01234567</p>

<pre><code>binary  00001010 00001011 00001100 00001101
  hex      0a       0b       0c       0d
</code></pre>

<p>在小端系统中书写整数(认真看)
byte  addr  0   1   2   3
bit offset  01234567 01234567 01234567 01234567</p>

<pre><code>binary  10110000 00110000 11010000 01010000
  hex      d0       c0       b0       a0
</code></pre>

<p>说明字节序：
<code>
    #include &lt;stdio.h&gt;  
    int main (void)  
    {  
        union b  
        {  
            short k;  //测试环境short占2字节  
            char i[2];  //测试环境char占1字节  
        }*s,a;  
        s=&amp;a;  
        s-&gt;i[0]=0x41;  
        s-&gt;i[1]=0x52;  
        printf("%x\n",s-&gt;k);  
        return 0;  
    }
</code>
输出：5241</p>

<hr />

<p>self code:
&#8220;`
    #include &lt;stdio.h>
    union W
    {
        struct Y
        {
            unsigned int s1:4;
            unsigned int s2:8;
            unsigned int s3:20;
        } y;
        unsigned int c;
    } w;</p>

<pre><code>union V 
{
    struct X
    {
        unsigned char s1:3;
        unsigned char s2:3;
        unsigned char s3:2;
    } x;
    unsigned char c;
} v;

int main()
{
    w.c = 0x12345678;
    printf("%x %x %x %x\n", w.c, w.y.s1, w.y.s2, w.y.s3); 

    v.c = 100;
    printf("%d %x %x %x\n", v.c, v.x.s1, v.x.s2, v.x.s3); 
    return 0;
}
</code></pre>

<p>&#8220;`</p>

<p>输出：<br/>
12345678 8 67 12345<br/>
100 4 4 1</p>

<p>100 = （01100100）2<br/>
因为字节序是小端的所以第一行输出说明：位域变量从左到右分配位，所以第二行的输出的位域变量也应该从左到右分配位。所以<br/>
100 = 001 001 10  （小端比特序二进制）<br/>
对应:  s1  s2  s3  （位域变量从左到右分配位）</p>

<p>符合。</p>
]]></content>
</entry>

</feed>
