<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<title><![CDATA[Tag: c | kk Blog —— 通用基础]]></title>
<link href="http://abcdxyzk.github.io/tags/c/atom.xml" rel="self"/>
<link href="http://abcdxyzk.github.io/"/>
<updated>2014-11-26T01:22:16+08:00</updated>
<id>http://abcdxyzk.github.io/</id>
<author>
<name><![CDATA[kk]]></name>

</author>
<generator uri="http://octopress.org/">Octopress</generator>

<entry>
<title type="html"><![CDATA[强制内联和强制不内联]]></title>
<link href="http://abcdxyzk.github.io/blog/2014/09/11/lang-c-inline-noinline/"/>
<updated>2014-09-11T09:34:00+08:00</updated>
<id>http://abcdxyzk.github.io/blog/2014/09/11/lang-c-inline-noinline</id>
<content type="html"><![CDATA[<h4>1.强制不内联</h4>

<p>一个函数，如果代码量比较少的话，用 -O3优化开关的话，gcc有可能将这个函数强制内联(inline)即使，你在函数前没有写inline助记符。<br/>
如果是一个手写汇编的函数，那样的话很有可能破坏参数。gcc里有强制不内联的，用法如下
<code>
    void foo() __attribute__((noinline));
</code>
但是有的gcc可能会忽略 noinline。<br/>
那么你可以将你实现的这个函数写到调用函数之后，就不会被inline了。这是因为编译器gcc只内联当前函数之前可见(实现代码在前)的函数。</p>

<h4>2.优化时无法识别inline函数中的ASM汇编</h4>

<p>当GCC尝试内联一个函数时，如果该函数中存在内联汇编，则该汇编语句块可能被丢弃；
<code>
    __inline__ __attribute__((always_inline))int Increment(int volatile *add, int inc)
    {
        int res;
        __asm__
        (
        "lock \n\t"
        "xaddl %0,(%1)\n\t"
        :"=r"(res)
        :"r"(add),"0"(inc)
        :"memory"
        );
        return res;
    }
</code></p>
]]></content>
</entry>

<entry>
<title type="html"><![CDATA[可重入函数与不可重入函数]]></title>
<link href="http://abcdxyzk.github.io/blog/2014/01/09/lang-c-re-enter-fun/"/>
<updated>2014-01-09T17:29:00+08:00</updated>
<id>http://abcdxyzk.github.io/blog/2014/01/09/lang-c-re-enter-fun</id>
<content type="html"><![CDATA[<p>可重入函数主要用于多任务环境中，简单来说就是可以被中断的函数，即在这个函数执行的任何时刻中断它，转入OS调度下去执行另外一段代 码，返回控制时不会出现什么错误；也意味着它除了使用自己栈上的变量以外不依赖于任何环境（包括static），这样的函数就是 purecode（纯代码）可重入，可以允许有该函数的多个副本在运行，由于它们使用的是分离的栈，所以不会互相干扰。而不可重入的函数由于使用了一些系 统资源，比如全局变量区、中断向量表等，所以它如果被中断的话，可能会出现问题，这类函数是不能运行在多任务环境下的。</p>

<p>可重入函数确实需要访问全局变量（包括 static），一定要注意实施互斥手段。它在并行运行环境中非常重要，但是一般要为访问全局变量付出一些性能代价。编写可重入函数时，若使用全局变量，则应通过关中断、信号量（即P、V操作）等手段对其加以保护。若对所使用的全局变量不加以保护，则此函数就不具有可重入性，即当多个进程调用此函数时，很有可能使有关全局变量变为不可知状态。</p>

<p>示例：假设Exam是 int型全局变量，函数Squre_Exam返回Exam平方值。那么如下函数不具有可重入性。
<code>
    int Exam = 0;
    unsigned int example( int para )
    {
        unsigned int temp;
        Exam = para; // （**）
         temp = Square_Exam( );
        return temp;  
    }
</code>
此函数若被多个进程调用的话，其结果可能是未知的，因为当（**）语句刚执行完后，另外一个使用本函数的进程可能正好被激活，那么当新激活的进程执行到此 函数时，将使Exam赋与另一个不同的para值，所以当控制重新回到“temp = Square_Exam( )”后，计算出的temp很可能不是预想中的结果。此函数应如下改进。
<code>
    int Exam = 0;
    unsigned int example( int para )
    {
        unsigned int temp;  
        [申请信号量操作] //(1)  加锁  
        Exam = para;  
        temp = Square_Exam( );  
        [释放信号量操作] //   解锁   
        return temp;  
    }
</code>
申请不到“信号量”，说明另外的进程正处于给Exam赋值并计算其平方过程中（即正在使用此信号）,本进程必须等待其释放信号后，才可继续执行。若申请到 信号，则可继续执行，但其它进程必须等待本进程释放信号量后，才能再使用本信号。保证函数的可重入性的方法：<br/>
     1、在写函数时候尽量使用局部变量（例如寄存器、堆栈中的变量）；<br/>
     2、对于要使用的全局变量要加以保护（如采取关中断、信号量等方法），这样构成的函数就一定是一个可重入的函数。</p>

<p>满足下列条件的函数多数是不可重入的：<br/>
     1、函数体内使用了静态的数据结构；<br/>
     2、函数体内调用了malloc()或者free()函数；<br/>
     3、函数体内调用了标准I/O函数。</p>

<p>如何将一个不可重入的函数改写成可重入函数呢？把一个不可重入函数变成可重入的唯一方法是用可重入规则来重写它。其实很简单，只要遵守了几条很容易理解的规则，那么写出来的函数就是可重入的：<br/>
     1、不要使用全局变量。因为别的代码很可能覆盖这些变量值。<br/>
     2、在和硬件发生交互的时候，切记执行类似disinterrupt()之类的操作，就是关闭硬件中断。完成交互记得打开中断，在有些系列上，这叫做“进入/ 退出核心”。<br/>
     3、不能调用其它任何不可重入的函数。<br/>
     4、谨慎使用堆栈。最好先在使用前先OS_ENTER_KERNAL。</p>
]]></content>
</entry>

<entry>
<title type="html"><![CDATA[字节序和比特序]]></title>
<link href="http://abcdxyzk.github.io/blog/2013/06/20/lang-c-B_b_byte/"/>
<updated>2013-06-20T18:23:00+08:00</updated>
<id>http://abcdxyzk.github.io/blog/2013/06/20/lang-c-B_b_byte</id>
<content type="html"><![CDATA[<p>字节序和比特序，因为比特序对所有代码（包括汇编）是透明的，所以对于小端系统，有说是用大端比特序，也有说是用小端比特序。<br/>
下面是copy一部分觉得靠谱的内容：<br/>
大小端
我们对"endianness"这个名词估计都很熟悉了。它首先被Danny Cohen于1980引入，用来表述计算机系统表示多字节整数的方式。
endianness分为两种：大端和小端。(从字节序的角度来看)大端方式是将整数中最高位byte存放在最低地址中。而小端方式则相反，将整数中的最高位byte存放在最高地址中。
对于某个确定的计算机系统，比特序通常与字节序保持一致。换言之，在大端系统中，每个byte中最高位bit存放在内存最低位；在小端系统中，最低位bit存放在内存最低位。
正如大部分人是按照从左至右的顺序书写数字，一个多字节整数的内存布局也应该遵循同样的方式，即从左至右为数值的最高位至最低位。正如我们在下面的例子中所看到的，这是书写整数最清晰的方式。</p>

<p>根据上述规则，我们按以下方式分别在大端和小端系统中值为0x0a0b0c0d的整数。
在大端系统中书写整数：
byte  addr  0   1   2   3
bit offset  01234567 01234567 01234567 01234567</p>

<pre><code>binary  00001010 00001011 00001100 00001101
  hex      0a       0b       0c       0d
</code></pre>

<p>在小端系统中书写整数(认真看)
byte  addr  0   1   2   3
bit offset  01234567 01234567 01234567 01234567</p>

<pre><code>binary  10110000 00110000 11010000 01010000
  hex      d0       c0       b0       a0
</code></pre>

<p>说明字节序：
<code>
    #include &lt;stdio.h&gt;  
    int main (void)  
    {  
        union b  
        {  
            short k;  //测试环境short占2字节  
            char i[2];  //测试环境char占1字节  
        }*s,a;  
        s=&amp;a;  
        s-&gt;i[0]=0x41;  
        s-&gt;i[1]=0x52;  
        printf("%x\n",s-&gt;k);  
        return 0;  
    }
</code>
输出：5241</p>

<hr />

<p>self code:
```
    #include &lt;stdio.h>
    union W
    {
        struct Y
        {
            unsigned int s1:4;
            unsigned int s2:8;
            unsigned int s3:20;
        } y;
        unsigned int c;
    } w;</p>

<pre><code>union V 
{
    struct X
    {
        unsigned char s1:3;
        unsigned char s2:3;
        unsigned char s3:2;
    } x;
    unsigned char c;
} v;

int main()
{
    w.c = 0x12345678;
    printf("%x %x %x %x\n", w.c, w.y.s1, w.y.s2, w.y.s3); 

    v.c = 100;
    printf("%d %x %x %x\n", v.c, v.x.s1, v.x.s2, v.x.s3); 
    return 0;
}
</code></pre>

<p>```</p>

<p>输出：<br/>
12345678 8 67 12345<br/>
100 4 4 1</p>

<p>100 = （01100100）2<br/>
因为字节序是小端的所以第一行输出说明：位域变量从左到右分配位，所以第二行的输出的位域变量也应该从左到右分配位。所以<br/>
100 = 001 001 10  （小端比特序二进制）<br/>
对应:  s1  s2  s3  （位域变量从左到右分配位）</p>

<p>符合。</p>
]]></content>
</entry>

<entry>
<title type="html"><![CDATA[c/c++函数扩展名]]></title>
<link href="http://abcdxyzk.github.io/blog/2013/03/26/lang-c-file-exname/"/>
<updated>2013-03-26T17:03:00+08:00</updated>
<id>http://abcdxyzk.github.io/blog/2013/03/26/lang-c-file-exname</id>
<content type="html"><![CDATA[<ul>
<li>后缀为.c的，gcc把它当作是C程序，而g++当作是c++程序；</li>
<li>后缀为.cpp的，两者都会认为是c++程序
<code>
  int printf(char*, ...);
  int main()
  {
      printf("test\n");
      return 0;
  }
</code>

<h5>一、</h5>

<p>保存为.c 文件， 用gcc编译能通过，g++编译不能通过。<br/>
g++会判定是不是你自己声明的函数，如果是，它会按照一种规则去重命名该函数。c++为了支持重载才这么做，而c没有重载。</p></li>
</ul>


<h5>二、</h5>

<p>保存为.cpp文件，用gcc、g++都编译不能通过</p>
]]></content>
</entry>

<entry>
<title type="html"><![CDATA[C语言运算符优先级]]></title>
<link href="http://abcdxyzk.github.io/blog/2013/03/01/lang-c-op-order/"/>
<updated>2013-03-01T18:41:00+08:00</updated>
<id>http://abcdxyzk.github.io/blog/2013/03/01/lang-c-op-order</id>
<content type="html"><![CDATA[<p>一共有十五个优先级：
<code>
1   ()  []  .  -&gt;
2   !  ~  ++  --  -(负号)  &amp;(取变量地址)  *(指针取值)   (type)(强制类型转换)  sizeof
3   * / %
4   + -
5   &gt;&gt; &lt;&lt;  
6   &gt; &gt;= &lt; &lt;=
7   == !=   
8   &amp;  
9   ^   
10  |   
11  &amp;&amp;
12  ||
13  ?:
14   =  +=  -=  *=  /=   %=  |=   ^=   &amp;=   &gt;&gt;=   &lt;&lt;=
15  ,
就着多吧   结合性：2   13  14  是从右至左   其他都是  从左至右
</code></p>
]]></content>
</entry>

</feed>
