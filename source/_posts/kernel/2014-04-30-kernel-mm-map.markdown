---
layout: post
title: "linux内存分配"
date: 2014-04-30 16:04:00 +0800
comments: false
categories:
- 2014
- 2014~04
- kernel
- kernel~mm
tags:
---
##### 关于虚拟内存有三点需要注意：
  1、4G的进程地址空间被人为的分为两个部分--用户空间与内核空间。用户空间从0到3G（0xc0000000）,内核空间占据3G到4G。用户进程通常情况下只能访问用户空间的虚拟地址，不能访问内核空间的虚拟地址。例外情况只有用户进程进行系统调用（代表用户进程在内核态执行）等时刻可以访问到内核空间。  
  2、用户空间对应进程，所以每当进程切换，用户空间就会跟着变化；而内核空间是由内核负责映射，它并不会跟着进程变化，是固定的。内核空间地址有自己对应的页表，用户进程各自有不同的页表。  
  3、每个进程的用户空间都是完全独立、互不相干的。

#### 一、4G地址空间解析图

![](/images/kernel/20140430-1.jpeg)

  上图展示了整个进程地址空间的分布，其中4G的地址空间分为两部分，在用户空间内，对应了内存分布的五个段：数据段、代码段、BSS段、堆、栈。在上篇文章中有详细的介绍。

二、虚拟地址空间分配及其与物理内存对应图

![](/images/kernel/20140430-2.jpeg)

  这个图示内核用户空间的划分，图中最重要的就是高端内存的映射  
  其中kmalloc和vmalloc函数申请的空间对应着不同的区域，同时又不同的含义。

三、物理内存分配图

![](/images/kernel/20140430-3.jpeg)

  这张图中页解释了三者的不同关系，和上篇文章中的内容有相似之处。

##### 伙伴算法：
  一种物理内存分配和回收的方法，物理内存所有空闲页都记录在BUDDY链表中。首选，系统建立一个链表，链表中的每个元素代表一类大小的物理内存，分别为2的0次方、1次方、2次方，个页大小，对应4K、8K、16K的内存，没一类大小的内存又有一个链表，表示目前可以分配的物理内存。例如现在仅存需要分配8K的物理内存，系统首先从8K那个链表中查询有无可分配的内存，若有直接分配；否则查找16K大小的链表，若有，首先将16K一分为二，将其中一个分配给进程，另一个插入8K的链表中，若无，继续查找32K，若有，首先把32K一分为二，其中一个16K大小的内存插入16K链表中，然后另一个16K继续一分为二，将其中一个插入8K的链表中，另一个分配给进程........以此类推。当内存释放时，查看相邻内存有无空闲，若存在两个联系的8K的空闲内存，直接合并成一个16K的内存，插入16K链表中。（伙伴算法用于物理内存分配方案）

##### SLAB算法：
  是一种对伙伴算的一种补充，对于用户进程的内存分配，伙伴算法已经够好了，但对于内核进程，还需要存在一类很小的数据（字节大小，比如进程描述符、虚拟内存描述符等），若每次给几个字节的数据分配一个4KB的页，实在太浪费，于是就有了SLBA算法，SLAB算法其实就是把一个页用力劈成一小块一小块，然后再分配。

