---
layout: post
title: "gdb print 语法"
date: 2014-08-28 16:13:00 +0800
comments: true
categories:
- 2014
- 2014~08
- debug
- debug~gdb
tags:
- gdb
---
```
print <expr>
print /<f> <expr>
```
<expr\>是表达式，是你所调试的程序的语言的表达式（GDB可以调试多种编程语言），<f>是输出的格式，比如，假如要把表达式按16进制的格式输出，那么就是/x。

#### 一、表达式
print和许多GDB的命令一样，可以接受一个表达式，GDB会根据当前的程序运行的数据来计算这个表达式，既然是表达式，那么就可以是当前程序运行中的const常量、变量、函数等内容。可惜的是GDB不能使用你在程序中所定义的宏。

表达式的语法应该是当前所调试的语言的语法，由于C/C++是一种大众型的语言，所以，本文中的例子都是关于C/C++的。（而关于用GDB调试其它语言的章节，我将在后面介绍）

在表达式中，有几种GDB所支持的操作符，它们可以用在任何一种语言中。  
`@`是一个和数组有关的操作符，在后面会有更具体的说明。  
`::`指定一个在文件或是一个函数中的变量。  
`{<type>} <addr>`<span style="color:red">表示一个指向内存地址<addr>的类型为type的一个对象。 p {char*} 0xffffffff12345678</span>

#### 二、程序变量
在GDB中，你可以随时查看以下三种变量的值：  
1、全局变量（所有文件可见的）  
2、静态全局变量（当前文件可见的）  
3、局部变量（当前Scope可见的）  
假如你的局部变量和全局变量发生冲突（也就是重名），一般情况下是局部变量会隐藏全局变量，也就是说，假如一个全局变量和一个函数中的局部变量同名时，假 如当前停止点在函数中，用print显示出的变量的值会是函数中的局部变量的值。假如此时你想查看全局变量的值时，你可以使用“::”操作符：
```
file::variable
function::variable
```
可以通过这种形式指定你所想查看的变量，是哪个文件中的或是哪个函数中的。例如，查看文件f2.c中的全局变量x的值：
```
gdb) p 'f2.c'::x
```
当然，“::”操作符会和C++中的发生冲突，GDB能自动识别“::” 是否C++的操作符，所以你不必担心在调试C++程序时会出现异常。

另外，需要注重的是，假如你的程序编译时开启了优化选项，那么在用GDB调试被优化过的程序时，可能会发生某些变量不能访问，或是取值错误码的情况。这个是很正常的，因为优化程序会删改你的程序，整理你程序的语句顺序，剔除一些无意义的变量等，所以在GDB调 试这种程序时，运行时的指令和你所编写指令就有不一样，也就会出现你所想象不到的结果。对付这种情况时，需要在编译程序时关闭编译优化。一般来说，几乎所 有的编译器都支持编译优化的开关，例如，GNU的C/C++编译器GCC，你可以使用“-gstabs”选项来解决这个问题。关于编译器的参数，还请查看 编译器的使用说明文档。
#### 三、数组
有时候，你需要查看一段连续的内存空间的值。比如数组的一段，或是动态分配的数据的大小。你可以使用GDB的“@”操作符，“@”的左边是第一个内存的地址的值，“@”的右边则你你想查看内存的长度。例如，你的程序中有这样的语句：
```
int *array = (int *) malloc (len * sizeof (int));
```
于是，在GDB调试过程中，你可以以如下命令显示出这个动态数组的取值：
```
p *array@len
```
@的左边是数组的首地址的值，也就是变量array所指向的内容，右边则是数据的长度，其保存在变量len中，其输出结果，大约是下面这个样子的：
```
(gdb) p *array@len
$1 = {2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40}
```
假如是静态数组的话，可以直接用print数组名，就可以显示数组中所有数据的内容了。

