---
layout: post
title: "插头 DP"
date: 2011-03-17 23:07:00 +0800
comments: false
categories:
- 2011
- 2011~03
- algorithm
- algorithm~dp
tags:
---
陈丹琦的大作  http://www.docin.com/p-46797997.html

http://acm.hdu.edu.cn/showproblem.php?pid=1964

http://acm.timus.ru/problem.aspx?space=1&num=1519

http://poj.org/problem?id=1739

http://acm.hdu.edu.cn/showproblem.php?pid=3377

http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3256

http://acm.hdu.edu.cn/showproblem.php?pid=1693

http://acm.fzu.edu.cn/problem.php?pid=1977

http://poj.org/problem?id=3133

// timus_1519  有效状态间转移
```
	#include<stdio.h>

	long long dp[60000],pre[60000];
	int all,r[60000],e[1600000];
	int p[60000][13];

	class DP {

	public:
		int n,m,can[33][33],last;
		int val[33],LL,UU,sta,next;
		int a[33],b[33],d[33],c[33];

		void input()
		{
			int i,j;
			char ch[15];
			last = 0;
			for(i=1;i<=n;i++)
			{
				scanf("%s",ch);
				for(j=1;j<=m;j++)
				{
					can[i][j] = ch[j-1]=='.'?(++last):-1;
				}
			}
		}

		int ok()
		{
			int i,l;
			l = 0;
			for(i=1;i<=m+1;i++)
			{
				b[i] = d[i] = -1;
				if(a[i] == 1) c[++l] = i;
				else
				if(a[i] == 2)
				{
					if(l == 0) return 0;
					b[c[l]] = i; d[i] = c[l];
					l--;
				}
			}
			if(l != 0) return 0;
			return 1;
		}

		void init()
		{
			int i,j,k;

			val[1] = 1;
			for(i=2;i<=m+2;i++) val[i] = val[i-1]*3;;

			for(i=0;i<=m+2;i++) a[i] = 0;
			a[1] = -1;

			all = 0;

			for(i=0;i<=val[m+2];i++)
			{
				a[1]++;
				k = 1; while(k <= m+1 && a[k]>2) { a[k]%=3; a[k+1]++; k++; }

				e[i] = -1;

				if(ok() == 0) continue;

				r[all] = i; e[i] = all;

				for(j=1;j<=m+1;j++) {
					p[all][j] = -1;
					if(b[j] != -1) p[all][j] = b[j];
					if(d[j] != -1) p[all][j] = d[j];
				}

				all++;
			}
		}

		void abc()
		{
			int i,j,k,l;

			input();
			init();

			for(i=0;i<all;i++) dp[i] = 0;

			dp[r[0]] = 1;

			for(i=1;i<=n;i++)
				for(j=1;j<=m;j++)
				{
					if(j == 1)
					{
						for(k=all-1;k>=0;k--)
						{
							l = r[k]; l = l/3; l = e[l];

							if(l != -1)
							{
								dp[k] = dp[l];
								if(r[k]%3 != 0) dp[k] = 0;
							}
							else
								dp[k] = 0;
						}
					}

					for(k=0;k<all;k++)
					{
						pre[k] = dp[k]; dp[k] = 0;
					}

					for(k=0;k<all;k++)
					if(pre[k] > 0)
					{
						LL = r[k]/val[j]%3;
						UU = r[k]/val[j+1]%3;

						if(can[i][j] == -1)
						{
							if(LL == 0 && UU == 0)
							{
								dp[k] += pre[k];
							}
							continue;
						}

						if(UU == 0 && LL == 0)
						{
							sta = r[k]+val[j]+val[j+1]+val[j+1];

							dp[e[sta]] += pre[k];
						}
						else
						if(LL == 0)
						{
							sta = r[k];
							dp[e[sta]] += pre[k];

							sta = r[k]+r[k]/val[j+1]%3*(val[j]-val[j+1]);
							dp[e[sta]] += pre[k];
						}
						else
						if(UU == 0)
						{
							sta = r[k];
							dp[e[sta]] += pre[k];

							sta = r[k]+r[k]/val[j]%3*(-val[j]+val[j+1]);
							dp[e[sta]] += pre[k];
						}
						else
						if(LL == 2 && UU == 1)
						{
							sta = r[k]-val[j]-val[j]-val[j+1];
							dp[e[sta]] += pre[k];
						}
						else
						if(LL == 1 && UU == 1)
						{
							if(p[k][j+1] > 0 && p[k][j+1] <= m+1)
							{
								sta = r[k]-val[j]-val[j+1]-val[p[k][j+1]];
								dp[e[sta]] += pre[k];
							}
						}
						else
						if(LL == 2 && UU == 2)
						{
							if(p[k][j] > 0)
							{
								sta = r[k]-val[j]-val[j]-val[j+1]-val[j+1]+val[p[k][j]];
								dp[e[sta]] += pre[k];
							}
						}
						else
						if(LL == 1 && UU == 2)
						{
							if(can[i][j] == last)
							{
								sta = r[k]-val[j]-val[j+1]-val[j+1];
								dp[e[sta]] += pre[k];
							}
						}
					}
				}
			printf("%lld\n",dp[r[0]]);
		}

		void solve()
		{
			while(scanf("%d %d",&n,&m) != EOF)
			{
				abc();
			}
		}
	};

	int main() {
		DP dp;
		dp.solve();
		return 0;
	}
```

